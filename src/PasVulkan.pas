(******************************************************************************
 *                                 PasVulkan                                  *
 ******************************************************************************
 *                        Version 2017-07-10-03-00-0000                       *
 ******************************************************************************
 *                                zlib license                                *
 *============================================================================*
 *                                                                            *
 * Copyright (C) 2016-2017, Benjamin Rosseaux (benjamin@rosseaux.de)          *
 *                                                                            *
 * This software is provided 'as-is', without any express or implied          *
 * warranty. In no event will the authors be held liable for any damages      *
 * arising from the use of this software.                                     *
 *                                                                            *
 * Permission is granted to anyone to use this software for any purpose,      *
 * including commercial applications, and to alter it and redistribute it     *
 * freely, subject to the following restrictions:                             *
 *                                                                            *
 * 1. The origin of this software must not be misrepresented; you must not    *
 *    claim that you wrote the original software. If you use this software    *
 *    in a product, an acknowledgement in the product documentation would be  *
 *    appreciated but is not required.                                        *
 * 2. Altered source versions must be plainly marked as such, and must not be *
 *    misrepresented as being the original software.                          *
 * 3. This notice may not be removed or altered from any source distribution. *
 *                                                                            *
 ******************************************************************************
 *                  General guidelines for code contributors                  *
 *============================================================================*
 *                                                                            *
 * 1. Make sure you are legally allowed to make a contribution under the zlib *
 *    license.                                                                *
 * 2. The zlib license header goes at the top of each source file, with       *
 *    appropriate copyright notice.                                           *
 * 3. This PasVulkan wrapper may be used only with the PasVulkan-own Vulkan   *
 *    Pascal header.                                                          *
 * 4. After a pull request, check the status of your pull request on          *
      http://github.com/BeRo1985/pasvulkan                                    *
 * 5. Write code, which is compatible with Delphi 7-XE7 and FreePascal >= 3.0 *
 *    so don't use generics/templates, operator overloading and another newer *
 *    syntax features than Delphi 7 has support for that, but if needed, make *
 *    it out-ifdef-able.                                                      *
 * 6. Don't use Delphi-only, FreePascal-only or Lazarus-only libraries/units, *
 *    but if needed, make it out-ifdef-able.                                  *
 * 7. No use of third-party libraries/units as possible, but if needed, make  *
 *    it out-ifdef-able.                                                      *
 * 8. Try to use const when possible.                                         *
 * 9. Make sure to comment out writeln, used while debugging.                 *
 * 10. Make sure the code compiles on 32-bit and 64-bit platforms (x86-32,    *
 *     x86-64, ARM, ARM64, etc.).                                             *
 * 11. Make sure the code runs on all platforms with Vulkan support           *
 *                                                                            *
 ******************************************************************************)
unit PasVulkan;
{$i PasVulkan.inc}
{$ifndef fpc}
 {$ifdef conditionalexpressions}
  {$if CompilerVersion>=24.0}
   {$legacyifend on}
  {$ifend}
 {$endif}
{$endif}

interface

uses {$if defined(Windows)}
      Windows,
     {$elseif defined(Unix)}
      BaseUnix,UnixType,dl,
     {$ifend}
     {$if defined(XLIB) and defined(VulkanUseXLIBUnits)}x,xlib,{$ifend}
     {$if defined(XCB) and defined(VulkanUseXCBUnits)}xcb,{$ifend}
     {$if defined(Mir) and defined(VulkanUseMirUnits)}Mir,{$ifend}
     {$if defined(Wayland) and defined(VulkanUseWaylandUnits)}Wayland,{$ifend}
     {$if defined(Android) and defined(VulkanUseAndroidUnits)}Android,{$ifend}
     SysUtils,Classes,SyncObjs,Math,
     {$ifdef PasVulkanPasMP}
      PasMP,
     {$endif}
     Vulkan;

const VulkanMinimumMemoryChunkSize=1 shl 24; // 16 MB minimum memory chunk size

      VkTTF_PID_Apple=0;
      VkTTF_PID_Macintosh=1;
      VkTTF_PID_ISO=2;
      VkTTF_PID_Microsoft=3;

      VkTTF_SID_APPLE_DEFAULT=0;
      VkTTF_SID_APPLE_UNICODE_1_1=1;
      VkTTF_SID_APPLE_ISO_10646=2;
      VkTTF_SID_APPLE_UNICODE_2_0=3;
      VkTTF_SID_APPLE_UNICODE32=4;
      VkTTF_SID_APPLE_VARIANT_SELECTOR=5;
      VkTTF_SID_APPLE_FULL_UNICODE_COVERAGE=6;

      VkTTF_SID_MAC_Roman=0;
      VkTTF_SID_MAC_Japanese=1;
      VkTTF_SID_MAC_Chinese=2;
      VkTTF_SID_MAC_Korean=3;
      VkTTF_SID_MAC_Arabic=4;
      VkTTF_SID_MAC_Hebrew=5;
      VkTTF_SID_MAC_Greek=6;
      VkTTF_SID_MAC_Russian=7;
      VkTTF_SID_MAC_RSymbol=8;
      VkTTF_SID_MAC_Devanagari=9;
      VkTTF_SID_MAC_Gurmukhi=10;
      VkTTF_SID_MAC_Gujarati=11;
      VkTTF_SID_MAC_Oriya=12;
      VkTTF_SID_MAC_Bengali=13;
      VkTTF_SID_MAC_Tamil=14;
      VkTTF_SID_MAC_Telugu=15;
      VkTTF_SID_MAC_Kannada=16;
      VkTTF_SID_MAC_Malayalam=17;
      VkTTF_SID_MAC_Sinhalese=18;
      VkTTF_SID_MAC_Burmese=19;
      VkTTF_SID_MAC_Khmer=20;
      VkTTF_SID_MAC_Thai=21;
      VkTTF_SID_MAC_Laotian=22;
      VkTTF_SID_MAC_Georgian=23;
      VkTTF_SID_MAC_Armenian=24;
      VkTTF_SID_MAC_Maldivian=25;
      VkTTF_SID_MAC_Tibetian=26;
      VkTTF_SID_MAC_Mongolian=27;
      VkTTF_SID_MAC_Geez=28;
      VkTTF_SID_MAC_Slavic=29;
      VkTTF_SID_MAC_Vietnamese=30;
      VkTTF_SID_MAC_Sindhi=31;
      VkTTF_SID_MAC_Uninterp=32;

      VkTTF_SID_MS_SYMBOL_CS=0;
      VkTTF_SID_MS_UNICODE_CS=1;
      VkTTF_SID_MS_SJIS=2;
      VkTTF_SID_MS_GB2312=3;
      VkTTF_SID_MS_BIG_5=4;
      VkTTF_SID_MS_WANSUNG=5;
      VkTTF_SID_MS_JOHAB=6;
      VkTTF_SID_MS_UCS_4=10;

      VkTTF_SID_ISO_ASCII=0;
      VkTTF_SID_ISO_10646=1;
      VkTTF_SID_ISO_8859_1=2;

      VkTTF_LID_MS_Arabic=$0401;
      VkTTF_LID_MS_Bulgarian=$0402;
      VkTTF_LID_MS_Catalan=$0403;
      VkTTF_LID_MS_TraditionalChinese=$0404;
      VkTTF_LID_MS_SimplifiedChinese=$0804;
      VkTTF_LID_MS_Czech=$0405;
      VkTTF_LID_MS_Danish=$0406;
      VkTTF_LID_MS_German=$0407;
      VkTTF_LID_MS_SwissGerman=$0807;
      VkTTF_LID_MS_Greek=$0408;
      VkTTF_LID_MS_USEnglish=$0409;
      VkTTF_LID_MS_UKEnglish=$0809;
      VkTTF_LID_MS_CastilianSpanish=$040a;
      VkTTF_LID_MS_MexicanSpanish=$080a;
      VkTTF_LID_MS_ModernSpanish=$0c0a;
      VkTTF_LID_MS_Finnish=$040b;
      VkTTF_LID_MS_French=$040c;
      VkTTF_LID_MS_BelgianFrench=$080c;
      VkTTF_LID_MS_CanadianFrench=$0c0c;
      VkTTF_LID_MS_SwissFrench=$100c;
      VkTTF_LID_MS_Hebrew=$040d;
      VkTTF_LID_MS_Hungarian=$040e;
      VkTTF_LID_MS_Icelandic=$040f;
      VkTTF_LID_MS_Italian=$0410;
      VkTTF_LID_MS_SwissItalian=$0810;
      VkTTF_LID_MS_Japanese=$0411;
      VkTTF_LID_MS_Korean=$0412;
      VkTTF_LID_MS_Dutch=$0413;
      VkTTF_LID_MS_BelgianDutch=$0813;
      VkTTF_LID_MS_NorwegianBokmal=$0414;
      VkTTF_LID_MS_NorwegianNynorsk=$0814;
      VkTTF_LID_MS_Polish=$0415;
      VkTTF_LID_MS_BrazilianPortuguese=$0416;
      VkTTF_LID_MS_Portuguese=$0816;
      VkTTF_LID_MS_RhaetoRomanic=$0417;
      VkTTF_LID_MS_Romanian=$0418;
      VkTTF_LID_MS_Russian=$0419;
      VkTTF_LID_MS_CroatoSerbian=$041a;
      VkTTF_LID_MS_SerboCroatian=$081a;
      VkTTF_LID_MS_Slovakian=$041b;
      VkTTF_LID_MS_Albanian=$041c;
      VkTTF_LID_MS_Swedish=$041d;
      VkTTF_LID_MS_Thai=$041e;
      VkTTF_LID_MS_Turkish=$041f;
      VkTTF_LID_MS_Urdu=$0420;
      VkTTF_LID_MS_Bahasa=$0421;

      VkTTF_LID_MAC_English=0;
      VkTTF_LID_MAC_French=1;
      VkTTF_LID_MAC_German=2;
      VkTTF_LID_MAC_Italian=3;
      VkTTF_LID_MAC_Dutch=4;
      VkTTF_LID_MAC_Swedish=5;
      VkTTF_LID_MAC_Spanish=6;
      VkTTF_LID_MAC_Danish=7;
      VkTTF_LID_MAC_Portuguese=8;
      VkTTF_LID_MAC_Norwegian=9;
      VkTTF_LID_MAC_Hebrew=10;
      VkTTF_LID_MAC_Japanese=11;
      VkTTF_LID_MAC_Arabic=12;
      VkTTF_LID_MAC_Finnish=13;
      VkTTF_LID_MAC_Greek=14;
      VkTTF_LID_MAC_Icelandic=15;
      VkTTF_LID_MAC_Maltese=16;
      VkTTF_LID_MAC_Turkish=17;
      VkTTF_LID_MAC_Yugoslavian=18;
      VkTTF_LID_MAC_Chinese=19;
      VkTTF_LID_MAC_Urdu=20;
      VkTTF_LID_MAC_Hindi=21;
      VkTTF_LID_MAC_Thai=22;

      VkTTF_cfgfNONE=0;
      VkTTF_cfgfXY=1;
      VkTTF_cfgfX=2;
      VkTTF_cfgfY=3;

      VkTTF_NID_Copyright=0;
      VkTTF_NID_Family=1;
      VkTTF_NID_Subfamily=2;
      VkTTF_NID_UniqueID=3;
      VkTTF_NID_FullName=4;
      VkTTF_NID_Version=5;
      VkTTF_NID_PostscriptName=6;
      VkTTF_NID_Trademark=7;

      VkTTF_CMAP_FORMAT0=0;
      VkTTF_CMAP_FORMAT2=2;
      VkTTF_CMAP_FORMAT4=4;
      VkTTF_CMAP_FORMAT6=6;
      VkTTF_CMAP_FORMAT8=8;
      VkTTF_CMAP_FORMAT10=10;
      VkTTF_CMAP_FORMAT12=12;
      VkTTF_CMAP_FORMAT13=13;
      VkTTF_CMAP_FORMAT14=14;

      VkTTF_OFFSET_TABLE_SIZE=12;

      VkTTF_MACINTOSH=1;
      VkTTF_MICROSOFT=2;

      VkTTF_GASP_GRIDFIT=1;
      VkTTF_GASP_DOGRAY=2;
      VkTTF_GASP_SYMMETRIC_GRIDFIT=4;
      VkTTF_GASP_SYMMETRIC_SMOOTHING=8;

      VkTTF_TT_NO_POINT=0;
      VkTTF_TT_OFF_CURVE=1;
      VkTTF_TT_ON_CURVE=2;

      VkTTF_TT_ERR_NoError=0;
      VkTTF_TT_ERR_InvalidFile=1;
      VkTTF_TT_ERR_CorruptFile=2;
      VkTTF_TT_ERR_OutOfMemory=3;
      VkTTF_TT_ERR_TableNotFound=4;
      VkTTF_TT_ERR_NoCharacterMapFound=5;
      VkTTF_TT_ERR_UnknownCharacterMapFormat=6;
      VkTTF_TT_ERR_CharacterMapNotPresent=7;
      VkTTF_TT_ERR_UnableToOpenFile=8;
      VkTTF_TT_ERR_UnknownKerningFormat=9;
      VkTTF_TT_ERR_UnknownGPOSFormat=10;
      VkTTF_TT_ERR_OutOfBounds=11;

      VkTTF_LineCapMode_BUTT=0;
      VkTTF_LineCapMode_SQUARE=1;
      VkTTF_LineCapMode_ROUND=2;

      VkTTF_LineJoinMode_BEVEL=0;
      VkTTF_LineJoinMode_ROUND=1;
      VkTTF_LineJoinMode_MITER=2;
      VkTTF_LineJoinMode_MITERREVERT=3;
      VkTTF_LineJoinMode_MITERROUND=4;

      VkTTF_LineInnerJoinMode_BEVEL=0;
      VkTTF_LineInnerJoinMode_MITER=1;
      VkTTF_LineInnerJoinMode_JAG=2;
      VkTTF_LineInnerJoinMode_ROUND=3;

      VkTTF_PolygonWindingRule_NONZERO=0; // TTF fonts uses the non-zero winding rule only
      VkTTF_PolygonWindingRule_EVENODD=1; // <- exists here only for completeness :-)

      VkTTF_PathFlag_OnCurve=1 shl 0;
      VkTTF_PathFlag_OnXShortVector=1 shl 1;
      VkTTF_PathFlag_OnYShortVector=1 shl 2;
      VkTTF_PathFlag_Repeat=1 shl 3;
      VkTTF_PathFlag_PositiveXShortVector=1 shl 4;
      VkTTF_PathFlag_ThisXIsSame=1 shl 4;
      VkTTF_PathFlag_PositiveYShortVector=1 shl 5;
      VkTTF_PathFlag_ThisYIsSame=1 shl 5;
      VkTTF_PathFlag_TouchedX=1 shl 6;
      VkTTF_PathFlag_TouchedY=1 shl 7;

      VkTTF_Zone_Twilight=0;
      VkTTF_Zone_Glyph=1;
      VkTTF_Zone_Count=2;

      VkTTF_PointType_Current=0;
      VkTTF_PointType_Unhinted=1;
      VkTTF_PointType_InFontUnits=2;
      VkTTF_PointType_Count=3;

      VULKAN_SPRITEATLASTEXTURE_WIDTH=2048;
      VULKAN_SPRITEATLASTEXTURE_HEIGHT=2048;

      VulkanXMLMaxListSize=2147483647 div SizeOf(TVkPointer);

      VulkanFontDistanceFieldSpreadValue=4;

type EVulkanException=class(Exception);

     EVulkanMemoryAllocationException=class(EVulkanException);

     EVulkanTextureException=class(EVulkanException);

     EVulkanSurfaceException=class(EVulkanException);

     EVulkanPipelineCacheException=class(EVulkanException);

     EVulkanResultException=class(EVulkanException)
      private
       fResultCode:TVkResult;
      public
       constructor Create(const aResultCode:TVkResult);
       destructor Destroy; override;
      published
       property ResultCode:TVkResult read fResultCode;
     end;

     PVulkanUUID=^TVulkanUUID;
     TVulkanUUID=array[0..VK_UUID_SIZE-1] of TVkUInt8;

     PVulkanBytes=^TVulkanBytes;
     TVulkanBytes=array[0..65535] of TVkUInt8;

     TVulkanFormatSizeFlag=
      (
       vfsfPacked,
       vfsfCompressed,
       vfsfPalettized,
       vfsfDepth,
       vfsfStencil
      );

     TVulkanFormatSizeFlags=set of TVulkanFormatSizeFlag;

     PVulkanFormatSize=^TVulkanFormatSize;
     TVulkanFormatSize=record
      Flags:TVulkanFormatSizeFlags;
      PaletteSizeInBits:TVkUInt32;
      BlockSizeInBits:TVkUInt32;
      BlockWidth:TVkUInt32; // in texels
      BlockHeight:TVkUInt32; // in texels
      BlockDepth:TVkUInt32; // in texels
     end;

     TVulkanObject=class(TInterfacedObject);

     PVulkanRawByteChar=PAnsiChar;
     TVulkanRawByteChar=AnsiChar;

     PVulkanUTF32Char=^TVulkanUTF32Char;
     TVulkanUTF32Char=TVKUInt32;

     PVulkanRawByteString=^TVulkanRawByteString;
     TVulkanRawByteString={$if declared(RawByteString)}RawByteString{$else}AnsiString{$ifend};

     PVulkanUTF8String=^TVulkanUTF8String;
     TVulkanUTF8String={$if declared(UTF8String)}UTF8String{$else}AnsiString{$ifend};

     PVulkanCharString=^TVulkanCharString;
     TVulkanCharString=TVkCharString;

     TVulkanCharStringArray=array of TVulkanCharString;
     TVkUInt8Array=array of TVkUInt8;
     TVkInt32Array=array of TVkInt32;
     TVkUInt32Array=array of TVkUInt32;
     TVkFloatArray=array of TVkFloat;
     TVkLayerPropertiesArray=array of TVkLayerProperties;
     TVkExtensionPropertiesArray=array of TVkExtensionProperties;
     TVkLayerExtensionPropertiesArray=array of array of TVkExtensionProperties;
     TPVkCharArray=array of PVkChar;
     TVkPhysicalDeviceArray=array of TVkPhysicalDevice;
     TVkQueueFamilyPropertiesArray=array of TVkQueueFamilyProperties;
     TVkSparseImageFormatPropertiesArray=array of TVkSparseImageFormatProperties;
     TVkSurfaceFormatKHRArray=array of TVkSurfaceFormatKHR;
     TVkPresentModeKHRArray=array of TVkPresentModeKHR;
     TVkDisplayPropertiesKHRArray=array of TVkDisplayPropertiesKHR;
     TVkDisplayPlanePropertiesKHRArray=array of TVkDisplayPlanePropertiesKHR;
     TVkDisplayKHRArray=array of TVkDisplayKHR;
     TVkDisplayModePropertiesKHRArray=array of TVkDisplayModePropertiesKHR;
     TVkDeviceQueueCreateInfoArray=array of TVkDeviceQueueCreateInfo;
     TVkImageArray=array of TVkImage;
     TVkSamplerArray=array of TVkSampler;
     TVkCommandBufferArray=array of TVkCommandBuffer;
     TVkDescriptorSetLayoutBindingArray=array of TVkDescriptorSetLayoutBinding;
     TVkDescriptorSetLayoutArray=array of TVkDescriptorSetLayout;
     TVkPushConstantRangeArray=array of TVkPushConstantRange;
     TVkPipelineShaderStageCreateInfoArray=array of TVkPipelineShaderStageCreateInfo;
     TVkPipelineVertexInputStateCreateInfoArray=array of TVkPipelineVertexInputStateCreateInfo;
     TVkAttachmentDescriptionArray=array of TVkAttachmentDescription;
     TVkSubpassDescriptionArray=array of TVkSubpassDescription;
     TVkSubpassDependencyArray=array of TVkSubpassDependency;
     TVkAttachmentReferenceArray=array of TVkAttachmentReference;
     TVkMemoryBarrierArray=array of TVkMemoryBarrier;
     TVkBufferMemoryBarrierArray=array of TVkBufferMemoryBarrier;
     TVkImageMemoryBarrierArray=array of TVkImageMemoryBarrier;
     TVkViewportArray=array of TVkViewport;
     TVkRect2DArray=array of TVkRect2D;
     TVkSampleMaskArray=array of TVkSampleMask;
     TVkVertexInputBindingDescriptionArray=array of TVkVertexInputBindingDescription;
     TVkVertexInputAttributeDescriptionArray=array of TVkVertexInputAttributeDescription;
     TVkPipelineColorBlendAttachmentStateArray=array of TVkPipelineColorBlendAttachmentState;
     TVkDynamicStateArray=array of TVkDynamicState;
     TVkDescriptorPoolSizeArray=array of TVkDescriptorPoolSize;
     TVkDescriptorSetArray=array of TVkDescriptorSet;
     TVkDescriptorImageInfoArray=array of TVkDescriptorImageInfo;
     TVkDescriptorBufferInfoArray=array of TVkDescriptorBufferInfo;
     TVkClearValueArray=array of TVkClearValue;
     TVkResultArray=array of TVkResult;
     TVkCopyDescriptorSetArray=array of TVkCopyDescriptorSet;
     TVkWriteDescriptorSetArray=array of TVkWriteDescriptorSet;
     TVkSpecializationMapEntryArray=array of TVkSpecializationMapEntry;
     TVkPipelineCacheArray=array of TVkPipelineCache;
     TVkBufferImageCopyArray=array of TVkBufferImageCopy;

     TVulkanBaseList=class(TVulkanObject)
      private
       fItemSize:TVkSizeInt;
       fCount:TVkSizeInt;
       fAllocated:TVkSizeInt;
       fMemory:TVkPointer;
       procedure SetCount(const NewCount:TVkSizeInt);
       function GetItem(const Index:TVkSizeInt):TVkPointer;
      protected
       procedure InitializeItem(var Item); virtual;
       procedure FinalizeItem(var Item); virtual;
       procedure CopyItem(const Source;var Destination); virtual;
       procedure ExchangeItem(var Source,Destination); virtual;
       function CompareItem(const Source,Destination):TVkInt32; virtual;
      public
       constructor Create(const aItemSize:TVkSizeInt);
       destructor Destroy; override;
       procedure Clear; virtual;
       procedure FillWith(const SourceData;const SourceCount:TVkSizeInt); virtual;
       function Add(const Item):TVkSizeInt;
       function Find(const Item):TVkSizeInt;
       procedure Insert(const Index:TVkSizeInt;const Item);
       procedure Delete(const Index:TVkSizeInt);
       procedure Remove(const Item);
       procedure Exchange(const Index,WithIndex:TVkSizeInt);
       property Count:TVkSizeInt read fCount write SetCount;
       property Allocated:TVkSizeInt read fAllocated;
       property Memory:TVkPointer read fMemory;
       property ItemPointers[const Index:TVkSizeInt]:TVkPointer read GetItem; default;
     end;

     TVulkanObjectList=class(TVulkanBaseList)
      private
       fOwnObjects:boolean;
       function GetItem(const Index:TVkSizeInt):TVulkanObject;
       procedure SetItem(const Index:TVkSizeInt;const Item:TVulkanObject);
      protected
       procedure InitializeItem(var Item); override;
       procedure FinalizeItem(var Item); override;
       procedure CopyItem(const Source;var Destination); override;
       procedure ExchangeItem(var Source,Destination); override;
       function CompareItem(const Source,Destination):TVkInt32; override;
      public
       constructor Create;
       destructor Destroy; override;
       procedure Clear; override;
       function Add(const Item:TVulkanObject):TVkSizeInt; reintroduce;
       function Find(const Item:TVulkanObject):TVkSizeInt; reintroduce;
       procedure Insert(const Index:TVkSizeInt;const Item:TVulkanObject); reintroduce;
       procedure Remove(const Item:TVulkanObject); reintroduce;
       property Items[const Index:TVkSizeInt]:TVulkanObject read GetItem write SetItem; default;
       property OwnObjects:boolean read fOwnObjects write fOwnObjects;
     end;

     TVkUInt32List=class(TVulkanBaseList)
      private
       function GetItem(const Index:TVkSizeInt):TVkUInt32;
       procedure SetItem(const Index:TVkSizeInt;const Item:TVkUInt32);
      protected
       procedure InitializeItem(var Item); override;
       procedure FinalizeItem(var Item); override;
       procedure CopyItem(const Source;var Destination); override;
       procedure ExchangeItem(var Source,Destination); override;
       function CompareItem(const Source,Destination):TVkInt32; override;
      public
       constructor Create;
       destructor Destroy; override;
       function Add(const Item:TVkUInt32):TVkSizeInt; reintroduce;
       function Find(const Item:TVkUInt32):TVkSizeInt; reintroduce;
       procedure Insert(const Index:TVkSizeInt;const Item:TVkUInt32); reintroduce;
       procedure Remove(const Item:TVkUInt32); reintroduce;
       property Items[const Index:TVkSizeInt]:TVkUInt32 read GetItem write SetItem; default;
     end;

     TVkFloatList=class(TVulkanBaseList)
      private
       function GetItem(const Index:TVkSizeInt):TVkFloat;
       procedure SetItem(const Index:TVkSizeInt;const Item:TVkFloat);
      protected
       procedure InitializeItem(var Item); override;
       procedure FinalizeItem(var Item); override;
       procedure CopyItem(const Source;var Destination); override;
       procedure ExchangeItem(var Source,Destination); override;
       function CompareItem(const Source,Destination):TVkInt32; override;
      public
       constructor Create;
       destructor Destroy; override;
       function Add(const Item:TVkFloat):TVkSizeInt; reintroduce;
       function Find(const Item:TVkFloat):TVkSizeInt; reintroduce;
       procedure Insert(const Index:TVkSizeInt;const Item:TVkFloat); reintroduce;
       procedure Remove(const Item:TVkFloat); reintroduce;
       property Items[const Index:TVkSizeInt]:TVkFloat read GetItem write SetItem; default;
     end;

     TVkImageViewList=class(TVulkanBaseList)
      private
       function GetItem(const Index:TVkSizeInt):TVkImageView;
       procedure SetItem(const Index:TVkSizeInt;const Item:TVkImageView);
      protected
       procedure InitializeItem(var Item); override;
       procedure FinalizeItem(var Item); override;
       procedure CopyItem(const Source;var Destination); override;
       procedure ExchangeItem(var Source,Destination); override;
       function CompareItem(const Source,Destination):TVkInt32; override;
      public
       constructor Create;
       destructor Destroy; override;
       function Add(const Item:TVkImageView):TVkSizeInt; reintroduce;
       function Find(const Item:TVkImageView):TVkSizeInt; reintroduce;
       procedure Insert(const Index:TVkSizeInt;const Item:TVkImageView); reintroduce;
       procedure Remove(const Item:TVkImageView); reintroduce;
       property Items[const Index:TVkSizeInt]:TVkImageView read GetItem write SetItem; default;
     end;

     TVkSamplerList=class(TVulkanBaseList)
      private
       function GetItem(const Index:TVkSizeInt):TVkSampler;
       procedure SetItem(const Index:TVkSizeInt;const Item:TVkSampler);
      protected
       procedure InitializeItem(var Item); override;
       procedure FinalizeItem(var Item); override;
       procedure CopyItem(const Source;var Destination); override;
       procedure ExchangeItem(var Source,Destination); override;
       function CompareItem(const Source,Destination):TVkInt32; override;
      public
       constructor Create;
       destructor Destroy; override;
       function Add(const Item:TVkSampler):TVkSizeInt; reintroduce;
       function Find(const Item:TVkSampler):TVkSizeInt; reintroduce;
       procedure Insert(const Index:TVkSizeInt;const Item:TVkSampler); reintroduce;
       procedure Remove(const Item:TVkSampler); reintroduce;
       property Items[const Index:TVkSizeInt]:TVkSampler read GetItem write SetItem; default;
     end;

     TVkDescriptorSetLayoutList=class(TVulkanBaseList)
      private
       function GetItem(const Index:TVkSizeInt):TVkDescriptorSetLayout;
       procedure SetItem(const Index:TVkSizeInt;const Item:TVkDescriptorSetLayout);
      protected
       procedure InitializeItem(var Item); override;
       procedure FinalizeItem(var Item); override;
       procedure CopyItem(const Source;var Destination); override;
       procedure ExchangeItem(var Source,Destination); override;
       function CompareItem(const Source,Destination):TVkInt32; override;
      public
       constructor Create;
       destructor Destroy; override;
       function Add(const Item:TVkDescriptorSetLayout):TVkSizeInt; reintroduce;
       function Find(const Item:TVkDescriptorSetLayout):TVkSizeInt; reintroduce;
       procedure Insert(const Index:TVkSizeInt;const Item:TVkDescriptorSetLayout); reintroduce;
       procedure Remove(const Item:TVkDescriptorSetLayout); reintroduce;
       property Items[const Index:TVkSizeInt]:TVkDescriptorSetLayout read GetItem write SetItem; default;
     end;

     TVkSampleMaskList=class(TVulkanBaseList)
      private
       function GetItem(const Index:TVkSizeInt):TVkSampleMask;
       procedure SetItem(const Index:TVkSizeInt;const Item:TVkSampleMask);
      protected
       procedure InitializeItem(var Item); override;
       procedure FinalizeItem(var Item); override;
       procedure CopyItem(const Source;var Destination); override;
       procedure ExchangeItem(var Source,Destination); override;
       function CompareItem(const Source,Destination):TVkInt32; override;
      public
       constructor Create;
       destructor Destroy; override;
       function Add(const Item:TVkSampleMask):TVkSizeInt; reintroduce;
       function Find(const Item:TVkSampleMask):TVkSizeInt; reintroduce;
       procedure Insert(const Index:TVkSizeInt;const Item:TVkSampleMask); reintroduce;
       procedure Remove(const Item:TVkSampleMask); reintroduce;
       property Items[const Index:TVkSizeInt]:TVkSampleMask read GetItem write SetItem; default;
     end;

     TVkDynamicStateList=class(TVulkanBaseList)
      private
       function GetItem(const Index:TVkSizeInt):TVkDynamicState;
       procedure SetItem(const Index:TVkSizeInt;const Item:TVkDynamicState);
      protected
       procedure InitializeItem(var Item); override;
       procedure FinalizeItem(var Item); override;
       procedure CopyItem(const Source;var Destination); override;
       procedure ExchangeItem(var Source,Destination); override;
       function CompareItem(const Source,Destination):TVkInt32; override;
      public
       constructor Create;
       destructor Destroy; override;
       function Add(const Item:TVkDynamicState):TVkSizeInt; reintroduce;
       function Find(const Item:TVkDynamicState):TVkSizeInt; reintroduce;
       procedure Insert(const Index:TVkSizeInt;const Item:TVkDynamicState); reintroduce;
       procedure Remove(const Item:TVkDynamicState); reintroduce;
       property Items[const Index:TVkSizeInt]:TVkDynamicState read GetItem write SetItem; default;
     end;

     TVkBufferViewList=class(TVulkanBaseList)
      private
       function GetItem(const Index:TVkSizeInt):TVkBufferView;
       procedure SetItem(const Index:TVkSizeInt;const Item:TVkBufferView);
      protected
       procedure InitializeItem(var Item); override;
       procedure FinalizeItem(var Item); override;
       procedure CopyItem(const Source;var Destination); override;
       procedure ExchangeItem(var Source,Destination); override;
       function CompareItem(const Source,Destination):TVkInt32; override;
      public
       constructor Create;
       destructor Destroy; override;
       function Add(const Item:TVkBufferView):TVkSizeInt; reintroduce;
       function Find(const Item:TVkBufferView):TVkSizeInt; reintroduce;
       procedure Insert(const Index:TVkSizeInt;const Item:TVkBufferView); reintroduce;
       procedure Remove(const Item:TVkBufferView); reintroduce;
       property Items[const Index:TVkSizeInt]:TVkBufferView read GetItem write SetItem; default;
     end;

     TVkClearValueList=class(TVulkanBaseList)
      private
       function GetItem(const Index:TVkSizeInt):TVkClearValue;
       procedure SetItem(const Index:TVkSizeInt;const Item:TVkClearValue);
      protected
       procedure InitializeItem(var Item); override;
       procedure FinalizeItem(var Item); override;
       procedure CopyItem(const Source;var Destination); override;
       procedure ExchangeItem(var Source,Destination); override;
       function CompareItem(const Source,Destination):TVkInt32; override;
      public
       constructor Create;
       destructor Destroy; override;
       function Add(const Item:TVkClearValue):TVkSizeInt; reintroduce;
       function Find(const Item:TVkClearValue):TVkSizeInt; reintroduce;
       procedure Insert(const Index:TVkSizeInt;const Item:TVkClearValue); reintroduce;
       procedure Remove(const Item:TVkClearValue); reintroduce;
       property Items[const Index:TVkSizeInt]:TVkClearValue read GetItem write SetItem; default;
     end;

     EVulkanDataStream=class(Exception);

     TVulkanDataStream=class(TStream)
      private
       fData:TVkPointer;
       fSize:TVkInt64;
       fPosition:TVkInt64;
      public
       constructor Create(const AData:TVkPointer;const ASize:TVkInt64);
       destructor Destroy; override;
       function Read(var Buffer;Count:TVkInt32):TVkInt32; override;
       function Write(const Buffer;Count:TVkInt32):TVkInt32; override;
       function Seek(Offset:TVkInt32;Origin:TVkUInt16):TVkInt32; overload; override;
       function Seek(const Offset:TVkInt64;Origin:TSeekOrigin):TVkInt64; overload; override;
       procedure SetSize(NewSize:TVkInt32); overload; override;
       procedure SetSize(const NewSize:TVkInt64); overload; override;
     end;

     TVulkanStringHashMapData=TVkPointer;

     PVulkanStringHashMapEntity=^TVulkanStringHashMapEntity;
     TVulkanStringHashMapEntity=record
      Key:TVulkanRawByteString;
      Value:TVulkanStringHashMapData;
     end;

     TVulkanStringHashMapEntities=array of TVulkanStringHashMapEntity;

     TVulkanStringHashMapEntityIndices=array of TVkInt32;

     TVulkanStringHashMap=class
      private
       function FindCell(const Key:TVulkanRawByteString):TVkUInt32;
       procedure Resize;
      protected
       function GetValue(const Key:TVulkanRawByteString):TVulkanStringHashMapData;
       procedure SetValue(const Key:TVulkanRawByteString;const Value:TVulkanStringHashMapData);
      public
       RealSize:TVkInt32;
       LogSize:TVkInt32;
       Size:TVkInt32;
       Entities:TVulkanStringHashMapEntities;
       EntityToCellIndex:TVulkanStringHashMapEntityIndices;
       CellToEntityIndex:TVulkanStringHashMapEntityIndices;
       constructor Create;
       destructor Destroy; override;
       procedure Clear;
       function Add(const Key:TVulkanRawByteString;Value:TVulkanStringHashMapData):PVulkanStringHashMapEntity;
       function Get(const Key:TVulkanRawByteString;CreateIfNotExist:boolean=false):PVulkanStringHashMapEntity;
       function TryGet(const Key:TVulkanRawByteString;out Value:TVulkanStringHashMapData):boolean;
       function ExistKey(const Key:TVulkanRawByteString):boolean;
       function Delete(const Key:TVulkanRawByteString):boolean;
       property Values[const Key:TVulkanRawByteString]:TVulkanStringHashMapData read GetValue write SetValue; default;
     end;

     TVulkanPointerHashMapData=TVkPointer;

     PVulkanPointerHashMapEntity=^TVulkanPointerHashMapEntity;
     TVulkanPointerHashMapEntity=record
      Key:TVkPointer;
      Value:TVulkanPointerHashMapData;
     end;

     TVulkanPointerHashMapEntities=array of TVulkanPointerHashMapEntity;

     TVulkanPointerHashMapEntityIndices=array of TVkInt32;

     TVulkanPointerHashMap=class
      private
       function FindCell(const Key:TVkPointer):TVkUInt32;
       procedure Resize;
      protected
       function GetValue(const Key:TVkPointer):TVulkanPointerHashMapData;
       procedure SetValue(const Key:TVkPointer;const Value:TVulkanPointerHashMapData);
      public
       RealSize:TVkInt32;
       LogSize:TVkInt32;
       Size:TVkInt32;
       Entities:TVulkanPointerHashMapEntities;
       EntityToCellIndex:TVulkanPointerHashMapEntityIndices;
       CellToEntityIndex:TVulkanPointerHashMapEntityIndices;
       constructor Create;
       destructor Destroy; override;
       procedure Clear;
       function Add(const Key:TVkPointer;Value:TVulkanPointerHashMapData):PVulkanPointerHashMapEntity;
       function Get(const Key:TVkPointer;CreateIfNotExist:boolean=false):PVulkanPointerHashMapEntity;
       function TryGet(const Key:TVkPointer;out Value:TVulkanPointerHashMapData):boolean;
       function ExistKey(const Key:TVkPointer):boolean;
       function Delete(const Key:TVkPointer):boolean;
       property Values[const Key:TVkPointer]:TVulkanPointerHashMapData read GetValue write SetValue; default;
     end;

     TVulkanInt64HashMapData=TVkPointer;

     PVulkanInt64HashMapEntity=^TVulkanInt64HashMapEntity;
     TVulkanInt64HashMapEntity=record
      Key:TVkInt64;
      Value:TVulkanInt64HashMapData;
     end;

     TVulkanInt64HashMapEntities=array of TVulkanInt64HashMapEntity;

     TVulkanInt64HashMapEntityIndices=array of TVkInt32;

     TVulkanInt64HashMap=class
      private
       function FindCell(const Key:TVkInt64):TVkUInt32;
       procedure Resize;
      protected
       function GetValue(const Key:TVkInt64):TVulkanInt64HashMapData;
       procedure SetValue(const Key:TVkInt64;const Value:TVulkanInt64HashMapData);
      public
       RealSize:TVkInt32;
       LogSize:TVkInt32;
       Size:TVkInt32;
       Entities:TVulkanInt64HashMapEntities;
       EntityToCellIndex:TVulkanInt64HashMapEntityIndices;
       CellToEntityIndex:TVulkanInt64HashMapEntityIndices;
       constructor Create;
       destructor Destroy; override;
       procedure Clear;
       function Add(const Key:TVkInt64;Value:TVulkanInt64HashMapData):PVulkanInt64HashMapEntity;
       function Get(const Key:TVkInt64;CreateIfNotExist:boolean=false):PVulkanInt64HashMapEntity;
       function TryGet(const Key:TVkInt64;out Value:TVulkanInt64HashMapData):boolean;
       function ExistKey(const Key:TVkInt64):boolean;
       function Delete(const Key:TVkInt64):boolean;
       property Values[const Key:TVkInt64]:TVulkanInt64HashMapData read GetValue write SetValue; default;
     end;

     TVulkanXMLClass=class
      public
       Previous,Next:TVulkanXMLClass;
       Core:TVkPointer;
       constructor Create; overload; virtual;
       destructor Destroy; override;
     end;

     PVulkanXMLClasses=^TVulkanXMLClasses;
     TVulkanXMLClasses=array[0..VulkanXMLMaxListSize-1] of TVulkanXMLClass;

     TVulkanXMLClassList=class(TVulkanXMLClass)
      private
       InternalList:PVulkanXMLClasses;
       InternalCount,InternalCapacity:TVkInt32;
       function GetItem(Index:TVkInt32):TVulkanXMLClass;
       procedure SetItem(Index:TVkInt32;Value:TVulkanXMLClass);
       function GetItemPointer(Index:TVkInt32):TVulkanXMLClass;
      public
       ClearWithContentDestroying:boolean;
       CapacityMinimium:TVkInt32;
       constructor Create; override;
       destructor Destroy; override;
       procedure Clear;
       procedure ClearNoFree;
       procedure ClearWithFree;
       function Add(Item:TVulkanXMLClass):TVkInt32;
       function Append(Item:TVulkanXMLClass):TVkInt32;
       function AddList(List:TVulkanXMLClassList):TVkInt32;
       function AppendList(List:TVulkanXMLClassList):TVkInt32;
       function NewClass:TVulkanXMLClass;
       procedure Insert(Index:TVkInt32;Item:TVulkanXMLClass);
       procedure Delete(Index:TVkInt32);
       procedure DeleteClass(Index:TVkInt32);
       function Remove(Item:TVulkanXMLClass):TVkInt32;
       function RemoveClass(Item:TVulkanXMLClass):TVkInt32;
       function Find(Item:TVulkanXMLClass):TVkInt32;
       function IndexOf(Item:TVulkanXMLClass):TVkInt32;
       procedure Exchange(Index1,Index2:TVkInt32);
       procedure SetCapacity(NewCapacity:TVkInt32);
       procedure SetOptimalCapacity(TargetCapacity:TVkInt32);
       procedure SetCount(NewCount:TVkInt32);
       function Push(Item:TVulkanXMLClass):TVkInt32;
       function Pop(var Item:TVulkanXMLClass):boolean; overload;
       function Pop:TVulkanXMLClass; overload;
       function Last:TVulkanXMLClass;
       property Count:TVkInt32 read InternalCount; 
       property Capacity:TVkInt32 read InternalCapacity write SetCapacity;
       property Item[Index:TVkInt32]:TVulkanXMLClass read GetItem write SetItem; default;
       property Items[Index:TVkInt32]:TVulkanXMLClass read GetItem write SetItem;
       property PItems[Index:TVkInt32]:TVulkanXMLClass read GetItemPointer;
     end;

     TVulkanXMLClassLinkedList=class(TVulkanXMLClass)
      public
       ClearWithContentDestroying:boolean;
       First,Last:TVulkanXMLClass;
       constructor Create; override;
       destructor Destroy; override;
       procedure Clear;
       procedure ClearNoFree;
       procedure ClearWithFree;
       procedure Add(Item:TVulkanXMLClass);
       procedure Append(Item:TVulkanXMLClass);
       procedure AddLinkedList(List:TVulkanXMLClassLinkedList);
       procedure AppendLinkedList(List:TVulkanXMLClassLinkedList);
       procedure Remove(Item:TVulkanXMLClass);
       procedure RemoveClass(Item:TVulkanXMLClass);
       procedure Push(Item:TVulkanXMLClass);
       function Pop(var Item:TVulkanXMLClass):boolean; overload;
       function Pop:TVulkanXMLClass; overload;
       function Count:TVkInt32;
     end;

     TVulkanXMLString={$ifdef VulkanXMLUnicode}{$if declared(UnicodeString)}UnicodeString{$else}WideString{$ifend}{$else}TVulkanRawByteString{$endif};
     TVulkanXMLChar={$ifdef VulkanXMLUnicode}WideChar{$else}TVulkanRawByteChar{$endif};

     TVulkanXMLParameter=class(TVulkanXMLClass)
      public
       Name:TVulkanRawByteString;
       Value:TVulkanXMLString;
       constructor Create; override;
       destructor Destroy; override;
       procedure Assign(From:TVulkanXMLParameter); virtual;
     end;

     TVulkanXMLItemList=class;

     TVulkanXMLTag=class;

     TVulkanXMLItem=class(TVulkanXMLClass)
      public
       Items:TVulkanXMLItemList;
       constructor Create; override;
       destructor Destroy; override;
       procedure Clear; virtual;
       procedure Add(Item:TVulkanXMLItem);
       procedure Assign(From:TVulkanXMLItem); virtual;
       function FindTag(const TagName:TVulkanRawByteString):TVulkanXMLTag;
     end;

     TVulkanXMLItemList=class(TVulkanXMLClassList)
      private
       function GetItem(Index:TVkInt32):TVulkanXMLItem;
       procedure SetItem(Index:TVkInt32;Value:TVulkanXMLItem);
      public
       constructor Create; override;
       destructor Destroy; override;
       function NewClass:TVulkanXMLItem;
       function FindTag(const TagName:TVulkanRawByteString):TVulkanXMLTag;
       property Item[Index:TVkInt32]:TVulkanXMLItem read GetItem write SetItem; default;
       property Items[Index:TVkInt32]:TVulkanXMLItem read GetItem write SetItem;
     end;

     TVulkanXMLText=class(TVulkanXMLItem)
      public
       Text:TVulkanXMLString;
       constructor Create; override;
       destructor Destroy; override;
       procedure Assign(From:TVulkanXMLItem); override;
       procedure SetText(AText:TVulkanRawByteString);
     end;

     TVulkanXMLCommentTag=class(TVulkanXMLItem)
      public
       Text:TVulkanRawByteString;
       constructor Create; override;
       destructor Destroy; override;
       procedure Assign(From:TVulkanXMLItem); override;
       procedure SetText(AText:TVulkanRawByteString);
     end;

     TVulkanXMLTag=class(TVulkanXMLItem)
      public
       Name:TVulkanRawByteString;
       Parameter:array of TVulkanXMLParameter;
       IsAloneTag:boolean;
       constructor Create; override;
       destructor Destroy; override;
       procedure Clear; override;
       procedure Assign(From:TVulkanXMLItem); override;
       function FindParameter(ParameterName:TVulkanRawByteString):TVulkanXMLParameter;
       function GetParameter(ParameterName:TVulkanRawByteString;default:TVulkanRawByteString=''):TVulkanRawByteString;
       function AddParameter(AParameter:TVulkanXMLParameter):boolean; overload;
       function AddParameter(Name:TVulkanRawByteString;Value:TVulkanXMLString):boolean; overload;
       function RemoveParameter(AParameter:TVulkanXMLParameter):boolean; overload;
       function RemoveParameter(ParameterName:TVulkanRawByteString):boolean; overload;
     end;

     TVulkanXMLProcessTag=class(TVulkanXMLTag)
      public
       constructor Create; override;
       destructor Destroy; override;
       procedure Assign(From:TVulkanXMLItem); override;
     end;

     TVulkanXMLScriptTag=class(TVulkanXMLItem)
      public
       Text:TVulkanRawByteString;
       constructor Create; override;
       destructor Destroy; override;
       procedure Assign(From:TVulkanXMLItem); override;
       procedure SetText(AText:TVulkanRawByteString);
     end;

     TVulkanXMLCDataTag=class(TVulkanXMLItem)
      public
       Text:TVulkanRawByteString;
       constructor Create; override;
       destructor Destroy; override;
       procedure Assign(From:TVulkanXMLItem); override;
       procedure SetText(AText:TVulkanRawByteString);
     end;

     TVulkanXMLDOCTYPETag=class(TVulkanXMLItem)
      public
       Text:TVulkanRawByteString;
       constructor Create; override;
       destructor Destroy; override;
       procedure Assign(From:TVulkanXMLItem); override;
       procedure SetText(AText:TVulkanRawByteString);
     end;

     TVulkanXMLExtraTag=class(TVulkanXMLItem)
      public
       Text:TVulkanRawByteString;
       constructor Create; override;
       destructor Destroy; override;
       procedure Assign(From:TVulkanXMLItem); override;
       procedure SetText(AText:TVulkanRawByteString);
     end;

     TVulkanXML=class(TVulkanXMLClass)
      private
       function ReadXMLText:TVulkanRawByteString;
       procedure WriteXMLText(Text:TVulkanRawByteString);
      public
       Root:TVulkanXMLItem;
       AutomaticAloneTagDetection:boolean;
       FormatIndent:boolean;
       FormatIndentText:boolean;
       constructor Create; override;
       destructor Destroy; override;
       procedure Assign(From:TVulkanXML);
       function Parse(Stream:TStream):boolean;
       function Read(Stream:TStream):boolean;
       function Write(Stream:TStream;IdentSize:TVkInt32=2):boolean;
       property Text:TVulkanRawByteString read ReadXMLText write WriteXMLText;
     end;

     TVulkanAllocationManager=class(TVulkanObject)
      private
       fAllocationCallbacks:TVkAllocationCallbacks;
      protected
       function AllocationCallback(const Size:TVkSize;const Alignment:TVkSize;const Scope:TVkSystemAllocationScope):PVkVoid; virtual;
       function ReallocationCallback(const Original:PVkVoid;const Size:TVkSize;const Alignment:TVkSize;const Scope:TVkSystemAllocationScope):PVkVoid; virtual;
       procedure FreeCallback(const Memory:PVkVoid); virtual;
       procedure InternalAllocationCallback(const Size:TVkSize;const Type_:TVkInternalAllocationType;const Scope:TVkSystemAllocationScope);
       procedure InternalFreeCallback(const Size:TVkSize;const Type_:TVkInternalAllocationType;const Scope:TVkSystemAllocationScope);
      public
       constructor Create;
       destructor Destroy; override;
       property AllocationCallbacks:TVkAllocationCallbacks read fAllocationCallbacks;
     end;

     PVulkanAvailableLayer=^TVulkanAvailableLayer;
     TVulkanAvailableLayer=record
      LayerName:TVulkanCharString;
      SpecVersion:TVkUInt32;
      ImplementationVersion:TVkUInt32;
      Description:TVulkanCharString;
     end;

     TVulkanAvailableLayers=array of TVulkanAvailableLayer;

     PVulkanAvailableExtension=^TVulkanAvailableExtension;
     TVulkanAvailableExtension=record
      LayerIndex:TVkUInt32;
      ExtensionName:TVulkanCharString;
      SpecVersion:TVkUInt32;
     end;

     TVulkanAvailableExtensions=array of TVulkanAvailableExtension;

     TVulkanInstance=class;

     TVulkanPhysicalDevice=class;

     TVulkanPhysicalDeviceList=class;

     TVulkanInstanceDebugReportCallback=function(const flags:TVkDebugReportFlagsEXT;const objectType:TVkDebugReportObjectTypeEXT;const object_:TVkUInt64;const location:TVkSize;messageCode:TVkInt32;const aLayerPrefix:TVulkaNCharString;const aMessage:TVulkanCharString):TVkBool32 of object;

     TVulkanInstance=class(TVulkanObject)
      private    
       fVulkan:TVulkan;
       fApplicationInfo:TVkApplicationInfo;
       fApplicationName:TVulkanCharString;
       fEngineName:TVulkanCharString;
       fValidation:longbool;
       fAllocationManager:TVulkanAllocationManager;
       fAllocationCallbacks:PVkAllocationCallbacks;
       fAvailableLayers:TVulkanAvailableLayers;
       fAvailableExtensions:TVulkanAvailableExtensions;
       fAvailableLayerNames:TStringList;
       fAvailableExtensionNames:TStringList;
       fEnabledLayerNames:TStringList;
       fEnabledExtensionNames:TStringList;
       fEnabledLayerNameStrings:array of TVulkanCharString;
       fEnabledExtensionNameStrings:array of TVulkanCharString;
       fRawEnabledLayerNameStrings:array of PVkChar;
       fRawEnabledExtensionNameStrings:array of PVkChar;
       fInstanceHandle:TVkInstance;
       fInstanceVulkan:TVulkan;
       fPhysicalDevices:TVulkanPhysicalDeviceList;
       fNeedToEnumeratePhysicalDevices:boolean;
       fDebugReportCallbackCreateInfoEXT:TVkDebugReportCallbackCreateInfoEXT;
       fDebugReportCallbackEXT:TVkDebugReportCallbackEXT;
       fOnInstanceDebugReportCallback:TVulkanInstanceDebugReportCallback;
       procedure SetApplicationInfo(const NewApplicationInfo:TVkApplicationInfo);
       function GetApplicationName:TVulkanCharString;
       procedure SetApplicationName(const NewApplicationName:TVulkanCharString);
       function GetApplicationVersion:TVkUInt32;
       procedure SetApplicationVersion(const NewApplicationVersion:TVkUInt32);
       function GetEngineName:TVulkanCharString;
       procedure SetEngineName(const NewEngineName:TVulkanCharString);
       function GetEngineVersion:TVkUInt32;
       procedure SetEngineVersion(const NewEngineVersion:TVkUInt32);
       function GetAPIVersion:TVkUInt32;
       procedure SetAPIVersion(const NewAPIVersion:TVkUInt32);
       procedure EnumeratePhysicalDevices;
      protected
       function DebugReportCallback(const flags:TVkDebugReportFlagsEXT;const objectType:TVkDebugReportObjectTypeEXT;const object_:TVkUInt64;const location:TVkSize;messageCode:TVkInt32;const aLayerPrefix:TVulkaNCharString;const aMessage:TVulkanCharString):TVkBool32; virtual;
      public
       constructor Create(const aApplicationName:TVulkanCharString='Vulkan application';
                          const aApplicationVersion:TVkUInt32=1;
                          const aEngineName:TVulkanCharString='Vulkan engine';
                          const aEngineVersion:TVkUInt32=1;
                          const pAPIVersion:TVkUInt32=VK_API_VERSION_1_0;
                          const aValidation:boolean=false;
                          const aAllocationManager:TVulkanAllocationManager=nil);
       destructor Destroy; override;
       procedure Initialize;
       procedure InstallDebugReportCallback;
       property ApplicationInfo:TVkApplicationInfo read fApplicationInfo write SetApplicationInfo;
      published
       property ApplicationName:TVulkanCharString read GetApplicationName write SetApplicationName;
       property ApplicationVersion:TVkUInt32 read GetApplicationVersion write SetApplicationVersion;
       property EngineName:TVulkanCharString read GetEngineName write SetEngineName;
       property EngineVersion:TVkUInt32 read GetEngineVersion write SetEngineVersion;
       property APIVersion:TVkUInt32 read GetAPIVersion write SetAPIVersion;
       property Validation:longbool read fValidation write fValidation;
       property AvailableLayers:TVulkanAvailableLayers read fAvailableLayers;
       property AvailableExtensions:TVulkanAvailableExtensions read fAvailableExtensions;
       property AvailableLayerNames:TStringList read fAvailableLayerNames;
       property AvailableExtensionNames:TStringList read fAvailableExtensionNames;
       property EnabledLayerNames:TStringList read fEnabledLayerNames;
       property EnabledExtensionNames:TStringList read fEnabledExtensionNames;
       property Handle:TVkInstance read fInstanceHandle;
       property Commands:TVulkan read fInstanceVulkan;
       property PhysicalDevices:TVulkanPhysicalDeviceList read fPhysicalDevices;
       property OnInstanceDebugReportCallback:TVulkanInstanceDebugReportCallback read fOnInstanceDebugReportCallback write fOnInstanceDebugReportCallback;
     end;

     TVulkanSurface=class;

     TVulkanPhysicalDevice=class(TVulkanObject)
      private
       fInstance:TVulkanInstance;
       fPhysicalDeviceHandle:TVkPhysicalDevice;
       fDeviceName:TVulkanCharString;
       fProperties:TVkPhysicalDeviceProperties;
       fMemoryProperties:TVkPhysicalDeviceMemoryProperties;
       fFeatures:TVkPhysicalDeviceFeatures;
       fQueueFamilyProperties:TVkQueueFamilyPropertiesArray;
       fAvailableLayers:TVulkanAvailableLayers;
       fAvailableExtensions:TVulkanAvailableExtensions;
       fAvailableLayerNames:TStringList;
       fAvailableExtensionNames:TStringList;
      public
       constructor Create(const aInstance:TVulkanInstance;const aPhysicalDevice:TVkPhysicalDevice);
       destructor Destroy; override;
       function HasQueueSupportForSparseBindings(const aQueueFamilyIndex:TVkUInt32):boolean;
       function GetFormatProperties(const aFormat:TVkFormat):TVkFormatProperties;
       function GetImageFormatProperties(const aFormat:TVkFormat;
                                         const aType:TVkImageType;
                                         const aTiling:TVkImageTiling;
                                         const aUsageFlags:TVkImageUsageFlags;
                                         const aCreateFlags:TVkImageCreateFlags):TVkImageFormatProperties;
       function GetSparseImageFormatProperties(const aFormat:TVkFormat;
                                               const aType:TVkImageType;
                                               const aSamples:TVkSampleCountFlagBits;
                                               const aUsageFlags:TVkImageUsageFlags;
                                               const aTiling:TVkImageTiling):TVkSparseImageFormatPropertiesArray;
       function GetSurfaceSupport(const aQueueFamilyIndex:TVkUInt32;const aSurface:TVulkanSurface):boolean;
       function GetSurfaceCapabilities(const aSurface:TVulkanSurface):TVkSurfaceCapabilitiesKHR;
       function GetSurfaceFormats(const aSurface:TVulkanSurface):TVkSurfaceFormatKHRArray;
       function GetSurfacePresentModes(const aSurface:TVulkanSurface):TVkPresentModeKHRArray;
       function GetDisplayProperties:TVkDisplayPropertiesKHRArray;
       function GetDisplayPlaneProperties:TVkDisplayPlanePropertiesKHRArray;
       function GetDisplayPlaneSupportedDisplays(const aPlaneIndex:TVkUInt32):TVkDisplayKHRArray;
       function GetDisplayModeProperties(const aDisplay:TVkDisplayKHR):TVkDisplayModePropertiesKHRArray;
       function GetMemoryType(const aTypeBits:TVkUInt32;const aProperties:TVkFlags):TVkUInt32;
       function GetBestSupportedDepthFormat(const aWithStencil:boolean):TVkFormat;
       function GetQueueNodeIndex(const aSurface:TVulkanSurface;const aQueueFlagBits:TVkQueueFlagBits):TVkInt32;
       function GetSurfaceFormat(const aSurface:TVulkanSurface):TVkSurfaceFormatKHR;
       property Properties:TVkPhysicalDeviceProperties read fProperties;
       property MemoryProperties:TVkPhysicalDeviceMemoryProperties read fMemoryProperties;
       property Features:TVkPhysicalDeviceFeatures read fFeatures;
      published
       property Handle:TVkPhysicalDevice read fPhysicalDeviceHandle;
       property DeviceName:TVulkanCharString read fDeviceName;
       property QueueFamilyProperties:TVkQueueFamilyPropertiesArray read fQueueFamilyProperties;
       property AvailableLayers:TVulkanAvailableLayers read fAvailableLayers;
       property AvailableExtensions:TVulkanAvailableExtensions read fAvailableExtensions;
       property AvailableLayerNames:TStringList read fAvailableLayerNames;
       property AvailableExtensionNames:TStringList read fAvailableExtensionNames;
     end;

     TVulkanPhysicalDeviceList=class(TVulkanObjectList)
      private
       function GetItem(const Index:TVkSizeInt):TVulkanPhysicalDevice;
       procedure SetItem(const Index:TVkSizeInt;const Item:TVulkanPhysicalDevice);
      public
       property Items[const Index:TVkSizeInt]:TVulkanPhysicalDevice read GetItem write SetItem; default;
     end;

     PVulkanSurfacePlatform=^TVulkanSurfacePlatform;
     TVulkanSurfacePlatform=
      (
       vspUnknown,
       vspAndroid,
       vspMir,
       vspWayland,
       vspWin32,
       vspXCB,
       vspXLIB,
       vspMolkenVK_IOS,
       vspMolkenVK_MacOS
      );

     PVulkanSurfaceCreateInfo=^TVulkanSurfaceCreateInfo;
     TVulkanSurfaceCreateInfo=record
      case TVulkanSurfacePlatform of
       vspUnknown:(
        sType:TVkStructureType; //< Must be VK_STRUCTURE_TYPE_*_SURFACE_CREATE_INFO_KHR
        aNext:PVkVoid; //< TVkPointer to next structure
        flags:TVkFlags; //< Reserved
       );
{$if defined(Android) and defined(Unix)}
       vspAndroid:(
        Android:TVkAndroidSurfaceCreateInfoKHR;
       );
{$ifend}
{$if defined(Mir) and defined(Unix)}
       vspMir:(
        Mir:TVkMirSurfaceCreateInfoKHR;
       );
{$ifend}
{$if defined(Wayland) and defined(Unix)}
       vspWayland:(
        Wayland:TVkWaylandSurfaceCreateInfoKHR;
       );
{$ifend}
{$if defined(Windows)}
       vspWin32:(
        Win32:TVkWin32SurfaceCreateInfoKHR;
       );
{$ifend}
{$if defined(XCB) and defined(Unix)}
       vspXCB:(
        XCB:TVkXCBSurfaceCreateInfoKHR;
       );
{$ifend}
{$if defined(XLIB) and defined(Unix)}
       vspXLIB:(
        XLIB:TVkXLIBSurfaceCreateInfoKHR;
       );
{$ifend}
{$if defined(MoltenVK_IOS) and defined(Darwin)}
       vspMolkenVK_IOS:(
        MolkenVK_IOS:TVkIOSSurfaceCreateInfoMVK;
       );
{$ifend}
{$if defined(MoltenVK_MacOS) and defined(Darwin)}
       vspMolkenVK_MacOS:(
        MolkenVK_MacOS:TVkMacOSSurfaceCreateInfoMVK;
       );
{$ifend}
     end;

     TVulkanSurface=class(TVulkanObject)
      private
       fInstance:TVulkanInstance;
       fSurfaceCreateInfo:TVulkanSurfaceCreateInfo;
       fSurfaceHandle:TVkSurfaceKHR;
      protected
      public
       constructor Create(const aInstance:TVulkanInstance;const aSurfaceCreateInfo:TVulkanSurfaceCreateInfo);
{$if defined(Android)}
       constructor CreateAndroid(const aInstance:TVulkanInstance;const aWindow:PVkAndroidANativeWindow);
{$ifend}
{$if defined(Mir) and defined(Unix)}
       constructor CreateMir(const aInstance:TVulkanInstance;const aConnection:PVkMirConnection;const aSurface:PVkMirSurface);
{$ifend}
{$if defined(Wayland) and defined(Unix)}
       constructor CreateWayland(const aInstance:TVulkanInstance;const aDisplay:PVkWaylandDisplay;const aSurface:PVkWaylandSurface);
{$ifend}
{$if defined(Windows)}
       constructor CreateWin32(const aInstance:TVulkanInstance;const aInstanceHandle,aWindowHandle:THandle);
{$ifend}
{$if defined(XCB) and defined(Unix)}
       constructor CreateXCB(const aInstance:TVulkanInstance;const aConnection:PVkXCBConnection;const aWindow:TVkXCBWindow);
{$ifend}
{$if defined(XLIB) and defined(Unix)}
       constructor CreateXLIB(const aInstance:TVulkanInstance;const aDisplay:PVkXLIBDisplay;const aWindow:TVkXLIBWindow);
{$ifend}
{$if defined(MoltenVK_IOS) and defined(Darwin)}
       constructor CreateMoltenVK_IOS(const aInstance:TVulkanInstance;const aView:PVkVoid);
{$ifend}
{$if defined(MoltenVK_MacOS) and defined(Darwin)}
       constructor CreateMoltenVK_MacOS(const aInstance:TVulkanInstance;const aView:PVkVoid);
{$ifend}
       destructor Destroy; override;
      published
       property Handle:TVkSurfaceKHR read fSurfaceHandle;
     end;

     TVulkanDeviceQueueCreateInfo=class;

     TVulkanDeviceQueueCreateInfoList=class;

     TVulkanDeviceMemoryManager=class;

     TVulkanQueue=class;

     TVulkanQueues=array of TVulkanQueue;

     TVulkanDevice=class(TVulkanObject)
      private
       fInstance:TVulkanInstance;
       fPhysicalDevice:TVulkanPhysicalDevice;
       fSurface:TVulkanSurface;
       fDeviceQueueCreateInfoList:TVulkanDeviceQueueCreateInfoList;
       fDeviceQueueCreateInfos:TVkDeviceQueueCreateInfoArray;
       fEnabledLayerNames:TStringList;
       fEnabledExtensionNames:TStringList;
       fEnabledLayerNameStrings:array of TVulkanCharString;
       fEnabledExtensionNameStrings:array of TVulkanCharString;
       fRawEnabledLayerNameStrings:array of PVkChar;
       fRawEnabledExtensionNameStrings:array of PVkChar;
       fEnabledFeatures:TVkPhysicalDeviceFeatures;
       fPointerToEnabledFeatures:PVkPhysicalDeviceFeatures;
       fAllocationManager:TVulkanAllocationManager;
       fAllocationCallbacks:PVkAllocationCallbacks;
       fDeviceHandle:TVkDevice;
       fDeviceVulkan:TVulkan;
       fPresentQueueFamilyIndex:TVkInt32;
       fGraphicsQueueFamilyIndex:TVkInt32;
       fComputeQueueFamilyIndex:TVkInt32;
       fTransferQueueFamilyIndex:TVkInt32;
       fQueues:TVulkanQueues;
       fPresentQueue:TVulkanQueue;
       fGraphicsQueue:TVulkanQueue;
       fComputeQueue:TVulkanQueue;
       fTransferQueue:TVulkanQueue;
       fMemoryManager:TVulkanDeviceMemoryManager;
      protected
      public
       constructor Create(const aInstance:TVulkanInstance;
                          const aPhysicalDevice:TVulkanPhysicalDevice=nil;
                          const aSurface:TVulkanSurface=nil;
                          const aAllocationManager:TVulkanAllocationManager=nil);
       destructor Destroy; override;
       procedure AddQueue(const aQueueFamilyIndex:TVkUInt32;const aQueuePriorities:array of TVkFloat;const aSurface:TVulkanSurface=nil);
       procedure AddQueues(const aPresent:boolean=true;
                           const aGraphics:boolean=true;
                           const aCompute:boolean=true;
                           const aTransfer:boolean=true;
                           const aSparseBinding:boolean=false;
                           const aSurface:TVulkanSurface=nil);
       procedure Initialize;
       procedure WaitIdle;
       property EnabledFeatures:PVkPhysicalDeviceFeatures read fPointerToEnabledFeatures;
      published
       property PhysicalDevice:TVulkanPhysicalDevice read fPhysicalDevice;
       property Surface:TVulkanSurface read fSurface;
       property EnabledLayerNames:TStringList read fEnabledLayerNames;
       property EnabledExtensionNames:TStringList read fEnabledExtensionNames;
       property Handle:TVkDevice read fDeviceHandle;
       property Commands:TVulkan read fDeviceVulkan;
       property PresentQueueFamilyIndex:TVkInt32 read fPresentQueueFamilyIndex;
       property GraphicsQueueFamilyIndex:TVkInt32 read fGraphicsQueueFamilyIndex;
       property ComputeQueueFamilyIndex:TVkInt32 read fComputeQueueFamilyIndex;
       property TransferQueueFamilyIndex:TVkInt32 read fTransferQueueFamilyIndex;
       property Queues:TVulkanQueues read fQueues;
       property PresentQueue:TVulkanQueue read fPresentQueue;
       property GraphicsQueue:TVulkanQueue read fGraphicsQueue;
       property ComputeQueue:TVulkanQueue read fComputeQueue;
       property TransferQueue:TVulkanQueue read fTransferQueue;
       property MemoryManager:TVulkanDeviceMemoryManager read fMemoryManager;
     end;

     TVulkanDeviceQueueCreateInfo=class(TVulkanObject)
      private
       fQueueFamilyIndex:TVkUInt32;
       fQueuePriorities:TVkFloatArray;
      public
       constructor Create(const aQueueFamilyIndex:TVkUInt32;const aQueuePriorities:array of TVkFloat);
       destructor Destroy; override;
      published
       property QueueFamilyIndex:TVkUInt32 read fQueueFamilyIndex;
       property QueuePriorities:TVkFloatArray read fQueuePriorities;
     end;

     TVulkanDeviceQueueCreateInfoList=class(TVulkanObjectList)
      private
       function GetItem(const Index:TVkSizeInt):TVulkanDeviceQueueCreateInfo;
       procedure SetItem(const Index:TVkSizeInt;const Item:TVulkanDeviceQueueCreateInfo);
      public
       property Items[const Index:TVkSizeInt]:TVulkanDeviceQueueCreateInfo read GetItem write SetItem; default;
     end;

     TVulkanResource=class(TVulkanObject)
      private
       fDevice:TVulkanDevice;
       fOwnsResource:boolean;
      public
       constructor Create; reintroduce; virtual;
       destructor Destroy; override;
       procedure Clear; virtual;
      published
       property Device:TVulkanDevice read fDevice write fDevice;
       property OwnsResource:boolean read fOwnsResource write fOwnsResource;
     end;

     PVulkanDeviceMemoryAllocationType=^TVulkanDeviceMemoryAllocationType;
     TVulkanDeviceMemoryAllocationType=
      (
       vdmatFree,
       vdmatUnknown,
       vdmatBuffer,
       vdmatImageLinear,
       vdmatImageOptimal
      );

     PVulkanDeviceMemoryChunkFlag=^TVulkanDeviceMemoryChunkFlag;
     TVulkanDeviceMemoryChunkFlag=
      (
       vdmcfPersistentMapped
      );

     PVulkanDeviceMemoryChunkFlags=^TVulkanDeviceMemoryChunkFlags;
     TVulkanDeviceMemoryChunkFlags=set of TVulkanDeviceMemoryChunkFlag;

     TVulkanDeviceMemoryChunkBlock=class;

     PVulkanDeviceMemoryChunkBlockRedBlackTreeKey=^TVulkanDeviceMemoryChunkBlockRedBlackTreeKey;
     TVulkanDeviceMemoryChunkBlockRedBlackTreeKey=TVkDeviceSize;

     PVulkanDeviceMemoryChunkBlockRedBlackTreeValue=^TVulkanDeviceMemoryChunkBlockRedBlackTreeValue;
     TVulkanDeviceMemoryChunkBlockRedBlackTreeValue=TVulkanDeviceMemoryChunkBlock;

     PVulkanDeviceMemoryChunkBlockRedBlackTreeNode=^TVulkanDeviceMemoryChunkBlockRedBlackTreeNode;
     TVulkanDeviceMemoryChunkBlockRedBlackTreeNode=class(TVulkanObject)
      private
       fKey:TVulkanDeviceMemoryChunkBlockRedBlackTreeKey;
       fValue:TVulkanDeviceMemoryChunkBlockRedBlackTreeValue;
       fLeft:TVulkanDeviceMemoryChunkBlockRedBlackTreeNode;
       fRight:TVulkanDeviceMemoryChunkBlockRedBlackTreeNode;
       fParent:TVulkanDeviceMemoryChunkBlockRedBlackTreeNode;
       fColor:boolean;
      public
       constructor Create(const aKey:TVulkanDeviceMemoryChunkBlockRedBlackTreeKey=0;
                          const aValue:TVulkanDeviceMemoryChunkBlockRedBlackTreeValue=nil;
                          const aLeft:TVulkanDeviceMemoryChunkBlockRedBlackTreeNode=nil;
                          const aRight:TVulkanDeviceMemoryChunkBlockRedBlackTreeNode=nil;
                          const aParent:TVulkanDeviceMemoryChunkBlockRedBlackTreeNode=nil;
                          const aColor:boolean=false);
       destructor Destroy; override;
       procedure Clear;
       function Minimum:TVulkanDeviceMemoryChunkBlockRedBlackTreeNode;
       function Maximum:TVulkanDeviceMemoryChunkBlockRedBlackTreeNode;
       function Predecessor:TVulkanDeviceMemoryChunkBlockRedBlackTreeNode;
       function Successor:TVulkanDeviceMemoryChunkBlockRedBlackTreeNode;
      published
       property Key:TVulkanDeviceMemoryChunkBlockRedBlackTreeKey read fKey write fKey;
       property Value:TVulkanDeviceMemoryChunkBlockRedBlackTreeValue read fValue write fValue;
       property Left:TVulkanDeviceMemoryChunkBlockRedBlackTreeNode read fLeft write fLeft;
       property Right:TVulkanDeviceMemoryChunkBlockRedBlackTreeNode read fRight write fRight;
       property Parent:TVulkanDeviceMemoryChunkBlockRedBlackTreeNode read fParent write fParent;
       property Color:boolean read fColor write fColor;
     end;

     TVulkanDeviceMemoryChunkBlockRedBlackTree=class(TVulkanObject)
      private
       fRoot:TVulkanDeviceMemoryChunkBlockRedBlackTreeNode;
      protected
       procedure RotateLeft(x:TVulkanDeviceMemoryChunkBlockRedBlackTreeNode);
       procedure RotateRight(x:TVulkanDeviceMemoryChunkBlockRedBlackTreeNode);
      public
       constructor Create;
       destructor Destroy; override;
       procedure Clear;
       function Find(const aKey:TVulkanDeviceMemoryChunkBlockRedBlackTreeKey):TVulkanDeviceMemoryChunkBlockRedBlackTreeNode;
       function Insert(const aKey:TVulkanDeviceMemoryChunkBlockRedBlackTreeKey;
                       const aValue:TVulkanDeviceMemoryChunkBlockRedBlackTreeValue):TVulkanDeviceMemoryChunkBlockRedBlackTreeNode;
       procedure Remove(const aNode:TVulkanDeviceMemoryChunkBlockRedBlackTreeNode);
       procedure Delete(const aKey:TVulkanDeviceMemoryChunkBlockRedBlackTreeKey);
      published
       function LeftMost:TVulkanDeviceMemoryChunkBlockRedBlackTreeNode;
       function RightMost:TVulkanDeviceMemoryChunkBlockRedBlackTreeNode;
       property Root:TVulkanDeviceMemoryChunkBlockRedBlackTreeNode read fRoot;
     end;

     TVulkanDeviceMemoryChunk=class;

     TVulkanDeviceMemoryChunkBlock=class(TVulkanObject)
      private
       fMemoryChunk:TVulkanDeviceMemoryChunk;
       fOffset:TVkDeviceSize;
       fSize:TVkDeviceSize;
       fAllocationType:TVulkanDeviceMemoryAllocationType;
       fOffsetRedBlackTreeNode:TVulkanDeviceMemoryChunkBlockRedBlackTreeNode;
       fSizeRedBlackTreeNode:TVulkanDeviceMemoryChunkBlockRedBlackTreeNode;
      public
       constructor Create(const aMemoryChunk:TVulkanDeviceMemoryChunk;
                          const aOffset:TVkDeviceSize;
                          const aSize:TVkDeviceSize;
                          const aAllocationType:TVulkanDeviceMemoryAllocationType);
       destructor Destroy; override;
       procedure Update(const aOffset:TVkDeviceSize;
                        const aSize:TVkDeviceSize;
                        const aAllocationType:TVulkanDeviceMemoryAllocationType);
      published
       property MemoryChunk:TVulkanDeviceMemoryChunk read fMemoryChunk;
       property Offset:TVkDeviceSize read fOffset;
       property Size:TVkDeviceSize read fSize;
       property AllocationType:TVulkanDeviceMemoryAllocationType read fAllocationType;
     end;

     PVulkanDeviceMemoryManagerChunkList=^TVulkanDeviceMemoryManagerChunkList;
     PVulkanDeviceMemoryManagerChunkLists=^TVulkanDeviceMemoryManagerChunkLists;

     TVulkanDeviceMemoryChunk=class(TVulkanObject)
      private
       fMemoryManager:TVulkanDeviceMemoryManager;
       fPreviousMemoryChunk:TVulkanDeviceMemoryChunk;
       fNextMemoryChunk:TVulkanDeviceMemoryChunk;
       fLock:TCriticalSection;
       fMemoryChunkFlags:TVulkanDeviceMemoryChunkFlags;
       fMemoryChunkList:PVulkanDeviceMemoryManagerChunkList;
       fSize:TVkDeviceSize;
       fUsed:TVkDeviceSize;
       fMappedOffset:TVkDeviceSize;
       fMappedSize:TVkDeviceSize;
       fOffsetRedBlackTree:TVulkanDeviceMemoryChunkBlockRedBlackTree;
       fSizeRedBlackTree:TVulkanDeviceMemoryChunkBlockRedBlackTree;
       fMemoryTypeIndex:TVkUInt32;
       fMemoryTypeBits:TVkUInt32;
       fMemoryHeapIndex:TVkUInt32;
       fMemoryPropertyFlags:TVkMemoryPropertyFlags;
       fMemoryHeapFlags:TVkMemoryHeapFlags;
       fMemoryHandle:TVkDeviceMemory;
       fMemory:PVkVoid;
      public
       constructor Create(const aMemoryManager:TVulkanDeviceMemoryManager;
                          const aMemoryChunkFlags:TVulkanDeviceMemoryChunkFlags;
                          const aSize:TVkDeviceSize;
                          const aMemoryTypeBits:TVkUInt32;
                          const aMemoryRequiredPropertyFlags:TVkMemoryPropertyFlags;
                          const aMemoryPreferredPropertyFlags:TVkMemoryPropertyFlags;
                          const aMemoryAvoidPropertyFlags:TVkMemoryPropertyFlags;
                          const aMemoryRequiredHeapFlags:TVkMemoryHeapFlags;
                          const aMemoryPreferredHeapFlags:TVkMemoryHeapFlags;
                          const aMemoryAvoidHeapFlags:TVkMemoryHeapFlags;
                          const aMemoryChunkList:PVulkanDeviceMemoryManagerChunkList);
       destructor Destroy; override;
       function AllocateMemory(out aOffset:TVkDeviceSize;const aSize,aAlignment:TVkDeviceSize;const aAllocationType:TVulkanDeviceMemoryAllocationType):boolean;
       function ReallocateMemory(var aOffset:TVkDeviceSize;const aSize,aAlignment:TVkDeviceSize):boolean;
       function FreeMemory(const aOffset:TVkDeviceSize):boolean;
       function MapMemory(const aOffset:TVkDeviceSize=0;const aSize:TVkDeviceSize=TVkDeviceSize(VK_WHOLE_SIZE)):PVkVoid;
       procedure UnmapMemory;
       procedure FlushMappedMemory;
       procedure FlushMappedMemoryRange(const aBase:TVkPointer;const aSize:TVkDeviceSize);
       procedure InvalidateMappedMemory;
       procedure InvalidateMappedMemoryRange(const aBase:TVkPointer;const aSize:TVkDeviceSize);
       property Memory:PVkVoid read fMemory;
      published
       property MemoryManager:TVulkanDeviceMemoryManager read fMemoryManager;
       property Size:TVkDeviceSize read fSize;
       property MemoryPropertyFlags:TVkMemoryPropertyFlags read fMemoryPropertyFlags;
       property MemoryHeapFlags:TVkMemoryPropertyFlags read fMemoryHeapFlags;
       property MemoryTypeIndex:TVkUInt32 read fMemoryTypeIndex;
       property MemoryTypeBits:TVkUInt32 read fMemoryTypeBits;
       property MemoryHeapIndex:TVkUInt32 read fMemoryHeapIndex;
       property Handle:TVkDeviceMemory read fMemoryHandle;
     end;

     PVulkanDeviceMemoryBlockFlag=^TVulkanDeviceMemoryBlockFlag;
     TVulkanDeviceMemoryBlockFlag=
      (
       vdmbfOwnSingleMemoryChunk,
       vdmbfPersistentMapped
      );

     PVulkanDeviceMemoryBlockFlags=^TVulkanDeviceMemoryBlockFlags;
     TVulkanDeviceMemoryBlockFlags=set of TVulkanDeviceMemoryBlockFlag;

     TVulkanDeviceMemoryBlock=class(TVulkanObject)
      private
       fMemoryManager:TVulkanDeviceMemoryManager;
       fMemoryChunk:TVulkanDeviceMemoryChunk;
       fOffset:TVkDeviceSize;
       fSize:TVkDeviceSize;
       fPreviousMemoryBlock:TVulkanDeviceMemoryBlock;
       fNextMemoryBlock:TVulkanDeviceMemoryBlock;
      public
       constructor Create(const aMemoryManager:TVulkanDeviceMemoryManager;
                          const aMemoryChunk:TVulkanDeviceMemoryChunk;
                          const aOffset:TVkDeviceSize;
                          const aSize:TVkDeviceSize);
       destructor Destroy; override;
       function MapMemory(const aOffset:TVkDeviceSize=0;const aSize:TVkDeviceSize=TVkDeviceSize(VK_WHOLE_SIZE)):PVkVoid;
       procedure UnmapMemory;
       procedure FlushMappedMemory;
       procedure FlushMappedMemoryRange(const aBase:TVkPointer;const aSize:TVkDeviceSize);
       procedure InvalidateMappedMemory;
       procedure InvalidateMappedMemoryRange(const aBase:TVkPointer;const aSize:TVkDeviceSize);
       function Fill(const aData:PVkVoid;const aSize:TVkDeviceSize):TVkDeviceSize;
      published
       property MemoryManager:TVulkanDeviceMemoryManager read fMemoryManager;
       property MemoryChunk:TVulkanDeviceMemoryChunk read fMemoryChunk;
       property Offset:TVkDeviceSize read fOffset;
       property Size:TVkDeviceSize read fSize;
     end;

     TVulkanDeviceMemoryManagerChunkList=record
      First:TVulkanDeviceMemoryChunk;
      Last:TVulkanDeviceMemoryChunk;
     end;

     TVulkanDeviceMemoryManagerChunkLists=array[0..31] of TVulkanDeviceMemoryManagerChunkList;

     TVulkanDeviceMemoryManager=class(TVulkanObject)
      private
       fDevice:TVulkanDevice;
       fLock:TCriticalSection;
       fMemoryChunkList:TVulkanDeviceMemoryManagerChunkList;
       fFirstMemoryBlock:TVulkanDeviceMemoryBlock;
       fLastMemoryBlock:TVulkanDeviceMemoryBlock;
      public
       constructor Create(const aDevice:TVulkanDevice);
       destructor Destroy; override;
       function AllocateMemoryBlock(const aMemoryBlockFlags:TVulkanDeviceMemoryBlockFlags;
                                    const aMemoryBlockSize:TVkDeviceSize;
                                    const aMemoryBlockAlignment:TVkDeviceSize;
                                    const aMemoryTypeBits:TVkUInt32;
                                    const aMemoryRequiredPropertyFlags:TVkMemoryPropertyFlags;
                                    const aMemoryPreferredPropertyFlags:TVkMemoryPropertyFlags;
                                    const aMemoryAvoidPropertyFlags:TVkMemoryPropertyFlags;
                                    const aMemoryRequiredHeapFlags:TVkMemoryHeapFlags;
                                    const aMemoryPreferredHeapFlags:TVkMemoryHeapFlags;
                                    const aMemoryAvoidHeapFlags:TVkMemoryHeapFlags;
                                    const aMemoryAllocationType:TVulkanDeviceMemoryAllocationType):TVulkanDeviceMemoryBlock;
       function FreeMemoryBlock(const aMemoryBlock:TVulkanDeviceMemoryBlock):boolean;
     end;

     TVulkanQueueFamilyIndices=array of TVkUInt32;

     TVulkanFence=class;

     TVulkanCommandBuffer=class;

     TVulkanBufferUseTemporaryStagingBufferMode=
      (
       vbutsbmAutomatic,
       vbutsbmYes,
       vbutsbmNo
      );

     PVulkanBufferFlag=^TVulkanBufferFlag;
     TVulkanBufferFlag=
      (
       vbfOwnSingleMemoryChunk,
       vbfPersistentMapped
      );

     PVulkanBufferFlags=^TVulkanBufferFlags;
     TVulkanBufferFlags=set of TVulkanBufferFlag;

     TVulkanBuffer=class(TVulkanObject)
      private
       fDevice:TVulkanDevice;
       fSize:TVkDeviceSize;
       fMemoryPropertyFlags:TVkMemoryPropertyFlags;
       fBufferFlags:TVulkanBufferFlags;
       fBufferHandle:TVkBuffer;
       fMemoryRequirements:TVkMemoryRequirements;
       fMemoryBlock:TVulkanDeviceMemoryBlock;
       fQueueFamilyIndices:TVulkanQueueFamilyIndices;
       fCountQueueFamilyIndices:TVkInt32;
       fDescriptorBufferInfo:TVkDescriptorBufferInfo;
       procedure Bind;
      public
       constructor Create(const aDevice:TVulkanDevice;
                          const aSize:TVkDeviceSize;
                          const aUsage:TVkBufferUsageFlags;
                          const aSharingMode:TVkSharingMode=VK_SHARING_MODE_EXCLUSIVE;
                          const aQueueFamilyIndices:TVkUInt32List=nil;
                          const aMemoryRequiredPropertyFlags:TVkMemoryPropertyFlags=TVkMemoryPropertyFlags(VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT) or TVkMemoryPropertyFlags(VK_MEMORY_PROPERTY_HOST_COHERENT_BIT);
                          const aMemoryPreferredPropertyFlags:TVkMemoryPropertyFlags=TVkMemoryPropertyFlags(VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT);
                          const aMemoryAvoidPropertyFlags:TVkMemoryPropertyFlags=0;
                          const aMemoryRequiredHeapFlags:TVkMemoryHeapFlags=0;
                          const aMemoryPreferredHeapFlags:TVkMemoryHeapFlags=0;
                          const aMemoryAvoidHeapFlags:TVkMemoryHeapFlags=0;
                          const aBufferFlags:TVulkanBufferFlags=[]);
       destructor Destroy; override;
       procedure UploadData(const aTransferQueue:TVulkanQueue;
                            const aTransferCommandBuffer:TVulkanCommandBuffer;
                            const aTransferFence:TVulkanFence;
                            const aData;
                            const aDataOffset:TVkDeviceSize;
                            const aDataSize:TVkDeviceSize;
                            const aUseTemporaryStagingBufferMode:TVulkanBufferUseTemporaryStagingBufferMode=vbutsbmAutomatic);
       procedure UpdateData(const aData;
                            const aDataOffset:TVkDeviceSize;
                            const aDataSize:TVkDeviceSize);
{      procedure UploadBarrier(const aCommandBuffer:TVulkanCommandBuffer);
       procedure DownloadBarrier(const aCommandBuffer:TVulkanCommandBuffer);}
       property DescriptorBufferInfo:TVkDescriptorBufferInfo read fDescriptorBufferInfo;
      published
       property Device:TVulkanDevice read fDevice;
       property Handle:TVkBuffer read fBufferHandle;
       property Size:TVkDeviceSize read fSize;
       property Memory:TVulkanDeviceMemoryBlock read fMemoryBlock;
     end;

     TVulkanBufferView=class(TVulkanObject)
      private
       fDevice:TVulkanDevice;
       fBufferViewHandle:TVkBufferView;
       fBuffer:TVulkanBuffer;
      public
       constructor Create(const aDevice:TVulkanDevice;
                          const aBuffer:TVulkanBuffer;
                          const aFormat:TVkFormat;
                          const aOffset:TVkDeviceSize=0;
                          const aRange:TVkDeviceSize=TVkDeviceSize(VK_WHOLE_SIZE)); reintroduce; overload;
       constructor Create(const aDevice:TVulkanDevice;
                          const aBufferView:TVkBufferView;
                          const aBuffer:TVulkanBuffer=nil); reintroduce; overload;
       destructor Destroy; override;
      published
       property Device:TVulkanDevice read fDevice;
       property Handle:TVkRenderPass read fBufferViewHandle;
       property Buffer:TVulkanBuffer read fBuffer write fBuffer;
     end;

     TVulkanEvent=class(TVulkanObject)
      private
       fDevice:TVulkanDevice;
       fEventHandle:TVkEvent;
      public
       constructor Create(const aDevice:TVulkanDevice;
                          const aFlags:TVkEventCreateFlags=TVkEventCreateFlags(0));
       destructor Destroy; override;
       function GetStatus:TVkResult;
       function SetEvent:TVkResult;
       function Reset:TVkResult;
      published
       property Device:TVulkanDevice read fDevice;
       property Handle:TVkEvent read fEventHandle;
     end;

     TVulkanFence=class(TVulkanObject)
      private
       fDevice:TVulkanDevice;
       fFenceHandle:TVkFence;
      public
       constructor Create(const aDevice:TVulkanDevice;
                          const aFlags:TVkFenceCreateFlags=TVkFenceCreateFlags(0));
       destructor Destroy; override;
       function GetStatus:TVkResult;
       function Reset:TVkResult; overload;
       class function Reset(const aFences:array of TVulkanFence):TVkResult; overload;
       function WaitFor(const aTimeOut:TVkUInt64=TVKUInt64(TVKInt64(-1))):TVkResult; overload;
       class function WaitFor(const aFences:array of TVulkanFence;const aWaitAll:boolean=true;const aTimeOut:TVkUInt64=TVKUInt64(TVKInt64(-1))):TVkResult; overload;
      published
       property Device:TVulkanDevice read fDevice;
       property Handle:TVkFence read fFenceHandle;
     end;

     TVulkanSemaphore=class(TVulkanObject)
      private
       fDevice:TVulkanDevice;
       fSemaphoreHandle:TVkSemaphore;
      public
       constructor Create(const aDevice:TVulkanDevice;
                          const aFlags:TVkSemaphoreCreateFlags=TVkSemaphoreCreateFlags(0));
       destructor Destroy; override;
      published
       property Device:TVulkanDevice read fDevice;
       property Handle:TVkSemaphore read fSemaphoreHandle;
     end;

     TVulkanQueue=class(TVulkanObject)
      private
       fDevice:TVulkanDevice;
       fQueueHandle:TVkQueue;
       fQueueFamilyIndex:TVkUInt32;
       fHasSupportForSparseBindings:boolean;
      public
       constructor Create(const aDevice:TVulkanDevice;
                          const aQueue:TVkQueue;
                          const aQueueFamilyIndex:TVKUInt32);
       destructor Destroy; override;
       procedure Submit(const aSubmitCount:TVkUInt32;const aSubmits:PVkSubmitInfo;const aFence:TVulkanFence=nil);
       procedure BindSparse(const aBindInfoCount:TVkUInt32;const aBindInfo:PVkBindSparseInfo;const aFence:TVulkanFence=nil);
       procedure WaitIdle;
      published
       property Device:TVulkanDevice read fDevice;
       property Handle:TVkQueue read fQueueHandle;
       property QueueFamilyIndex:TVkUInt32 read fQueueFamilyIndex;
       property HasSupportForSparseBindings:boolean read fHasSupportForSparseBindings;
     end;

     TVulkanCommandPool=class(TVulkanObject)
      private
       fDevice:TVulkanDevice;
       fQueueFamilyIndex:TVkUInt32;
       fFlags:TVkCommandPoolCreateFlags;
       fCommandPoolHandle:TVkCommandPool;
      public
       constructor Create(const aDevice:TVulkanDevice;
                          const aQueueFamilyIndex:TVkUInt32;
                          const aFlags:TVkCommandPoolCreateFlags=TVkCommandPoolCreateFlags(VK_COMMAND_POOL_CREATE_RESET_COMMAND_BUFFER_BIT));
       destructor Destroy; override;
      published
       property Device:TVulkanDevice read fDevice;
       property QueueFamilyIndex:TVkUInt32 read fQueueFamilyIndex;
       property Handle:TVkCommandPool read fCommandPoolHandle;
     end;

     TVulkanImage=class;

     TVulkanCommandBuffer=class(TVulkanObject)
      private
       fDevice:TVulkanDevice;
       fCommandPool:TVulkanCommandPool;
       fLevel:TVkCommandBufferLevel;
       fCommandBufferHandle:TVkCommandBuffer;
//     fFence:TVulkanFence;
      public
       constructor Create(const aCommandPool:TVulkanCommandPool;
                          const aLevel:TVkCommandBufferLevel;
                          const aCommandBufferHandle:TVkCommandBuffer); reintroduce; overload;
       constructor Create(const aCommandPool:TVulkanCommandPool;
                          const aLevel:TVkCommandBufferLevel=VK_COMMAND_BUFFER_LEVEL_PRIMARY); reintroduce; overload;
       destructor Destroy; override;
       class function Allocate(const aCommandPool:TVulkanCommandPool;
                               const aLevel:TVkCommandBufferLevel=VK_COMMAND_BUFFER_LEVEL_PRIMARY;
                               const aCommandBufferCount:TVkUInt32=1):TVulkanObjectList;
       procedure BeginRecording(const aFlags:TVkCommandBufferUsageFlags=0;const aInheritanceInfo:PVkCommandBufferInheritanceInfo=nil);
       procedure BeginRecordingPrimary;
       procedure BeginRecordingSecondary(const aRenderPass:TVkRenderPass;const aSubPass:TVkUInt32;const aFrameBuffer:TVkFramebuffer;const aOcclusionQueryEnable:boolean;const aQueryFlags:TVkQueryControlFlags;const aPipelineStatistics:TVkQueryPipelineStatisticFlags;const aFlags:TVkCommandBufferUsageFlags=TVkCommandBufferUsageFlags(VK_COMMAND_BUFFER_USAGE_RENDER_PASS_CONTINUE_BIT));
       procedure EndRecording;
       procedure Reset(const aFlags:TVkCommandBufferResetFlags=TVkCommandBufferResetFlags(VK_COMMAND_BUFFER_RESET_RELEASE_RESOURCES_BIT));
       procedure CmdBindPipeline(pipelineBindPoint:TVkPipelineBindPoint;pipeline:TVkPipeline);
       procedure CmdSetViewport(firstViewport:TVkUInt32;viewportCount:TVkUInt32;const aViewports:PVkViewport);
       procedure CmdSetScissor(firstScissor:TVkUInt32;scissorCount:TVkUInt32;const aScissors:PVkRect2D);
       procedure CmdSetLineWidth(lineWidth:TVkFloat);
       procedure CmdSetDepthBias(depthBiasConstantFactor:TVkFloat;depthBiasClamp:TVkFloat;depthBiasSlopeFactor:TVkFloat);
       procedure CmdSetBlendConstants(const blendConstants:TVkFloat);
       procedure CmdSetDepthBounds(minDepthBounds:TVkFloat;maxDepthBounds:TVkFloat);
       procedure CmdSetStencilCompareMask(faceMask:TVkStencilFaceFlags;compareMask:TVkUInt32);
       procedure CmdSetStencilWriteMask(faceMask:TVkStencilFaceFlags;writeMask:TVkUInt32);
       procedure CmdSetStencilReference(faceMask:TVkStencilFaceFlags;reference:TVkUInt32);
       procedure CmdBindDescriptorSets(pipelineBindPoint:TVkPipelineBindPoint;layout:TVkPipelineLayout;firstSet:TVkUInt32;descriptorSetCount:TVkUInt32;const aDescriptorSets:PVkDescriptorSet;dynamicOffsetCount:TVkUInt32;const aDynamicOffsets:PVkUInt32);
       procedure CmdBindIndexBuffer(buffer:TVkBuffer;offset:TVkDeviceSize;indexType:TVkIndexType);
       procedure CmdBindVertexBuffers(firstBinding:TVkUInt32;bindingCount:TVkUInt32;const aBuffers:PVkBuffer;const aOffsets:PVkDeviceSize);
       procedure CmdDraw(vertexCount:TVkUInt32;instanceCount:TVkUInt32;firstVertex:TVkUInt32;firstInstance:TVkUInt32);
       procedure CmdDrawIndexed(indexCount:TVkUInt32;instanceCount:TVkUInt32;firstIndex:TVkUInt32;vertexOffset:TVkInt32;firstInstance:TVkUInt32);
       procedure CmdDrawIndirect(buffer:TVkBuffer;offset:TVkDeviceSize;drawCount:TVkUInt32;stride:TVkUInt32);
       procedure CmdDrawIndexedIndirect(buffer:TVkBuffer;offset:TVkDeviceSize;drawCount:TVkUInt32;stride:TVkUInt32);
       procedure CmdDispatch(x:TVkUInt32;y:TVkUInt32;z:TVkUInt32);
       procedure CmdDispatchIndirect(buffer:TVkBuffer;offset:TVkDeviceSize);
       procedure CmdCopyBuffer(srcBuffer:TVkBuffer;dstBuffer:TVkBuffer;regionCount:TVkUInt32;const aRegions:PVkBufferCopy);
       procedure CmdCopyImage(srcImage:TVkImage;srcImageLayout:TVkImageLayout;dstImage:TVkImage;dstImageLayout:TVkImageLayout;regionCount:TVkUInt32;const aRegions:PVkImageCopy);
       procedure CmdBlitImage(srcImage:TVkImage;srcImageLayout:TVkImageLayout;dstImage:TVkImage;dstImageLayout:TVkImageLayout;regionCount:TVkUInt32;const aRegions:PVkImageBlit;filter:TVkFilter);
       procedure CmdCopyBufferToImage(srcBuffer:TVkBuffer;dstImage:TVkImage;dstImageLayout:TVkImageLayout;regionCount:TVkUInt32;const aRegions:PVkBufferImageCopy);
       procedure CmdCopyImageToBuffer(srcImage:TVkImage;srcImageLayout:TVkImageLayout;dstBuffer:TVkBuffer;regionCount:TVkUInt32;const aRegions:PVkBufferImageCopy);
       procedure CmdUpdateBuffer(dstBuffer:TVkBuffer;dstOffset:TVkDeviceSize;dataSize:TVkDeviceSize;const aData:PVkVoid);
       procedure CmdFillBuffer(dstBuffer:TVkBuffer;dstOffset:TVkDeviceSize;size:TVkDeviceSize;data:TVkUInt32);
       procedure CmdClearColorImage(image:TVkImage;imageLayout:TVkImageLayout;const aColor:PVkClearColorValue;rangeCount:TVkUInt32;const aRanges:PVkImageSubresourceRange);
       procedure CmdClearDepthStencilImage(image:TVkImage;imageLayout:TVkImageLayout;const aDepthStencil:PVkClearDepthStencilValue;rangeCount:TVkUInt32;const aRanges:PVkImageSubresourceRange);
       procedure CmdClearAttachments(attachmentCount:TVkUInt32;const aAttachments:PVkClearAttachment;rectCount:TVkUInt32;const aRects:PVkClearRect);
       procedure CmdResolveImage(srcImage:TVkImage;srcImageLayout:TVkImageLayout;dstImage:TVkImage;dstImageLayout:TVkImageLayout;regionCount:TVkUInt32;const aRegions:PVkImageResolve);
       procedure CmdSetEvent(event:TVkEvent;stageMask:TVkPipelineStageFlags);
       procedure CmdResetEvent(event:TVkEvent;stageMask:TVkPipelineStageFlags);
       procedure CmdWaitEvents(eventCount:TVkUInt32;const aEvents:PVkEvent;srcStageMask:TVkPipelineStageFlags;dstStageMask:TVkPipelineStageFlags;memoryBarrierCount:TVkUInt32;const aMemoryBarriers:PVkMemoryBarrier;bufferMemoryBarrierCount:TVkUInt32;const aBufferMemoryBarriers:PVkBufferMemoryBarrier;imageMemoryBarrierCount:TVkUInt32;const aImageMemoryBarriers:PVkImageMemoryBarrier);
       procedure CmdPipelineBarrier(srcStageMask:TVkPipelineStageFlags;dstStageMask:TVkPipelineStageFlags;dependencyFlags:TVkDependencyFlags;memoryBarrierCount:TVkUInt32;const aMemoryBarriers:PVkMemoryBarrier;bufferMemoryBarrierCount:TVkUInt32;const aBufferMemoryBarriers:PVkBufferMemoryBarrier;imageMemoryBarrierCount:TVkUInt32;const aImageMemoryBarriers:PVkImageMemoryBarrier);
       procedure CmdBeginQuery(queryPool:TVkQueryPool;query:TVkUInt32;flags:TVkQueryControlFlags);
       procedure CmdEndQuery(queryPool:TVkQueryPool;query:TVkUInt32);
       procedure CmdResetQueryPool(queryPool:TVkQueryPool;firstQuery:TVkUInt32;queryCount:TVkUInt32);
       procedure CmdWriteTimestamp(pipelineStage:TVkPipelineStageFlagBits;queryPool:TVkQueryPool;query:TVkUInt32);
       procedure CmdCopyQueryPoolResults(queryPool:TVkQueryPool;firstQuery:TVkUInt32;queryCount:TVkUInt32;dstBuffer:TVkBuffer;dstOffset:TVkDeviceSize;stride:TVkDeviceSize;flags:TVkQueryResultFlags);
       procedure CmdPushConstants(layout:TVkPipelineLayout;stageFlags:TVkShaderStageFlags;offset:TVkUInt32;size:TVkUInt32;const aValues:PVkVoid);
       procedure CmdBeginRenderPass(const aRenderPassBegin:PVkRenderPassBeginInfo;contents:TVkSubpassContents);
       procedure CmdNextSubpass(contents:TVkSubpassContents);
       procedure CmdEndRenderPass;
       procedure CmdExecuteCommands(commandBufferCount:TVkUInt32;const aCommandBuffers:PVkCommandBuffer);
       procedure CmdExecute(const aCommandBuffer:TVulkanCommandBuffer);
       procedure MetaCmdPresentToDrawImageBarrier(const aImage:TVulkanImage;const aDoTransitionToColorAttachmentOptimalLayout:boolean=true);
       procedure MetaCmdDrawToPresentImageBarrier(const aImage:TVulkanImage;const aDoTransitionToPresentSrcLayout:boolean=true);
       procedure MetaCmdMemoryBarrier(const aSrcStageMask,aDstStageMask:TVkPipelineStageFlags;const aSrcAccessMask,aDstAccessMask:TVkAccessFlags);
       procedure Execute(const aQueue:TVulkanQueue;const aWaitDstStageFlags:TVkPipelineStageFlags;const aWaitSemaphore:TVulkanSemaphore=nil;const aSignalSemaphore:TVulkanSemaphore=nil;const aFence:TVulkanFence=nil;const aDoWaitAndResetFence:boolean=true);
      published
       property Device:TVulkanDevice read fDevice;
       property CommandPool:TVulkanCommandPool read fCommandPool;
       property Level:TVkCommandBufferLevel read fLevel;
       property Handle:TVkCommandBuffer read fCommandBufferHandle;
     end;

     TVulkanCommandBufferSubmitQueueSubmitInfos=array of TVkSubmitInfo;

     TVulkanCommandBufferSubmitQueueSubmitInfoSubmitInfoWaitSemaphores=array of TVkSemaphore;

     TVulkanCommandBufferSubmitQueueSubmitInfoWaitDstStageFlags=array of TVkPipelineStageFlags;

     TVulkanCommandBufferSubmitQueueSubmitInfoSubmitInfoSignalSemaphores=array of TVkSemaphore;

     TVulkanCommandBufferSubmitQueue=class(TVulkanObject)
      private
       fDevice:TVulkanDevice;
       fQueue:TVulkanQueue;
       fSubmitInfos:TVulkanCommandBufferSubmitQueueSubmitInfos;
       fSubmitInfoWaitSemaphores:TVulkanCommandBufferSubmitQueueSubmitInfoSubmitInfoWaitSemaphores;
       fSubmitInfoWaitDstStageFlags:TVulkanCommandBufferSubmitQueueSubmitInfoWaitDstStageFlags;
       fSubmitInfoSignalSemaphores:TVulkanCommandBufferSubmitQueueSubmitInfoSubmitInfoSignalSemaphores;
       fCountSubmitInfos:TVkInt32;
      public
       constructor Create(const aQueue:TVulkanQueue); reintroduce;
       destructor Destroy; override;
       procedure Reset;
       procedure QueueSubmit(const aCommandBuffer:TVulkanCommandBuffer;const aWaitDstStageFlags:TVkPipelineStageFlags;const aWaitSemaphore:TVulkanSemaphore=nil;const aSignalSemaphore:TVulkanSemaphore=nil);
       procedure SubmitQueued(const aFence:TVulkanFence=nil;const aDoWaitAndResetFence:boolean=true);
     end;

     TVulkanRenderPassAttachmentDescriptions=array of TVkAttachmentDescription;

     TVulkanRenderPassAttachmentReferences=array of TVkAttachmentReference;

     PVulkanRenderPassSubpassDescription=^TVulkanRenderPassSubpassDescription;
     TVulkanRenderPassSubpassDescription=record
      Flags:TVkSubpassDescriptionFlags;
      PipelineBindPoint:TVkPipelineBindPoint;
      InputAttachments:array of TVkInt32;
      ColorAttachments:array of TVkInt32;
      ResolveAttachments:array of TVkInt32;
      DepthStencilAttachment:TVkInt32;
      PreserveAttachments:array of TVkUInt32;
      aInputAttachments:TVulkanRenderPassAttachmentReferences;
      aColorAttachments:TVulkanRenderPassAttachmentReferences;
      aResolveAttachments:TVulkanRenderPassAttachmentReferences;
     end;

     TVulkanRenderPassSubpassDescriptions=array of TVulkanRenderPassSubpassDescription;

     TVulkanFrameBuffer=class;

     TVulkanRenderPass=class(TVulkanObject)
      private
       fDevice:TVulkanDevice;
       fRenderPassHandle:TVkRenderPass;
       fAttachmentDescriptions:TVulkanRenderPassAttachmentDescriptions;
       fCountAttachmentDescriptions:TVkInt32;
       fAttachmentReferences:TVulkanRenderPassAttachmentReferences;
       fCountAttachmentReferences:TVkInt32;
       fRenderPassSubpassDescriptions:TVulkanRenderPassSubpassDescriptions;
       fSubpassDescriptions:TVkSubpassDescriptionArray;
       fCountSubpassDescriptions:TVkInt32;
       fSubpassDependencies:TVkSubpassDependencyArray;
       fCountSubpassDependencies:TVkInt32;
       fClearValues:TVkClearValueArray;
       function GetClearValue(const Index:TVkUInt32):PVkClearValue;
      public
       constructor Create(const aDevice:TVulkanDevice);
       destructor Destroy; override;
       function AddAttachmentDescription(const aFlags:TVkAttachmentDescriptionFlags;
                                         const aFormat:TVkFormat;
                                         const aSamples:TVkSampleCountFlagBits;
                                         const aLoadOp:TVkAttachmentLoadOp;
                                         const aStoreOp:TVkAttachmentStoreOp;
                                         const aStencilLoadOp:TVkAttachmentLoadOp;
                                         const aStencilStoreOp:TVkAttachmentStoreOp;
                                         const aInitialLayout:TVkImageLayout;
                                         const aFinalLayout:TVkImageLayout):TVkUInt32;
       function AddAttachmentReference(const aAttachment:TVkUInt32;
                                       const aLayout:TVkImageLayout):TVkUInt32;
       function AddSubpassDescription(const aFlags:TVkSubpassDescriptionFlags;
                                      const aPipelineBindPoint:TVkPipelineBindPoint;
                                      const aInputAttachments:array of TVkInt32;
                                      const aColorAttachments:array of TVkInt32;
                                      const aResolveAttachments:array of TVkInt32;
                                      const aDepthStencilAttachment:TVkInt32;
                                      const aPreserveAttachments:array of TVkUInt32):TVkUInt32;
       function AddSubpassDependency(const aSrcSubpass:TVkUInt32;
                                     const aDstSubpass:TVkUInt32;
                                     const aSrcStageMask:TVkPipelineStageFlags;
                                     const aDstStageMask:TVkPipelineStageFlags;
                                     const aSrcAccessMask:TVkAccessFlags;
                                     const aDstAccessMask:TVkAccessFlags;
                                     const aDependencyFlags:TVkDependencyFlags):TVkUInt32;
       procedure Initialize;
       procedure BeginRenderPass(const aCommandBuffer:TVulkanCommandBuffer;
                                 const aFrameBuffer:TVulkanFrameBuffer;
                                 const aSubpassContents:TVkSubpassContents;
                                 const aOffsetX,aOffsetY,aWidth,aHeight:TVkUInt32);
       procedure EndRenderPass(const aCommandBuffer:TVulkanCommandBuffer);
       property ClearValues[const Index:TVkUInt32]:PVkClearValue read GetClearValue;
      published
       property Device:TVulkanDevice read fDevice;
       property Handle:TVkRenderPass read fRenderPassHandle;
     end;

     TVulkanSampler=class(TVulkanObject)
      private
       fDevice:TVulkanDevice;
       fSamplerHandle:TVkSampler;
       fDoDestroy:boolean;
      public
       constructor Create(const aDevice:TVulkanDevice;
                          const aSampler:TVkSampler;
                          const aDoDestroy:boolean=true); reintroduce; overload;
       constructor Create(const aDevice:TVulkanDevice;
                          const aMagFilter:TVkFilter;
                          const aMinFilter:TVkFilter;
                          const aMipmapMode:TVkSamplerMipmapMode;
                          const aAddressModeU:TVkSamplerAddressMode;
                          const aAddressModeV:TVkSamplerAddressMode;
                          const aAddressModeW:TVkSamplerAddressMode;
                          const aMipLodBias:TVkFloat;
                          const aAnisotropyEnable:boolean;
                          const aMaxAnisotropy:TVkFloat;
                          const aCompareEnable:boolean;
                          const aCompareOp:TVkCompareOp;
                          const aMinLod:TVkFloat;
                          const aMaxLod:TVkFloat;
                          const aBorderColor:TVkBorderColor;
                          const aUnnormalizedCoordinates:boolean); reintroduce; overload;
       destructor Destroy; override;
      published
       property Device:TVulkanDevice read fDevice;
       property Handle:TVkSampler read fSamplerHandle;
     end;

     TVulkanImageView=class;

     TVulkanImage=class(TVulkanObject)
      private
       fDevice:TVulkanDevice;
       fImageHandle:TVkImage;
       fImageView:TVulkanImageView;
       fDoDestroy:boolean;
      public
       constructor Create(const aDevice:TVulkanDevice;
                          const aImage:TVkImage;
                          const aImageView:TVulkanImageView=nil;
                          const aDoDestroy:boolean=true); reintroduce; overload;
       constructor Create(const aDevice:TVulkanDevice;
                          const aFlags:TVkImageCreateFlags;
                          const aImageType:TVkImageType;
                          const aFormat:TVkFormat;
                          const aExtentWidth:TVkUInt32;
                          const aExtentHeight:TVkUInt32;
                          const aExtentDepth:TVkUInt32;
                          const aMipLevels:TVkUInt32;
                          const aArrayLayers:TVkUInt32;
                          const aSamples:TVkSampleCountFlagBits;
                          const aTiling:TVkImageTiling;
                          const aUsage:TVkImageUsageFlags;
                          const aSharingMode:TVkSharingMode;
                          const aQueueFamilyIndexCount:TVkUInt32;
                          const aQueueFamilyIndices:PVkUInt32;
                          const aInitialLayout:TVkImageLayout); reintroduce; overload;
       constructor Create(const aDevice:TVulkanDevice;
                          const aFlags:TVkImageCreateFlags;
                          const aImageType:TVkImageType;
                          const aFormat:TVkFormat;
                          const aExtentWidth:TVkUInt32;
                          const aExtentHeight:TVkUInt32;
                          const aExtentDepth:TVkUInt32;
                          const aMipLevels:TVkUInt32;
                          const aArrayLayers:TVkUInt32;
                          const aSamples:TVkSampleCountFlagBits;
                          const aTiling:TVkImageTiling;
                          const aUsage:TVkImageUsageFlags;
                          const aSharingMode:TVkSharingMode;
                          const aQueueFamilyIndices:array of TVkUInt32;
                          const aInitialLayout:TVkImageLayout); reintroduce; overload;
       destructor Destroy; override;
       procedure SetLayout(const aAspectMask:TVkImageAspectFlags;
                           const aOldImageLayout:TVkImageLayout;
                           const aNewImageLayout:TVkImageLayout;
                           const aRange:PVkImageSubresourceRange;
                           const aCommandBuffer:TVulkanCommandBuffer;
                           const aQueue:TVulkanQueue=nil;
                           const aFence:TVulkanFence=nil;
                           const aBeginAndExecuteCommandBuffer:boolean=false;
                           const aSrcQueueFamilyIndex:TVkQueue=TVkQueue(VK_QUEUE_FAMILY_IGNORED);
                           const aDstQueueFamilyIndex:TVkQueue=TVkQueue(VK_QUEUE_FAMILY_IGNORED));
      published
       property Device:TVulkanDevice read fDevice;
       property Handle:TVkImage read fImageHandle;
       property ImageView:TVulkanImageView read fImageView write fImageView;
     end;

     TVulkanImageView=class(TVulkanObject)
      private
       fDevice:TVulkanDevice;
       fImageViewHandle:TVkImageView;
       fImage:TVulkanImage;
      public
       constructor Create(const aDevice:TVulkanDevice;
                          const aImageView:TVkImageView;
                          const aImage:TVulkanImage=nil); reintroduce; overload;
       constructor Create(const aDevice:TVulkanDevice;
                          const aImage:TVulkanImage;
                          const aImageViewType:TVkImageViewType;
                          const aFormat:TvkFormat;
                          const aComponentRed:TVkComponentSwizzle=VK_COMPONENT_SWIZZLE_IDENTITY;
                          const aComponentGreen:TVkComponentSwizzle=VK_COMPONENT_SWIZZLE_IDENTITY;
                          const aComponentBlue:TVkComponentSwizzle=VK_COMPONENT_SWIZZLE_IDENTITY;
                          const aComponentAlpha:TVkComponentSwizzle=VK_COMPONENT_SWIZZLE_IDENTITY;
                          const aImageAspectFlags:TVkImageAspectFlags=TVkImageAspectFlags(VK_IMAGE_ASPECT_COLOR_BIT);
                          const aBaseMipLevel:TVkUInt32=0;
                          const aCountMipMapLevels:TVkUInt32=1;
                          const aBaseArrayLayer:TVkUInt32=1;
                          const aCountArrayLayers:TVkUInt32=0); reintroduce; overload;
       destructor Destroy; override;
      published
       property Device:TVulkanDevice read fDevice;
       property Handle:TVkRenderPass read fImageViewHandle;
       property Image:TVulkanImage read fImage write fImage;
     end;

     TVulkanFrameBufferAttachment=class(TVulkanObject)
      private
       fDevice:TVulkanDevice;
       fWidth:TVkUInt32;
       fHeight:TVkUInt32;
       fFormat:TVkFormat;
       fImage:TVulkanImage;
       fImageView:TVulkanImageView;
       fMemoryBlock:TVulkanDeviceMemoryBlock;
       fDoDestroy:boolean;
      public
       constructor Create(const aDevice:TVulkanDevice;
                          const aGraphicsQueue:TVulkanQueue;
                          const aGraphicsCommandBuffer:TVulkanCommandBuffer;
                          const aGraphicsCommandBufferFence:TVulkanFence;
                          const aWidth:TVkUInt32;
                          const aHeight:TVkUInt32;
                          const aFormat:TVkFormat;
                          const aUsage:TVkBufferUsageFlags); reintroduce; overload;
       constructor Create(const aDevice:TVulkanDevice;
                          const aImage:TVulkanImage;
                          const aImageView:TVulkanImageView;
                          const aWidth:TVkUInt32;
                          const aHeight:TVkUInt32;
                          const aFormat:TVkFormat;
                          const aDoDestroy:boolean=true); reintroduce; overload;
       destructor Destroy; override;
      published
       property Device:TVulkanDevice read fDevice;
       property Width:TVkUInt32 read fWidth;
       property Height:TVkUInt32 read fHeight;
       property Format:TVkFormat read fFormat;
       property Image:TVulkanImage read fImage;
       property ImageView:TVulkanImageView read fImageView;
       property Memory:TVulkanDeviceMemoryBlock read fMemoryBlock;
     end;

     TVulkanFrameBufferAttachments=array of TVulkanFrameBufferAttachment;

     TVulkanFrameBufferAttachmentImageViews=array of TVkImageView;

     TVulkanFrameBuffer=class(TVulkanObject)
      private
       fDevice:TVulkanDevice;
       fFrameBufferHandle:TVkFrameBuffer;
       fFrameBufferAttachments:TVulkanFrameBufferAttachments;
       fFrameBufferAttachmentImageViews:TVulkanFrameBufferAttachmentImageViews;
       fCountFrameBufferAttachments:TVkInt32;
       fRenderPass:TVulkanRenderPass;
       fWidth:TVkUInt32;
       fHeight:TVkUInt32;
       fLayers:TVkUInt32;
       fDoDestroy:boolean;
       fDoDestroyAttachments:boolean;
       function GetFrameBufferAttachment(const aIndex:TVkInt32):TVulkanFrameBufferAttachment;
      public
       constructor Create(const aDevice:TVulkanDevice;
                          const aRenderPass:TVulkanRenderPass;
                          const aWidth:TVkUInt32;
                          const aHeight:TVkUInt32;
                          const aLayers:TVkUInt32); reintroduce; overload;
       constructor Create(const aDevice:TVulkanDevice;
                          const aRenderPass:TVulkanRenderPass;
                          const aWidth:TVkUInt32;
                          const aHeight:TVkUInt32;
                          const aLayers:TVkUInt32;
                          const aFrameBufferAttachments:array of TVulkanFrameBufferAttachment;
                          const aDoDestroyAttachments:boolean=true); reintroduce; overload;
       constructor Create(const aDevice:TVulkanDevice;
                          const aRenderPass:TVulkanRenderPass;
                          const aWidth:TVkUInt32;
                          const aHeight:TVkUInt32;
                          const aLayers:TVkUInt32;
                          const aFrameBufferHandle:TVkFrameBuffer;
                          const aFrameBufferAttachments:array of TVulkanFrameBufferAttachment;
                          const aDoDestroy:boolean=true;
                          const aDoDestroyAttachments:boolean=true); reintroduce; overload;
       destructor Destroy; override;
       function AddAttachment(const aFrameBufferAttachment:TVulkanFrameBufferAttachment):TVkInt32;
       procedure Initialize;
       property Attachments[const aIndex:TVkInt32]:TVulkanFrameBufferAttachment read GetFrameBufferAttachment; default;
      published
       property Device:TVulkanDevice read fDevice;
       property Handle:TVkFrameBuffer read fFrameBufferHandle;
       property CountAttachments:TVkInt32 read fCountFrameBufferAttachments;
       property RenderPass:TVulkanRenderPass read fRenderPass;
       property Width:TVkUInt32 read fWidth;
       property Height:TVkUInt32 read fHeight;
       property Layers:TVkUInt32 read fLayers;
     end;

     TVulkanSwapChainImages=array of TVulkanImage;

     TVulkanSwapChain=class(TVulkanObject)
      private
       fDevice:TVulkanDevice;
       fSurface:TVulkanSurface;
       fSwapChainHandle:TVkSwapChainKHR;
       fQueueFamilyIndices:TVulkanQueueFamilyIndices;
       fCountQueueFamilyIndices:TVkInt32;
       fImageFormat:TVkFormat;
       fImageColorSpace:TVkColorSpaceKHR;
       fImages:TVulkanSwapChainImages;
       fPresentMode:TVkPresentModeKHR;
       fCurrentImageIndex:TVkUInt32;
       fCountImages:TVkUInt32;
       fWidth:TVkInt32;
       fHeight:TVkInt32;
       function GetImage(const aImageIndex:TVkInt32):TVulkanImage;
       function GetCurrentImage:TVulkanImage;
      public
       constructor Create(const aDevice:TVulkanDevice;
                          const aSurface:TVulkanSurface;
                          const aOldSwapChain:TVulkanSwapChain=nil;
                          const aDesiredImageWidth:TVkUInt32=0;
                          const aDesiredImageHeight:TVkUInt32=0;
                          const aDesiredImageCount:TVkUInt32=2;
                          const aImageArrayLayers:TVkUInt32=1;
                          const aImageFormat:TVkFormat=VK_FORMAT_UNDEFINED;
                          const aImageColorSpace:TVkColorSpaceKHR=VK_COLOR_SPACE_SRGB_NONLINEAR_KHR;
                          const aImageUsage:TVkImageUsageFlags=TVkImageUsageFlags(VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT);
                          const aImageSharingMode:TVkSharingMode=VK_SHARING_MODE_EXCLUSIVE;
                          const aQueueFamilyIndices:TVkUInt32List=nil;
                          const aCompositeAlpha:TVkCompositeAlphaFlagBitsKHR=VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR;
                          const aPresentMode:TVkPresentModeKHR=VK_PRESENT_MODE_MAILBOX_KHR;
                          const aClipped:boolean=true;
                          const aDesiredTransform:TVkSurfaceTransformFlagsKHR=TVkSurfaceTransformFlagsKHR($ffffffff));
       destructor Destroy; override;
       function QueuePresent(const aQueue:TVulkanQueue;const aSemaphore:TVulkanSemaphore=nil):TVkResult;
       function AcquireNextImage(const aSemaphore:TVulkanSemaphore=nil;const aFence:TVulkanFence=nil;const aTimeOut:TVkUInt64=TVkUInt64(high(TVkUInt64))):TVkResult;
       property Images[const aImageIndex:TVkInt32]:TVulkanImage read GetImage; default;
      published
       property Device:TVulkanDevice read fDevice;
       property Surface:TVulkanSurface read fSurface;
       property Handle:TVkSwapChainKHR read fSwapChainHandle;
       property ImageFormat:TVkFormat read fImageFormat;
       property ImageColorSpace:TVkColorSpaceKHR read fImageColorSpace;
       property PresentMode:TVkPresentModeKHR read fPresentMode;
       property CurrentImageIndex:TVkUInt32 read fCurrentImageIndex;
       property CountImages:TVkUInt32 read fCountImages;
       property CurrentImage:TVulkanImage read GetCurrentImage;
       property Width:TVkInt32 read fWidth;
       property Height:TVkInt32 read fHeight;
     end;

     TVulkanRenderTarget=class(TVulkanObject)
      private
      protected
       function GetRenderPass:TVulkanRenderPass; virtual; abstract;
       function GetFrameBuffer:TVulkanFrameBuffer; virtual; abstract;
      public
      published
       property RenderPass:TVulkanRenderPass read GetRenderPass;
       property FrameBuffer:TVulkanFrameBuffer read GetFrameBuffer;
     end;

     TVulkanSwapChainSimpleDirectRenderTargetFrameBuffers=array of TVulkanFrameBuffer;

     TVulkanSwapChainSimpleDirectRenderTarget=class(TVulkanRenderTarget)
      private
       fDevice:TVulkanDevice;
       fSwapChain:TVulkanSwapChain;
       fDepthImageFormat:TVkFormat;
       fDepthFrameBufferAttachment:TVulkanFrameBufferAttachment;
       fFrameBufferColorAttachments:TVulkanFrameBufferAttachments;
       fFrameBuffers:TVulkanSwapChainSimpleDirectRenderTargetFrameBuffers;
       fRenderPass:TVulkanRenderPass;
      protected
       function GetRenderPass:TVulkanRenderPass; override;
       function GetFrameBuffer:TVulkanFrameBuffer; override;
       function GetFrameBufferAtIndex(const aIndex:TVkInt32):TVulkanFrameBuffer;
      public
       constructor Create(const aDevice:TVulkanDevice;
                          const aSwapChain:TVulkanSwapChain;
                          const aPresentQueue:TVulkanQueue;
                          const aPresentCommandBuffer:TVulkanCommandBuffer;
                          const aPresentCommandBufferFence:TVulkanFence;
                          const aGraphicsQueue:TVulkanQueue;
                          const aGraphicsCommandBuffer:TVulkanCommandBuffer;
                          const aGraphicsCommandBufferFence:TVulkanFence;
                          const aDepthImageFormat:TVkFormat=VK_FORMAT_UNDEFINED;
                          const aDepthImageFormatWithStencil:boolean=false;
                          const aClear:boolean=true);
       destructor Destroy; override;
       property FrameBuffers[const aIndex:TVkInt32]:TVulkanFrameBuffer read GetFrameBufferAtIndex;
      published
       property Device:TVulkanDevice read fDevice;
       property SwapChain:TVulkanSwapChain read fSwapChain;
       property DepthImageFormat:TVkFormat read fDepthImageFormat;
     end;

     PVulkanShaderModuleVariableStorageClass=^TVulkanShaderModuleVariableStorageClass;
     TVulkanShaderModuleVariableStorageClass=
      (      
       vsmcscUniformConstant=0,
       vsmcscInput=1,
       vsmcscUniform=2,
       vsmcscOutput=3,
       vsmcscWorkgroup=4,
       vsmcscCrossWorkgroup=5,
       vsmcscPrivate=6,
       vsmcscFunction=7,
       vsmcscGeneric=8,
       vsmcscPushConstant=9,
       vsmcscAtomicCounter=10,
       vsmcscImage=11,
       vsmcscStorageBuffer=12,
       vsmcscMax=$7fffffff
      );

     PVulkanShaderModuleVariable=^TVulkanShaderModuleVariable;
     TVulkanShaderModuleVariable={$ifdef HAS_ADVANCED_RECORDS}record{$else}object{$endif}
      private
       fDebugName:TVkCharString;
       fName:TVkInt32;
       fLocation:TVkInt32;
       fBinding:TVkInt32;
       fDescriptorSet:TVkInt32;
       fInstruction:TVkInt32;
       fStorageClass:TVulkanShaderModuleVariableStorageClass;
      public
       property DebugName:TVkCharString read fDebugName;                                 // The name of the variable
       property Name:TVkInt32 read fName;                                                // The internal name (integer) of the variable
       property Location:TVkInt32 read fLocation;                                        // The location in the binding
       property Binding:TVkInt32 read fBinding;                                          // The binding in the descriptor set or I/O channel
       property DescriptorSet:TVkInt32 read fDescriptorSet;                              // The descriptor set (for uniforms)
       property Instruction:TVkInt32 read fInstruction;                                  // The instruction index
       property StorageClass:TVulkanShaderModuleVariableStorageClass read fStorageClass; // Storage class of the variable
     end;

     TVulkanShaderModuleVariables=array of TVulkanShaderModuleVariable;

     TVulkanShaderModule=class(TVulkanObject)
      private
       fDevice:TVulkanDevice;
       fShaderModuleHandle:TVkShaderModule;
       fData:PVkVoid;
       fDataAligned:PVkVoid;
       fDataSize:TVkSize;
       procedure Load;
      public
       constructor Create(const aDevice:TVulkanDevice;const aData;const aDataSize:TVkSize); overload;
       constructor Create(const aDevice:TVulkanDevice;const aStream:TStream); overload;
       constructor Create(const aDevice:TVulkanDevice;const aFileName:string); overload;
       destructor Destroy; override;
       function GetVariables:TVulkanShaderModuleVariables;
      published
       property Device:TVulkanDevice read fDevice;
       property Handle:TVkShaderModule read fShaderModuleHandle;
     end;

     TVulkanShaderModules=array of TVulkanShaderModule;

     TVulkanDescriptorPool=class(TVulkanObject)
      private
       fDevice:TVulkanDevice;
       fDescriptorPoolHandle:TVkDescriptorPool;
       fDescriptorPoolSizes:TVkDescriptorPoolSizeArray;
       fCountDescriptorPoolSizes:TVkInt32;
       fFlags:TVkDescriptorPoolCreateFlags;
       fMaxSets:TVkUInt32;
      public
       constructor Create(const aDevice:TVulkanDevice;
                          const aFlags:TVkDescriptorPoolCreateFlags;
                          const aMaxSets:TVkUInt32);
       destructor Destroy; override;
       function AddDescriptorPoolSize(const aType:TVkDescriptorType;const aDescriptorCount:TVkUInt32):TVkInt32;
       procedure Initialize;
       property Device:TVulkanDevice read fDevice;
       property Handle:TVkDescriptorPool read fDescriptorPoolHandle;
     end;

     TVulkanDescriptorSetLayoutBinding=class(TVulkanObject)
      private                     
       fDescriptorSetLayoutBinding:TVkDescriptorSetLayoutBinding;
       fImmutableSamplers:TVkSamplerArray;
       fCountImmutableSamplers:TVkInt32;
       function GetBinding:TVkUInt32;
       procedure SetBinding(const aBinding:TVkUInt32);
       function GetDescriptorType:TVkDescriptorType;
       procedure SetDescriptorType(const aDescriptorType:TVkDescriptorType);
       function GetDescriptorCount:TVkUInt32;
       procedure SetDescriptorCount(const aDescriptorCount:TVkUInt32);
       function GetStageFlags:TVkShaderStageFlags;
       procedure SetStageFlags(const aStageFlags:TVkShaderStageFlags);
      public
       constructor Create(const aBinding:TVkUInt32;
                          const aDescriptorType:TVkDescriptorType;
                          const aDescriptorCount:TVkUInt32;
                          const aStageFlags:TVkShaderStageFlags);
       destructor Destroy; override;
       procedure AddImmutableSampler(const aImmutableSampler:TVulkanSampler);
       procedure AddImmutableSamplers(const aImmutableSamplers:array of TVulkanSampler);
       procedure Initialize;
      published
       property Binding:TVkUInt32 read GetBinding write SetBinding;
       property DescriptorType:TVkDescriptorType read GetDescriptorType write SetDescriptorType;
       property DescriptorCount:TVkUInt32 read GetDescriptorCount write SetDescriptorCount;
       property StageFlags:TVkShaderStageFlags read GetStageFlags write SetStageFlags;
     end;

     TVulkanDescriptorSetLayout=class(TVulkanObject)
      private
       fDevice:TVulkanDevice;
       fDescriptorSetLayoutHandle:TVkDescriptorSetLayout;
       fDescriptorSetLayoutBindingList:TVulkanObjectList;
       fDescriptorSetLayoutBindingArray:TVkDescriptorSetLayoutBindingArray;
      public
       constructor Create(const aDevice:TVulkanDevice);
       destructor Destroy; override;
       procedure AddBinding(const aBinding:TVkUInt32;
                            const aDescriptorType:TVkDescriptorType;
                            const aDescriptorCount:TVkUInt32;
                            const aStageFlags:TVkShaderStageFlags;
                            const aImmutableSamplers:array of TVulkanSampler);
       procedure Initialize;
       property Device:TVulkanDevice read fDevice;
       property Handle:TVkDescriptorSetLayout read fDescriptorSetLayoutHandle;
     end;

     PVulkanDescriptorSetWriteDescriptorSetMetaData=^TVulkanDescriptorSetWriteDescriptorSetMetaData;
     TVulkanDescriptorSetWriteDescriptorSetMetaData=record
      ImageInfo:array of TVkDescriptorImageInfo;
      BufferInfo:array of TVkDescriptorBufferInfo;
      TexelBufferView:array of TVkBufferView;
     end;

     TVulkanDescriptorSetWriteDescriptorSetMetaDataArray=array of TVulkanDescriptorSetWriteDescriptorSetMetaData;

     TVulkanDescriptorSet=class(TVulkanObject)
      private
       fDevice:TVulkanDevice;
       fDescriptorPool:TVulkanDescriptorPool;
       fDescriptorSetLayout:TVulkanDescriptorSetLayout;
       fDescriptorSetHandle:TVkDescriptorSet;
       fDescriptorSetAllocateInfo:TVkDescriptorSetAllocateInfo;
       fCopyDescriptorSetQueue:TVkCopyDescriptorSetArray;
       fCopyDescriptorSetQueueSize:TVkInt32;
       fWriteDescriptorSetQueue:TVkWriteDescriptorSetArray;
       fWriteDescriptorSetQueueMetaData:TVulkanDescriptorSetWriteDescriptorSetMetaDataArray;
       fWriteDescriptorSetQueueSize:TVkInt32;
      public
       constructor Create(const aDescriptorPool:TVulkanDescriptorPool;
                          const aDescriptorSetLayout:TVulkanDescriptorSetLayout);
       destructor Destroy; override;
       class function Allocate(const aDescriptorPool:TVulkanDescriptorPool;
                               const aDescriptorSetLayouts:array of TVulkanDescriptorSetLayout):TVulkanObjectList;
       procedure CopyFromDescriptorSet(const aSourceDescriptorSet:TVulkanDescriptorSet;
                                       const aSourceBinding:TVkUInt32;
                                       const aSourceArrayElement:TVkUInt32;
                                       const aDestinationBinding:TVkUInt32;
                                       const aDestinationArrayElement:TVkUInt32;
                                       const aDescriptorCount:TVkUInt32;
                                       const aDoInstant:boolean=false);
       procedure WriteToDescriptorSet(const aDestinationBinding:TVkUInt32;
                                      const aDestinationArrayElement:TVkUInt32;
                                      const aDescriptorCount:TVkUInt32;
                                      const aDescriptorType:TVkDescriptorType;
                                      const aImageInfo:array of TVkDescriptorImageInfo;
                                      const aBufferInfo:array of TVkDescriptorBufferInfo;
                                      const aTexelBufferView:array of TVkBufferView;
                                      const aDoInstant:boolean=false);
       procedure Flush;
      published
       property Device:TVulkanDevice read fDevice;
       property Handle:TVkDescriptorSet read fDescriptorSetHandle;
       property DescriptorPool:TVulkanDescriptorPool read fDescriptorPool;
       property DescriptorSetLayout:TVulkanDescriptorSetLayout read fDescriptorSetLayout;
     end;

     TVulkanPipelineLayout=class(TVulkanObject)
      private
       fDevice:TVulkanDevice;
       fPipelineLayoutHandle:TVkPipelineLayout;
       fDescriptorSetLayouts:TVkDescriptorSetLayoutArray;
       fCountDescriptorSetLayouts:TVkInt32;
       fPushConstantRanges:TVkPushConstantRangeArray;
       fCountPushConstantRanges:TVkInt32;
      public
       constructor Create(const aDevice:TVulkanDevice);
       destructor Destroy; override;
       function AddDescriptorSetLayout(const aDescriptorSetLayout:TVkDescriptorSetLayout):TVkInt32; overload;
       function AddDescriptorSetLayout(const aDescriptorSetLayout:TVulkanDescriptorSetLayout):TVkInt32; overload;
       function AddDescriptorSetLayouts(const aDescriptorSetLayouts:array of TVkDescriptorSetLayout):TVkInt32; overload;
       function AddDescriptorSetLayouts(const aDescriptorSetLayouts:array of TVulkanDescriptorSetLayout):TVkInt32; overload;
       function AddPushConstantRange(const aPushConstantRange:TVkPushConstantRange):TVkInt32; overload;
       function AddPushConstantRange(const aStageFlags:TVkShaderStageFlags;const aOffset,aSize:TVkUInt32):TVkInt32; overload;
       function AddPushConstantRanges(const aPushConstantRanges:array of TVkPushConstantRange):TVkInt32;
       procedure Initialize;
      published
       property Device:TVulkanDevice read fDevice;
       property Handle:TVkPipelineLayout read fPipelineLayoutHandle;
     end;

     TVulkanPipelineShaderStage=class(TVulkanObject)
      private
       fPipelineShaderStageCreateInfo:TVkPipelineShaderStageCreateInfo;
       fPointerToPipelineShaderStageCreateInfo:PVkPipelineShaderStageCreateInfo;
       fName:TVkCharString;
       fSpecializationInfo:PVkSpecializationInfo;
       fDoCopyAndDoFree:boolean;
       fSpecializationMapEntries:TVkSpecializationMapEntryArray;
       fCountSpecializationMapEntries:TVkInt32;
       fInitialized:boolean;
       procedure AllocateSpecializationInfo;
      public
       constructor Create(const aStage:TVkShaderStageFlagBits;
                          const aModule:TVulkanShaderModule;
                          const aName:TVkCharString);
       destructor Destroy; override;
       procedure AddSpecializationDataFromMemory(const aData:TVkPointer;const aDataSize:TVkSize;const aDoCopyAndDoFree:boolean=true);
       procedure AddSpecializationDataFromStream(const aStream:TStream);
       procedure AddSpecializationDataFromFile(const aFileName:string);
       function AddSpecializationMapEntry(const aSpecializationMapEntry:TVkSpecializationMapEntry):TVkInt32; overload;
       function AddSpecializationMapEntry(const aConstantID,aOffset:TVkUInt32;const aSize:TVkSize):TVkInt32; overload;
       function AddSpecializationMapEntries(const aSpecializationMapEntries:array of TVkSpecializationMapEntry):TVkInt32;
       procedure Initialize;
       property PipelineShaderStageCreateInfo:PVkPipelineShaderStageCreateInfo read fPointerToPipelineShaderStageCreateInfo;
      published
     end;

     TVulkanPipelineCache=class(TVulkanObject)
      private
       fDevice:TVulkanDevice;
       fPipelineCacheHandle:TVkPipelineCache;
      public
       constructor Create(const aDevice:TVulkanDevice;const aInitialData:TVkPointer=nil;const aInitialDataSize:TVkSize=0);
       constructor CreateFromMemory(const aDevice:TVulkanDevice;const aInitialData:TVkPointer;const aInitialDataSize:TVkSize);
       constructor CreateFromStream(const aDevice:TVulkanDevice;const aStream:TStream);
       constructor CreateFromFile(const aDevice:TVulkanDevice;const aFileName:string);
       destructor Destroy; override;
       procedure SaveToStream(const aStream:TStream);
       procedure SaveToFile(const aFileName:string);
       procedure Merge(const aSourcePipelineCache:TVulkanPipelineCache); overload;
       procedure Merge(const aSourcePipelineCaches:array of TVulkanPipelineCache); overload;
      published
       property Device:TVulkanDevice read fDevice;
       property Handle:TVkPipelineCache read fPipelineCacheHandle;
     end;

     TVulkanPipeline=class(TVulkanObject)
      private
       fDevice:TVulkanDevice;
       fPipelineHandle:TVkPipeline;
      public
       constructor Create(const aDevice:TVulkanDevice);
       destructor Destroy; override;
      published
       property Device:TVulkanDevice read fDevice;
       property Handle:TVkPipeline read fPipelineHandle;
     end;

     TVulkanComputePipeline=class(TVulkanPipeline)
      public
       constructor Create(const aDevice:TVulkanDevice;
                          const aCache:TVulkanPipelineCache;
                          const aFlags:TVkPipelineCreateFlags;
                          const aStage:TVulkanPipelineShaderStage;
                          const aLayout:TVulkanPipelineLayout;
                          const aBasePipelineHandle:TVulkanPipeline;
                          const aBasePipelineIndex:TVkInt32); reintroduce;
     end;

     TVulkanPipelineState=class(TVulkanObject)
      public
       constructor Create;
       destructor Destroy; override;
     end;

     TVulkanPipelineVertexInputState=class(TVulkanPipelineState)
      private
       fVertexInputStateCreateInfo:TVkPipelineVertexInputStateCreateInfo;
       fPointerToVertexInputStateCreateInfo:PVkPipelineVertexInputStateCreateInfo;
       fVertexInputBindingDescriptions:TVkVertexInputBindingDescriptionArray;
       fCountVertexInputBindingDescriptions:TVkInt32;
       fVertexInputAttributeDescriptions:TVkVertexInputAttributeDescriptionArray;
       fCountVertexInputAttributeDescriptions:TVkInt32;
       function GetVertexInputBindingDescription(const aIndex:TVkInt32):PVkVertexInputBindingDescription;
       function GetVertexInputAttributeDescription(const aIndex:TVkInt32):PVkVertexInputAttributeDescription;
       procedure SetCountVertexInputBindingDescriptions(const aNewCount:TVkInt32);
       procedure SetCountVertexInputAttributeDescriptions(const aNewCount:TVkInt32);
       procedure Initialize;
      public
       constructor Create;
       destructor Destroy; override;
       procedure Assign(const aFrom:TVulkanPipelineVertexInputState);
       function AddVertexInputBindingDescription(const aVertexInputBindingDescription:TVkVertexInputBindingDescription):TVkInt32; overload;
       function AddVertexInputBindingDescription(const aBinding,aStride:TVkUInt32;const aInputRate:TVkVertexInputRate):TVkInt32; overload;
       function AddVertexInputBindingDescriptions(const aVertexInputBindingDescriptions:array of TVkVertexInputBindingDescription):TVkInt32;
       function AddVertexInputAttributeDescription(const aVertexInputAttributeDescription:TVkVertexInputAttributeDescription):TVkInt32; overload;
       function AddVertexInputAttributeDescription(const aLocation,aBinding:TVkUInt32;const aFormat:TVkFormat;const aOffset:TVkUInt32):TVkInt32; overload;
       function AddVertexInputAttributeDescriptions(const aVertexInputAttributeDescriptions:array of TVkVertexInputAttributeDescription):TVkInt32;
       property VertexInputStateCreateInfo:PVkPipelineVertexInputStateCreateInfo read fPointerToVertexInputStateCreateInfo;
       property VertexInputBindingDescriptions[const aIndex:TVkInt32]:PVkVertexInputBindingDescription read GetVertexInputBindingDescription;
       property VertexInputAttributeDescriptions[const aIndex:TVkInt32]:PVkVertexInputAttributeDescription read GetVertexInputAttributeDescription;
      published
       property CountVertexInputBindingDescriptions:TVkInt32 read fCountVertexInputBindingDescriptions write SetCountVertexInputBindingDescriptions;
       property CountVertexInputAttributeDescriptions:TVkInt32 read fCountVertexInputAttributeDescriptions write SetCountVertexInputAttributeDescriptions;
     end;

     TVulkanPipelineInputAssemblyState=class(TVulkanPipelineState)
      private
       fInputAssemblyStateCreateInfo:TVkPipelineInputAssemblyStateCreateInfo;
       fPointerToInputAssemblyStateCreateInfo:PVkPipelineInputAssemblyStateCreateInfo;
       function GetTopology:TVkPrimitiveTopology;
       procedure SetTopology(const aNewValue:TVkPrimitiveTopology);
       function GetPrimitiveRestartEnable:boolean;
       procedure SetPrimitiveRestartEnable(const aNewValue:boolean);
      public
       constructor Create;
       destructor Destroy; override;
       procedure Assign(const aFrom:TVulkanPipelineInputAssemblyState);
       procedure SetInputAssemblyState(const aTopology:TVkPrimitiveTopology;const aPrimitiveRestartEnable:boolean);
       property InputAssemblyStateCreateInfo:PVkPipelineInputAssemblyStateCreateInfo read fPointerToInputAssemblyStateCreateInfo;
      published
       property Topology:TVkPrimitiveTopology read GetTopology write SetTopology;
       property PrimitiveRestartEnable:boolean read GetPrimitiveRestartEnable write SetPrimitiveRestartEnable;
     end;

     TVulkanPipelineTessellationState=class(TVulkanPipelineState)
      private
       fTessellationStateCreateInfo:TVkPipelineTessellationStateCreateInfo;
       fPointerToTessellationStateCreateInfo:PVkPipelineTessellationStateCreateInfo;
       function GetPatchControlPoints:TVkUInt32;
       procedure SetPatchControlPoints(const aNewValue:TVkUInt32);
      public
       constructor Create;
       destructor Destroy; override;
       procedure Assign(const aFrom:TVulkanPipelineTessellationState);
       procedure SetTessellationState(const aPatchControlPoints:TVkUInt32);
       property TessellationStateCreateInfo:PVkPipelineTessellationStateCreateInfo read fPointerToTessellationStateCreateInfo;
      published
       property PatchControlPoints:TVkUInt32 read GetPatchControlPoints write SetPatchControlPoints;
     end;

     TVulkanPipelineViewPortState=class(TVulkanPipelineState)
      private
       fViewportStateCreateInfo:TVkPipelineViewportStateCreateInfo;
       fPointerToViewportStateCreateInfo:PVkPipelineViewportStateCreateInfo;
       fViewPorts:TVkViewportArray;
       fCountViewPorts:TVkInt32;
       fDynamicViewPorts:boolean;
       fScissors:TVkRect2DArray;
       fCountScissors:TVkInt32;
       fDynamicScissors:boolean;
       function GetViewPort(const aIndex:TVkInt32):PVkViewport;
       function GetScissor(const aIndex:TVkInt32):PVkRect2D;
       procedure SetCountViewPorts(const aNewCount:TVkInt32);
       procedure SetCountScissors(const aNewCount:TVkInt32);
       procedure Initialize;
      public
       constructor Create;
       destructor Destroy; override;
       procedure Assign(const aFrom:TVulkanPipelineViewPortState);
       function AddViewPort(const aViewPort:TVkViewport):TVkInt32; overload;
       function AddViewPort(const pX,pY,aWidth,aHeight,aMinDepth,aMaxDepth:TVkFloat):TVkInt32; overload;
       function AddViewPorts(const aViewPorts:array of TVkViewport):TVkInt32; overload;
       function AddScissor(const aScissor:TVkRect2D):TVkInt32; overload;
       function AddScissor(const pX,pY:TVkInt32;const aWidth,aHeight:TVkUInt32):TVkInt32; overload;
       function AddScissors(const aScissors:array of TVkRect2D):TVkInt32; overload;
       property ViewportStateCreateInfo:PVkPipelineViewportStateCreateInfo read fPointerToViewportStateCreateInfo;
       property ViewPorts[const aIndex:TVkInt32]:PVkViewport read GetViewPort;
       property Scissors[const aIndex:TVkInt32]:PVkRect2D read GetScissor;
      published
       property CountViewPorts:TVkInt32 read fCountViewPorts write SetCountViewPorts;
       property DynamicViewPorts:boolean read fDynamicViewPorts write fDynamicViewPorts;
       property CountScissors:TVkInt32 read fCountScissors write SetCountScissors;
       property DynamicScissors:boolean read fDynamicScissors write fDynamicScissors;
     end;

     TVulkanPipelineRasterizationState=class(TVulkanPipelineState)
      private
       fRasterizationStateCreateInfo:TVkPipelineRasterizationStateCreateInfo;
       fPointerToRasterizationStateCreateInfo:PVkPipelineRasterizationStateCreateInfo;
       function GetDepthClampEnable:boolean;
       procedure SetDepthClampEnable(const aNewValue:boolean);
       function GetRasterizerDiscardEnable:boolean;
       procedure SetRasterizerDiscardEnable(const aNewValue:boolean);
       function GetPolygonMode:TVkPolygonMode;
       procedure SetPolygonMode(const aNewValue:TVkPolygonMode);
       function GetCullMode:TVkCullModeFlags;
       procedure SetCullMode(const aNewValue:TVkCullModeFlags);
       function GetFrontFace:TVkFrontFace;
       procedure SetFrontFace(const aNewValue:TVkFrontFace);
       function GetDepthBiasEnable:boolean;
       procedure SetDepthBiasEnable(const aNewValue:boolean);
       function GetDepthBiasConstantFactor:TVkFloat;
       procedure SetDepthBiasConstantFactor(const aNewValue:TVkFloat);
       function GetDepthBiasClamp:TVkFloat;
       procedure SetDepthBiasClamp(const aNewValue:TVkFloat);
       function GetDepthBiasSlopeFactor:TVkFloat;
       procedure SetDepthBiasSlopeFactor(const aNewValue:TVkFloat);
       function GetLineWidth:TVkFloat;
       procedure SetLineWidth(const aNewValue:TVkFloat);
      public
       constructor Create;
       destructor Destroy; override;
       procedure Assign(const aFrom:TVulkanPipelineRasterizationState);
       procedure SetRasterizationState(const aDepthClampEnable:boolean;
                                       const aRasterizerDiscardEnable:boolean;
                                       const aPolygonMode:TVkPolygonMode;
                                       const aCullMode:TVkCullModeFlags;
                                       const aFrontFace:TVkFrontFace;
                                       const aDepthBiasEnable:boolean;
                                       const aDepthBiasConstantFactor:TVkFloat;
                                       const aDepthBiasClamp:TVkFloat;
                                       const aDepthBiasSlopeFactor:TVkFloat;
                                       const aLineWidth:TVkFloat);
       property RasterizationStateCreateInfo:PVkPipelineRasterizationStateCreateInfo read fPointerToRasterizationStateCreateInfo;
      published
       property DepthClampEnable:boolean read GetDepthClampEnable write SetDepthClampEnable;
       property RasterizerDiscardEnable:boolean read GetRasterizerDiscardEnable write SetRasterizerDiscardEnable;
       property PolygonMode:TVkPolygonMode read GetPolygonMode write SetPolygonMode;
       property CullMode:TVkCullModeFlags read GetCullMode write SetCullMode;
       property FrontFace:TVkFrontFace read GetFrontFace write SetFrontFace;
       property DepthBiasEnable:boolean read GetDepthBiasEnable write SetDepthBiasEnable;
       property DepthBiasConstantFactor:TVkFloat read GetDepthBiasConstantFactor write SetDepthBiasConstantFactor;
       property DepthBiasClamp:TVkFloat read GetDepthBiasClamp write SetDepthBiasClamp;
       property DepthBiasSlopeFactor:TVkFloat read GetDepthBiasSlopeFactor write SetDepthBiasSlopeFactor;
       property LineWidth:TVkFloat read GetLineWidth write SetLineWidth;
     end;

     TVulkanPipelineMultisampleState=class(TVulkanPipelineState)
      private
       fMultisampleStateCreateInfo:TVkPipelineMultisampleStateCreateInfo;
       fPointerToMultisampleStateCreateInfo:PVkPipelineMultisampleStateCreateInfo;
       fSampleMasks:TVkSampleMaskArray;
       fCountSampleMasks:TVkInt32;
       function GetRasterizationSamples:TVkSampleCountFlagBits;
       procedure SetRasterizationSamples(const aNewValue:TVkSampleCountFlagBits);
       function GetSampleShadingEnable:boolean;
       procedure SetSampleShadingEnable(const aNewValue:boolean);
       function GetSampleMask(const aIndex:TVkInt32):TVkSampleMask;
       procedure SetSampleMask(const aIndex:TVkInt32;const aNewValue:TVkSampleMask);
       procedure SetCountSampleMasks(const aNewCount:TVkInt32);
       function GetMinSampleShading:TVkFloat;
       procedure SetMinSampleShading(const aNewValue:TVkFloat);
       function GetAlphaToCoverageEnable:boolean;
       procedure SetAlphaToCoverageEnable(const aNewValue:boolean);
       function GetAlphaToOneEnable:boolean;
       procedure SetAlphaToOneEnable(const aNewValue:boolean);
       procedure Initialize;
      public
       constructor Create;
       destructor Destroy; override;
       procedure Assign(const aFrom:TVulkanPipelineMultisampleState);
       function AddSampleMask(const aSampleMask:TVkSampleMask):TVkInt32;
       function AddSampleMasks(const aSampleMasks:array of TVkSampleMask):TVkInt32;
       procedure SetMultisampleState(const aRasterizationSamples:TVkSampleCountFlagBits;
                                     const aSampleShadingEnable:boolean;
                                     const aMinSampleShading:TVkFloat;
                                     const aSampleMask:array of TVkSampleMask;
                                     const aAlphaToCoverageEnable:boolean;
                                     const aAlphaToOneEnable:boolean);
       property MultisampleStateCreateInfo:PVkPipelineMultisampleStateCreateInfo read fPointerToMultisampleStateCreateInfo;
       property SampleMasks[const aIndex:TVkInt32]:TVkSampleMask read GetSampleMask write SetSampleMask;
      published                                                                            
       property RasterizationSamples:TVkSampleCountFlagBits read GetRasterizationSamples write SetRasterizationSamples;
       property SampleShadingEnable:boolean read GetSampleShadingEnable write SetSampleShadingEnable;
       property MinSampleShading:TVkFloat read GetMinSampleShading write SetMinSampleShading;
       property CountSampleMasks:TVkInt32 read fCountSampleMasks write SetCountSampleMasks;
       property AlphaToCoverageEnable:boolean read GetAlphaToCoverageEnable write SetAlphaToCoverageEnable;
       property AlphaToOneEnable:boolean read GetAlphaToOneEnable write SetAlphaToOneEnable;
     end;

     TVulkanStencilOpState=class(TVulkanObject)
      private
       fStencilOpState:PVkStencilOpState;
       function GetFailOp:TVkStencilOp;
       procedure SetFailOp(const aNewValue:TVkStencilOp);
       function GetPassOp:TVkStencilOp;
       procedure SetPassOp(const aNewValue:TVkStencilOp);
       function GetDepthFailOp:TVkStencilOp;
       procedure SetDepthFailOp(const aNewValue:TVkStencilOp);
       function GetCompareOp:TVkCompareOp;
       procedure SetCompareOp(const aNewValue:TVkCompareOp);
       function GetCompareMask:TVkUInt32;
       procedure SetCompareMask(const aNewValue:TVkUInt32);
       function GetWriteMask:TVkUInt32;
       procedure SetWriteMask(const aNewValue:TVkUInt32);
       function GetReference:TVkUInt32;
       procedure SetReference(const aNewValue:TVkUInt32);
      public
       constructor Create(const aStencilOpState:PVkStencilOpState);
       destructor Destroy; override;
       procedure Assign(const aFrom:TVulkanStencilOpState);
       property StencilOpState:PVkStencilOpState read fStencilOpState;
      published
       property FailOp:TVkStencilOp read GetFailOp write SetFailOp;
       property PassOp:TVkStencilOp read GetPassOp write SetPassOp;
       property DepthFailOp:TVkStencilOp read GetDepthFailOp write SetDepthFailOp;
       property CompareOp:TVkCompareOp read GetCompareOp write SetCompareOp;
       property CompareMask:TVkUInt32 read GetCompareMask write SetCompareMask;
       property WriteMask:TVkUInt32 read GetWriteMask write SetWriteMask;
       property Reference:TVkUInt32 read GetReference write SetReference;
     end;

     TVulkanPipelineDepthStencilState=class(TVulkanPipelineState)
      private
       fDepthStencilStateCreateInfo:TVkPipelineDepthStencilStateCreateInfo;
       fPointerToDepthStencilStateCreateInfo:PVkPipelineDepthStencilStateCreateInfo;
       fFrontStencilOpState:TVulkanStencilOpState;
       fBackStencilOpState:TVulkanStencilOpState;
       function GetDepthTestEnable:boolean;
       procedure SetDepthTestEnable(const aNewValue:boolean);
       function GetDepthWriteEnable:boolean;
       procedure SetDepthWriteEnable(const aNewValue:boolean);
       function GetDepthCompareOp:TVkCompareOp;
       procedure SetDepthCompareOp(const aNewValue:TVkCompareOp);
       function GetDepthBoundsTestEnable:boolean;
       procedure SetDepthBoundsTestEnable(const aNewValue:boolean);
       function GetStencilTestEnable:boolean;
       procedure SetStencilTestEnable(const aNewValue:boolean);
       function GetMinDepthBounds:TVkFloat;
       procedure SetMinDepthBounds(const aNewValue:TVkFloat);
       function GetMaxDepthBounds:TVkFloat;
       procedure SetMaxDepthBounds(const aNewValue:TVkFloat);
      public
       constructor Create;
       destructor Destroy; override;
       procedure Assign(const aFrom:TVulkanPipelineDepthStencilState);
       procedure SetDepthStencilState(const aDepthTestEnable:boolean;
                                      const aDepthWriteEnable:boolean;
                                      const aDepthCompareOp:TVkCompareOp;
                                      const aDepthBoundsTestEnable:boolean;
                                      const aStencilTestEnable:boolean;
                                      const aFront:TVkStencilOpState;
                                      const aBack:TVkStencilOpState;
                                      const aMinDepthBounds:TVkFloat;
                                      const aMaxDepthBounds:TVkFloat);
       property DepthStencilStateCreateInfo:PVkPipelineDepthStencilStateCreateInfo read fPointerToDepthStencilStateCreateInfo;
      published
       property DepthTestEnable:boolean read GetDepthTestEnable write SetDepthTestEnable;
       property DepthWriteEnable:boolean read GetDepthWriteEnable write SetDepthWriteEnable;
       property DepthCompareOp:TVkCompareOp read GetDepthCompareOp write SetDepthCompareOp;
       property DepthBoundsTestEnable:boolean read GetDepthBoundsTestEnable write SetDepthBoundsTestEnable;
       property StencilTestEnable:boolean read GetStencilTestEnable write SetStencilTestEnable;
       property Front:TVulkanStencilOpState read fFrontStencilOpState;
       property Back:TVulkanStencilOpState read fBackStencilOpState;
       property MinDepthBounds:TVkFloat read GetMinDepthBounds write SetMinDepthBounds;
       property MaxDepthBounds:TVkFloat read GetMaxDepthBounds write SetMaxDepthBounds;
     end;

     TVulkanPipelineColorBlendState=class(TVulkanPipelineState)
      private
       fColorBlendStateCreateInfo:TVkPipelineColorBlendStateCreateInfo;
       fPointerToColorBlendStateCreateInfo:PVkPipelineColorBlendStateCreateInfo;
       fColorBlendAttachmentStates:TVkPipelineColorBlendAttachmentStateArray;
       fCountColorBlendAttachmentStates:TVkInt32;
       function GetLogicOpEnable:boolean;
       procedure SetLogicOpEnable(const aNewValue:boolean);
       function GetLogicOp:TVkLogicOp;
       procedure SetLogicOp(const aNewValue:TVkLogicOp);
       procedure SetCountColorBlendAttachmentStates(const aNewCount:TVkInt32);
       function GetColorBlendAttachmentState(const aIndex:TVkInt32):PVkPipelineColorBlendAttachmentState;
       function GetBlendConstant(const aIndex:TVkInt32):TVkFloat;
       procedure SetBlendConstant(const aIndex:TVkInt32;const aNewValue:TVkFloat);
      public
       constructor Create;
       destructor Destroy; override;
       procedure Assign(const aFrom:TVulkanPipelineColorBlendState);
       procedure SetColorBlendState(const aLogicOpEnable:boolean;
                                    const aLogicOp:TVkLogicOp;
                                    const aBlendConstants:array of TVkFloat);
       function AddColorBlendAttachmentState(const aColorBlendAttachmentState:TVkPipelineColorBlendAttachmentState):TVkInt32; overload;
       function AddColorBlendAttachmentState(const aBlendEnable:boolean;
                                             const aSrcColorBlendFactor:TVkBlendFactor;
                                             const aDstColorBlendFactor:TVkBlendFactor;
                                             const aColorBlendOp:TVkBlendOp;
                                             const aSrcAlphaBlendFactor:TVkBlendFactor;
                                             const aDstAlphaBlendFactor:TVkBlendFactor;
                                             const aAlphaBlendOp:TVkBlendOp;
                                             const aColorWriteMask:TVkColorComponentFlags):TVkInt32; overload;
       function AddColorBlendAttachmentStates(const aColorBlendAttachmentStates:array of TVkPipelineColorBlendAttachmentState):TVkInt32;
       procedure Initialize;
       property ColorBlendStateCreateInfo:PVkPipelineColorBlendStateCreateInfo read fPointerToColorBlendStateCreateInfo;
       property ColorBlendAttachmentStates[const aIndex:TVkInt32]:PVkPipelineColorBlendAttachmentState read GetColorBlendAttachmentState;
       property BlendConstants[const aIndex:TVkInt32]:TVkFloat read GetBlendConstant write SetBlendConstant;
      published
       property LogicOpEnable:boolean read GetLogicOpEnable write SetLogicOpEnable;
       property LogicOp:TVkLogicOp read GetLogicOp write SetLogicOp;
       property CountColorBlendAttachmentStates:TVkInt32 read fCountColorBlendAttachmentStates write SetCountColorBlendAttachmentStates;
     end;

     TVulkanPipelineDynamicState=class(TVulkanPipelineState)
      private
       fDynamicStateCreateInfo:TVkPipelineDynamicStateCreateInfo;
       fPointerToDynamicStateCreateInfo:PVkPipelineDynamicStateCreateInfo;
       fDynamicStates:TVkDynamicStateArray;
       fCountDynamicStates:TVkInt32;
       function GetDynamicState(const aIndex:TVkInt32):PVkDynamicState;
       procedure SetCountDynamicStates(const aNewCount:TVkInt32);
       procedure Initialize;
      public
       constructor Create;
       destructor Destroy; override;
       procedure Assign(const aFrom:TVulkanPipelineDynamicState);
       function AddDynamicState(const aDynamicState:TVkDynamicState):TVkInt32;
       function AddDynamicStates(const aDynamicStates:array of TVkDynamicState):TVkInt32;
       property DynamicStateStateCreateInfo:PVkPipelineDynamicStateCreateInfo read fPointerToDynamicStateCreateInfo;
       property DynamicStates[const aIndex:TVkInt32]:PVkDynamicState read GetDynamicState;
      published
       property CountDynamicStates:TVkInt32 read fCountDynamicStates write SetCountDynamicStates;
     end;

     TVulkanGraphicsPipelineConstructor=class(TVulkanPipeline)
      private
       fGraphicsPipelineCreateInfo:TVkGraphicsPipelineCreateInfo;
       fStages:TVkPipelineShaderStageCreateInfoArray;
       fCountStages:TVkInt32;
       fVertexInputState:TVulkanPipelineVertexInputState;
       fInputAssemblyState:TVulkanPipelineInputAssemblyState;
       fTessellationState:TVulkanPipelineTessellationState;
       fViewPortState:TVulkanPipelineViewPortState;
       fRasterizationState:TVulkanPipelineRasterizationState;
       fMultisampleState:TVulkanPipelineMultisampleState;
       fDepthStencilState:TVulkanPipelineDepthStencilState;
       fColorBlendState:TVulkanPipelineColorBlendState;
       fDynamicState:TVulkanPipelineDynamicState;
       fPipelineCache:TVkPipelineCache;
      public
       constructor Create(const aDevice:TVulkanDevice;
                          const aCache:TVulkanPipelineCache;
                          const aFlags:TVkPipelineCreateFlags;
                          const aStages:array of TVulkanPipelineShaderStage;
                          const aLayout:TVulkanPipelineLayout;
                          const aRenderPass:TVulkanRenderPass;
                          const aSubPass:TVkUInt32;
                          const aBasePipelineHandle:TVulkanPipeline;
                          const aBasePipelineIndex:TVkInt32); reintroduce;
       destructor Destroy; override;
       procedure Assign(const aFrom:TVulkanGraphicsPipelineConstructor);
       function AddStage(const aStage:TVulkanPipelineShaderStage):TVkInt32;
       function AddStages(const aStages:array of TVulkanPipelineShaderStage):TVkInt32;
       function AddVertexInputBindingDescription(const aVertexInputBindingDescription:TVkVertexInputBindingDescription):TVkInt32; overload;
       function AddVertexInputBindingDescription(const aBinding,aStride:TVkUInt32;const aInputRate:TVkVertexInputRate):TVkInt32; overload;
       function AddVertexInputBindingDescriptions(const aVertexInputBindingDescriptions:array of TVkVertexInputBindingDescription):TVkInt32;
       function AddVertexInputAttributeDescription(const aVertexInputAttributeDescription:TVkVertexInputAttributeDescription):TVkInt32; overload;
       function AddVertexInputAttributeDescription(const aLocation,aBinding:TVkUInt32;const aFormat:TVkFormat;const aOffset:TVkUInt32):TVkInt32; overload;
       function AddVertexInputAttributeDescriptions(const aVertexInputAttributeDescriptions:array of TVkVertexInputAttributeDescription):TVkInt32;
       procedure SetInputAssemblyState(const aTopology:TVkPrimitiveTopology;const aPrimitiveRestartEnable:boolean);
       procedure SetTessellationState(const aPatchControlPoints:TVkUInt32);
       function AddViewPort(const aViewPort:TVkViewport):TVkInt32; overload;
       function AddViewPort(const pX,pY,aWidth,aHeight,aMinDepth,aMaxDepth:TVkFloat):TVkInt32; overload;
       function AddViewPorts(const aViewPorts:array of TVkViewport):TVkInt32; overload;
       function AddScissor(const aScissor:TVkRect2D):TVkInt32; overload;
       function AddScissor(const pX,pY:TVkInt32;const aWidth,aHeight:TVkUInt32):TVkInt32; overload;
       function AddScissors(const aScissors:array of TVkRect2D):TVkInt32; overload;
       procedure SetRasterizationState(const aDepthClampEnable:boolean;
                                       const aRasterizerDiscardEnable:boolean;
                                       const aPolygonMode:TVkPolygonMode;
                                       const aCullMode:TVkCullModeFlags;
                                       const aFrontFace:TVkFrontFace;
                                       const aDepthBiasEnable:boolean;
                                       const aDepthBiasConstantFactor:TVkFloat;
                                       const aDepthBiasClamp:TVkFloat;
                                       const aDepthBiasSlopeFactor:TVkFloat;
                                       const aLineWidth:TVkFloat);
       procedure SetMultisampleState(const aRasterizationSamples:TVkSampleCountFlagBits;
                                     const aSampleShadingEnable:boolean;
                                     const aMinSampleShading:TVkFloat;
                                     const aSampleMask:array of TVkSampleMask;
                                     const aAlphaToCoverageEnable:boolean;
                                     const aAlphaToOneEnable:boolean);
       procedure SetDepthStencilState(const aDepthTestEnable:boolean;
                                      const aDepthWriteEnable:boolean;
                                      const aDepthCompareOp:TVkCompareOp;
                                      const aDepthBoundsTestEnable:boolean;
                                      const aStencilTestEnable:boolean;
                                      const aFront:TVkStencilOpState;
                                      const aBack:TVkStencilOpState;
                                      const aMinDepthBounds:TVkFloat;
                                      const aMaxDepthBounds:TVkFloat);
       procedure SetColorBlendState(const aLogicOpEnable:boolean;
                                    const aLogicOp:TVkLogicOp;
                                    const aBlendConstants:array of TVkFloat);
       function AddColorBlendAttachmentState(const aColorBlendAttachmentState:TVkPipelineColorBlendAttachmentState):TVkInt32; overload;
       function AddColorBlendAttachmentState(const aBlendEnable:boolean;
                                             const aSrcColorBlendFactor:TVkBlendFactor;
                                             const aDstColorBlendFactor:TVkBlendFactor;
                                             const aColorBlendOp:TVkBlendOp;
                                             const aSrcAlphaBlendFactor:TVkBlendFactor;
                                             const aDstAlphaBlendFactor:TVkBlendFactor;
                                             const aAlphaBlendOp:TVkBlendOp;
                                             const aColorWriteMask:TVkColorComponentFlags):TVkInt32; overload;
       function AddColorBlendAttachmentStates(const aColorBlendAttachmentStates:array of TVkPipelineColorBlendAttachmentState):TVkInt32;
       function AddDynamicState(const aDynamicState:TVkDynamicState):TVkInt32;
       function AddDynamicStates(const aDynamicStates:array of TVkDynamicState):TVkInt32;
       procedure Initialize;
       property Stages:TVkPipelineShaderStageCreateInfoArray read fStages;
      published
       property CountStages:TVkInt32 read fCountStages;
       property VertexInputState:TVulkanPipelineVertexInputState read fVertexInputState;
       property InputAssemblyState:TVulkanPipelineInputAssemblyState read fInputAssemblyState;
       property TessellationState:TVulkanPipelineTessellationState read fTessellationState;
       property ViewPortState:TVulkanPipelineViewPortState read fViewPortState;
       property RasterizationState:TVulkanPipelineRasterizationState read fRasterizationState;
       property MultisampleState:TVulkanPipelineMultisampleState read fMultisampleState;
       property DepthStencilState:TVulkanPipelineDepthStencilState read fDepthStencilState;
       property ColorBlendState:TVulkanPipelineColorBlendState read fColorBlendState;
       property DynamicState:TVulkanPipelineDynamicState read fDynamicState;
     end;

     TVulkanGraphicsPipeline=class(TVulkanPipeline)
      private
       fGraphicsPipelineConstructor:TVulkanGraphicsPipelineConstructor;
       function GetCountStages:TVkInt32;
       function GetVertexInputState:TVulkanPipelineVertexInputState;
       function GetInputAssemblyState:TVulkanPipelineInputAssemblyState;
       function GetTessellationState:TVulkanPipelineTessellationState;
       function GetViewPortState:TVulkanPipelineViewPortState;
       function GetRasterizationState:TVulkanPipelineRasterizationState;
       function GetMultisampleState:TVulkanPipelineMultisampleState;
       function GetDepthStencilState:TVulkanPipelineDepthStencilState;
       function GetColorBlendState:TVulkanPipelineColorBlendState;
       function GetDynamicState:TVulkanPipelineDynamicState;
      public
       constructor Create(const aDevice:TVulkanDevice;
                          const aCache:TVulkanPipelineCache;
                          const aFlags:TVkPipelineCreateFlags;
                          const aStages:array of TVulkanPipelineShaderStage;
                          const aLayout:TVulkanPipelineLayout;
                          const aRenderPass:TVulkanRenderPass;
                          const aSubPass:TVkUInt32;
                          const aBasePipelineHandle:TVulkanPipeline;
                          const aBasePipelineIndex:TVkInt32); reintroduce;
       destructor Destroy; override;
       procedure Assign(const aFrom:TVulkanGraphicsPipeline);
       function AddStage(const aStage:TVulkanPipelineShaderStage):TVkInt32;
       function AddStages(const aStages:array of TVulkanPipelineShaderStage):TVkInt32;
       function AddVertexInputBindingDescription(const aVertexInputBindingDescription:TVkVertexInputBindingDescription):TVkInt32; overload;
       function AddVertexInputBindingDescription(const aBinding,aStride:TVkUInt32;const aInputRate:TVkVertexInputRate):TVkInt32; overload;
       function AddVertexInputBindingDescriptions(const aVertexInputBindingDescriptions:array of TVkVertexInputBindingDescription):TVkInt32;
       function AddVertexInputAttributeDescription(const aVertexInputAttributeDescription:TVkVertexInputAttributeDescription):TVkInt32; overload;
       function AddVertexInputAttributeDescription(const aLocation,aBinding:TVkUInt32;const aFormat:TVkFormat;const aOffset:TVkUInt32):TVkInt32; overload;
       function AddVertexInputAttributeDescriptions(const aVertexInputAttributeDescriptions:array of TVkVertexInputAttributeDescription):TVkInt32;
       procedure SetInputAssemblyState(const aTopology:TVkPrimitiveTopology;const aPrimitiveRestartEnable:boolean);
       procedure SetTessellationState(const aPatchControlPoints:TVkUInt32);
       function AddViewPort(const aViewPort:TVkViewport):TVkInt32; overload;
       function AddViewPort(const pX,pY,aWidth,aHeight,aMinDepth,aMaxDepth:TVkFloat):TVkInt32; overload;
       function AddViewPorts(const aViewPorts:array of TVkViewport):TVkInt32; overload;
       function AddScissor(const aScissor:TVkRect2D):TVkInt32; overload;
       function AddScissor(const pX,pY:TVkInt32;const aWidth,aHeight:TVkUInt32):TVkInt32; overload;
       function AddScissors(const aScissors:array of TVkRect2D):TVkInt32; overload;
       procedure SetRasterizationState(const aDepthClampEnable:boolean;
                                       const aRasterizerDiscardEnable:boolean;
                                       const aPolygonMode:TVkPolygonMode;
                                       const aCullMode:TVkCullModeFlags;
                                       const aFrontFace:TVkFrontFace;
                                       const aDepthBiasEnable:boolean;
                                       const aDepthBiasConstantFactor:TVkFloat;
                                       const aDepthBiasClamp:TVkFloat;
                                       const aDepthBiasSlopeFactor:TVkFloat;
                                       const aLineWidth:TVkFloat);
       procedure SetMultisampleState(const aRasterizationSamples:TVkSampleCountFlagBits;
                                     const aSampleShadingEnable:boolean;
                                     const aMinSampleShading:TVkFloat;
                                     const aSampleMask:array of TVkSampleMask;
                                     const aAlphaToCoverageEnable:boolean;
                                     const aAlphaToOneEnable:boolean);
       procedure SetDepthStencilState(const aDepthTestEnable:boolean;
                                      const aDepthWriteEnable:boolean;
                                      const aDepthCompareOp:TVkCompareOp;
                                      const aDepthBoundsTestEnable:boolean;
                                      const aStencilTestEnable:boolean;
                                      const aFront:TVkStencilOpState;
                                      const aBack:TVkStencilOpState;
                                      const aMinDepthBounds:TVkFloat;
                                      const aMaxDepthBounds:TVkFloat);
       procedure SetColorBlendState(const aLogicOpEnable:boolean;
                                    const aLogicOp:TVkLogicOp;
                                    const aBlendConstants:array of TVkFloat);
       function AddColorBlendAttachmentState(const aColorBlendAttachmentState:TVkPipelineColorBlendAttachmentState):TVkInt32; overload;
       function AddColorBlendAttachmentState(const aBlendEnable:boolean;
                                             const aSrcColorBlendFactor:TVkBlendFactor;
                                             const aDstColorBlendFactor:TVkBlendFactor;
                                             const aColorBlendOp:TVkBlendOp;
                                             const aSrcAlphaBlendFactor:TVkBlendFactor;
                                             const aDstAlphaBlendFactor:TVkBlendFactor;
                                             const aAlphaBlendOp:TVkBlendOp;
                                             const aColorWriteMask:TVkColorComponentFlags):TVkInt32; overload;
       function AddColorBlendAttachmentStates(const aColorBlendAttachmentStates:array of TVkPipelineColorBlendAttachmentState):TVkInt32;
       function AddDynamicState(const aDynamicState:TVkDynamicState):TVkInt32;
       function AddDynamicStates(const aDynamicStates:array of TVkDynamicState):TVkInt32;
       procedure Initialize;
       procedure FreeMemory;
      published
       property CountStages:TVkInt32 read GetCountStages;
       property VertexInputState:TVulkanPipelineVertexInputState read GetVertexInputState;
       property InputAssemblyState:TVulkanPipelineInputAssemblyState read GetInputAssemblyState;
       property TessellationState:TVulkanPipelineTessellationState read GetTessellationState;
       property ViewPortState:TVulkanPipelineViewPortState read GetViewPortState;
       property RasterizationState:TVulkanPipelineRasterizationState read GetRasterizationState;
       property MultisampleState:TVulkanPipelineMultisampleState read GetMultisampleState;
       property DepthStencilState:TVulkanPipelineDepthStencilState read GetDepthStencilState;
       property ColorBlendState:TVulkanPipelineColorBlendState read GetColorBlendState;
       property DynamicState:TVulkanPipelineDynamicState read GetDynamicState;
     end;

     TVulkanTextureUsageFlag=
      (
       vtufUndefined,
       vtufGeneral,
       vtufTransferSrc,
       vtufTransferDst,
       vtufSampled,
       vtufStorage,
       vtufColorAttachment,
       vtufPresentation
      );

     TVulkanTextureUsageFlags=set of TVulkanTextureUsageFlag;

     TVulkanTextureWrapMode=
      (
       vtwmRepeat,
       vtwmClampToEdge,
       vtwmClampToBorder
      );

     TVulkanTextureFilterMode=
      (
       vtfmNearest,
       vtfmLinear,
       vtfmBilinear
      );

     TVulkanTextureDefaultType=
      (
       vtdtCheckerboard,
       vtdtPyramids,
       vtdtCircles
      );

     TVulkanTexture=class(TVulkanObject)
      private
       fDevice:TVulkanDevice;
       fFormat:TVkFormat;
       fImageLayout:TVkImageLayout;
       fImage:TVulkanImage;
       fImageView:TVulkanImageView;
       fSampler:TVulkanSampler;
       fDescriptorImageInfo:TVkDescriptorImageInfo;
       fMemoryBlock:TVulkanDeviceMemoryBlock;
       fWidth:TVkInt32;
       fHeight:TVkInt32;
       fDepth:TVkInt32;
       fCountArrayLayers:TVkInt32;
       fCountMipMaps:TVkInt32;
       fSampleCount:TVkSampleCountFlagBits;
       fUsage:TVulkanTextureUsageFlag;
       fUsageFlags:TVulkanTextureUsageFlags;
       fWrapModeU:TVulkanTextureWrapMode;
       fWrapModeV:TVulkanTextureWrapMode;
       fWrapModeW:TVulkanTextureWrapMode;
       fFilterMode:TVulkanTextureFilterMode;
       fBorderColor:TVkBorderColor;
       fMaxAnisotropy:double;
      public
       constructor Create; reintroduce;
       constructor CreateFromMemory(const aDevice:TVulkanDevice;
                                    const aGraphicsQueue:TVulkanQueue;
                                    const aGraphicsCommandBuffer:TVulkanCommandBuffer;
                                    const aGraphicsFence:TVulkanFence;
                                    const aTransferQueue:TVulkanQueue;
                                    const aTransferCommandBuffer:TVulkanCommandBuffer;
                                    const aTransferFence:TVulkanFence;
                                    const aFormat:TVkFormat;
                                    const aSampleCount:TVkSampleCountFlagBits;
                                    const aWidth:TVkInt32;
                                    const aHeight:TVkInt32;
                                    const aDepth:TVkInt32;
                                    const aCountArrayElements:TVkInt32;
                                    const aCountFaces:TVkInt32;
                                    const aCountMipMaps:TVkInt32;
                                    const aUsageFlags:TVulkanTextureUsageFlags;
                                    const aData:TVkPointer;
                                    const aDataSize:TVkSizeInt;
                                    const aMipMapSizeStored:boolean;
                                    const aSwapEndianness:boolean;
                                    const aSwapEndiannessTexels:TVkInt32;
                                    const aFromDDS:boolean=false);
       constructor CreateFromStream(const aDevice:TVulkanDevice;
                                    const aGraphicsQueue:TVulkanQueue;
                                    const aGraphicsCommandBuffer:TVulkanCommandBuffer;
                                    const aGraphicsFence:TVulkanFence;
                                    const aTransferQueue:TVulkanQueue;
                                    const aTransferCommandBuffer:TVulkanCommandBuffer;
                                    const aTransferFence:TVulkanFence;
                                    const aFormat:TVkFormat;
                                    const aSampleCount:TVkSampleCountFlagBits;
                                    const aWidth:TVkInt32;
                                    const aHeight:TVkInt32;
                                    const aDepth:TVkInt32;
                                    const aCountArrayElements:TVkInt32;
                                    const aCountFaces:TVkInt32;
                                    const aCountMipMaps:TVkInt32;
                                    const aUsageFlags:TVulkanTextureUsageFlags;
                                    const aStream:TStream;
                                    const aMipMapSizeStored:boolean;
                                    const aSwapEndianness:boolean;
                                    const aSwapEndiannessTexels:TVkInt32;
                                    const aFromDDS:boolean=false);
       constructor CreateFromKTX(const aDevice:TVulkanDevice;
                                 const aGraphicsQueue:TVulkanQueue;
                                 const aGraphicsCommandBuffer:TVulkanCommandBuffer;
                                 const aGraphicsFence:TVulkanFence;
                                 const aTransferQueue:TVulkanQueue;
                                 const aTransferCommandBuffer:TVulkanCommandBuffer;
                                 const aTransferFence:TVulkanFence;
                                 const aStream:TStream);
       constructor CreateFromDDS(const aDevice:TVulkanDevice;
                                 const aGraphicsQueue:TVulkanQueue;
                                 const aGraphicsCommandBuffer:TVulkanCommandBuffer;
                                 const aGraphicsFence:TVulkanFence;
                                 const aTransferQueue:TVulkanQueue;
                                 const aTransferCommandBuffer:TVulkanCommandBuffer;
                                 const aTransferFence:TVulkanFence;
                                 const aStream:TStream);
       constructor CreateFromHDR(const aDevice:TVulkanDevice;
                                 const aGraphicsQueue:TVulkanQueue;
                                 const aGraphicsCommandBuffer:TVulkanCommandBuffer;
                                 const aGraphicsFence:TVulkanFence;
                                 const aTransferQueue:TVulkanQueue;
                                 const aTransferCommandBuffer:TVulkanCommandBuffer;
                                 const aTransferFence:TVulkanFence;
                                 const aStream:TStream;
                                 const aMipMaps:boolean);
       constructor CreateFromTGA(const aDevice:TVulkanDevice;
                                 const aGraphicsQueue:TVulkanQueue;
                                 const aGraphicsCommandBuffer:TVulkanCommandBuffer;
                                 const aGraphicsFence:TVulkanFence;
                                 const aTransferQueue:TVulkanQueue;
                                 const aTransferCommandBuffer:TVulkanCommandBuffer;
                                 const aTransferFence:TVulkanFence;
                                 const aStream:TStream;
                                 const aMipMaps:boolean);
       constructor CreateFromPNG(const aDevice:TVulkanDevice;
                                 const aGraphicsQueue:TVulkanQueue;
                                 const aGraphicsCommandBuffer:TVulkanCommandBuffer;
                                 const aGraphicsFence:TVulkanFence;
                                 const aTransferQueue:TVulkanQueue;
                                 const aTransferCommandBuffer:TVulkanCommandBuffer;
                                 const aTransferFence:TVulkanFence;
                                 const aStream:TStream;
                                 const aMipMaps:boolean);
       constructor CreateFromJPEG(const aDevice:TVulkanDevice;
                                  const aGraphicsQueue:TVulkanQueue;
                                  const aGraphicsCommandBuffer:TVulkanCommandBuffer;
                                  const aGraphicsFence:TVulkanFence;
                                  const aTransferQueue:TVulkanQueue;
                                  const aTransferCommandBuffer:TVulkanCommandBuffer;
                                  const aTransferFence:TVulkanFence;
                                  const aStream:TStream;
                                  const aMipMaps:boolean);
       constructor CreateFromBMP(const aDevice:TVulkanDevice;
                                 const aGraphicsQueue:TVulkanQueue;
                                 const aGraphicsCommandBuffer:TVulkanCommandBuffer;
                                 const aGraphicsFence:TVulkanFence;
                                 const aTransferQueue:TVulkanQueue;
                                 const aTransferCommandBuffer:TVulkanCommandBuffer;
                                 const aTransferFence:TVulkanFence;
                                 const aStream:TStream;
                                 const aMipMaps:boolean);
       constructor CreateFromImage(const aDevice:TVulkanDevice;
                                   const aGraphicsQueue:TVulkanQueue;
                                   const aGraphicsCommandBuffer:TVulkanCommandBuffer;
                                   const aGraphicsFence:TVulkanFence;
                                   const aTransferQueue:TVulkanQueue;
                                   const aTransferCommandBuffer:TVulkanCommandBuffer;
                                   const aTransferFence:TVulkanFence;
                                   const aStream:TStream;
                                   const aMipMaps:boolean);
       constructor CreateDefault(const aDevice:TVulkanDevice;
                                 const aGraphicsQueue:TVulkanQueue;
                                 const aGraphicsCommandBuffer:TVulkanCommandBuffer;
                                 const aGraphicsFence:TVulkanFence;
                                 const aTransferQueue:TVulkanQueue;
                                 const aTransferCommandBuffer:TVulkanCommandBuffer;
                                 const aTransferFence:TVulkanFence;
                                 const aDefaultType:TVulkanTextureDefaultType;
                                 const aWidth:TVkInt32;
                                 const aHeight:TVkInt32;
                                 const aDepth:TVkInt32;
                                 const aCountArrayElements:TVkInt32;
                                 const aCountFaces:TVkInt32;
                                 const aMipmaps:boolean;
                                 const aBorder:boolean);
       destructor Destroy; override;
       procedure UpdateSampler;
       property DescriptorImageInfo:TVkDescriptorImageInfo read fDescriptorImageInfo;
      published
       property Device:TVulkanDevice read fDevice;
       property Format:TVkFormat read fFormat;
       property ImageLayout:TVkImageLayout read fImageLayout;
       property Image:TVulkanImage read fImage;
       property ImageView:TVulkanImageView read fImageView;
       property Sampler:TVulkanSampler read fSampler;
       property MemoryBlock:TVulkanDeviceMemoryBlock read fMemoryBlock;
       property Width:TVkInt32 read fWidth;
       property Height:TVkInt32 read fHeight;
       property Depth:TVkInt32 read fDepth;
       property CountArrayLayers:TVkInt32 read fCountArrayLayers;
       property CountMipMaps:TVkInt32 read fCountMipMaps;
       property SampleCount:TVkSampleCountFlagBits read fSampleCount;
       property Usage:TVulkanTextureUsageFlag read fUsage;
       property UsageFlags:TVulkanTextureUsageFlags read fUsageFlags;
       property WrapModeU:TVulkanTextureWrapMode read fWrapModeU write fWrapModeU;
       property WrapModeV:TVulkanTextureWrapMode read fWrapModeV write fWrapModeV;
       property WrapModeW:TVulkanTextureWrapMode read fWrapModeW write fWrapModeW;
       property FilterMode:TVulkanTextureFilterMode read fFilterMode write fFilterMode;
       property BorderColor:TVkBorderColor read fBorderColor write fBorderColor;
       property MaxAnisotropy:double read fMaxAnisotropy write fMaxAnisotropy;
     end;

     PVulkanSpritePoint=^TVulkanSpritePoint;
     TVulkanSpritePoint=record
      x:single;
      y:single;
     end;

     PVulkanSpriteRect=^TVulkanSpriteRect;
     TVulkanSpriteRect=packed record
      Left:single;
      Top:single;
      Right:single;
      Bottom:single;
     end;

     PVulkanSpriteColor=^TVulkanSpriteColor;
     TVulkanSpriteColor=record
      r:single;
      g:single;
      b:single;
      a:single;
     end;

     PVulkanSpriteTexturePixel=^TVulkanSpriteTexturePixel;
     TVulkanSpriteTexturePixel=packed record
      r:TVkUInt8;
      g:TVkUInt8;
      b:TVkUInt8;
      a:TVkUInt8;
     end;

     PVulkanSpriteTexturePixels=^TVulkanSpriteTexturePixels;
     TVulkanSpriteTexturePixels=array[0..65535] of TVulkanSpriteTexturePixel;

     TVulkanSpriteTexture=class
      private
       fTexture:TVulkanTexture;
       fWidth:TVkInt32;
       fHeight:TVkInt32;
       fUploaded:boolean;
       fDirty:boolean;
       fPixels:PVulkanSpriteTexturePixels;
      public
       constructor Create(const aPixels:PVulkanSpriteTexturePixels;const aWidth,aHeight:TVkInt32); reintroduce;
       destructor Destroy; override;
       procedure Upload(const aDevice:TVulkanDevice;
                        const aGraphicsQueue:TVulkanQueue;
                        const aGraphicsCommandBuffer:TVulkanCommandBuffer;
                        const aGraphicsFence:TVulkanFence;
                        const aTransferQueue:TVulkanQueue;
                        const aTransferCommandBuffer:TVulkanCommandBuffer;
                        const aTransferFence:TVulkanFence;
                        const aMipMaps:boolean);
       procedure Unload;
      published
       property Texture:TVulkanTexture read fTexture;
       property Width:TVkInt32 read fWidth;
       property Height:TVkInt32 read fHeight;
       property Uploaded:boolean read fUploaded;
       property Dirty:boolean read fDirty write fDirty;
     end;

     PVulkanSpriteFontChar=^TVulkanSpriteFontChar;
     TVulkanSpriteFontChar=record
      TextureRect:TVulkanSpriteRect;
      Advance:TVulkanSpritePoint;
     end;

     PVulkanSpriteFontChars=^TVulkanSpriteFontChars;
     TVulkanSpriteFontChars=array[TVulkanRawByteChar] of TVulkanSpriteFontChar;

     TVulkanSpriteFont=class
      public
       Texture:TVulkanSpriteTexture;
       Chars:TVulkanSpriteFontChars;
       constructor Create; virtual;
       destructor Destroy; override;
     end;

     TVulkanSprite=class
      public
       Texture:TVulkanSpriteTexture;
       Name:TVulkanRawByteString;
       x:TVkInt32;
       y:TVkInt32;
       Width:TVkInt32;
       Height:TVkInt32;
       TrimmedX:TVkInt32;
       TrimmedY:TVkInt32;
       TrimmedWidth:TVkInt32;
       TrimmedHeight:TVkInt32;
       Rotated:boolean;
       constructor Create;
       destructor Destroy; override;
     end;

     TVulkanSprites=array of TVulkanSprite;

     PVulkanSpriteBatchVertex=^TVulkanSpriteBatchVertex;
     TVulkanSpriteBatchVertex=packed record
      Position:TVulkanSpritePoint;
      TextureCoord:TVulkanSpritePoint;
      Color:TVulkanSpriteColor;
     end;

     TVulkanSpriteBatchVertices=array of TVulkanSpriteBatchVertex;
     
     TVulkanSpriteBatchVulkanBuffers=array of TVulkanBuffer;

     PVulkanSpriteBatchVulkanVertexDataBuffer=^TVulkanSpriteBatchVulkanVertexDataBuffer;
     TVulkanSpriteBatchVulkanVertexDataBuffer=array[0..(32768*4)-1] of TVulkanSpriteBatchVertex;

     TVulkanSpriteBatchVulkanVertexDataBuffers=array of TVulkanSpriteBatchVulkanVertexDataBuffer;

     TVulkanSpriteBatchVulkanVertexDataBufferSizes=array of TVkSizeInt;

     PVulkanSpriteBatchRenderingMode=^TVulkanSpriteBatchRenderingMode;
     TVulkanSpriteBatchRenderingMode=
      (
       vsbrmNormal,
       vsbrmFont
      );

     PVulkanSpriteBatchBlendingMode=^TVulkanSpriteBatchBlendingMode;
     TVulkanSpriteBatchBlendingMode=
      (
       vsbbmNone,
       vsbbmAlphaBlending,
       vsbbmAdditiveBlending
      );

     TVulkanSpriteBatchHook=procedure(const aData:TVkPointer) of object;

     PVulkanSpriteBatchQueueItem=^TVulkanSpriteBatchQueueItem;
     TVulkanSpriteBatchQueueItem=record
      BufferIndex:TVkInt32;
      case TVkInt32 of
       0:(
        DescriptorSetIndex:TVkInt32;
        CountVertices:TVkInt32;
        CountIndices:TVkInt32;
        RenderingMode:TVulkanSpriteBatchRenderingMode;
        BlendingMode:TVulkanSpriteBatchBlendingMode;
        Scissor:TVkRect2D;
       );
       1:(
        Hook:TVulkanSpriteBatchHook;
        HookData:pointer;
       );
     end;

     TVulkanSpriteBatchQueueItems=array of TVulkanSpriteBatchQueueItem;

     TVulkanSpriteBatchDescriptorSets=array of TVulkanDescriptorSet;

     TVulkanSpriteBatchGraphicsPipelines=array[TVulkanSpriteBatchRenderingMode,TVulkanSpriteBatchBlendingMode] of TVulkanGraphicsPipeline;

     PVulkanSpriteBatchBuffer=^TVulkanSpriteBatchBuffer;
     TVulkanSpriteBatchBuffer=record
      fSpinLock:TVkInt32;
      fVulkanVertexBuffers:TVulkanSpriteBatchVulkanBuffers;
      fVulkanVertexDataBuffers:TVulkanSpriteBatchVulkanVertexDataBuffers;
      fVulkanVertexDataBufferSizes:TVulkanSpriteBatchVulkanVertexDataBufferSizes;
      fCountVulkanVertexBuffers:TVkInt32;
      fCountUsedVertexBuffers:TVkInt32;
      fQueueItems:TVulkanSpriteBatchQueueItems;
      fCountQueueItems:TVkInt32;
     end;

     TVulkanSpriteBatchBuffers=array of TVulkanSpriteBatchBuffer;

     TVulkanSpriteBatch=class
      private
       fDevice:TVulkanDevice;
       fGraphicsQueue:TVulkanQueue;
       fGraphicsCommandBuffer:TVulkanCommandBuffer;
       fGraphicsFence:TVulkanFence;
       fTransferQueue:TVulkanQueue;
       fTransferCommandBuffer:TVulkanCommandBuffer;
       fTransferFence:TVulkanFence;
       fPipelineCache:TVulkanPipelineCache;
       fFontVertexShaderModule:TVulkanShaderModule;
       fFontFragmentShaderModule:TVulkanShaderModule;
       fSpriteBatchVertexShaderModule:TVulkanShaderModule;
       fSpriteBatchFragmentShaderModule:TVulkanShaderModule;
       fVulkanPipelineFontShaderStageTriangleVertex:TVulkanPipelineShaderStage;
       fVulkanPipelineFontShaderStageTriangleFragment:TVulkanPipelineShaderStage;
       fVulkanPipelineSpriteBatchShaderStageTriangleVertex:TVulkanPipelineShaderStage;
       fVulkanPipelineSpriteBatchShaderStageTriangleFragment:TVulkanPipelineShaderStage;
       fVulkanDescriptorPool:TVulkanDescriptorPool;
       fVulkanDescriptorSetLayout:TVulkanDescriptorSetLayout;
       fVulkanDescriptorSets:TVulkanSpriteBatchDescriptorSets;
       fCountVulkanDescriptorSets:TVkInt32;
       fVulkanTextureDescriptorSetHashMap:TVulkanPointerHashMap;
       fVulkanRenderPass:TVulkanRenderPass;
       fVulkanPipelineLayout:TVulkanPipelineLayout;
       fVulkanGraphicsPipelines:TVulkanSpriteBatchGraphicsPipelines;
       fVulkanIndexBuffer:TVulkanBuffer;
       fVulkanSpriteBatchBuffers:TVulkanSpriteBatchBuffers;
       fCountBuffers:TVkInt32;
       fCurrentFillSpriteBatchBuffer:PVulkanSpriteBatchBuffer;
       fWidth:TVkInt32;
       fHeight:TVkInt32;
       fViewPort:TVkViewport;
       fPointerToViewport:PVkViewport;
       fCurrentVulkanVertexBufferIndex:TVkInt32;
       fVertexBufferCount:TVkSizeInt;
       fVertexBufferSize:TVkSizeInt;
       fIndexBufferCount:TVkSizeInt;
       fIndexBufferSize:TVkSizeInt;
       fRenderingMode:TVulkanSpriteBatchRenderingMode;
       fBlendingMode:TVulkanSpriteBatchBlendingMode;
       fLastTexture:TVulkanSpriteTexture;
       fInverseWidth:single;
       fInverseHeight:single;
       fInverseTextureWidth:single;
       fInverseTextureHeight:single;
       fVertexBufferUsed:TVkSizeInt;
       fIndexBufferUsed:TVkSizeInt;
       fCurrentDestinationVertexDataBuffer:PVulkanSpriteBatchVulkanVertexDataBuffer;
       fScissor:TVkRect2D;
       function RotatePoint(const PointToRotate,AroundPoint:TVulkanSpritePoint;Cosinus,Sinus:single):TVulkanSpritePoint;
       procedure SetTexture(const Texture:TVulkanSpriteTexture);
       procedure SetRenderingMode(aRenderingMode:TVulkanSpriteBatchRenderingMode);
       procedure SetBlendingMode(aBlendingMode:TVulkanSpriteBatchBlendingMode);
       procedure GetNextDestinationVertexBuffer;
      public
       constructor Create(const aDevice:TVulkanDevice;
                          const aGraphicsQueue:TVulkanQueue;
                          const aGraphicsCommandBuffer:TVulkanCommandBuffer;
                          const aGraphicsFence:TVulkanFence;
                          const aTransferQueue:TVulkanQueue;
                          const aTransferCommandBuffer:TVulkanCommandBuffer;
                          const aTransferFence:TVulkanFence;
                          const aPipelineCache:TVulkanPipelineCache;
                          const aRenderPass:TVulkanRenderPass;
                          const aCountBuffers:TVkInt32); reintroduce;
       destructor Destroy; override;
       procedure Start(const aBufferIndex:TVkInt32);
       procedure Stop;
       procedure Flush;
       procedure SetScissor(const aScissor:TVkRect2D); overload;
       procedure SetScissor(const aLeft,aTop,aWidth,aHeight:TVkInt32); overload;
       procedure Hook(const aHook:TVulkanSpriteBatchHook;const aData:TVkPointer); overload;
       procedure Draw(const Texture:TVulkanSpriteTexture;const Src,Dest:TVulkanSpriteRect;const Color:TVulkanSpriteColor); overload;
       procedure Draw(const Texture:TVulkanSpriteTexture;Dest:TVulkanSpriteRect;const Color:TVulkanSpriteColor); overload;
       procedure Draw(const Texture:TVulkanSpriteTexture;const x,y:single;const Color:TVulkanSpriteColor); overload;
       procedure Draw(const Texture:TVulkanSpriteTexture;const x,y:single); overload;
       procedure Draw(const Texture:TVulkanSpriteTexture;const sx1,sy1,sx2,sy2,dx1,dy1,dx2,dy2,Alpha:single); overload;
       procedure Draw(const Texture:TVulkanSpriteTexture;const Src:TVulkanSpriteRect;Dest:TVulkanSpriteRect;const Origin:TVulkanSpritePoint;const Color:TVulkanSpriteColor); overload;
       procedure Draw(const Texture:TVulkanSpriteTexture;const Src,Dest:TVulkanSpriteRect;const Origin:TVulkanSpritePoint;Rotation:single;const Color:TVulkanSpriteColor); overload;
       procedure Draw(const Sprite:TVulkanSprite;const Src,Dest:TVulkanSpriteRect;const Color:TVulkanSpriteColor); overload;
       procedure Draw(const Sprite:TVulkanSprite;const Src,Dest:TVulkanSpriteRect;const Origin:TVulkanSpritePoint;Rotation:single;const Color:TVulkanSpriteColor); overload;
       procedure Draw(const Sprite:TVulkanSprite;const x,y:single;const Color:TVulkanSpriteColor); overload;
       procedure Draw(const Sprite:TVulkanSprite;const x,y:single); overload;
       procedure Draw(const Sprite:TVulkanSprite;const sx1,sy1,sx2,sy2,dx1,dy1,dx2,dy2,Alpha:single); overload;
       procedure DrawText(const Font:TVulkanSpriteFont;const Text:TVulkanRawByteString;x,y:single;const Color:TVulkanSpriteColor);
       procedure ExecuteUpload(const aVulkanCommandBuffer:TVulkanCommandBuffer;const aBufferIndex:TVkInt32);
       procedure ExecuteDraw(const aVulkanCommandBuffer:TVulkanCommandBuffer;const aBufferIndex:TVkInt32);
      public
       property Viewport:PVkViewport read fPointerToViewport;
      published
       property Device:TVulkanDevice read fDevice;
       property Width:TVkInt32 read fWidth write fWidth;
       property Height:TVkInt32 read fHeight write fHeight;
       property RenderingMode:TVulkanSpriteBatchRenderingMode read fRenderingMode write SetRenderingMode;
       property BlendingMode:TVulkanSpriteBatchBlendingMode read fBlendingMode write SetBlendingMode;
     end;

     PVulkanSpriteAtlasTextureRectNode=^TVulkanSpriteAtlasTextureRectNode;
     TVulkanSpriteAtlasTextureRectNode=record
      Left:PVulkanSpriteAtlasTextureRectNode;
      Right:PVulkanSpriteAtlasTextureRectNode;
      x:TVkInt32;
      y:TVkInt32;
      Width:TVkInt32;
      Height:TVkInt32;
      FreeArea:TVkInt32;
      ContentWidth:TVkInt32;
      ContentHeight:TVkInt32;
     end;

     PVulkanSpriteAtlasTexture=^TVulkanSpriteAtlasTexture;
     TVulkanSpriteAtlasTexture=record
      Next:PVulkanSpriteAtlasTexture;
      Texture:TVulkanSpriteTexture;
      Data:TVkPointer;
      Width:TVkInt32;
      Height:TVkInt32;
      Dirty:boolean;
      RootNode:PVulkanSpriteAtlasTextureRectNode;
     end;

     TVulkanSpriteAtlas=class
      private
       fDevice:TVulkanDevice;
       fTextureList:PVulkanSpriteAtlasTexture;
       fList:TList;
       fHashMap:TVulkanStringHashMap;
       fIsUploaded:boolean;
       fMipMaps:boolean;
       fAutomaticTrim:boolean;
       function GetCount:TVkInt32;
       function GetItem(Index:TVkInt32):TVulkanSprite;
       procedure SetItem(Index:TVkInt32;Item:TVulkanSprite);
       function GetSprite(const Name:TVulkanRawByteString):TVulkanSprite;
       procedure AddSprite(Sprite:TVulkanSprite);
       function LoadImage(const aDataPointer:TVkPointer;
                          const aDataSize:TVkSizeInt;
                          var aImageData:TVkPointer;
                          var aImageWidth,aImageHeight:TVkInt32):boolean;
      public
       constructor Create(const aDevice:TVulkanDevice); reintroduce;
       destructor Destroy; override;
       procedure Upload(const aGraphicsQueue:TVulkanQueue;
                        const aGraphicsCommandBuffer:TVulkanCommandBuffer;
                        const aGraphicsFence:TVulkanFence;
                        const aTransferQueue:TVulkanQueue;
                        const aTransferCommandBuffer:TVulkanCommandBuffer;
                        const aTransferFence:TVulkanFence); virtual;
       procedure Unload; virtual;
       function Uploaded:boolean; virtual;
       procedure ClearAll; virtual;
       function LoadXML(const aTextureStream:TStream;const aStream:TStream):boolean; virtual;
       function LoadRawSprite(const Name:TVulkanRawByteString;ImageData:TVkPointer;ImageWidth,ImageHeight:TVkInt32):TVulkanSprite; virtual;
       function LoadSprite(const Name:TVulkanRawByteString;Stream:TStream):TVulkanSprite; virtual;
       function LoadSprites(const Name:TVulkanRawByteString;Stream:TStream;SpriteWidth:TVkInt32=64;SpriteHeight:TVkInt32=64):TVulkanSprites; virtual;
       property Device:TVulkanDevice read fDevice;
       property Count:TVkInt32 read GetCount;
       property Items[Index:TVkInt32]:TVulkanSprite read GetItem write SetItem;
       property Sprites[const Name:TVulkanRawByteString]:TVulkanSprite read GetSprite; default;
      published
       property MipMaps:boolean read fMipMaps write fMipMaps;
       property AutomaticTrim:boolean read fAutomaticTrim write fAutomaticTrim;
     end;

     EVulkanTrueTypeFont=class(Exception);

     TVulkanTrueTypeFont=class;

     TVulkanTrueTypeFontRasterizer=class
      protected
       fLastX:TVkInt32;
       fLastY:TVkInt32;
       function GetCanvas:TVkPointer; virtual;
       procedure SetCanvas(NewCanvas:TVkPointer); virtual;
       function GetWidth:TVkInt32; virtual;
       procedure SetWidth(NewWidth:TVkInt32); virtual;
       function GetHeight:TVkInt32; virtual;
       procedure SetHeight(NewHeight:TVkInt32); virtual;
       function GetWindingRule:TVkInt32; virtual;
       procedure SetWindingRule(NewWindingRule:TVkInt32); virtual;
      public
       constructor Create; virtual;
       destructor Destroy; override;
       procedure Clear; virtual;
       procedure Reset; virtual;
       procedure Resize(NewWidth,NewHeight:TVkInt32); virtual;
       procedure MoveTo(ToX,ToY:TVkInt32); virtual;
       procedure LineTo(ToX,ToY:TVkInt32); virtual;
       procedure QuadraticCurveTo(const ControlX,ControlY,AnchorX,AnchorY:TVkInt32;const Tolerance:TVkInt32=2;const MaxLevel:TVkInt32=32); virtual;
       procedure CubicCurveTo(const c1x,c1y,c2x,c2y,ax,ay:TVkInt32;const Tolerance:TVkInt32=2;const MaxLevel:TVkInt32=32); virtual;
       procedure Close; virtual;
       procedure Render; virtual;
       property Canvas:TVkPointer read GetCanvas write SetCanvas;
       property Width:TVkInt32 read GetWidth write SetWidth;
       property Height:TVkInt32 read GetHeight write SetHeight;
       property WindingRule:TVkInt32 read GetWindingRule write SetWindingRule;
     end;

     TVulkanTrueTypeFontPolygonRasterizerGammaLookUpTable=array[TVkUInt8] of TVkUInt8;

     PVulkanTrueTypeFontPolygonRasterizerCell=^TVulkanTrueTypeFontPolygonRasterizerCell;
     TVulkanTrueTypeFontPolygonRasterizerCell=record
      Previous:PVulkanTrueTypeFontPolygonRasterizerCell;
      Next:PVulkanTrueTypeFontPolygonRasterizerCell;
      x:TVkInt32;
      Area:TVkInt32;
      Cover:TVkInt32;
     end;

     TVulkanTrueTypeFontPolygonRasterizerCells=array of PVulkanTrueTypeFontPolygonRasterizerCell;

     TVulkanTrueTypeFontPolygonRasterizerScanline=record
      CellFirst:PVulkanTrueTypeFontPolygonRasterizerCell;
      CellLast:PVulkanTrueTypeFontPolygonRasterizerCell;
     end;
     TVulkanTrueTypeFontPolygonRasterizerScanlines=array of TVulkanTrueTypeFontPolygonRasterizerScanline;

     TVulkanTrueTypeFontPolygonRasterizer=class(TVulkanTrueTypeFontRasterizer)
      protected
       fCurrentWidth:TVkInt32;
       fCurrentHeight:TVkInt32;
       fCurrentGamma:TVkDouble;
       fCurrentWindingRule:TVkInt32;
       fCurrentGammaLookUpTable:TVulkanTrueTypeFontPolygonRasterizerGammaLookUpTable;
       fCellX:TVkInt32;
       fCellY:TVkInt32;
       fArea:TVkInt32;
       fCover:TVkInt32;
       fCells:TVulkanTrueTypeFontPolygonRasterizerCells;
       fNumCells:TVkInt32;
       fX:TVkInt32;
       fY:TVkInt32;
       fMoveToX:TVkInt32;
       fMoveToY:TVkInt32;
       fScanlines:TVulkanTrueTypeFontPolygonRasterizerScanlines;
       fRenderMinY:TVkInt32;
       fRenderMaxY:TVkInt32;
       fNeedToClose:boolean;
       fCanvas:TVkPointer;
       fAntialiasing:boolean;
       fForceNonAntialiasing:boolean;
       function GetCanvas:TVkPointer; override;
       procedure SetCanvas(NewCanvas:TVkPointer); override;
       function GetWidth:TVkInt32; override;
       procedure SetWidth(NewWidth:TVkInt32); override;
       function GetHeight:TVkInt32; override;
       procedure SetHeight(NewHeight:TVkInt32); override;
       function GetWindingRule:TVkInt32; override;
       procedure SetWindingRule(NewWindingRule:TVkInt32); override;
       function NewCell:PVulkanTrueTypeFontPolygonRasterizerCell;
       procedure RecordCell;
       procedure SetCell(NewX,NewY:TVkInt32;Force:boolean=false);
       procedure StartCell(NewX,NewY:TVkInt32);
       procedure RenderScanLine(NewY,x1,y1,x2,y2:TVkInt32);
       procedure RenderLine(ToX,ToY:TVkInt32);
       procedure ProcessSpan(x,y,Area,Len:TVkInt32);
       procedure MakeScanLineSpansAndRenderThese;
       procedure SetGamma(AGamma:TVkDouble);
       procedure RenderSpanCoverage(y,x,Len,Coverage:TVkInt32); virtual;
      public
       constructor Create; override;
       destructor Destroy; override;
       procedure Clear; override;
       procedure Reset; override;
       procedure Resize(NewWidth,NewHeight:TVkInt32); override;
       procedure MoveTo(ToX,ToY:TVkInt32); override;
       procedure LineTo(ToX,ToY:TVkInt32); override;
       procedure Close; override;
       procedure Render; override;
       property Gamma:TVkDouble read fCurrentGamma write SetGamma;
       property GammaLookUpTable:TVulkanTrueTypeFontPolygonRasterizerGammaLookUpTable read fCurrentGammaLookUpTable write fCurrentGammaLookUpTable;
       property Antialiasing:boolean read fAntialiasing write fAntialiasing;
     end;

     TVulkanTrueTypeFontStrokeRasterizerPoint=record
      x:TVkInt32;
      y:TVkInt32;
      d:TVkInt32;
     end;

     TVulkanTrueTypeFontStrokeRasterizerPoints=array of TVulkanTrueTypeFontStrokeRasterizerPoint;

     TVulkanTrueTypeFontStrokeRasterizer=class(TVulkanTrueTypeFontRasterizer)
      private
       fLinePoints:TVulkanTrueTypeFontStrokeRasterizerPoints;
       fNumLinePoints:TVkInt32;
       fLineWidth:TVkDouble;
       fLineCapMode:TVkInt32;
       fLineJoinMode:TVkInt32;
       fLineInnerJoinMode:TVkInt32;
       fLineStrokePattern:TVulkanRawByteString;
       fLineStrokePatternStepSize:TVkDouble;
       fStartLineX:TVkInt32;
       fStartLineY:TVkInt32;
       fFlushLineOnWork:boolean;
       fRasterizer:TVulkanTrueTypeFontRasterizer;
       procedure AddLinePoint(const x,y:TVkInt32);
       procedure ConvertLineStorkeToPolygon;
       procedure FlushLine;
      protected
       function GetCanvas:TVkPointer; override;
       procedure SetCanvas(NewCanvas:TVkPointer); override;
       function GetWidth:TVkInt32; override;
       procedure SetWidth(NewWidth:TVkInt32); override;
       function GetHeight:TVkInt32; override;
       procedure SetHeight(NewHeight:TVkInt32); override;
       function GetWindingRule:TVkInt32; override;
       procedure SetWindingRule(NewWindingRule:TVkInt32); override;
      public
       constructor Create(Rasterizer:TVulkanTrueTypeFontRasterizer); reintroduce;
       destructor Destroy; override;
       procedure Clear; override;
       procedure Reset; override;
       procedure Resize(NewWidth,NewHeight:TVkInt32); override;
       procedure MoveTo(ToX,ToY:TVkInt32); override;
       procedure LineTo(ToX,ToY:TVkInt32); override;
       procedure Close; override;
       procedure Render; override;
       property LineWidth:TVkDouble read fLineWidth write fLineWidth;
       property LineCapMode:TVkInt32 read fLineCapMode write fLineCapMode;
       property LineJoinMode:TVkInt32 read fLineJoinMode write fLineJoinMode;
       property LineInnerJoinMode:TVkInt32 read fLineInnerJoinMode write fLineInnerJoinMode;
       property LineStrokePattern:TVulkanRawByteString read fLineStrokePattern write fLineStrokePattern;
       property LineStrokePatternStepSize:TVkDouble read fLineStrokePatternStepSize write fLineStrokePatternStepSize;
     end;

     PVulkanTrueTypeFontKerningPair=^TVulkanTrueTypeFontKerningPair;
     TVulkanTrueTypeFontKerningPair=record
      Left:TVkUInt32;
      Right:TVkUInt32;
      Value:TVkInt32;
     end;

     TVulkanTrueTypeFontKerningPairs=array of TVulkanTrueTypeFontKerningPair;

     PVulkanTrueTypeFontKerningTable=^TVulkanTrueTypeFontKerningTable;
     TVulkanTrueTypeFontKerningTable=record
      Horizontal:longbool;
      Minimum:longbool;
      XStream:longbool;
      ValueOverride:longbool;
      BinarySearch:longbool;
      KerningPairs:TVulkanTrueTypeFontKerningPairs;
      CountKerningPairs:TVkInt32;
     end;

     TVulkanTrueTypeFontKerningTables=array of TVulkanTrueTypeFontKerningTable;

     PVulkanTrueTypeFontGlyphPoint=^TVulkanTrueTypeFontGlyphPoint;
     TVulkanTrueTypeFontGlyphPoint=record
      x:TVkInt32;
      y:TVkInt32;
      Flags:TVkUInt32;
     end;
     TVulkanTrueTypeFontGlyphPoints=array of TVulkanTrueTypeFontGlyphPoint;

     TVulkanTrueTypeFontContour=record
      Points:TVulkanTrueTypeFontGlyphPoints;
     end;
     TVulkanTrueTypeFontContours=array of TVulkanTrueTypeFontContour;

     PVulkanTrueTypeFontGlyphCompositeSubGlyph=^TVulkanTrueTypeFontGlyphCompositeSubGlyph;
     TVulkanTrueTypeFontGlyphCompositeSubGlyph=record
      Glyph:TVkUInt32;
      Flags:TVkUInt32;
      Arg1:TVkInt32;
      Arg2:TVkInt32;
      xx:TVkInt32;
      yx:TVkInt32;
      xy:TVkInt32;
      yy:TVkInt32;
     end;

     TVulkanTrueTypeFontGlyphCompositeSubGlyphs=array of TVulkanTrueTypeFontGlyphCompositeSubGlyph;

     PVulkanTrueTypeFontGlyphBounds=^TVulkanTrueTypeFontGlyphBounds;
     TVulkanTrueTypeFontGlyphBounds=record
      XMin:TVkInt16;
      YMin:TVkInt16;
      XMax:TVkInt16;
      YMax:TVkInt16;
     end;

     TVulkanTrueTypeFontGlyphEndPointIndices=array of TVkInt32;

     PVulkanTrueTypeFontGlyphBuffer=^TVulkanTrueTypeFontGlyphBuffer;
     TVulkanTrueTypeFontGlyphBuffer=record
      Bounds:TVulkanTrueTypeFontGlyphBounds;
      Points:TVulkanTrueTypeFontGlyphPoints;
      UnhintedPoints:TVulkanTrueTypeFontGlyphPoints;
      InFontUnitsPoints:TVulkanTrueTypeFontGlyphPoints;
      EndPointIndices:TVulkanTrueTypeFontGlyphEndPointIndices;
      CountPoints:TVkInt32;
      CountIndices:TVkInt32;
     end;

     PVulkanTrueTypeFontByteArray=^TVulkanTrueTypeFontByteArray;
     TVulkanTrueTypeFontByteArray=array[0..65535] of TVkUInt8;

     PVulkanTrueTypeFontByteCodeInterpreterProgramBytes=^TVulkanTrueTypeFontByteCodeInterpreterProgramBytes;
     TVulkanTrueTypeFontByteCodeInterpreterProgramBytes=record
      Data:PVulkanTrueTypeFontByteArray;
      Size:TVkInt32;
     end;

     PVulkanTrueTypeFontGlyph=^TVulkanTrueTypeFontGlyph;
     TVulkanTrueTypeFontGlyph=record
      Bounds:TVulkanTrueTypeFontGlyphBounds;
      Points:TVulkanTrueTypeFontGlyphPoints;
      EndPointIndices:TVulkanTrueTypeFontGlyphEndPointIndices;
      CompositeSubGlyphs:TVulkanTrueTypeFontGlyphCompositeSubGlyphs;
      UseMetricsFrom:TVkInt32;
      Instructions:TVulkanTrueTypeFontByteCodeInterpreterProgramBytes;
      Locked:longbool;
      AdvanceWidth:TVkInt32;
      AdvanceHeight:TVkInt32;
      LeftSideBearing:TVkInt32;
      TopSideBearing:TVkInt32;
     end;

     TVulkanTrueTypeFontGlyphs=array of TVulkanTrueTypeFontGlyph;

     TVulkanTrueTypeFontCVTTable=array of TVkInt32;

     TVulkanTrueTypeFontBytes=array of TVkUInt8;

     TVulkanTrueTypeFontLongWords=array of TVkUInt32;

     TVulkanTrueTypeFontGlyphIndexSubHeaderKeys=array[0..255] of TVkUInt16;

     TVulkanTrueTypeFontPolygonCommandType=
      (
       VkTTF_PolygonCommandType_MOVETO,
       VkTTF_PolygonCommandType_LINETO,
       VkTTF_PolygonCommandType_QUADRATICCURVETO,
       VkTTF_PolygonCommandType_CUBICCURVETO,
       VkTTF_PolygonCommandType_CLOSE
      );

     TVulkanTrueTypeFontPolygonCommandPoint=packed record
      x:TVkInt32;
      y:TVkInt32;
     end;

     TVulkanTrueTypeFontPolygonCommandPoints=array[0..2] of TVulkanTrueTypeFontPolygonCommandPoint;

     PVulkanTrueTypeFontPolygonCommand=^TVulkanTrueTypeFontPolygonCommand;
     TVulkanTrueTypeFontPolygonCommand=record
      CommandType:TVulkanTrueTypeFontPolygonCommandType;
      Points:TVulkanTrueTypeFontPolygonCommandPoints;
     end;

     TVulkanTrueTypeFontPolygonCommands=array of TVulkanTrueTypeFontPolygonCommand;

     TVulkanTrueTypeFontPolygon=record
      Commands:TVulkanTrueTypeFontPolygonCommands;
     end;

     PVulkanTrueTypeFontPolygonBuffer=^TVulkanTrueTypeFontPolygonBuffer;
     TVulkanTrueTypeFontPolygonBuffer=record
      Commands:TVulkanTrueTypeFontPolygonCommands;
      CountCommands:TVkInt32;
     end;

     TVulkanTrueTypeFontPolygonBuffers=array of TVulkanTrueTypeFontPolygonBuffer;

     PVulkanTrueTypeFontGASPRange=^TVulkanTrueTypeFontGASPRange;
     TVulkanTrueTypeFontGASPRange=record
      LowerPPEM:TVkInt32;
      UpperPPEM:TVkInt32;
      Flags:TVkUInt32;
     end;

     TVulkanTrueTypeFontGASPRanges=array of TVulkanTrueTypeFontGASPRange;

     TVulkanTrueTypeFontGlyphFlagBitmap=array of TVkUInt32;

     PVulkanTrueTypeFont2d14=^TVulkanTrueTypeFontVector2d14;
     TVulkanTrueTypeFont2d14=TVkInt16;

     PVulkanTrueTypeFont26d6=^TVulkanTrueTypeFontVector26d6;
     TVulkanTrueTypeFont26d6=TVkInt32;

     PVulkanTrueTypeFontVector2d14=^TVulkanTrueTypeFontVector2d14;
     TVulkanTrueTypeFontVector2d14=array[0..1] of TVulkanTrueTypeFont2d14;

     PVulkanTrueTypeFontVector26d6=^TVulkanTrueTypeFontVector26d6;
     TVulkanTrueTypeFontVector26d6=array[0..1] of TVulkanTrueTypeFont26d6;

     PVulkanTrueTypeFontVectorThreeInt32=^TVulkanTrueTypeFontVectorThreeInt32;
     TVulkanTrueTypeFontVectorThreeInt32=array[0..2] of TVkInt32;

     PVulkanTrueTypeFontGraphicsState=^TVulkanTrueTypeFontGraphicsState;
     TVulkanTrueTypeFontGraphicsState=record
      pv:TVulkanTrueTypeFontVector2d14;
      fv:TVulkanTrueTypeFontVector2d14;
      dv:TVulkanTrueTypeFontVector2d14;
      rp:TVulkanTrueTypeFontVectorThreeInt32;
      zp:TVulkanTrueTypeFontVectorThreeInt32;
      ControlValueCutIn:TVulkanTrueTypeFont26d6;
      SingleWidthCutIn:TVulkanTrueTypeFont26d6;
      SingleWidth:TVulkanTrueTypeFont26d6;
      DeltaBase:TVkInt32;
      DeltaShift:TVkInt32;
      MinDist:TVulkanTrueTypeFont26d6;
      Loop:TVkInt32;
      RoundPeriod:TVulkanTrueTypeFont26d6;
      RoundPhase:TVulkanTrueTypeFont26d6;
      RoundThreshold:TVulkanTrueTypeFont26d6;
      RoundSuper45:boolean;
      AutoFlip:boolean;
      InstructionControl:TVkInt32;
     end;

     TVulkanTrueTypeFontByteCodeInterpreterInt32Array=array of TVkInt32;

     TVulkanTrueTypeFontByteCodeInterpreterPoints=array[0..VkTTF_Zone_Count-1,0..VkTTF_PointType_Count-1] of TVulkanTrueTypeFontGlyphPoints;

     PVulkanTrueTypeFontByteCodeInterpreterCallStackEntry=^TVulkanTrueTypeFontByteCodeInterpreterCallStackEntry;
     TVulkanTrueTypeFontByteCodeInterpreterCallStackEntry=record
       ProgramBytes:TVulkanTrueTypeFontByteCodeInterpreterProgramBytes;
       PC:TVkInt32;
       LoopCount:TVkInt32;
     end;

     PVulkanTrueTypeFontByteCodeInterpreterCallStackEntries=^TVulkanTrueTypeFontByteCodeInterpreterCallStackEntries;
     TVulkanTrueTypeFontByteCodeInterpreterCallStackEntries=array[0..31] of TVulkanTrueTypeFontByteCodeInterpreterCallStackEntry;

     TVulkanTrueTypeFontByteCodeInterpreterFunctions=array of TVulkanTrueTypeFontByteCodeInterpreterProgramBytes;

     PVulkanTrueTypeFontByteCodeInterpreterParameters=^TVulkanTrueTypeFontByteCodeInterpreterParameters;
     TVulkanTrueTypeFontByteCodeInterpreterParameters=record
      pCurrent:TVulkanTrueTypeFontGlyphPoints;
      pUnhinted:TVulkanTrueTypeFontGlyphPoints;
      pInFontUnits:TVulkanTrueTypeFontGlyphPoints;
      Ends:TVulkanTrueTypeFontGlyphEndPointIndices;
     end;

     TVulkanTrueTypeFontByteCodeInterpreter=class
      private
       fFont:TVulkanTrueTypeFont;
{$ifdef ttfdebug}
       fLastCVT:TVulkanTrueTypeFontByteCodeInterpreterInt32Array;
       fLastStack:TVulkanTrueTypeFontByteCodeInterpreterInt32Array;
       fLastStorage:TVulkanTrueTypeFontByteCodeInterpreterInt32Array;
       fLastGraphicsState:TVulkanTrueTypeFontGraphicsState;
       fLastPoints:TVulkanTrueTypeFontByteCodeInterpreterPoints;
{$endif}
       fCVT:TVulkanTrueTypeFontByteCodeInterpreterInt32Array;
       fStack:TVulkanTrueTypeFontByteCodeInterpreterInt32Array;
       fStorage:TVulkanTrueTypeFontByteCodeInterpreterInt32Array;
       fFunctions:TVulkanTrueTypeFontByteCodeInterpreterFunctions;
       fScale:TVkInt32;
       fForceReinitialize:longbool;
       fGraphicsState:TVulkanTrueTypeFontGraphicsState;
       fDefaultGraphicsState:TVulkanTrueTypeFontGraphicsState;
       fPoints:TVulkanTrueTypeFontByteCodeInterpreterPoints;
       fEnds:TVulkanTrueTypeFontGlyphEndPointIndices;
      public
       constructor Create(AFont:TVulkanTrueTypeFont);
       destructor Destroy; override;
       procedure Reinitialize;
       function SkipInstructionPayload(const ProgramBytes:TVulkanTrueTypeFontByteCodeInterpreterProgramBytes;var PC:TVkInt32):boolean;
       function MulDiv(a,b,c:TVkInt32;DoRound:boolean):TVkInt32;
       procedure MovePoint(var p:TVulkanTrueTypeFontGlyphPoint;Distance:TVkInt32;Touch:boolean);
       function DotProduct(x,y:TVulkanTrueTypeFont26d6;const q:TVulkanTrueTypeFontVector2d14):TVulkanTrueTypeFont26d6;
       function Div18d14(a,b:TVulkanTrueTypeFont26d6):TVulkanTrueTypeFont26d6;
       function Mul18d14(a,b:TVulkanTrueTypeFont26d6):TVulkanTrueTypeFont26d6;
       function Div26d6(a,b:TVulkanTrueTypeFont26d6):TVulkanTrueTypeFont26d6;
       function Mul26d6(a,b:TVulkanTrueTypeFont26d6):TVulkanTrueTypeFont26d6;
       function RoundValue(Value:TVulkanTrueTypeFont26d6):TVulkanTrueTypeFont26d6;
       procedure IUPInterpolate(IUPY:boolean;p1,p2,ref1,ref2:TVkInt32);
       procedure IUPShift(IUPY:boolean;p1,p2,p:TVkInt32);
       function GetPoint(ZonePointer,PointType,Index:TVkInt32):PVulkanTrueTypeFontGlyphPoint;
       procedure Normalize(var x,y:TVulkanTrueTypeFont26d6);
       function GetCVT(Index:TVkInt32):TVkInt32;
       procedure SetCVT(Index,Value:TVkInt32);
       procedure ComputePointDisplacement(Flag:boolean;var Zone,Ref:TVkInt32;var dx,dy:TVulkanTrueTypeFont26d6);
       procedure Run(ProgramBytes:TVulkanTrueTypeFontByteCodeInterpreterProgramBytes;Parameters:PVulkanTrueTypeFontByteCodeInterpreterParameters=nil);
       property Font:TVulkanTrueTypeFont read fFont;
     end;

     TVulkanTrueTypeFont=class
      private
       fGlyphBuffer:TVulkanTrueTypeFontGlyphBuffer;
       fPolygonBuffer:TVulkanTrueTypeFontPolygonBuffer;
       fFontData:TVulkanTrueTypeFontBytes;
       fGlyphLoadedBitmap:TVulkanTrueTypeFontGlyphFlagBitmap;
       fGlyphs:TVulkanTrueTypeFontGlyphs;
       fCMaps:array[0..1] of PVulkanTrueTypeFontByteArray;
       fCMapLengths:array[0..1] of TVkInt32;
       fGlyphOffsetArray:TVulkanTrueTypeFontLongWords;
       fKerningTables:TVulkanTrueTypeFontKerningTables;
       fSubHeaderKeys:TVulkanTrueTypeFontGlyphIndexSubHeaderKeys;
       fFontDataSize:TVkInt32;
       fGlyfOffset:TVkUInt32;
       fNumfHMetrics:TVkUInt16;
       fNumfVMetrics:TVkUInt16;
       fNumTables:TVkUInt16;
       fCMapFormat:TVkUInt16;
       fLastError:TVkUInt16;
       fPostScriptFlavored:boolean;
       fIndexToLocationFormat:TVkInt16;
       fStringCopyright:TVulkanRawByteString;
       fStringFamily:TVulkanRawByteString;
       fStringSubFamily:TVulkanRawByteString;
       fStringFullName:TVulkanRawByteString;
       fStringUniqueID:TVulkanRawByteString;
       fStringVersion:TVulkanRawByteString;
       fStringPostScript:TVulkanRawByteString;
       fStringTrademark:TVulkanRawByteString;
       fMinX:TVkInt16;
       fMinY:TVkInt16;
       fMaxX:TVkInt16;
       fMaxY:TVkInt16;
       fUnitsPerEm:TVkUInt16;
       fUnitsPerPixel:TVkUInt16;
       fThinBoldStrength:TVkInt32;
       fAscender:TVkUInt16;
       fDescender:TVkUInt16;
       fLineGap:TVkUInt16;
       fAdvanceWidthMax:TVkUInt16;
       fAdvanceHeightMax:TVkUInt16;
       fPlatformID:TVkUInt16;
       fSpecificID:TVkUInt16;
       fLanguageID:TVkUInt16;
       fSize:TVkInt32;
       fLetterSpacingX:TVkInt32;
       fLetterSpacingY:TVkInt32;
       fStyleIndex:TVkInt32;
       fTargetPPI:TVkInt32;
       fHinting:boolean;
       fForceSelector:boolean;
       fCountGlyphs:TVkInt32;
       fMaxTwilightPoints:TVkInt32;
       fMaxStorage:TVkInt32;
       fMaxFunctionDefs:TVkInt32;
       fMaxStackElements:TVkInt32;
       fCVT:TVulkanTrueTypeFontCVTTable;
       fFPGM:TVulkanTrueTypeFontByteCodeInterpreterProgramBytes;
       fPREP:TVulkanTrueTypeFontByteCodeInterpreterProgramBytes;
       fByteCodeInterpreter:TVulkanTrueTypeFontByteCodeInterpreter;
       fByteCodeInterpreterParameters:TVulkanTrueTypeFontByteCodeInterpreterParameters;
       fIgnoreByteCodeInterpreter:boolean;
       fGASPRanges:TVulkanTrueTypeFontGASPRanges;
       function ReadFontData(Stream:TStream;CollectionIndex:TVkInt32):TVkInt32;
       function GetTableDirEntry(Tag:TVkUInt32;var CheckSum,Offset,Size:TVkUInt32):TVkInt32;
       function LoadOS2:TVkInt32;
       function LoadHEAD:TVkInt32;
       function LoadMAXP:TVkInt32;
       function LoadNAME:TVkInt32;
       function LoadCFF:TVkInt32;
       function LoadLOCA:TVkInt32;
       function LoadGLYF:TVkInt32;
       function LoadHHEA:TVkInt32;
       function LoadHMTX:TVkInt32;
       function LoadVHEA:TVkInt32;
       function LoadVMTX:TVkInt32;
       function LoadGPOS:TVkInt32;
       function LoadKERN:TVkInt32;
       function LoadCMAP:TVkInt32;
       function LoadCVT:TVkInt32;
       function LoadFPGM:TVkInt32;
       function LoadPREP:TVkInt32;
       function LoadGASP:TVkInt32;
       function LoadGlyphData(GlyphIndex:TVkInt32):TVkInt32;
       procedure SetSize(NewSize:TVkInt32);
      public
       constructor Create(const Stream:TStream;const TargetPPI:TVkInt32=96;const ForceSelector:boolean=false;const PlatformID:TVkUInt16=VkTTF_PID_Microsoft;const SpecificID:TVkUInt16=VkTTF_SID_MS_UNICODE_CS;const LanguageID:TVkUInt16=VkTTF_LID_MS_USEnglish;const CollectionIndex:TVkInt32=0);
       destructor Destroy; override;
       function GetGASPRange:PVulkanTrueTypeFontGASPRange;
       function GetGlyphIndex(CharCode:TVkUInt32;CMapIndex:TVkInt32=0):TVkUInt32;
       function GetGlyphAdvanceWidth(GlyphIndex:TVkInt32):TVkInt32;
       function GetGlyphAdvanceHeight(GlyphIndex:TVkInt32):TVkInt32;
       function GetGlyphLeftSideBearing(GlyphIndex:TVkInt32):TVkInt32;
       function GetGlyphRightSideBearing(GlyphIndex:TVkInt32):TVkInt32;
       function GetGlyphTopSideBearing(GlyphIndex:TVkInt32):TVkInt32;
       function GetGlyphBottomSideBearing(GlyphIndex:TVkInt32):TVkInt32;
       function GetKerning(Left,Right:TVkUInt32;Horizontal:boolean):TVkInt32;
       function GetStyleIndex(Thin,Bold,Italic:boolean):TVkInt32;
       function TextWidth(const Text:UTF8String):TVkInt32;
       function TextHeight(const Text:UTF8String):TVkInt32;
       function RowHeight(const Percent:TVkInt32):TVkInt32;
       function GetUnitsPerEm:TVkInt32;
       function GetScaleFactor:TVkDouble;
       function GetScaleFactorFixed:TVkInt32;
       function Scale(Value:TVkInt32):TVkInt32;
       function GetScale:TVkInt32;
       function ScaleRound(Value:TVkInt32):TVkInt32;
       procedure ResetGlyphBuffer(var GlyphBuffer:TVulkanTrueTypeFontGlyphBuffer);
       procedure TransformGlyphBuffer(var GlyphBuffer:TVulkanTrueTypeFontGlyphBuffer;GlyphStartPointIndex,StartIndex,EndIndex:TVkInt32);
       procedure FillGlyphBuffer(var GlyphBuffer:TVulkanTrueTypeFontGlyphBuffer;const GlyphIndex:TVkInt32);
       procedure ResetPolygonBuffer(var PolygonBuffer:TVulkanTrueTypeFontPolygonBuffer);
       procedure FillPolygonBuffer(var PolygonBuffer:TVulkanTrueTypeFontPolygonBuffer;const GlyphBuffer:TVulkanTrueTypeFontGlyphBuffer);
       procedure FillTextPolygonBuffer(var PolygonBuffer:TVulkanTrueTypeFontPolygonBuffer;const Text:UTF8String;const StartX:TVkInt32=0;const StartY:TVkInt32=0);
       procedure GetPolygonBufferBounds(const PolygonBuffer:TVulkanTrueTypeFontPolygonBuffer;out x0,y0,x1,y1:TVkInt32;const Tolerance:TVkInt32=2;const MaxLevel:TVkInt32=32);
       procedure DrawPolygonBuffer(Rasterizer:TVulkanTrueTypeFontRasterizer;const PolygonBuffer:TVulkanTrueTypeFontPolygonBuffer;x,y:TVkInt32;Tolerance:TVkInt32=2;MaxLevel:TVkInt32=32);
       property Glyphs:TVulkanTrueTypeFontGlyphs read fGlyphs;
       property CountGlyphs:TVkInt32 read fCountGlyphs;
       property Size:TVkInt32 read fSize write SetSize;
       property LetterSpacingX:TVkInt32 read fLetterSpacingX write fLetterSpacingX;
       property LetterSpacingY:TVkInt32 read fLetterSpacingY write fLetterSpacingY;
       property StyleIndex:TVkInt32 read fStyleIndex write fStyleIndex;
       property Hinting:boolean read fHinting write fHinting;
       property GASPRanges:TVulkanTrueTypeFontGASPRanges read fGASPRanges;
       property MinX:TVkInt16 read fMinX;
       property MinY:TVkInt16 read fMinY;
       property MaxX:TVkInt16 read fMaxX;
       property MaxY:TVkInt16 read fMaxY;
       property Copyright:TVulkanRawByteString read fStringCopyright;
       property Family:TVulkanRawByteString read fStringFamily;
       property SubFamily:TVulkanRawByteString read fStringSubFamily;
       property FullName:TVulkanRawByteString read fStringFullName;
       property UniqueID:TVulkanRawByteString read fStringUniqueID;
       property Version:TVulkanRawByteString read fStringVersion;
       property PostScript:TVulkanRawByteString read fStringPostScript;
       property Trademark:TVulkanRawByteString read fStringTrademark;
     end;

     TVulkanFontCodePointBitmap=array of TVkUInt32;

     PVulkanFontCharacterRange=^TVulkanFontCharacterRange;
     TVulkanFontCharacterRange=set of AnsiChar;

     PVulkanFontCodePointRange=^TVulkanFontCodePointRange;
     TVulkanFontCodePointRange=record
      FromCodePoint:TVkUInt32;
      ToCodePoint:TVkUInt32;
     end;

     TVulkanFontCodePointRanges=array of TVulkanFontCodePointRange;

     PVulkanFontGlyph=^TVulkanFontGlyph;
     TVulkanFontGlyph=record
      AdvanceWidth:TVkFloat;
      AdvanceHeight:TVkFloat;
      LeftSideBearing:TVkFloat;
      RightSideBearing:TVkFloat;
      TopSideBearing:TVkFloat;
      BottomSideBearing:TVkFloat;
      BoundsMinX:TVkFloat;
      BoundsMinY:TVkFloat;
      BoundsMaxX:TVkFloat;
      BoundsMaxY:TVkFloat;
      OffsetX:TVkFloat;
      OffsetY:TVkFloat;
      Width:TVkInt32;
      Height:TVkInt32;
      Sprite:TVulkanSprite;
     end;

     TPVulkanFontGlyphs=array of PVulkanFontGlyph;

     TVulkanFontGlyphs=array of TVulkanFontGlyph;

     PVulkanFontCodePointGlyphPair=^TVulkanFontCodePointGlyphPair;
     TVulkanFontCodePointGlyphPair=record
      CodePoint:TVkUInt32;
      Glyph:TVkInt32;
     end;

     TVulkanFontCodePointGlyphPairs=array of TVulkanFontCodePointGlyphPair;

     PVulkanFontKerningPair=^TVulkanFontKerningPair;
     TVulkanFontKerningPair=record
      Left:TVkUInt32;
      Right:TVkUInt32;
      Horizontal:TVkInt32;
      Vertical:TVkInt32;
     end;

     TVulkanFontKerningPairs=array of TVulkanFontKerningPair;

     PVulkanFontDistanceFieldPixel=^TVulkanFontDistanceFieldPixel;
     TVulkanFontDistanceFieldPixel=packed record
      r,g,b,a:byte;
     end;

     TVulkanFontDistanceFieldPixels=array of TVulkanFontDistanceFieldPixel;

     PVulkanFontDistanceField=^TVulkanFontDistanceField;
     TVulkanFontDistanceField=record
      OffsetX:TVkDouble;
      OffsetY:TVkDouble;
      Width:TVkInt32;
      Height:TVkInt32;
      Pixels:TVulkanFontDistanceFieldPixels;
     end;

     TVulkanFontDistanceFields=array of TVulkanFontDistanceField;

     PVulkanFontDistanceFieldJob=^TVulkanFontDistanceFieldJob;
     TVulkanFontDistanceFieldJob=record
      DistanceField:PVulkanFontDistanceField;
      MultiChannel:boolean;
      PolygonBuffer:TVulkanTrueTypeFontPolygonBuffer;
     end;

     TVulkanFontDistanceFieldJobs=array of TVulkanFontDistanceFieldJob;

     TVulkanFont=class(TVulkanSpriteAtlas)
      private
       fTargetPPI:TVkInt32;
       fUnitsPerEm:TVkInt32;
       fBaseScaleFactor:TVkFloat;
       fInverseBaseScaleFactor:TVkFloat;
       fMinX:TVkFloat;
       fMinY:TVkFloat;
       fMaxX:TVkFloat;
       fMaxY:TVkFloat;
       fMinimumCodePoint:TVkUInt32;
       fMaximumCodePoint:TVkUInt32;
       fCodePointBitmap:TVulkanFontCodePointBitmap;
       fGlyphs:TVulkanFontGlyphs;
       fCodePointGlyphPairs:TVulkanFontCodePointGlyphPairs;
       fKerningPairs:TVulkanFontKerningPairs;
       fCodePointToGlyphHashMap:TVulkanInt64HashMap;
       fKerningPairHashMap:TVulkanInt64HashMap;
{$ifdef PasVulkanPasMP}
       fDistanceFieldJobs:TVulkanFontDistanceFieldJobs;
{$endif}
       procedure GenerateSignedDistanceField(var DistanceField:TVulkanFontDistanceField;const MultiChannel:boolean;const PolygonBuffer:TVulkanTrueTypeFontPolygonBuffer);
{$ifdef PasVulkanPasMP}
       procedure GenerateSignedDistanceFieldParallelForJobFunction(const Job:PPasMPJob;const ThreadIndex:TPasMPInt32;const Data:pointer;const FromIndex,ToIndex:TPasMPNativeInt);
{$endif}
      public
       constructor Create(const aDevice:TVulkanDevice;const aTargetPPI:TVkInt32=72); reintroduce;
       constructor CreateFromTrueTypeFont(const aDevice:TVulkanDevice;const aTrueTypeFont:TVulkanTrueTypeFont;const aCodePointRanges:array of TVulkanFontCodePointRange);
       destructor Destroy; override;
       class function CodePointRange(const aFromCodePoint,aToCodePoint:TVkUInt32):TVulkanFontCodePointRange; overload;
       class function CodePointRange(const aFromCodePoint,aToCodePoint:WideChar):TVulkanFontCodePointRange; overload;
       class function CodePointRange(const aCharacterRange:TVulkanFontCharacterRange):TVulkanFontCodePointRange; overload;
       function GetScaleFactor(const aSize:TVkFloat):TVkFloat;
       function TextWidth(const aText:TVulkanRawByteString;const aSize:TVkFloat):TVkFloat;
       function TextHeight(const aText:TVulkanRawByteString;const aSize:TVkFloat):TVkFloat;
       function RowHeight(const Percent:TVkFloat):TVkFloat;
       procedure Draw(const aSpriteBatch:TVulkanSpriteBatch;const aText:TVulkanRawByteString;const aX,aY,aSize:TVkFloat;const aColorRed:TVkFloat=1.0;const aColorGreen:TVkFloat=1.0;const aColorBlue:TVkFloat=1.0;const aColorAlpha:TVkFloat=1.0);
     end;

var VulkanFloatToHalfFloatBaseTable:array[0..511] of TVkUInt16;
    VulkanFloatToHalfFloatShiftTable:array[0..511] of TVkUInt8;

    VulkanHalfFloatToFloatMantissaTable:array[0..2047] of TVkUInt32;
    VulkanHalfFloatToFloatExponentTable:array[0..63] of TVkUInt32;
    VulkanHalfFloatToFloatOffsetTable:array[0..63] of TVkUInt32;

    VulkanHalfFloatLookUpTablesInitialized:boolean=false;

{$ifdef PasVulkanPasMP}
    VulkanPasMP:TPasMP=nil;
    VulkanPasMPLock:TPasMPSpinLock=nil;
{$endif}

const VulkanImageViewTypeToImageTiling:array[TVkImageViewType] of TVkImageTiling=
       (
        VK_IMAGE_TILING_LINEAR,  // VK_IMAGE_VIEW_TYPE_1D
        VK_IMAGE_TILING_OPTIMAL, // VK_IMAGE_VIEW_TYPE_2D
        VK_IMAGE_TILING_OPTIMAL, // VK_IMAGE_VIEW_TYPE_3D
        VK_IMAGE_TILING_OPTIMAL, // VK_IMAGE_VIEW_TYPE_CUBE
        VK_IMAGE_TILING_LINEAR,  // VK_IMAGE_VIEW_TYPE_1D_ARRAY
        VK_IMAGE_TILING_OPTIMAL, // VK_IMAGE_VIEW_TYPE_2D_ARRAY
        VK_IMAGE_TILING_LINEAR   // VK_IMAGE_VIEW_TYPE_CUBE_ARRAY
       );

{$ifdef PasVulkanPasMP}
function GetVulkanPasMP:TPasMP;
{$endif}

function VulkanConvertFloatToHalfFloat(const aValue:TVkFloat):TVkHalfFloat; {$ifdef CAN_INLINE}inline;{$endif}
function VulkanConvertHalfFloatToFloat(const aValue:TVkHalfFloat):TVkFloat; {$ifdef CAN_INLINE}inline;{$endif}

function VulkanGetFormatFromOpenGLFormat(const aFormat,aType:TVkUInt32):TVkFormat;
function VulkanGetFormatFromOpenGLType(const aType,aNumComponents:TVkUInt32;const aNormalized:boolean):TVkFormat;
function VulkanGetFormatFromOpenGLInternalFormat(const aInternalFormat:TVkUInt32):TVkFormat;

function VulkanGetFormatSize(const aFormat:TVkFormat):TVulkanFormatSize;

function VulkanRoundUpToPowerOfTwo(Value:TVkSize):TVkSize;

function VulkanErrorToString(const ErrorCode:TVkResult):TVulkanCharString;

function StringListToVulkanCharStringArray(const StringList:TStringList):TVulkanCharStringArray;

procedure VulkanSetImageLayout(const aImage:TVkImage;
                               const aAspectMask:TVkImageAspectFlags;
                               const aOldImageLayout:TVkImageLayout;
                               const aNewImageLayout:TVkImageLayout;
                               const aRange:PVkImageSubresourceRange;
                               const aCommandBuffer:TVulkanCommandBuffer;
                               const aQueue:TVulkanQueue=nil;
                               const aFence:TVulkanFence=nil;
                               const aBeginAndExecuteCommandBuffer:boolean=false;
                               const aSrcQueueFamilyIndex:TVkQueue=TVkQueue(VK_QUEUE_FAMILY_IGNORED);
                               const aDstQueueFamilyIndex:TVkQueue=TVkQueue(VK_QUEUE_FAMILY_IGNORED));

procedure VulkanDisableFloatingPointExceptions;

function VulkanSpritePoint(const x,y:single):TVulkanSpritePoint;
function VulkanSpriteRect(const Left,Top,Right,Bottom:single):TVulkanSpriteRect;
function VulkanSpriteColor(const r,g,b,a:single):TVulkanSpriteColor;

implementation

const suDONOTKNOW=-1;
      suNOUTF8=0;
      suPOSSIBLEUTF8=1;
      suISUTF8=2;

      ucACCEPT=0;
      ucERROR=16;

      VulkanUTF8DFACharClasses:array[TVulkanRawByteChar] of TVkUInt8=
       (
        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
        1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
        1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
        1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
        1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
        3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,
        3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,
        4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,
        5,5,5,5,5,5,5,5,6,6,6,6,7,7,8,8
       );

     VulkanUTF8DFATransitions:array[TVkUInt8] of TVkUInt8=
      (
       0,16,16,32,48,64,80,96,16,16,16,16,16,16,16,16,
       16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,
       16,0,16,16,16,16,16,16,16,16,16,16,16,16,16,16,
       16,32,16,16,16,16,16,16,16,16,16,16,16,16,16,16,
       16,48,16,16,16,16,16,16,16,16,16,16,16,16,16,16,
       16,64,16,16,16,16,16,16,16,16,16,16,16,16,16,16,
       16,80,16,16,16,16,16,16,16,16,16,16,16,16,16,16,
       16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,
       16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,
       16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,
       16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,
       16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,
       16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,
       16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,
       16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,
       16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16
      );

      BooleanToVkBool:array[boolean] of TVkBool32=(VK_FALSE,VK_TRUE);

      MipMapLevels:array[boolean] of TVkInt32=(1,-1);

      CELL_EMPTY=-1;
      CELL_DELETED=-2;
      ENT_EMPTY=-1;
      ENT_DELETED=-2;

      GL_INVALID_VALUE=$0501;
      GL_RED=$1903; // same as GL_RED_EXT
      GL_GREEN=$1904; // deprecated
      GL_BLUE=$1905; // deprecated
      GL_ALPHA=$1906; // deprecated
      GL_LUMINANCE=$1909; // deprecated
      GL_SLUMINANCE=$8c46; // deprecated, same as GL_SLUMINANCE_EXT
      GL_LUMINANCE_ALPHA=$190a; // deprecated
      GL_SLUMINANCE_ALPHA=$8c44; // deprecated, same as GL_SLUMINANCE_ALPHA_EXT
      GL_INTENSITY=$8049; // deprecated, same as GL_INTENSITY_EXT
      GL_RG=$8227; // same as GL_RG_EXT
      GL_RGB=$1907;
      GL_BGR=$80e0; // same as GL_BGR_EXT
      GL_RGBA=$1908;
      GL_BGRA=$80e1; // same as GL_BGRA_EXT
      GL_RED_INTEGER=$8d94; // same as GL_RED_INTEGER_EXT
      GL_GREEN_INTEGER=$8d95; // deprecated, same as GL_GREEN_INTEGER_EXT
      GL_BLUE_INTEGER=$8d96; // deprecated, same as GL_BLUE_INTEGER_EXT
      GL_ALPHA_INTEGER=$8d97; // deprecated, same as GL_ALPHA_INTEGER_EXT
      GL_LUMINANCE_INTEGER=$8d9c; // deprecated, same as GL_LUMINANCE_INTEGER_EXT
      GL_LUMINANCE_ALPHA_INTEGER=$8d9d; // deprecated, same as GL_LUMINANCE_ALPHA_INTEGER_EXT
      GL_RG_INTEGER=$8228; // same as GL_RG_INTEGER_EXT
      GL_RGB_INTEGER=$8d98; // same as GL_RGB_INTEGER_EXT
      GL_BGR_INTEGER=$8d9a; // same as GL_BGR_INTEGER_EXT
      GL_RGBA_INTEGER=$8d99; // same as GL_RGBA_INTEGER_EXT
      GL_BGRA_INTEGER=$8d9b; // same as GL_BGRA_INTEGER_EXT
      GL_COLOR_INDEX=$1900; // deprecated
      GL_STENCIL_INDEX=$1901;
      GL_DEPTH_COMPONENT=$1902;
      GL_DEPTH_STENCIL=$84f9; // same as GL_DEPTH_STENCIL_NV and GL_DEPTH_STENCIL_EXT and GL_DEPTH_STENCIL_OES
      GL_BYTE=$1400;
      GL_UNSIGNED_BYTE=$1401;
      GL_SHORT=$1402;
      GL_UNSIGNED_SHORT=$1403;
      GL_INT=$1404;
      GL_UNSIGNED_INT=$1405;
      GL_INT64=$140e; // same as GL_INT64_NV and GL_INT64_ARB
      GL_UNSIGNED_INT64=$140f; // same as GL_UNSIGNED_INT64_NV and GL_UNSIGNED_INT64_ARB
      GL_HALF_FLOAT=$140b; // same as GL_HALF_FLOAT_NV and GL_HALF_FLOAT_ARB
      GL_HALF_FLOAT_OES=$8d61; // Note that this different from GL_HALF_FLOAT.
      GL_FLOAT=$1406;
      GL_DOUBLE=$140a; // same as GL_DOUBLE_EXT
      GL_UNSIGNED_BYTE_3_3_2=$8032; // same as GL_UNSIGNED_BYTE_3_3_2_EXT
      GL_UNSIGNED_BYTE_2_3_3_REV=$8362; // same as GL_UNSIGNED_BYTE_2_3_3_REV_EXT
      GL_UNSIGNED_SHORT_5_6_5=$8363; // same as GL_UNSIGNED_SHORT_5_6_5_EXT
      GL_UNSIGNED_SHORT_5_6_5_REV=$8364; // same as GL_UNSIGNED_SHORT_5_6_5_REV_EXT
      GL_UNSIGNED_SHORT_4_4_4_4=$8033; // same as GL_UNSIGNED_SHORT_4_4_4_4_EXT
      GL_UNSIGNED_SHORT_4_4_4_4_REV=$8365; // same as GL_UNSIGNED_SHORT_4_4_4_4_REV_IMG and GL_UNSIGNED_SHORT_4_4_4_4_REV_EXT
      GL_UNSIGNED_SHORT_5_5_5_1=$8034; // same as GL_UNSIGNED_SHORT_5_5_5_1_EXT
      GL_UNSIGNED_SHORT_1_5_5_5_REV=$8366; // same as GL_UNSIGNED_SHORT_1_5_5_5_REV_EXT
      GL_UNSIGNED_INT_8_8_8_8=$8035; // same as GL_UNSIGNED_INT_8_8_8_8_EXT
      GL_UNSIGNED_INT_8_8_8_8_REV=$8367; // same as GL_UNSIGNED_INT_8_8_8_8_REV_EXT
      GL_UNSIGNED_INT_10_10_10_2=$8036; // same as GL_UNSIGNED_INT_10_10_10_2_EXT
      GL_UNSIGNED_INT_2_10_10_10_REV=$8368; // same as GL_UNSIGNED_INT_2_10_10_10_REV_EXT
      GL_UNSIGNED_INT_10F_11F_11F_REV=$8c3b; // same as GL_UNSIGNED_INT_10F_11F_11F_REV_EXT
      GL_UNSIGNED_INT_5_9_9_9_REV=$8c3e; // same as GL_UNSIGNED_INT_5_9_9_9_REV_EXT
      GL_UNSIGNED_INT_24_8=$84fa; // same as GL_UNSIGNED_INT_24_8_NV and GL_UNSIGNED_INT_24_8_EXT and GL_UNSIGNED_INT_24_8_OES
      GL_FLOAT_32_UNSIGNED_INT_24_8_REV=$8dad; // same as GL_FLOAT_32_UNSIGNED_INT_24_8_REV_NV and GL_FLOAT_32_UNSIGNED_INT_24_8_REV_ARB
      GL_R8=$8229; // same as GL_R8_EXT
      GL_RG8=$822b; // same as GL_RG8_EXT
      GL_RGB8=$8051; // same as GL_RGB8_EXT and GL_RGB8_OES
      GL_RGBA8=$8058; // same as GL_RGBA8_EXT and GL_RGBA8_OES
      GL_R8_SNORM=$8f94;
      GL_RG8_SNORM=$8f95;
      GL_RGB8_SNORM=$8f96;
      GL_RGBA8_SNORM=$8f97;
      GL_R8UI=$8232;
      GL_RG8UI=$8238;
      GL_RGB8UI=$8d7d; // same as GL_RGB8UI_EXT
      GL_RGBA8UI=$8d7c; // same as GL_RGBA8UI_EXT
      GL_R8I=$8231;
      GL_RG8I=$8237;
      GL_RGB8I=$8d8f; // same as GL_RGB8I_EXT
      GL_RGBA8I=$8d8e; // same as GL_RGBA8I_EXT
      GL_SR8=$8fbd; // same as GL_SR8_EXT
      GL_SRG8=$8fbe; // same as GL_SRG8_EXT
      GL_SRGB8=$8c41; // same as GL_SRGB8_EXT
      GL_SRGB8_ALPHA8=$8c43; // same as GL_SRGB8_ALPHA8_EXT
      GL_R16=$822a; // same as GL_R16_EXT
      GL_RG16=$822c; // same as GL_RG16_EXT
      GL_RGB16=$8054; // same as GL_RGB16_EXT
      GL_RGBA16=$805b; // same as GL_RGBA16_EXT
      GL_R16_SNORM=$8f98; // same as GL_R16_SNORM_EXT
      GL_RG16_SNORM=$8f99; // same as GL_RG16_SNORM_EXT
      GL_RGB16_SNORM=$8f9a; // same as GL_RGB16_SNORM_EXT
      GL_RGBA16_SNORM=$8f9b; // same as GL_RGBA16_SNORM_EXT
      GL_R16UI=$8234;
      GL_RG16UI=$823a;
      GL_RGB16UI=$8d77; // same as GL_RGB16UI_EXT
      GL_RGBA16UI=$8d76; // same as GL_RGBA16UI_EXT
      GL_R16I=$8233;
      GL_RG16I=$8239;
      GL_RGB16I=$8d89; // same as GL_RGB16I_EXT
      GL_RGBA16I=$8d88; // same as GL_RGBA16I_EXT
      GL_R16F=$822d; // same as GL_R16F_EXT
      GL_RG16F=$822f; // same as GL_RG16F_EXT
      GL_RGB16F=$881b; // same as GL_RGB16F_EXT and GL_RGB16F_ARB
      GL_RGBA16F=$881a; // sama as GL_RGBA16F_EXT and GL_RGBA16F_ARB
      GL_R32UI=$8236;
      GL_RG32UI=$823c;
      GL_RGB32UI=$8d71; // same as GL_RGB32UI_EXT
      GL_RGBA32UI=$8d70; // same as GL_RGBA32UI_EXT
      GL_R32I=$8235;
      GL_RG32I=$823b;
      GL_RGB32I=$8d83; // same as GL_RGB32I_EXT
      GL_RGBA32I=$8d82; // same as GL_RGBA32I_EXT
      GL_R32F=$822e; // same as GL_R32F_EXT
      GL_RG32F=$8230; // same as GL_RG32F_EXT
      GL_RGB32F=$8815; // same as GL_RGB32F_EXT and GL_RGB32F_ARB
      GL_RGBA32F=$8814; // same as GL_RGBA32F_EXT and GL_RGBA32F_ARB
      GL_R3_G3_B2=$2a10;
      GL_RGB4=$804f; // same as GL_RGB4_EXT
      GL_RGB5=$8050; // same as GL_RGB5_EXT
      GL_RGB565=$8d62; // same as GL_RGB565_EXT and GL_RGB565_OES
      GL_RGB10=$8052; // same as GL_RGB10_EXT
      GL_RGB12=$8053; // same as GL_RGB12_EXT
      GL_RGBA2=$8055; // same as GL_RGBA2_EXT
      GL_RGBA4=$8056; // same as GL_RGBA4_EXT and GL_RGBA4_OES
      GL_RGBA12=$805a; // same as GL_RGBA12_EXT
      GL_RGB5_A1=$8057; // same as GL_RGB5_A1_EXT and GL_RGB5_A1_OES
      GL_RGB10_A2=$8059; // same as GL_RGB10_A2_EXT
      GL_RGB10_A2UI=$906f;
      GL_R11F_G11F_B10F=$8c3a; // same as GL_R11F_G11F_B10F_APPLE and GL_R11F_G11F_B10F_EXT
      GL_RGB9_E5=$8c3d; // same as GL_RGB9_E5_APPLE and GL_RGB9_E5_EXT
      GL_ALPHA4=$803b; // deprecated, same as GL_ALPHA4_EXT
      GL_ALPHA8=$803c; // deprecated, same as GL_ALPHA8_EXT
      GL_ALPHA8_SNORM=$9014; // deprecated
      GL_ALPHA8UI_EXT=$8d7e; // deprecated
      GL_ALPHA8I_EXT=$8d90; // deprecated
      GL_ALPHA12=$803d; // deprecated, same as GL_ALPHA12_EXT
      GL_ALPHA16=$803e; // deprecated, same as GL_ALPHA16_EXT
      GL_ALPHA16_SNORM=$9018; // deprecated
      GL_ALPHA16UI_EXT=$8d78; // deprecated
      GL_ALPHA16I_EXT=$8d8a; // deprecated
      GL_ALPHA16F_ARB=$881c; // deprecated, same as GL_ALPHA_FLOAT16_APPLE and GL_ALPHA_FLOAT16_ATI
      GL_ALPHA32UI_EXT=$8d72; // deprecated
      GL_ALPHA32I_EXT=$8d84; // deprecated
      GL_ALPHA32F_ARB=$8816; // deprecated, same as GL_ALPHA_FLOAT32_APPLE and GL_ALPHA_FLOAT32_ATI
      GL_LUMINANCE4=$803f; // deprecated, same as GL_LUMINANCE4_EXT
      GL_LUMINANCE8=$8040; // deprecated, same as GL_LUMINANCE8_EXT
      GL_LUMINANCE8_SNORM=$9015; // deprecated
      GL_SLUMINANCE8=$8c47; // deprecated, same as GL_SLUMINANCE8_EXT
      GL_LUMINANCE8UI_EXT=$8d80; // deprecated
      GL_LUMINANCE8I_EXT=$8d92; // deprecated
      GL_LUMINANCE12=$8041; // deprecated, same as GL_LUMINANCE12_EXT
      GL_LUMINANCE16=$8042; // deprecated, same as GL_LUMINANCE16_EXT
      GL_LUMINANCE16_SNORM=$9019; // deprecated
      GL_LUMINANCE16UI_EXT=$8d7a; // deprecated
      GL_LUMINANCE16I_EXT=$8d8c; // deprecated
      GL_LUMINANCE16F_ARB=$881e; // deprecated, same as GL_LUMINANCE_FLOAT16_APPLE and GL_LUMINANCE_FLOAT16_ATI
      GL_LUMINANCE32UI_EXT=$8d74; // deprecated
      GL_LUMINANCE32I_EXT=$8d86; // deprecated
      GL_LUMINANCE32F_ARB=$8818; // deprecated, same as GL_LUMINANCE_FLOAT32_APPLE and GL_LUMINANCE_FLOAT32_ATI
      GL_LUMINANCE4_ALPHA4=$8043; // deprecated, same as GL_LUMINANCE4_ALPHA4_EXT
      GL_LUMINANCE6_ALPHA2=$8044; // deprecated, same as GL_LUMINANCE6_ALPHA2_EXT
      GL_LUMINANCE8_ALPHA8=$8045; // deprecated, same as GL_LUMINANCE8_ALPHA8_EXT
      GL_LUMINANCE8_ALPHA8_SNORM=$9016; // deprecated
      GL_SLUMINANCE8_ALPHA8=$8c45; // deprecated, same as GL_SLUMINANCE8_ALPHA8_EXT
      GL_LUMINANCE_ALPHA8UI_EXT=$8d81; // deprecated
      GL_LUMINANCE_ALPHA8I_EXT=$8d93; // deprecated
      GL_LUMINANCE12_ALPHA4=$8046; // deprecated, same as GL_LUMINANCE12_ALPHA4_EXT
      GL_LUMINANCE12_ALPHA12=$8047; // deprecated, same as GL_LUMINANCE12_ALPHA12_EXT
      GL_LUMINANCE16_ALPHA16=$8048; // deprecated, same as GL_LUMINANCE16_ALPHA16_EXT
      GL_LUMINANCE16_ALPHA16_SNORM=$901a; // deprecated
      GL_LUMINANCE_ALPHA16UI_EXT=$8d7b; // deprecated
      GL_LUMINANCE_ALPHA16I_EXT=$8d8d; // deprecated
      GL_LUMINANCE_ALPHA16F_ARB=$881f; // deprecated, same as GL_LUMINANCE_ALPHA_FLOAT16_APPLE and GL_LUMINANCE_ALPHA_FLOAT16_ATI
      GL_LUMINANCE_ALPHA32UI_EXT=$8d75; // deprecated
      GL_LUMINANCE_ALPHA32I_EXT=$8d87; // deprecated
      GL_LUMINANCE_ALPHA32F_ARB=$8819; // deprecated, same as GL_LUMINANCE_ALPHA_FLOAT32_APPLE and GL_LUMINANCE_ALPHA_FLOAT32_ATI
      GL_INTENSITY4=$804a; // deprecated, same as GL_INTENSITY4_EXT
      GL_INTENSITY8=$804b; // deprecated, same as GL_INTENSITY8_EXT
      GL_INTENSITY8_SNORM=$9017; // deprecated
      GL_INTENSITY8UI_EXT=$8d7f; // deprecated
      GL_INTENSITY8I_EXT=$8d91; // deprecated
      GL_INTENSITY12=$804c; // deprecated, same as GL_INTENSITY12_EXT
      GL_INTENSITY16=$804d; // deprecated, same as GL_INTENSITY16_EXT
      GL_INTENSITY16_SNORM=$901b; // deprecated
      GL_INTENSITY16UI_EXT=$8d79; // deprecated
      GL_INTENSITY16I_EXT=$8d8b; // deprecated
      GL_INTENSITY16F_ARB=$881d; // deprecated, same as GL_INTENSITY_FLOAT16_APPLE and GL_INTENSITY_FLOAT16_ATI
      GL_INTENSITY32UI_EXT=$8d73; // deprecated
      GL_INTENSITY32I_EXT=$8d85; // deprecated
      GL_INTENSITY32F_ARB=$8817; // deprecated, same as GL_INTENSITY_FLOAT32_APPLE and GL_INTENSITY_FLOAT32_ATI
      GL_COMPRESSED_RED=$8225;
      GL_COMPRESSED_ALPHA=$84e9; // deprecated, same as GL_COMPRESSED_ALPHA_ARB
      GL_COMPRESSED_LUMINANCE=$84ea; // deprecated, same as GL_COMPRESSED_LUMINANCE_ARB
      GL_COMPRESSED_SLUMINANCE=$8c4a; // deprecated, same as GL_COMPRESSED_SLUMINANCE_EXT
      GL_COMPRESSED_LUMINANCE_ALPHA=$84eb; // deprecated, same as GL_COMPRESSED_LUMINANCE_ALPHA_ARB
      GL_COMPRESSED_SLUMINANCE_ALPHA=$8c4b; // deprecated, same as GL_COMPRESSED_SLUMINANCE_ALPHA_EXT
      GL_COMPRESSED_INTENSITY=$84ec; // deprecated, same as GL_COMPRESSED_INTENSITY_ARB
      GL_COMPRESSED_RG=$8226;
      GL_COMPRESSED_RGB=$84ed; // same as GL_COMPRESSED_RGB_ARB
      GL_COMPRESSED_RGBA=$84ee; // same as GL_COMPRESSED_RGBA_ARB
      GL_COMPRESSED_SRGB=$8c48; // same as GL_COMPRESSED_SRGB_EXT
      GL_COMPRESSED_SRGB_ALPHA=$8c49; // same as GL_COMPRESSED_SRGB_ALPHA_EXT
      GL_COMPRESSED_RGB_FXT1_3DFX=$86b0; // deprecated
      GL_COMPRESSED_RGBA_FXT1_3DFX=$86b1; // deprecated
      GL_COMPRESSED_RGB_S3TC_DXT1_EXT=$83f0;
      GL_COMPRESSED_RGBA_S3TC_DXT1_EXT=$83f1;
      GL_COMPRESSED_RGBA_S3TC_DXT3_EXT=$83f2;
      GL_COMPRESSED_RGBA_S3TC_DXT5_EXT=$83f3;
      GL_COMPRESSED_SRGB_S3TC_DXT1_EXT=$8c4c;
      GL_COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT=$8c4d;
      GL_COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT=$8c4e;
      GL_COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT=$8c4f;
      GL_COMPRESSED_LUMINANCE_LATC1_EXT=$8c70;
      GL_COMPRESSED_LUMINANCE_ALPHA_LATC2_EXT=$8c72;
      GL_COMPRESSED_SIGNED_LUMINANCE_LATC1_EXT=$8c71;
      GL_COMPRESSED_SIGNED_LUMINANCE_ALPHA_LATC2_EXT=$8c73;
      GL_COMPRESSED_RED_RGTC1=$8dbb; // same as GL_COMPRESSED_RED_RGTC1_EXT
      GL_COMPRESSED_RG_RGTC2=$8dbd; // same as GL_COMPRESSED_RG_RGTC2_EXT
      GL_COMPRESSED_SIGNED_RED_RGTC1=$8dbc; // same as GL_COMPRESSED_SIGNED_RED_RGTC1_EXT
      GL_COMPRESSED_SIGNED_RG_RGTC2=$8dbe; // same as GL_COMPRESSED_SIGNED_RG_RGTC2_EXT
      GL_COMPRESSED_RGB_BPTC_SIGNED_FLOAT=$8e8e; // same as GL_COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_ARB
      GL_COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT=$8e8f; // same as GL_COMPRESSED_RGB_BPTC_SIGNED_FLOAT_ARB
      GL_COMPRESSED_RGBA_BPTC_UNORM=$8e8c; // same as GL_COMPRESSED_RGBA_BPTC_UNORM_ARB
      GL_COMPRESSED_SRGB_ALPHA_BPTC_UNORM=$8e8d; // same as GL_COMPRESSED_SRGB_ALPHA_BPTC_UNORM_ARB
      GL_ETC1_RGB8_OES=$8d64;
      GL_COMPRESSED_RGB8_ETC2=$9274;
      GL_COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2=$9276;
      GL_COMPRESSED_RGBA8_ETC2_EAC=$9278;
      GL_COMPRESSED_SRGB8_ETC2=$9275;
      GL_COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2=$9277;
      GL_COMPRESSED_SRGB8_ALPHA8_ETC2_EAC=$9279;
      GL_COMPRESSED_R11_EAC=$9270;
      GL_COMPRESSED_RG11_EAC=$9272;
      GL_COMPRESSED_SIGNED_R11_EAC=$9271;
      GL_COMPRESSED_SIGNED_RG11_EAC=$9273;
      GL_COMPRESSED_RGB_PVRTC_2BPPV1_IMG=$8c01;
      GL_COMPRESSED_RGB_PVRTC_4BPPV1_IMG=$8c00;
      GL_COMPRESSED_RGBA_PVRTC_2BPPV1_IMG=$8c03;
      GL_COMPRESSED_RGBA_PVRTC_4BPPV1_IMG=$8c02;
      GL_COMPRESSED_RGBA_PVRTC_2BPPV2_IMG=$9137;
      GL_COMPRESSED_RGBA_PVRTC_4BPPV2_IMG=$9138;
      GL_COMPRESSED_SRGB_PVRTC_2BPPV1_EXT=$8a54;
      GL_COMPRESSED_SRGB_PVRTC_4BPPV1_EXT=$8a55;
      GL_COMPRESSED_SRGB_ALPHA_PVRTC_2BPPV1_EXT=$8a56;
      GL_COMPRESSED_SRGB_ALPHA_PVRTC_4BPPV1_EXT=$8a57;
      GL_COMPRESSED_SRGB_ALPHA_PVRTC_2BPPV2_IMG=$93f0;
      GL_COMPRESSED_SRGB_ALPHA_PVRTC_4BPPV2_IMG=$93f1;
      GL_COMPRESSED_RGBA_ASTC_4x4_KHR=$93b0;
      GL_COMPRESSED_RGBA_ASTC_5x4_KHR=$93b1;
      GL_COMPRESSED_RGBA_ASTC_5x5_KHR=$93b2;
      GL_COMPRESSED_RGBA_ASTC_6x5_KHR=$93b3;
      GL_COMPRESSED_RGBA_ASTC_6x6_KHR=$93b4;
      GL_COMPRESSED_RGBA_ASTC_8x5_KHR=$93b5;
      GL_COMPRESSED_RGBA_ASTC_8x6_KHR=$93b6;
      GL_COMPRESSED_RGBA_ASTC_8x8_KHR=$93b7;
      GL_COMPRESSED_RGBA_ASTC_10x5_KHR=$93b8;
      GL_COMPRESSED_RGBA_ASTC_10x6_KHR=$93b9;
      GL_COMPRESSED_RGBA_ASTC_10x8_KHR=$93ba;
      GL_COMPRESSED_RGBA_ASTC_10x10_KHR=$93bb;
      GL_COMPRESSED_RGBA_ASTC_12x10_KHR=$93bc;
      GL_COMPRESSED_RGBA_ASTC_12x12_KHR=$93bd;
      GL_COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR=$93d0;
      GL_COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR=$93d1;
      GL_COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR=$93d2;
      GL_COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR=$93d3;
      GL_COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR=$93d4;
      GL_COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR=$93d5;
      GL_COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR=$93d6;
      GL_COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR=$93d7;
      GL_COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR=$93d8;
      GL_COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR=$93d9;
      GL_COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR=$93da;
      GL_COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR=$93db;
      GL_COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR=$93dc;
      GL_COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR=$93dd;
      GL_COMPRESSED_RGBA_ASTC_3x3x3_OES=$93c0;
      GL_COMPRESSED_RGBA_ASTC_4x3x3_OES=$93c1;
      GL_COMPRESSED_RGBA_ASTC_4x4x3_OES=$93c2;
      GL_COMPRESSED_RGBA_ASTC_4x4x4_OES=$93c3;
      GL_COMPRESSED_RGBA_ASTC_5x4x4_OES=$93c4;
      GL_COMPRESSED_RGBA_ASTC_5x5x4_OES=$93c5;
      GL_COMPRESSED_RGBA_ASTC_5x5x5_OES=$93c6;
      GL_COMPRESSED_RGBA_ASTC_6x5x5_OES=$93c7;
      GL_COMPRESSED_RGBA_ASTC_6x6x5_OES=$93c8;
      GL_COMPRESSED_RGBA_ASTC_6x6x6_OES=$93c9;
      GL_COMPRESSED_SRGB8_ALPHA8_ASTC_3x3x3_OES=$93e0;
      GL_COMPRESSED_SRGB8_ALPHA8_ASTC_4x3x3_OES=$93e1;
      GL_COMPRESSED_SRGB8_ALPHA8_ASTC_4x4x3_OES=$93e2;
      GL_COMPRESSED_SRGB8_ALPHA8_ASTC_4x4x4_OES=$93e3;
      GL_COMPRESSED_SRGB8_ALPHA8_ASTC_5x4x4_OES=$93e4;
      GL_COMPRESSED_SRGB8_ALPHA8_ASTC_5x5x4_OES=$93e5;
      GL_COMPRESSED_SRGB8_ALPHA8_ASTC_5x5x5_OES=$93e6;
      GL_COMPRESSED_SRGB8_ALPHA8_ASTC_6x5x5_OES=$93e7;
      GL_COMPRESSED_SRGB8_ALPHA8_ASTC_6x6x5_OES=$93e8;
      GL_COMPRESSED_SRGB8_ALPHA8_ASTC_6x6x6_OES=$93e9;
      GL_ATC_RGB_AMD=$8c92;
      GL_ATC_RGBA_EXPLICIT_ALPHA_AMD=$8c93;
      GL_ATC_RGBA_INTERPOLATED_ALPHA_AMD=$87ee;
      GL_PALETTE4_RGB8_OES=$8b90;
      GL_PALETTE4_RGBA8_OES=$8b91;
      GL_PALETTE4_R5_G6_B5_OES=$8b92;
      GL_PALETTE4_RGBA4_OES=$8b93;
      GL_PALETTE4_RGB5_A1_OES=$8b94;
      GL_PALETTE8_RGB8_OES=$8b95;
      GL_PALETTE8_RGBA8_OES=$8b96;
      GL_PALETTE8_R5_G6_B5_OES=$8b97;
      GL_PALETTE8_RGBA4_OES=$8b98;
      GL_PALETTE8_RGB5_A1_OES=$8b99;
      GL_COLOR_INDEX1_EXT=$80e2; // deprecated
      GL_COLOR_INDEX2_EXT=$80e3; // deprecated
      GL_COLOR_INDEX4_EXT=$80e4; // deprecated
      GL_COLOR_INDEX8_EXT=$80e5; // deprecated
      GL_COLOR_INDEX12_EXT=$80e6; // deprecated
      GL_COLOR_INDEX16_EXT=$80e7; // deprecated
      GL_DEPTH_COMPONENT16=$81a5; // same as GL_DEPTH_COMPONENT16_SGIX and GL_DEPTH_COMPONENT16_ARB
      GL_DEPTH_COMPONENT24=$81a6; // same as GL_DEPTH_COMPONENT24_SGIX and GL_DEPTH_COMPONENT24_ARB
      GL_DEPTH_COMPONENT32=$81a7; // same as GL_DEPTH_COMPONENT32_SGIX and GL_DEPTH_COMPONENT32_ARB and GL_DEPTH_COMPONENT32_OES
      GL_DEPTH_COMPONENT32F=$8cac; // same as GL_DEPTH_COMPONENT32F_ARB
      GL_DEPTH_COMPONENT32F_NV=$8dab; // Note that this different from GL_DEPTH_COMPONENT32F.
      GL_STENCIL_INDEX1=$8d46; // same as GL_STENCIL_INDEX1_EXT
      GL_STENCIL_INDEX4=$8d47; // same as GL_STENCIL_INDEX4_EXT
      GL_STENCIL_INDEX8=$8d48; // same as GL_STENCIL_INDEX8_EXT
      GL_STENCIL_INDEX16=$8d49; // same as GL_STENCIL_INDEX16_EXT
      GL_DEPTH24_STENCIL8=$88f0; // same as GL_DEPTH24_STENCIL8_EXT and GL_DEPTH24_STENCIL8_OES
      GL_DEPTH32F_STENCIL8=$8cad; // same as GL_DEPTH32F_STENCIL8_ARB
      GL_DEPTH32F_STENCIL8_NV=$8dac; // Note that this different from GL_DEPTH32F_STENCIL8.

{$i PasVulkanAssets.inc}

type PUInt32Array=^TUInt32Array;
     TUInt32Array=array[0..65535] of TVkUInt32;

{$ifdef PasVulkanPasMP}
function GetVulkanPasMP:TPasMP;
begin
 result:=TVkPointer(TPasMPInterlocked.Read(TVkPointer(VulkanPasMP)));
 if not assigned(result) then begin
  VulkanPasMPLock.Acquire;
  try
   result:=TVkPointer(TPasMPInterlocked.Read(TVkPointer(VulkanPasMP)));
   if not assigned(result) then begin
    result:=TPasMP.GetGlobalInstance;
    TPasMPInterlocked.Write(TVkPointer(VulkanPasMP),TVkPointer(result));
   end;
  finally
   VulkanPasMPLock.Release;
  end;
 end;
end;
{$endif}

procedure GenerateHalfFloatLookUpTables;
var i,e:TVkInt32;
    Mantissa,Exponent:TVkUInt32;
begin
 if not VulkanHalfFloatLookUpTablesInitialized then begin
  VulkanHalfFloatLookUpTablesInitialized:=true;
  for i:=0 to 255 do begin
   e:=i-127;
   case e of
    -127..-25:begin
     // Very small numbers maps to zero
     VulkanFloatToHalfFloatBaseTable[i or $000]:=$0000;
     VulkanFloatToHalfFloatBaseTable[i or $100]:=$8000;
     VulkanFloatToHalfFloatShiftTable[i or $000]:=24;
     VulkanFloatToHalfFloatShiftTable[i or $100]:=24;
    end;
    -24..-15:begin
     // Small numbers maps to denormals
     VulkanFloatToHalfFloatBaseTable[i or $000]:=($0400 shr ((-e)-14)) or $0000;
     VulkanFloatToHalfFloatBaseTable[i or $100]:=($0400 shr ((-e)-14)) or $8000;
     VulkanFloatToHalfFloatShiftTable[i or $000]:=(-e)-1;
     VulkanFloatToHalfFloatShiftTable[i or $100]:=(-e)-1;
    end;
    -14..15:begin
     // Normal numbers just loses precision
     VulkanFloatToHalfFloatBaseTable[i or $000]:=((e+15) shl 10) or $0000;
     VulkanFloatToHalfFloatBaseTable[i or $100]:=((e+15) shl 10) or $8000;
     VulkanFloatToHalfFloatShiftTable[i or $000]:=13;
     VulkanFloatToHalfFloatShiftTable[i or $100]:=13;
    end;
    16..127:begin
     // Large numbers maps to infinity
     VulkanFloatToHalfFloatBaseTable[i or $000]:=$7c00;
     VulkanFloatToHalfFloatBaseTable[i or $100]:=$fc00;
     VulkanFloatToHalfFloatShiftTable[i or $000]:=24;
     VulkanFloatToHalfFloatShiftTable[i or $100]:=24;
    end;
    else begin
     // Infinity and NaN's stay infinity and NaN's
     VulkanFloatToHalfFloatBaseTable[i or $000]:=$7c00;
     VulkanFloatToHalfFloatBaseTable[i or $100]:=$fc00;
     VulkanFloatToHalfFloatShiftTable[i or $000]:=13;
     VulkanFloatToHalfFloatShiftTable[i or $100]:=13;
    end;
   end;
  end;
  begin
   begin
    VulkanHalfFloatToFloatMantissaTable[0]:=0;
    for i:=1 to 1023 do begin
     Mantissa:=i shl 13;
     Exponent:=0;
     while (Mantissa and $00800000)=0 do begin // While not normalized
      dec(Exponent,$00800000);                 // Decrement exponent by 1 shl 23
      Mantissa:=Mantissa shl 1;                // Shift mantissa
     end;
     Mantissa:=Mantissa and not $00800000;     // Clear leading 1 bit
     inc(Exponent,$38800000);                  // Adjust bias by (127-14) shl 23
     VulkanHalfFloatToFloatMantissaTable[i]:=Mantissa or Exponent;
    end;
    for i:=1024 to 2047 do begin
     VulkanHalfFloatToFloatMantissaTable[i]:=$38000000+((i-1024) shl 13);
    end;
   end;
   begin
    VulkanHalfFloatToFloatExponentTable[0]:=0;
    for i:=1 to 30 do begin
     VulkanHalfFloatToFloatExponentTable[i]:=i shl 23;
    end;
    VulkanHalfFloatToFloatExponentTable[31]:=$47800000;
    VulkanHalfFloatToFloatExponentTable[32]:=0;
    for i:=33 to 62 do begin
     VulkanHalfFloatToFloatExponentTable[i]:=TVkUInt32(TVkUInt32(i-32) shl 23) or $80000000;
    end;
    VulkanHalfFloatToFloatExponentTable[63]:=$c7800000;
   end;
   begin
    VulkanHalfFloatToFloatOffsetTable[0]:=0;
    for i:=1 to 31 do begin
     VulkanHalfFloatToFloatOffsetTable[i]:=1024;
    end;
    VulkanHalfFloatToFloatOffsetTable[32]:=0;
    for i:=33 to 63 do begin
     VulkanHalfFloatToFloatOffsetTable[i]:=1024;
    end;
   end;
  end;
 end;
end;

function VulkanConvertFloatToHalfFloat(const aValue:TVkFloat):TVkHalfFloat; {$ifdef CAN_INLINE}inline;{$endif}
var CastedValue:TVkUInt32 absolute aValue;
begin
 result:=VulkanFloatToHalfFloatBaseTable[CastedValue shr 23]+TVkUInt16((CastedValue and $007fffff) shr VulkanFloatToHalfFloatShiftTable[CastedValue shr 23]);
end;

function VulkanConvertHalfFloatToFloat(const aValue:TVkHalfFloat):TVkFloat; {$ifdef CAN_INLINE}inline;{$endif}
var f:TVkUInt32;
begin
 f:=VulkanHalfFloatToFloatMantissaTable[VulkanHalfFloatToFloatOffsetTable[aValue shr 10]+(aValue and $3ff)]+VulkanHalfFloatToFloatExponentTable[aValue shr 10];
 result:=TVkFloat(TVkPointer(@f)^);
end;

function VulkanGetFormatFromOpenGLFormat(const aFormat,aType:TVkUInt32):TVkFormat;
begin
 case aType of
  GL_UNSIGNED_BYTE:begin
   case aFormat of
    GL_RED:begin
     result:=VK_FORMAT_R8_UNORM;
    end;
    GL_RG:begin
     result:=VK_FORMAT_R8G8_UNORM;
    end;
    GL_RGB:begin
     result:=VK_FORMAT_R8G8B8_UNORM;
    end;
    GL_BGR:begin
     result:=VK_FORMAT_B8G8R8_UNORM;
    end;
    GL_RGBA:begin
     result:=VK_FORMAT_R8G8B8A8_UNORM;
    end;
    GL_BGRA:begin
     result:=VK_FORMAT_B8G8R8A8_UNORM;
    end;
    GL_RED_INTEGER:begin
     result:=VK_FORMAT_R8_UINT;
    end;
    GL_RG_INTEGER:begin
     result:=VK_FORMAT_R8G8_UINT;
    end;
    GL_RGB_INTEGER:begin
     result:=VK_FORMAT_R8G8B8_UINT;
    end;
    GL_BGR_INTEGER:begin
     result:=VK_FORMAT_B8G8R8_UINT;
    end;
    GL_RGBA_INTEGER:begin
     result:=VK_FORMAT_R8G8B8A8_UINT;
    end;
    GL_BGRA_INTEGER:begin
     result:=VK_FORMAT_B8G8R8A8_UINT;
    end;
    GL_STENCIL_INDEX:begin
     result:=VK_FORMAT_S8_UINT;
    end;
    GL_DEPTH_COMPONENT:begin
     result:=VK_FORMAT_UNDEFINED;
    end;
    GL_DEPTH_STENCIL:begin
     result:=VK_FORMAT_UNDEFINED;
    end;
    else begin
     result:=VK_FORMAT_UNDEFINED;
    end;
   end;
  end;
  GL_BYTE:begin
   case aFormat of
    GL_RED:begin
     result:=VK_FORMAT_R8_SNORM;
    end;
    GL_RG:begin
     result:=VK_FORMAT_R8G8_SNORM;
    end;
    GL_RGB:begin
     result:=VK_FORMAT_R8G8B8_SNORM;
    end;
    GL_BGR:begin
     result:=VK_FORMAT_B8G8R8_SNORM;
    end;
    GL_RGBA:begin
     result:=VK_FORMAT_R8G8B8A8_SNORM;
    end;
    GL_BGRA:begin
     result:=VK_FORMAT_B8G8R8A8_SNORM;
    end;
    GL_RED_INTEGER:begin
     result:=VK_FORMAT_R8_SINT;
    end;
    GL_RG_INTEGER:begin
     result:=VK_FORMAT_R8G8_SINT;
    end;
    GL_RGB_INTEGER:begin
     result:=VK_FORMAT_R8G8B8_SINT;
    end;
    GL_BGR_INTEGER:begin
     result:=VK_FORMAT_B8G8R8_SINT;
    end;
    GL_RGBA_INTEGER:begin
     result:=VK_FORMAT_R8G8B8A8_SINT;
    end;
    GL_BGRA_INTEGER:begin
     result:=VK_FORMAT_B8G8R8A8_SINT;
    end;
    GL_STENCIL_INDEX:begin
     result:=VK_FORMAT_UNDEFINED;
    end;
    GL_DEPTH_COMPONENT:begin
     result:=VK_FORMAT_UNDEFINED;
    end;
    GL_DEPTH_STENCIL:begin
     result:=VK_FORMAT_UNDEFINED;
    end;
    else begin
     result:=VK_FORMAT_UNDEFINED;
    end;
   end;
  end;
  GL_UNSIGNED_SHORT:begin
   case aFormat of
    GL_RED:begin
     result:=VK_FORMAT_R16_UNORM;
    end;
    GL_RG:begin
     result:=VK_FORMAT_R16G16_UNORM;
    end;
    GL_RGB:begin
     result:=VK_FORMAT_R16G16B16_UNORM;
    end;
    GL_BGR:begin
     result:=VK_FORMAT_UNDEFINED;
    end;
    GL_RGBA:begin
     result:=VK_FORMAT_R16G16B16A16_UNORM;
    end;
    GL_BGRA:begin
     result:=VK_FORMAT_UNDEFINED;
    end;
    GL_RED_INTEGER:begin
     result:=VK_FORMAT_R16_UINT;
    end;
    GL_RG_INTEGER:begin
     result:=VK_FORMAT_R16G16_UINT;
    end;
    GL_RGB_INTEGER:begin
     result:=VK_FORMAT_R16G16B16_UINT;
    end;
    GL_BGR_INTEGER:begin
     result:=VK_FORMAT_UNDEFINED;
    end;
    GL_RGBA_INTEGER:begin
     result:=VK_FORMAT_R16G16B16A16_UINT;
    end;
    GL_BGRA_INTEGER:begin
     result:=VK_FORMAT_UNDEFINED;
    end;
    GL_STENCIL_INDEX:begin
     result:=VK_FORMAT_UNDEFINED;
    end;
    GL_DEPTH_COMPONENT:begin
     result:=VK_FORMAT_D16_UNORM;
    end;
    GL_DEPTH_STENCIL:begin
     result:=VK_FORMAT_D16_UNORM_S8_UINT;
    end;
    else begin
     result:=VK_FORMAT_UNDEFINED;
    end;
   end;
  end;
  GL_SHORT:begin
   case aFormat of
    GL_RED:begin
     result:=VK_FORMAT_R16_SNORM;
    end;
    GL_RG:begin
     result:=VK_FORMAT_R16G16_SNORM;
    end;
    GL_RGB:begin
     result:=VK_FORMAT_R16G16B16_SNORM;
    end;
    GL_BGR:begin
     result:=VK_FORMAT_UNDEFINED;
    end;
    GL_RGBA:begin
     result:=VK_FORMAT_R16G16B16A16_SNORM;
    end;
    GL_BGRA:begin
     result:=VK_FORMAT_UNDEFINED;
    end;
    GL_RED_INTEGER:begin
     result:=VK_FORMAT_R16_SINT;
    end;
    GL_RG_INTEGER:begin
     result:=VK_FORMAT_R16G16_SINT;
    end;
    GL_RGB_INTEGER:begin
     result:=VK_FORMAT_R16G16B16_SINT;
    end;
    GL_BGR_INTEGER:begin
     result:=VK_FORMAT_UNDEFINED;
    end;
    GL_RGBA_INTEGER:begin
     result:=VK_FORMAT_R16G16B16A16_SINT;
    end;
    GL_BGRA_INTEGER:begin
     result:=VK_FORMAT_UNDEFINED;
    end;
    GL_STENCIL_INDEX:begin
     result:=VK_FORMAT_UNDEFINED;
    end;
    GL_DEPTH_COMPONENT:begin
     result:=VK_FORMAT_UNDEFINED;
    end;
    GL_DEPTH_STENCIL:begin
     result:=VK_FORMAT_UNDEFINED;
    end;
    else begin
     result:=VK_FORMAT_UNDEFINED;
    end;
   end;
  end;
  GL_HALF_FLOAT,GL_HALF_FLOAT_OES:begin
   case aFormat of
    GL_RED:begin
     result:=VK_FORMAT_R16_SFLOAT;
    end;
    GL_RG:begin
     result:=VK_FORMAT_R16G16_SFLOAT;
    end;
    GL_RGB:begin
     result:=VK_FORMAT_R16G16B16_SFLOAT;
    end;
    GL_BGR:begin
     result:=VK_FORMAT_UNDEFINED;
    end;
    GL_RGBA:begin
     result:=VK_FORMAT_R16G16B16A16_SFLOAT;
    end;
    GL_BGRA:begin
     result:=VK_FORMAT_UNDEFINED;
    end;
    GL_RED_INTEGER:begin
     result:=VK_FORMAT_UNDEFINED;
    end;
    GL_RG_INTEGER:begin
     result:=VK_FORMAT_UNDEFINED;
    end;
    GL_RGB_INTEGER:begin
     result:=VK_FORMAT_UNDEFINED;
    end;
    GL_BGR_INTEGER:begin
     result:=VK_FORMAT_UNDEFINED;
    end;
    GL_RGBA_INTEGER:begin
     result:=VK_FORMAT_UNDEFINED;
    end;
    GL_BGRA_INTEGER:begin
     result:=VK_FORMAT_UNDEFINED;
    end;
    GL_STENCIL_INDEX:begin
     result:=VK_FORMAT_UNDEFINED;
    end;
    GL_DEPTH_COMPONENT:begin
     result:=VK_FORMAT_UNDEFINED;
    end;
    GL_DEPTH_STENCIL:begin
     result:=VK_FORMAT_UNDEFINED;
    end;
    else begin
     result:=VK_FORMAT_UNDEFINED;
    end;
   end;
  end;
  GL_UNSIGNED_INT:begin
   case aFormat of
    GL_RED:begin
     result:=VK_FORMAT_R32_UINT;
    end;
    GL_RG:begin
     result:=VK_FORMAT_R32G32_UINT;
    end;
    GL_RGB:begin
     result:=VK_FORMAT_R32G32B32_UINT;
    end;
    GL_BGR:begin
     result:=VK_FORMAT_UNDEFINED;
    end;
    GL_RGBA:begin
     result:=VK_FORMAT_R32G32B32A32_UINT;
    end;
    GL_BGRA:begin
     result:=VK_FORMAT_UNDEFINED;
    end;
    GL_RED_INTEGER:begin
     result:=VK_FORMAT_R32_UINT;
    end;
    GL_RG_INTEGER:begin
     result:=VK_FORMAT_R32G32_UINT;
    end;
    GL_RGB_INTEGER:begin
     result:=VK_FORMAT_R32G32B32_UINT;
    end;
    GL_BGR_INTEGER:begin
     result:=VK_FORMAT_UNDEFINED;
    end;
    GL_RGBA_INTEGER:begin
     result:=VK_FORMAT_R32G32B32A32_UINT;
    end;
    GL_BGRA_INTEGER:begin
     result:=VK_FORMAT_UNDEFINED;
    end;
    GL_STENCIL_INDEX:begin
     result:=VK_FORMAT_UNDEFINED;
    end;
    GL_DEPTH_COMPONENT:begin
     result:=VK_FORMAT_X8_D24_UNORM_PACK32;
    end;
    GL_DEPTH_STENCIL:begin
     result:=VK_FORMAT_D24_UNORM_S8_UINT;
    end;
    else begin
     result:=VK_FORMAT_UNDEFINED;
    end;
   end;
  end;
  GL_INT:begin
   case aFormat of
    GL_RED:begin
     result:=VK_FORMAT_R32_SINT;
    end;
    GL_RG:begin
     result:=VK_FORMAT_R32G32_SINT;
    end;
    GL_RGB:begin
     result:=VK_FORMAT_R32G32B32_SINT;
    end;
    GL_BGR:begin
     result:=VK_FORMAT_UNDEFINED;
    end;
    GL_RGBA:begin
     result:=VK_FORMAT_R32G32B32A32_SINT;
    end;
    GL_BGRA:begin
     result:=VK_FORMAT_UNDEFINED;
    end;
    GL_RED_INTEGER:begin
     result:=VK_FORMAT_R32_SINT;
    end;
    GL_RG_INTEGER:begin
     result:=VK_FORMAT_R32G32_SINT;
    end;
    GL_RGB_INTEGER:begin
     result:=VK_FORMAT_R32G32B32_SINT;
    end;
    GL_BGR_INTEGER:begin
     result:=VK_FORMAT_UNDEFINED;
    end;
    GL_RGBA_INTEGER:begin
     result:=VK_FORMAT_R32G32B32A32_SINT;
    end;
    GL_BGRA_INTEGER:begin
     result:=VK_FORMAT_UNDEFINED;
    end;
    GL_STENCIL_INDEX:begin
     result:=VK_FORMAT_UNDEFINED;
    end;
    GL_DEPTH_COMPONENT:begin
     result:=VK_FORMAT_UNDEFINED;
    end;
    GL_DEPTH_STENCIL:begin
     result:=VK_FORMAT_UNDEFINED;
    end;
    else begin
     result:=VK_FORMAT_UNDEFINED;
    end;
   end;
  end;
  GL_FLOAT:begin
   case aFormat of
    GL_RED:begin
     result:=VK_FORMAT_R32_SFLOAT;
    end;
    GL_RG:begin
     result:=VK_FORMAT_R32G32_SFLOAT;
    end;
    GL_RGB:begin
     result:=VK_FORMAT_R32G32B32_SFLOAT;
    end;
    GL_BGR:begin
     result:=VK_FORMAT_UNDEFINED;
    end;
    GL_RGBA:begin
     result:=VK_FORMAT_R32G32B32A32_SFLOAT;
    end;
    GL_BGRA:begin
     result:=VK_FORMAT_UNDEFINED;
    end;
    GL_RED_INTEGER:begin
     result:=VK_FORMAT_UNDEFINED;
    end;
    GL_RG_INTEGER:begin
     result:=VK_FORMAT_UNDEFINED;
    end;
    GL_RGB_INTEGER:begin
     result:=VK_FORMAT_UNDEFINED;
    end;
    GL_BGR_INTEGER:begin
     result:=VK_FORMAT_UNDEFINED;
    end;
    GL_RGBA_INTEGER:begin
     result:=VK_FORMAT_UNDEFINED;
    end;
    GL_BGRA_INTEGER:begin
     result:=VK_FORMAT_UNDEFINED;
    end;
    GL_STENCIL_INDEX:begin
     result:=VK_FORMAT_UNDEFINED;
    end;
    GL_DEPTH_COMPONENT:begin
     result:=VK_FORMAT_D32_SFLOAT;
    end;
    GL_DEPTH_STENCIL:begin
     result:=VK_FORMAT_D32_SFLOAT_S8_UINT;
    end;
    else begin
     result:=VK_FORMAT_UNDEFINED;
    end;
   end;
  end;
  GL_UNSIGNED_INT64:begin
   case aFormat of
    GL_RED:begin
     result:=VK_FORMAT_R64_UINT;
    end;
    GL_RG:begin
     result:=VK_FORMAT_R64G64_UINT;
    end;
    GL_RGB:begin
     result:=VK_FORMAT_R64G64B64_UINT;
    end;
    GL_BGR:begin
     result:=VK_FORMAT_UNDEFINED;
    end;
    GL_RGBA:begin
     result:=VK_FORMAT_R64G64B64A64_UINT;
    end;
    GL_BGRA:begin
     result:=VK_FORMAT_UNDEFINED;
    end;
    GL_RED_INTEGER:begin
     result:=VK_FORMAT_UNDEFINED;
    end;
    GL_RG_INTEGER:begin
     result:=VK_FORMAT_UNDEFINED;
    end;
    GL_RGB_INTEGER:begin
     result:=VK_FORMAT_UNDEFINED;
    end;
    GL_BGR_INTEGER:begin
     result:=VK_FORMAT_UNDEFINED;
    end;
    GL_RGBA_INTEGER:begin
     result:=VK_FORMAT_UNDEFINED;
    end;
    GL_BGRA_INTEGER:begin
     result:=VK_FORMAT_UNDEFINED;
    end;
    GL_STENCIL_INDEX:begin
     result:=VK_FORMAT_UNDEFINED;
    end;
    GL_DEPTH_COMPONENT:begin
     result:=VK_FORMAT_UNDEFINED;
    end;
    GL_DEPTH_STENCIL:begin
     result:=VK_FORMAT_UNDEFINED;
    end;
    else begin
     result:=VK_FORMAT_UNDEFINED;
    end;
   end;
  end;
  GL_INT64:begin
   case aFormat of
    GL_RED:begin
     result:=VK_FORMAT_R64_SINT;
    end;
    GL_RG:begin
     result:=VK_FORMAT_R64G64_SINT;
    end;
    GL_RGB:begin
     result:=VK_FORMAT_R64G64B64_SINT;
    end;
    GL_BGR:begin
     result:=VK_FORMAT_UNDEFINED;
    end;
    GL_RGBA:begin
     result:=VK_FORMAT_R64G64B64A64_SINT;
    end;
    GL_BGRA:begin
     result:=VK_FORMAT_UNDEFINED;
    end;
    GL_RED_INTEGER:begin
     result:=VK_FORMAT_R64_SINT;
    end;
    GL_RG_INTEGER:begin
     result:=VK_FORMAT_R64G64_SINT;
    end;
    GL_RGB_INTEGER:begin
     result:=VK_FORMAT_R64G64B64_SINT;
    end;
    GL_BGR_INTEGER:begin
     result:=VK_FORMAT_UNDEFINED;
    end;
    GL_RGBA_INTEGER:begin
     result:=VK_FORMAT_R64G64B64A64_SINT;
    end;
    GL_BGRA_INTEGER:begin
     result:=VK_FORMAT_UNDEFINED;
    end;
    GL_STENCIL_INDEX:begin
     result:=VK_FORMAT_UNDEFINED;
    end;
    GL_DEPTH_COMPONENT:begin
     result:=VK_FORMAT_UNDEFINED;
    end;
    GL_DEPTH_STENCIL:begin
     result:=VK_FORMAT_UNDEFINED;
    end;
    else begin
     result:=VK_FORMAT_UNDEFINED;
    end;
   end;
  end;
  GL_DOUBLE:begin
   case aFormat of
    GL_RED:begin
     result:=VK_FORMAT_R64_SFLOAT;
    end;
    GL_RG:begin
     result:=VK_FORMAT_R64G64_SFLOAT;
    end;
    GL_RGB:begin
     result:=VK_FORMAT_R64G64B64_SFLOAT;
    end;
    GL_BGR:begin
     result:=VK_FORMAT_UNDEFINED;
    end;
    GL_RGBA:begin
     result:=VK_FORMAT_R64G64B64A64_SFLOAT;
    end;
    GL_BGRA:begin
     result:=VK_FORMAT_UNDEFINED;
    end;
    GL_RED_INTEGER:begin
     result:=VK_FORMAT_R64_SFLOAT;
    end;
    GL_RG_INTEGER:begin
     result:=VK_FORMAT_R64G64_SFLOAT;
    end;
    GL_RGB_INTEGER:begin
     result:=VK_FORMAT_R64G64B64_SFLOAT;
    end;
    GL_BGR_INTEGER:begin
     result:=VK_FORMAT_UNDEFINED;
    end;
    GL_RGBA_INTEGER:begin
     result:=VK_FORMAT_R64G64B64A64_SFLOAT;
    end;
    GL_BGRA_INTEGER:begin
     result:=VK_FORMAT_UNDEFINED;
    end;
    GL_STENCIL_INDEX:begin
     result:=VK_FORMAT_UNDEFINED;
    end;
    GL_DEPTH_COMPONENT:begin
     result:=VK_FORMAT_UNDEFINED;
    end;
    GL_DEPTH_STENCIL:begin
     result:=VK_FORMAT_UNDEFINED;
    end;
    else begin
     result:=VK_FORMAT_UNDEFINED;
    end;
   end;
  end;
  GL_UNSIGNED_BYTE_3_3_2:begin
   result:=VK_FORMAT_UNDEFINED;
  end;
  GL_UNSIGNED_BYTE_2_3_3_REV:begin
   result:=VK_FORMAT_UNDEFINED;
  end;
  GL_UNSIGNED_SHORT_5_6_5:begin
   case aFormat of
    GL_RGB,GL_RGB_INTEGER:begin
     result:=VK_FORMAT_R5G6B5_UNORM_PACK16;
    end;
    else begin
     result:=VK_FORMAT_UNDEFINED;
    end;
   end;
  end;
  GL_UNSIGNED_SHORT_5_6_5_REV:begin
   case aFormat of
    GL_BGR,GL_BGR_INTEGER:begin
     result:=VK_FORMAT_B5G6R5_UNORM_PACK16;
    end;
    else begin
     result:=VK_FORMAT_UNDEFINED;
    end;
   end;
  end;
  GL_UNSIGNED_SHORT_4_4_4_4:begin
   case aFormat of
    GL_RGB,GL_BGRA,GL_RGB_INTEGER,GL_BGRA_INTEGER:begin
     result:=VK_FORMAT_R4G4B4A4_UNORM_PACK16;
    end;
    else begin
     result:=VK_FORMAT_UNDEFINED;
    end;
   end;
  end;
  GL_UNSIGNED_SHORT_4_4_4_4_REV:begin
   case aFormat of
    GL_RGB,GL_BGRA,GL_RGB_INTEGER,GL_BGRA_INTEGER:begin
     result:=VK_FORMAT_B4G4R4A4_UNORM_PACK16;
    end;
    else begin
     result:=VK_FORMAT_UNDEFINED;
    end;
   end;
  end;
  GL_UNSIGNED_SHORT_5_5_5_1:begin
   case aFormat of
    GL_RGB,GL_BGRA,GL_RGB_INTEGER,GL_BGRA_INTEGER:begin
     result:=VK_FORMAT_R5G5B5A1_UNORM_PACK16;
    end;
    else begin
     result:=VK_FORMAT_UNDEFINED;
    end;
   end;
  end;
  GL_UNSIGNED_SHORT_1_5_5_5_REV:begin
   case aFormat of
    GL_RGB,GL_BGRA,GL_RGB_INTEGER,GL_BGRA_INTEGER:begin
     result:=VK_FORMAT_A1R5G5B5_UNORM_PACK16;
    end;
    else begin
     result:=VK_FORMAT_UNDEFINED;
    end;
   end;
  end;
  GL_UNSIGNED_INT_8_8_8_8:begin
   case aFormat of
    GL_RGB,GL_BGRA:begin
     result:=VK_FORMAT_R8G8B8A8_UNORM;
    end;
    GL_RGB_INTEGER,GL_BGRA_INTEGER:begin
     result:=VK_FORMAT_R8G8B8A8_UINT;
    end;
    else begin
     result:=VK_FORMAT_UNDEFINED;
    end;
   end;
  end;
  GL_UNSIGNED_INT_8_8_8_8_REV:begin
   case aFormat of
    GL_RGB,GL_BGRA:begin
     result:=VK_FORMAT_A8B8G8R8_UNORM_PACK32;
    end;
    GL_RGB_INTEGER,GL_BGRA_INTEGER:begin
     result:=VK_FORMAT_A8B8G8R8_UINT_PACK32;
    end;
    else begin
     result:=VK_FORMAT_UNDEFINED;
    end;
   end;
  end;
  GL_UNSIGNED_INT_10_10_10_2:begin
   case aFormat of
    GL_RGB,GL_BGRA:begin
     result:=VK_FORMAT_A2R10G10B10_UNORM_PACK32;
    end;
    GL_RGB_INTEGER,GL_BGRA_INTEGER:begin
     result:=VK_FORMAT_A2R10G10B10_UINT_PACK32;
    end;
    else begin
     result:=VK_FORMAT_UNDEFINED;
    end;
   end;
  end;
  GL_UNSIGNED_INT_2_10_10_10_REV:begin
   case aFormat of
    GL_RGB,GL_BGRA:begin
     result:=VK_FORMAT_A2B10G10R10_UINT_PACK32;
    end;
    GL_RGB_INTEGER,GL_BGRA_INTEGER:begin
     result:=VK_FORMAT_A2B10G10R10_UNORM_PACK32;
    end;
    else begin
     result:=VK_FORMAT_UNDEFINED;
    end;
   end;
  end;
  GL_UNSIGNED_INT_10F_11F_11F_REV:begin
   case aFormat of
    GL_RGB,GL_BGR:begin
     result:=VK_FORMAT_B10G11R11_UFLOAT_PACK32;
    end;
    else begin
     result:=VK_FORMAT_UNDEFINED;
    end;
   end;
  end;
  GL_UNSIGNED_INT_5_9_9_9_REV:begin
   case aFormat of
    GL_RGB,GL_BGR:begin
     result:=VK_FORMAT_E5B9G9R9_UFLOAT_PACK32;
    end;
    else begin
     result:=VK_FORMAT_UNDEFINED;
    end;
   end;
  end;
  GL_UNSIGNED_INT_24_8:begin
   case aFormat of
    GL_DEPTH_STENCIL:begin
     result:=VK_FORMAT_D24_UNORM_S8_UINT;
    end;
    else begin
     result:=VK_FORMAT_UNDEFINED;
    end;
   end;
  end;
  GL_FLOAT_32_UNSIGNED_INT_24_8_REV:begin
   case aFormat of
    GL_DEPTH_STENCIL:begin
     result:=VK_FORMAT_D32_SFLOAT_S8_UINT;
    end;
    else begin
     result:=VK_FORMAT_UNDEFINED;
    end;
   end;
  end;
  else begin
   result:=VK_FORMAT_UNDEFINED;
  end;
 end;
end;

function VulkanGetFormatFromOpenGLType(const aType,aNumComponents:TVkUInt32;const aNormalized:boolean):TVkFormat;
begin
 case aType of
  GL_UNSIGNED_BYTE:begin
   case aNumComponents of
    1:begin
     if aNormalized then begin
      result:=VK_FORMAT_R8_UNORM;
     end else begin
      result:=VK_FORMAT_R8_UINT;
     end;
    end;
    2:begin
     if aNormalized then begin
      result:=VK_FORMAT_R8G8_UNORM;
     end else begin
      result:=VK_FORMAT_R8G8_UINT;
     end;
    end;
    3:begin
     if aNormalized then begin
      result:=VK_FORMAT_R8G8B8_UNORM;
     end else begin
      result:=VK_FORMAT_R8G8B8_UINT;
     end;
    end;
    4:begin
     if aNormalized then begin
      result:=VK_FORMAT_R8G8B8A8_UNORM;
     end else begin
      result:=VK_FORMAT_R8G8B8A8_UINT;
     end;
    end;
    else begin
     result:=VK_FORMAT_UNDEFINED;
    end;
   end;
  end;
  GL_BYTE:begin
   case aNumComponents of
    1:begin
     if aNormalized then begin
      result:=VK_FORMAT_R8_SNORM;
     end else begin
      result:=VK_FORMAT_R8_SINT;
     end;
    end;
    2:begin
     if aNormalized then begin
      result:=VK_FORMAT_R8G8_SNORM;
     end else begin
      result:=VK_FORMAT_R8G8_SINT;
     end;
    end;
    3:begin
     if aNormalized then begin
      result:=VK_FORMAT_R8G8B8_SNORM;
     end else begin
      result:=VK_FORMAT_R8G8B8_SINT;
     end;
    end;
    4:begin
     if aNormalized then begin
      result:=VK_FORMAT_R8G8B8A8_SNORM;
     end else begin
      result:=VK_FORMAT_R8G8B8A8_SINT;
     end;
    end;
    else begin
     result:=VK_FORMAT_UNDEFINED;
    end;
   end;
  end;
  GL_UNSIGNED_SHORT:begin
   case aNumComponents of
    1:begin
     if aNormalized then begin
      result:=VK_FORMAT_R16_UNORM;
     end else begin
      result:=VK_FORMAT_R16_UINT;
     end;
    end;
    2:begin
     if aNormalized then begin
      result:=VK_FORMAT_R16G16_UNORM;
     end else begin
      result:=VK_FORMAT_R16G16_UINT;
     end;
    end;
    3:begin
     if aNormalized then begin
      result:=VK_FORMAT_R16G16B16_UNORM;
     end else begin
      result:=VK_FORMAT_R16G16B16_UINT;
     end;
    end;
    4:begin
     if aNormalized then begin
      result:=VK_FORMAT_R16G16B16A16_UNORM;
     end else begin
      result:=VK_FORMAT_R16G16B16A16_UINT;
     end;
    end;
    else begin
     result:=VK_FORMAT_UNDEFINED;
    end;
   end;
  end;
  GL_SHORT:begin
   case aNumComponents of
    1:begin
     if aNormalized then begin
      result:=VK_FORMAT_R16_SNORM;
     end else begin
      result:=VK_FORMAT_R16_SINT;
     end;
    end;
    2:begin
     if aNormalized then begin
      result:=VK_FORMAT_R16G16_SNORM;
     end else begin
      result:=VK_FORMAT_R16G16_SINT;
     end;
    end;
    3:begin
     if aNormalized then begin
      result:=VK_FORMAT_R16G16B16_SNORM;
     end else begin
      result:=VK_FORMAT_R16G16B16_SINT;
     end;
    end;
    4:begin
     if aNormalized then begin
      result:=VK_FORMAT_R16G16B16A16_SNORM;
     end else begin
      result:=VK_FORMAT_R16G16B16A16_SINT;
     end;
    end;
    else begin
     result:=VK_FORMAT_UNDEFINED;
    end;
   end;
  end;
  GL_HALF_FLOAT,GL_HALF_FLOAT_OES:begin
   case aNumComponents of
    1:begin
     result:=VK_FORMAT_R16_SFLOAT;
    end;
    2:begin
     result:=VK_FORMAT_R16G16_SFLOAT;
    end;
    3:begin
     result:=VK_FORMAT_R16G16B16_SFLOAT;
    end;
    4:begin
     result:=VK_FORMAT_R16G16B16A16_SFLOAT;
    end;
    else begin
     result:=VK_FORMAT_UNDEFINED;
    end;
   end;
  end;
  GL_UNSIGNED_INT:begin
   case aNumComponents of
    1:begin
     result:=VK_FORMAT_R32_UINT;
    end;
    2:begin
     result:=VK_FORMAT_R32G32_UINT;
    end;
    3:begin
     result:=VK_FORMAT_R32G32B32_UINT;
    end;
    4:begin
     result:=VK_FORMAT_R32G32B32A32_UINT;
    end;
    else begin
     result:=VK_FORMAT_UNDEFINED;
    end;
   end;
  end;
  GL_INT:begin
   case aNumComponents of
    1:begin
     result:=VK_FORMAT_R32_SINT;
    end;
    2:begin
     result:=VK_FORMAT_R32G32_SINT;
    end;
    3:begin
     result:=VK_FORMAT_R32G32B32_SINT;
    end;
    4:begin
     result:=VK_FORMAT_R32G32B32A32_SINT;
    end;
    else begin
     result:=VK_FORMAT_UNDEFINED;
    end;
   end;
  end;
  GL_FLOAT:begin
   case aNumComponents of
    1:begin
     result:=VK_FORMAT_R32_SFLOAT;
    end;
    2:begin
     result:=VK_FORMAT_R32G32_SFLOAT;
    end;
    3:begin
     result:=VK_FORMAT_R32G32B32_SFLOAT;
    end;
    4:begin
     result:=VK_FORMAT_R32G32B32A32_SFLOAT;
    end;
    else begin
     result:=VK_FORMAT_UNDEFINED;
    end;
   end;
  end;
  GL_UNSIGNED_INT64:begin
   case aNumComponents of
    1:begin
     result:=VK_FORMAT_R64_UINT;
    end;
    2:begin
     result:=VK_FORMAT_R64G64_UINT;
    end;
    3:begin
     result:=VK_FORMAT_R64G64B64_UINT;
    end;
    4:begin
     result:=VK_FORMAT_R64G64B64A64_UINT;
    end;
    else begin
     result:=VK_FORMAT_UNDEFINED;
    end;
   end;
  end;
  GL_INT64:begin
   case aNumComponents of
    1:begin
     result:=VK_FORMAT_R64_SINT;
    end;
    2:begin
     result:=VK_FORMAT_R64G64_SINT;
    end;
    3:begin
     result:=VK_FORMAT_R64G64B64_SINT;
    end;
    4:begin
     result:=VK_FORMAT_R64G64B64A64_SINT;
    end;
    else begin
     result:=VK_FORMAT_UNDEFINED;
    end;
   end;
  end;
  GL_DOUBLE:begin
   case aNumComponents of
    1:begin
     result:=VK_FORMAT_R64_SFLOAT;
    end;
    2:begin
     result:=VK_FORMAT_R64G64_SFLOAT;
    end;
    3:begin
     result:=VK_FORMAT_R64G64B64_SFLOAT;
    end;
    4:begin
     result:=VK_FORMAT_R64G64B64A64_SFLOAT;
    end;
    else begin
     result:=VK_FORMAT_UNDEFINED;
    end;
   end;
  end;
  GL_UNSIGNED_BYTE_3_3_2:begin
   result:=VK_FORMAT_UNDEFINED;
  end;
  GL_UNSIGNED_BYTE_2_3_3_REV:begin
   result:=VK_FORMAT_UNDEFINED;
  end;
  GL_UNSIGNED_SHORT_5_6_5:begin
   result:=VK_FORMAT_R5G6B5_UNORM_PACK16;
  end;
  GL_UNSIGNED_SHORT_5_6_5_REV:begin
   result:=VK_FORMAT_B5G6R5_UNORM_PACK16;
  end;
  GL_UNSIGNED_SHORT_4_4_4_4:begin
   result:=VK_FORMAT_R4G4B4A4_UNORM_PACK16;
  end;
  GL_UNSIGNED_SHORT_4_4_4_4_REV:begin
   result:=VK_FORMAT_B4G4R4A4_UNORM_PACK16;
  end;
  GL_UNSIGNED_SHORT_5_5_5_1:begin
   result:=VK_FORMAT_R5G5B5A1_UNORM_PACK16;
  end;
  GL_UNSIGNED_SHORT_1_5_5_5_REV:begin
   result:=VK_FORMAT_A1R5G5B5_UNORM_PACK16;
  end;
  GL_UNSIGNED_INT_8_8_8_8:begin
   if aNormalized then begin
    result:=VK_FORMAT_R8G8B8A8_UNORM;
   end else begin
    result:=VK_FORMAT_R8G8B8A8_UINT;
   end;
  end;
  GL_UNSIGNED_INT_8_8_8_8_REV:begin
   if aNormalized then begin
    result:=VK_FORMAT_A8B8G8R8_UNORM_PACK32;
   end else begin
    result:=VK_FORMAT_A8B8G8R8_UINT_PACK32;
   end;
  end;
  GL_UNSIGNED_INT_10_10_10_2:begin
   if aNormalized then begin
    result:=VK_FORMAT_A2R10G10B10_UNORM_PACK32;
   end else begin
    result:=VK_FORMAT_A2R10G10B10_UINT_PACK32;
   end;
  end;
  GL_UNSIGNED_INT_2_10_10_10_REV:begin
   if aNormalized then begin
    result:=VK_FORMAT_A2B10G10R10_UNORM_PACK32;
   end else begin
    result:=VK_FORMAT_A2B10G10R10_UINT_PACK32;
   end;
  end;
  GL_UNSIGNED_INT_10F_11F_11F_REV:begin
   result:=VK_FORMAT_B10G11R11_UFLOAT_PACK32;
  end;
  GL_UNSIGNED_INT_5_9_9_9_REV:begin
   result:=VK_FORMAT_E5B9G9R9_UFLOAT_PACK32;
  end;
  GL_UNSIGNED_INT_24_8:begin
   result:=VK_FORMAT_D24_UNORM_S8_UINT;
  end;
  GL_FLOAT_32_UNSIGNED_INT_24_8_REV:begin
   result:=VK_FORMAT_D32_SFLOAT_S8_UINT;
  end;
  else begin
   result:=VK_FORMAT_UNDEFINED;
  end;
 end;
end;

function VulkanGetFormatFromOpenGLInternalFormat(const aInternalFormat:TVkUInt32):TVkFormat;
begin
 case aInternalFormat of
  GL_R8:begin
   result:=VK_FORMAT_R8_UNORM; // 1-component, 8-bit unsigned normalized
  end;
  GL_RG8:begin
   result:=VK_FORMAT_R8G8_UNORM; // 2-component, 8-bit unsigned normalized
  end;
  GL_RGB8:begin
   result:=VK_FORMAT_R8G8B8_UNORM; // 3-component, 8-bit unsigned normalized
  end;
  GL_RGBA8:begin
   result:=VK_FORMAT_R8G8B8A8_UNORM; // 4-component, 8-bit unsigned normalized
  end;
  GL_R8_SNORM:begin
   result:=VK_FORMAT_R8_SNORM; // 1-component, 8-bit signed normalized
  end;
  GL_RG8_SNORM:begin
   result:=VK_FORMAT_R8G8_SNORM; // 2-component, 8-bit signed normalized
  end;
  GL_RGB8_SNORM:begin
   result:=VK_FORMAT_R8G8B8_SNORM; // 3-component, 8-bit signed normalized
  end;
  GL_RGBA8_SNORM:begin
   result:=VK_FORMAT_R8G8B8A8_SNORM; // 4-component, 8-bit signed normalized
  end;
  GL_R8UI:begin
   result:=VK_FORMAT_R8_UINT; // 1-component, 8-bit unsigned integer
  end;
  GL_RG8UI:begin
   result:=VK_FORMAT_R8G8_UINT; // 2-component, 8-bit unsigned integer
  end;
  GL_RGB8UI:begin
   result:=VK_FORMAT_R8G8B8_UINT; // 3-component, 8-bit unsigned integer
  end;
  GL_RGBA8UI:begin
   result:=VK_FORMAT_R8G8B8A8_UINT; // 4-component, 8-bit unsigned integer
  end;
  GL_R8I:begin
   result:=VK_FORMAT_R8_SINT; // 1-component, 8-bit signed integer
  end;
  GL_RG8I:begin
   result:=VK_FORMAT_R8G8_SINT; // 2-component, 8-bit signed integer
  end;
  GL_RGB8I:begin
   result:=VK_FORMAT_R8G8B8_SINT; // 3-component, 8-bit signed integer
  end;
  GL_RGBA8I:begin
   result:=VK_FORMAT_R8G8B8A8_SINT; // 4-component, 8-bit signed integer
  end;
  GL_SR8:begin
   result:=VK_FORMAT_R8_SRGB; // 1-component, 8-bit sRGB
  end;
  GL_SRG8:begin
   result:=VK_FORMAT_R8G8_SRGB; // 2-component, 8-bit sRGB
  end;
  GL_SRGB8:begin
   result:=VK_FORMAT_R8G8B8_SRGB; // 3-component, 8-bit sRGB
  end;
  GL_SRGB8_ALPHA8:begin
   result:=VK_FORMAT_R8G8B8A8_SRGB; // 4-component, 8-bit sRGB
  end;
  GL_R16:begin
   result:=VK_FORMAT_R16_UNORM; // 1-component, 16-bit unsigned normalized
  end;
  GL_RG16:begin
   result:=VK_FORMAT_R16G16_UNORM; // 2-component, 16-bit unsigned normalized
  end;
  GL_RGB16:begin
   result:=VK_FORMAT_R16G16B16_UNORM; // 3-component, 16-bit unsigned normalized
  end;
  GL_RGBA16:begin
   result:=VK_FORMAT_R16G16B16A16_UNORM; // 4-component, 16-bit unsigned normalized
  end;
  GL_R16_SNORM:begin
   result:=VK_FORMAT_R16_SNORM; // 1-component, 16-bit signed normalized
  end;
  GL_RG16_SNORM:begin
   result:=VK_FORMAT_R16G16_SNORM; // 2-component, 16-bit signed normalized
  end;
  GL_RGB16_SNORM:begin
   result:=VK_FORMAT_R16G16B16_SNORM; // 3-component, 16-bit signed normalized
  end;
  GL_RGBA16_SNORM:begin
   result:=VK_FORMAT_R16G16B16A16_SNORM; // 4-component, 16-bit signed normalized
  end;
  GL_R16UI:begin
   result:=VK_FORMAT_R16_UINT; // 1-component, 16-bit unsigned integer
  end;
  GL_RG16UI:begin
   result:=VK_FORMAT_R16G16_UINT; // 2-component, 16-bit unsigned integer
  end;
  GL_RGB16UI:begin
   result:=VK_FORMAT_R16G16B16_UINT; // 3-component, 16-bit unsigned integer
  end;
  GL_RGBA16UI:begin
   result:=VK_FORMAT_R16G16B16A16_UINT; // 4-component, 16-bit unsigned integer
  end;
  GL_R16I:begin
   result:=VK_FORMAT_R16_SINT; // 1-component, 16-bit signed integer
  end;
  GL_RG16I:begin
   result:=VK_FORMAT_R16G16_SINT; // 2-component, 16-bit signed integer
  end;
  GL_RGB16I:begin
   result:=VK_FORMAT_R16G16B16_SINT; // 3-component, 16-bit signed integer
  end;
  GL_RGBA16I:begin
   result:=VK_FORMAT_R16G16B16A16_SINT; // 4-component, 16-bit signed integer
  end;
  GL_R16F:begin
   result:=VK_FORMAT_R16_SFLOAT; // 1-component, 16-bit floating-point
  end;
  GL_RG16F:begin
   result:=VK_FORMAT_R16G16_SFLOAT; // 2-component, 16-bit floating-point
  end;
  GL_RGB16F:begin
   result:=VK_FORMAT_R16G16B16_SFLOAT; // 3-component, 16-bit floating-point
  end;
  GL_RGBA16F:begin
   result:=VK_FORMAT_R16G16B16A16_SFLOAT; // 4-component, 16-bit floating-point
  end;
  GL_R32UI:begin
   result:=VK_FORMAT_R32_UINT; // 1-component, 32-bit unsigned integer
  end;
  GL_RG32UI:begin
   result:=VK_FORMAT_R32G32_UINT; // 2-component, 32-bit unsigned integer
  end;
  GL_RGB32UI:begin
   result:=VK_FORMAT_R32G32B32_UINT; // 3-component, 32-bit unsigned integer
  end;
  GL_RGBA32UI:begin
   result:=VK_FORMAT_R32G32B32A32_UINT; // 4-component, 32-bit unsigned integer
  end;
  GL_R32I:begin
   result:=VK_FORMAT_R32_SINT; // 1-component, 32-bit signed integer
  end;
  GL_RG32I:begin
   result:=VK_FORMAT_R32G32_SINT; // 2-component, 32-bit signed integer
  end;
  GL_RGB32I:begin
   result:=VK_FORMAT_R32G32B32_SINT; // 3-component, 32-bit signed integer
  end;
  GL_RGBA32I:begin
   result:=VK_FORMAT_R32G32B32A32_SINT; // 4-component, 32-bit signed integer
  end;
  GL_R32F:begin
   result:=VK_FORMAT_R32_SFLOAT; // 1-component, 32-bit floating-point
  end;
  GL_RG32F:begin
   result:=VK_FORMAT_R32G32_SFLOAT; // 2-component, 32-bit floating-point
  end;
  GL_RGB32F:begin
   result:=VK_FORMAT_R32G32B32_SFLOAT; // 3-component, 32-bit floating-point
  end;
  GL_RGBA32F:begin
   result:=VK_FORMAT_R32G32B32A32_SFLOAT; // 4-component, 32-bit floating-point
  end;
  GL_R3_G3_B2:begin
   result:=VK_FORMAT_UNDEFINED; // 3-component 3:3:2, unsigned normalized
  end;
  GL_RGB4:begin
   result:=VK_FORMAT_UNDEFINED; // 3-component 4:4:4, unsigned normalized
  end;
  GL_RGB5:begin
   result:=VK_FORMAT_R5G5B5A1_UNORM_PACK16; // 3-component 5:5:5, unsigned normalized
  end;
  GL_RGB565:begin
   result:=VK_FORMAT_R5G6B5_UNORM_PACK16; // 3-component 5:6:5, unsigned normalized
  end;
  GL_RGB10:begin
   result:=VK_FORMAT_A2R10G10B10_UNORM_PACK32; // 3-component 10:10:10, unsigned normalized
  end;
  GL_RGB12:begin
   result:=VK_FORMAT_UNDEFINED; // 3-component 12:12:12, unsigned normalized
  end;
  GL_RGBA2:begin
   result:=VK_FORMAT_UNDEFINED; // 4-component 2:2:2:2, unsigned normalized
  end;
  GL_RGBA4:begin
   result:=VK_FORMAT_R4G4B4A4_UNORM_PACK16; // 4-component 4:4:4:4, unsigned normalized
  end;
  GL_RGBA12:begin
   result:=VK_FORMAT_UNDEFINED; // 4-component 12:12:12:12, unsigned normalized
  end;
  GL_RGB5_A1:begin
   result:=VK_FORMAT_A1R5G5B5_UNORM_PACK16; // 4-component 5:5:5:1, unsigned normalized
  end;
  GL_RGB10_A2:begin
   result:=VK_FORMAT_A2R10G10B10_UNORM_PACK32; // 4-component 10:10:10:2, unsigned normalized
  end;
  GL_RGB10_A2UI:begin
   result:=VK_FORMAT_A2R10G10B10_UINT_PACK32; // 4-component 10:10:10:2, unsigned integer
  end;
  GL_R11F_G11F_B10F:begin
   result:=VK_FORMAT_B10G11R11_UFLOAT_PACK32; // 3-component 11:11:10, floating-point
  end;
  GL_RGB9_E5:begin
   result:=VK_FORMAT_E5B9G9R9_UFLOAT_PACK32; // 3-component/exp 9:9:9/5, floating-point
  end;
  GL_COMPRESSED_RGB_S3TC_DXT1_EXT:begin
   result:=VK_FORMAT_BC1_RGB_UNORM_BLOCK; // line through 3D space, 4x4 blocks, unsigned normalized
  end;
  GL_COMPRESSED_RGBA_S3TC_DXT1_EXT:begin
   result:=VK_FORMAT_BC1_RGBA_UNORM_BLOCK; // line through 3D space plus 1-bit alpha, 4x4 blocks, unsigned normalized
  end;
  GL_COMPRESSED_RGBA_S3TC_DXT5_EXT:begin
   result:=VK_FORMAT_BC2_UNORM_BLOCK; // line through 3D space plus line through 1D space, 4x4 blocks, unsigned normalized
  end;
  GL_COMPRESSED_RGBA_S3TC_DXT3_EXT:begin
   result:=VK_FORMAT_BC3_UNORM_BLOCK; // line through 3D space plus 4-bit alpha, 4x4 blocks, unsigned normalized
  end;
  GL_COMPRESSED_SRGB_S3TC_DXT1_EXT:begin
   result:=VK_FORMAT_BC1_RGB_SRGB_BLOCK; // line through 3D space, 4x4 blocks, sRGB
  end;
  GL_COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT:begin
   result:=VK_FORMAT_BC1_RGBA_SRGB_BLOCK; // line through 3D space plus 1-bit alpha, 4x4 blocks, sRGB
  end;
  GL_COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT:begin
   result:=VK_FORMAT_BC2_SRGB_BLOCK; // line through 3D space plus line through 1D space, 4x4 blocks, sRGB
  end;
  GL_COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT:begin
   result:=VK_FORMAT_BC3_SRGB_BLOCK; // line through 3D space plus 4-bit alpha, 4x4 blocks, sRGB
  end;
  GL_COMPRESSED_LUMINANCE_LATC1_EXT:begin
   result:=VK_FORMAT_BC4_UNORM_BLOCK; // line through 1D space, 4x4 blocks, unsigned normalized
  end;
  GL_COMPRESSED_LUMINANCE_ALPHA_LATC2_EXT:begin
   result:=VK_FORMAT_BC5_UNORM_BLOCK; // two lines through 1D space, 4x4 blocks, unsigned normalized
  end;
  GL_COMPRESSED_SIGNED_LUMINANCE_LATC1_EXT:begin
   result:=VK_FORMAT_BC4_SNORM_BLOCK; // line through 1D space, 4x4 blocks, signed normalized
  end;
  GL_COMPRESSED_SIGNED_LUMINANCE_ALPHA_LATC2_EXT:begin
   result:=VK_FORMAT_BC5_SNORM_BLOCK; // two lines through 1D space, 4x4 blocks, signed normalized
  end;
  GL_COMPRESSED_RED_RGTC1:begin
   result:=VK_FORMAT_BC4_UNORM_BLOCK; // line through 1D space, 4x4 blocks, unsigned normalized
  end;
  GL_COMPRESSED_RG_RGTC2:begin
   result:=VK_FORMAT_BC5_UNORM_BLOCK; // two lines through 1D space, 4x4 blocks, unsigned normalized
  end;
  GL_COMPRESSED_SIGNED_RED_RGTC1:begin
   result:=VK_FORMAT_BC4_SNORM_BLOCK; // line through 1D space, 4x4 blocks, signed normalized
  end;
  GL_COMPRESSED_SIGNED_RG_RGTC2:begin
   result:=VK_FORMAT_BC5_SNORM_BLOCK; // two lines through 1D space, 4x4 blocks, signed normalized
  end;
  GL_COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT:begin
   result:=VK_FORMAT_BC6H_UFLOAT_BLOCK; // 3-component, 4x4 blocks, unsigned floating-point
  end;
  GL_COMPRESSED_RGB_BPTC_SIGNED_FLOAT:begin
   result:=VK_FORMAT_BC6H_SFLOAT_BLOCK; // 3-component, 4x4 blocks, signed floating-point
  end;
  GL_COMPRESSED_RGBA_BPTC_UNORM:begin
   result:=VK_FORMAT_BC7_UNORM_BLOCK; // 4-component, 4x4 blocks, unsigned normalized
  end;
  GL_COMPRESSED_SRGB_ALPHA_BPTC_UNORM:begin
   result:=VK_FORMAT_BC7_SRGB_BLOCK; // 4-component, 4x4 blocks, sRGB
  end;
  GL_ETC1_RGB8_OES:begin
   result:=VK_FORMAT_ETC2_R8G8B8_UNORM_BLOCK; // 3-component ETC1, 4x4 blocks, unsigned normalized
  end;
  GL_COMPRESSED_RGB8_ETC2:begin
   result:=VK_FORMAT_ETC2_R8G8B8_UNORM_BLOCK; // 3-component ETC2, 4x4 blocks, unsigned normalized
  end;
  GL_COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2:begin
   result:=VK_FORMAT_ETC2_R8G8B8A1_UNORM_BLOCK; // 4-component ETC2 with 1-bit alpha, 4x4 blocks, unsigned normalized
  end;
  GL_COMPRESSED_RGBA8_ETC2_EAC:begin
   result:=VK_FORMAT_ETC2_R8G8B8A8_UNORM_BLOCK; // 4-component ETC2, 4x4 blocks, unsigned normalized
  end;
  GL_COMPRESSED_SRGB8_ETC2:begin
   result:=VK_FORMAT_ETC2_R8G8B8_SRGB_BLOCK; // 3-component ETC2, 4x4 blocks, sRGB
  end;
  GL_COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2:begin
   result:=VK_FORMAT_ETC2_R8G8B8A1_SRGB_BLOCK; // 4-component ETC2 with 1-bit alpha, 4x4 blocks, sRGB
  end;
  GL_COMPRESSED_SRGB8_ALPHA8_ETC2_EAC:begin
   result:=VK_FORMAT_ETC2_R8G8B8A8_SRGB_BLOCK; // 4-component ETC2, 4x4 blocks, sRGB
  end;
  GL_COMPRESSED_R11_EAC:begin
   result:=VK_FORMAT_EAC_R11_UNORM_BLOCK; // 1-component ETC, 4x4 blocks, unsigned normalized
  end;
  GL_COMPRESSED_RG11_EAC:begin
   result:=VK_FORMAT_EAC_R11G11_UNORM_BLOCK; // 2-component ETC, 4x4 blocks, unsigned normalized
  end;
  GL_COMPRESSED_SIGNED_R11_EAC:begin
   result:=VK_FORMAT_EAC_R11_SNORM_BLOCK; // 1-component ETC, 4x4 blocks, signed normalized
  end;
  GL_COMPRESSED_SIGNED_RG11_EAC:begin
   result:=VK_FORMAT_EAC_R11G11_SNORM_BLOCK; // 2-component ETC, 4x4 blocks, signed normalized
  end;
  GL_COMPRESSED_RGB_PVRTC_4BPPV1_IMG:begin
   result:=VK_FORMAT_UNDEFINED; // 3-component PVRTC, 16x8 blocks, unsigned normalized
  end;
  GL_COMPRESSED_RGB_PVRTC_2BPPV1_IMG:begin
   result:=VK_FORMAT_UNDEFINED; // 3-component PVRTC, 8x8 blocks, unsigned normalized
  end;
  GL_COMPRESSED_RGBA_PVRTC_4BPPV1_IMG:begin
   result:=VK_FORMAT_UNDEFINED; // 4-component PVRTC, 16x8 blocks, unsigned normalized
  end;
  GL_COMPRESSED_RGBA_PVRTC_2BPPV1_IMG:begin
   result:=VK_FORMAT_UNDEFINED; // 4-component PVRTC, 8x8 blocks, unsigned normalized
  end;
  GL_COMPRESSED_RGBA_PVRTC_2BPPV2_IMG:begin
   result:=VK_FORMAT_UNDEFINED; // 4-component PVRTC, 8x4 blocks, unsigned normalized
  end;
  GL_COMPRESSED_RGBA_PVRTC_4BPPV2_IMG:begin
   result:=VK_FORMAT_UNDEFINED; // 4-component PVRTC, 4x4 blocks, unsigned normalized
  end;
  GL_COMPRESSED_SRGB_PVRTC_2BPPV1_EXT:begin
   result:=VK_FORMAT_UNDEFINED; // 3-component PVRTC, 16x8 blocks, sRGB
  end;
  GL_COMPRESSED_SRGB_PVRTC_4BPPV1_EXT:begin
   result:=VK_FORMAT_UNDEFINED; // 3-component PVRTC, 8x8 blocks, sRGB
  end;
  GL_COMPRESSED_SRGB_ALPHA_PVRTC_2BPPV1_EXT:begin
   result:=VK_FORMAT_UNDEFINED; // 4-component PVRTC, 16x8 blocks, sRGB
  end;
  GL_COMPRESSED_SRGB_ALPHA_PVRTC_4BPPV1_EXT:begin
   result:=VK_FORMAT_UNDEFINED; // 4-component PVRTC, 8x8 blocks, sRGB
  end;
  GL_COMPRESSED_SRGB_ALPHA_PVRTC_2BPPV2_IMG:begin
   result:=VK_FORMAT_UNDEFINED; // 4-component PVRTC, 8x4 blocks, sRGB
  end;
  GL_COMPRESSED_SRGB_ALPHA_PVRTC_4BPPV2_IMG:begin
   result:=VK_FORMAT_UNDEFINED; // 4-component PVRTC, 4x4 blocks, sRGB
  end;
  GL_COMPRESSED_RGBA_ASTC_4x4_KHR:begin
   result:=VK_FORMAT_ASTC_4x4_UNORM_BLOCK; // 4-component ASTC, 4x4 blocks, unsigned normalized
  end;
  GL_COMPRESSED_RGBA_ASTC_5x4_KHR:begin
   result:=VK_FORMAT_ASTC_5x4_UNORM_BLOCK; // 4-component ASTC, 5x4 blocks, unsigned normalized
  end;
  GL_COMPRESSED_RGBA_ASTC_5x5_KHR:begin
   result:=VK_FORMAT_ASTC_5x5_UNORM_BLOCK; // 4-component ASTC, 5x5 blocks, unsigned normalized
  end;
  GL_COMPRESSED_RGBA_ASTC_6x5_KHR:begin
   result:=VK_FORMAT_ASTC_6x5_UNORM_BLOCK; // 4-component ASTC, 6x5 blocks, unsigned normalized
  end;
  GL_COMPRESSED_RGBA_ASTC_6x6_KHR:begin
   result:=VK_FORMAT_ASTC_6x6_UNORM_BLOCK; // 4-component ASTC, 6x6 blocks, unsigned normalized
  end;
  GL_COMPRESSED_RGBA_ASTC_8x5_KHR:begin
   result:=VK_FORMAT_ASTC_8x5_UNORM_BLOCK; // 4-component ASTC, 8x5 blocks, unsigned normalized
  end;
  GL_COMPRESSED_RGBA_ASTC_8x6_KHR:begin
   result:=VK_FORMAT_ASTC_8x6_UNORM_BLOCK; // 4-component ASTC, 8x6 blocks, unsigned normalized
  end;
  GL_COMPRESSED_RGBA_ASTC_8x8_KHR:begin
   result:=VK_FORMAT_ASTC_8x8_UNORM_BLOCK; // 4-component ASTC, 8x8 blocks, unsigned normalized
  end;
  GL_COMPRESSED_RGBA_ASTC_10x5_KHR:begin
   result:=VK_FORMAT_ASTC_10x5_UNORM_BLOCK; // 4-component ASTC, 10x5 blocks, unsigned normalized
  end;
  GL_COMPRESSED_RGBA_ASTC_10x6_KHR:begin
   result:=VK_FORMAT_ASTC_10x6_UNORM_BLOCK; // 4-component ASTC, 10x6 blocks, unsigned normalized
  end;
  GL_COMPRESSED_RGBA_ASTC_10x8_KHR:begin
   result:=VK_FORMAT_ASTC_10x8_UNORM_BLOCK; // 4-component ASTC, 10x8 blocks, unsigned normalized
  end;
  GL_COMPRESSED_RGBA_ASTC_10x10_KHR:begin
   result:=VK_FORMAT_ASTC_10x10_UNORM_BLOCK; // 4-component ASTC, 10x10 blocks, unsigned normalized
  end;
  GL_COMPRESSED_RGBA_ASTC_12x10_KHR:begin
   result:=VK_FORMAT_ASTC_12x10_UNORM_BLOCK; // 4-component ASTC, 12x10 blocks, unsigned normalized
  end;
  GL_COMPRESSED_RGBA_ASTC_12x12_KHR:begin
   result:=VK_FORMAT_ASTC_12x12_UNORM_BLOCK; // 4-component ASTC, 12x12 blocks, unsigned normalized
  end;
  GL_COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR:begin
   result:=VK_FORMAT_ASTC_4x4_SRGB_BLOCK; // 4-component ASTC, 4x4 blocks, sRGB
  end;
  GL_COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR:begin
   result:=VK_FORMAT_ASTC_5x4_SRGB_BLOCK; // 4-component ASTC, 5x4 blocks, sRGB
  end;
  GL_COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR:begin
   result:=VK_FORMAT_ASTC_5x5_SRGB_BLOCK; // 4-component ASTC, 5x5 blocks, sRGB
  end;
  GL_COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR:begin
   result:=VK_FORMAT_ASTC_6x5_SRGB_BLOCK; // 4-component ASTC, 6x5 blocks, sRGB
  end;
  GL_COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR:begin
   result:=VK_FORMAT_ASTC_6x6_SRGB_BLOCK; // 4-component ASTC, 6x6 blocks, sRGB
  end;
  GL_COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR:begin
   result:=VK_FORMAT_ASTC_8x5_SRGB_BLOCK; // 4-component ASTC, 8x5 blocks, sRGB
  end;
  GL_COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR:begin
   result:=VK_FORMAT_ASTC_8x6_SRGB_BLOCK; // 4-component ASTC, 8x6 blocks, sRGB
  end;
  GL_COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR:begin
   result:=VK_FORMAT_ASTC_8x8_SRGB_BLOCK; // 4-component ASTC, 8x8 blocks, sRGB
  end;
  GL_COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR:begin
   result:=VK_FORMAT_ASTC_10x5_SRGB_BLOCK; // 4-component ASTC, 10x5 blocks, sRGB
  end;
  GL_COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR:begin
   result:=VK_FORMAT_ASTC_10x6_SRGB_BLOCK; // 4-component ASTC, 10x6 blocks, sRGB
  end;
  GL_COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR:begin
   result:=VK_FORMAT_ASTC_10x8_SRGB_BLOCK; // 4-component ASTC, 10x8 blocks, sRGB
  end;
  GL_COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR:begin
   result:=VK_FORMAT_ASTC_10x10_SRGB_BLOCK; // 4-component ASTC, 10x10 blocks, sRGB
  end;
  GL_COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR:begin
   result:=VK_FORMAT_ASTC_12x10_SRGB_BLOCK; // 4-component ASTC, 12x10 blocks, sRGB
  end;
  GL_COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR:begin
   result:=VK_FORMAT_ASTC_12x12_SRGB_BLOCK; // 4-component ASTC, 12x12 blocks, sRGB
  end;
  GL_COMPRESSED_RGBA_ASTC_3x3x3_OES:begin
   result:=VK_FORMAT_UNDEFINED; // 4-component ASTC, 3x3x3 blocks, unsigned normalized
  end;
  GL_COMPRESSED_RGBA_ASTC_4x3x3_OES:begin
   result:=VK_FORMAT_UNDEFINED; // 4-component ASTC, 4x3x3 blocks, unsigned normalized
  end;
  GL_COMPRESSED_RGBA_ASTC_4x4x3_OES:begin
   result:=VK_FORMAT_UNDEFINED; // 4-component ASTC, 4x4x3 blocks, unsigned normalized
  end;
  GL_COMPRESSED_RGBA_ASTC_4x4x4_OES:begin
   result:=VK_FORMAT_UNDEFINED; // 4-component ASTC, 4x4x4 blocks, unsigned normalized
  end;
  GL_COMPRESSED_RGBA_ASTC_5x4x4_OES:begin
   result:=VK_FORMAT_UNDEFINED; // 4-component ASTC, 5x4x4 blocks, unsigned normalized
  end;
  GL_COMPRESSED_RGBA_ASTC_5x5x4_OES:begin
   result:=VK_FORMAT_UNDEFINED; // 4-component ASTC, 5x5x4 blocks, unsigned normalized
  end;
  GL_COMPRESSED_RGBA_ASTC_5x5x5_OES:begin
   result:=VK_FORMAT_UNDEFINED; // 4-component ASTC, 5x5x5 blocks, unsigned normalized
  end;
  GL_COMPRESSED_RGBA_ASTC_6x5x5_OES:begin
   result:=VK_FORMAT_UNDEFINED; // 4-component ASTC, 6x5x5 blocks, unsigned normalized
  end;
  GL_COMPRESSED_RGBA_ASTC_6x6x5_OES:begin
   result:=VK_FORMAT_UNDEFINED; // 4-component ASTC, 6x6x5 blocks, unsigned normalized
  end;
  GL_COMPRESSED_RGBA_ASTC_6x6x6_OES:begin
   result:=VK_FORMAT_UNDEFINED; // 4-component ASTC, 6x6x6 blocks, unsigned normalized
  end;
  GL_COMPRESSED_SRGB8_ALPHA8_ASTC_3x3x3_OES:begin
   result:=VK_FORMAT_UNDEFINED; // 4-component ASTC, 3x3x3 blocks, sRGB
  end;
  GL_COMPRESSED_SRGB8_ALPHA8_ASTC_4x3x3_OES:begin
   result:=VK_FORMAT_UNDEFINED; // 4-component ASTC, 4x3x3 blocks, sRGB
  end;
  GL_COMPRESSED_SRGB8_ALPHA8_ASTC_4x4x3_OES:begin
   result:=VK_FORMAT_UNDEFINED; // 4-component ASTC, 4x4x3 blocks, sRGB
  end;
  GL_COMPRESSED_SRGB8_ALPHA8_ASTC_4x4x4_OES:begin
   result:=VK_FORMAT_UNDEFINED; // 4-component ASTC, 4x4x4 blocks, sRGB
  end;
  GL_COMPRESSED_SRGB8_ALPHA8_ASTC_5x4x4_OES:begin
   result:=VK_FORMAT_UNDEFINED; // 4-component ASTC, 5x4x4 blocks, sRGB
  end;
  GL_COMPRESSED_SRGB8_ALPHA8_ASTC_5x5x4_OES:begin
   result:=VK_FORMAT_UNDEFINED; // 4-component ASTC, 5x5x4 blocks, sRGB
  end;
  GL_COMPRESSED_SRGB8_ALPHA8_ASTC_5x5x5_OES:begin
   result:=VK_FORMAT_UNDEFINED; // 4-component ASTC, 5x5x5 blocks, sRGB
  end;
  GL_COMPRESSED_SRGB8_ALPHA8_ASTC_6x5x5_OES:begin
   result:=VK_FORMAT_UNDEFINED; // 4-component ASTC, 6x5x5 blocks, sRGB
  end;
  GL_COMPRESSED_SRGB8_ALPHA8_ASTC_6x6x5_OES:begin
   result:=VK_FORMAT_UNDEFINED; // 4-component ASTC, 6x6x5 blocks, sRGB
  end;
  GL_COMPRESSED_SRGB8_ALPHA8_ASTC_6x6x6_OES:begin
   result:=VK_FORMAT_UNDEFINED; // 4-component ASTC, 6x6x6 blocks, sRGB
  end;
  GL_ATC_RGB_AMD:begin
   result:=VK_FORMAT_UNDEFINED; // 3-component, 4x4 blocks, unsigned normalized
  end;
  GL_ATC_RGBA_EXPLICIT_ALPHA_AMD:begin
   result:=VK_FORMAT_UNDEFINED; // 4-component, 4x4 blocks, unsigned normalized
  end;
  GL_ATC_RGBA_INTERPOLATED_ALPHA_AMD:begin
   result:=VK_FORMAT_UNDEFINED; // 4-component, 4x4 blocks, unsigned normalized
  end;
  GL_PALETTE4_RGB8_OES:begin
   result:=VK_FORMAT_UNDEFINED; // 3-component 8:8:8, 4-bit palette, unsigned normalized
  end;
  GL_PALETTE4_RGBA8_OES:begin
   result:=VK_FORMAT_UNDEFINED; // 4-component 8:8:8:8, 4-bit palette, unsigned normalized
  end;
  GL_PALETTE4_R5_G6_B5_OES:begin
   result:=VK_FORMAT_UNDEFINED; // 3-component 5:6:5, 4-bit palette, unsigned normalized
  end;
  GL_PALETTE4_RGBA4_OES:begin
   result:=VK_FORMAT_UNDEFINED; // 4-component 4:4:4:4, 4-bit palette, unsigned normalized
  end;
  GL_PALETTE4_RGB5_A1_OES:begin
   result:=VK_FORMAT_UNDEFINED; // 4-component 5:5:5:1, 4-bit palette, unsigned normalized
  end;
  GL_PALETTE8_RGB8_OES:begin
   result:=VK_FORMAT_UNDEFINED; // 3-component 8:8:8, 8-bit palette, unsigned normalized
  end;
  GL_PALETTE8_RGBA8_OES:begin
   result:=VK_FORMAT_UNDEFINED; // 4-component 8:8:8:8, 8-bit palette, unsigned normalized
  end;
  GL_PALETTE8_R5_G6_B5_OES:begin
   result:=VK_FORMAT_UNDEFINED; // 3-component 5:6:5, 8-bit palette, unsigned normalized
  end;
  GL_PALETTE8_RGBA4_OES:begin
   result:=VK_FORMAT_UNDEFINED; // 4-component 4:4:4:4, 8-bit palette, unsigned normalized
  end;
  GL_PALETTE8_RGB5_A1_OES:begin
   result:=VK_FORMAT_UNDEFINED; // 4-component 5:5:5:1, 8-bit palette, unsigned normalized
  end;
  GL_DEPTH_COMPONENT16:begin
   result:=VK_FORMAT_D16_UNORM;
  end;
  GL_DEPTH_COMPONENT24:begin
   result:=VK_FORMAT_X8_D24_UNORM_PACK32;
  end;
  GL_DEPTH_COMPONENT32:begin
   result:=VK_FORMAT_UNDEFINED;
  end;
  GL_DEPTH_COMPONENT32F:begin
   result:=VK_FORMAT_D32_SFLOAT;
  end;
  GL_DEPTH_COMPONENT32F_NV:begin
   result:=VK_FORMAT_D32_SFLOAT;
  end;
  GL_STENCIL_INDEX1:begin
   result:=VK_FORMAT_UNDEFINED;
  end;
  GL_STENCIL_INDEX4:begin
   result:=VK_FORMAT_UNDEFINED;
  end;
  GL_STENCIL_INDEX8:begin
   result:=VK_FORMAT_S8_UINT;
  end;
  GL_STENCIL_INDEX16:begin
   result:=VK_FORMAT_UNDEFINED;
  end;
  GL_DEPTH24_STENCIL8:begin
   result:=VK_FORMAT_D24_UNORM_S8_UINT;
  end;
  GL_DEPTH32F_STENCIL8:begin
   result:=VK_FORMAT_D32_SFLOAT_S8_UINT;
  end;
  GL_DEPTH32F_STENCIL8_NV:begin
   result:=VK_FORMAT_D32_SFLOAT_S8_UINT;
  end;
  else begin
   result:=VK_FORMAT_UNDEFINED;
  end;
 end;
end;

function VulkanGetFormatSize(const aFormat:TVkFormat):TVulkanFormatSize;
begin
 case aFormat of
  VK_FORMAT_R4G4_UNORM_PACK8:begin
   result.Flags:=[vfsfPacked];
   result.PaletteSizeInBits:=0;
   result.BlockSizeInBits:=1*8;
   result.BlockWidth:=1;
   result.BlockHeight:=1;
   result.BlockDepth:=1;
  end;
  VK_FORMAT_R4G4B4A4_UNORM_PACK16,VK_FORMAT_B4G4R4A4_UNORM_PACK16,VK_FORMAT_R5G6B5_UNORM_PACK16,VK_FORMAT_B5G6R5_UNORM_PACK16,VK_FORMAT_R5G5B5A1_UNORM_PACK16,VK_FORMAT_B5G5R5A1_UNORM_PACK16,VK_FORMAT_A1R5G5B5_UNORM_PACK16:begin
   result.Flags:=[vfsfPacked];
   result.PaletteSizeInBits:=0;
   result.BlockSizeInBits:=2*8;
   result.BlockWidth:=1;
   result.BlockHeight:=1;
   result.BlockDepth:=1;
  end;
  VK_FORMAT_R8_UNORM,VK_FORMAT_R8_SNORM,VK_FORMAT_R8_USCALED,VK_FORMAT_R8_SSCALED,VK_FORMAT_R8_UINT,VK_FORMAT_R8_SINT,VK_FORMAT_R8_SRGB:begin
   result.Flags:=[];
   result.PaletteSizeInBits:=0;
   result.BlockSizeInBits:=1*8;
   result.BlockWidth:=1;
   result.BlockHeight:=1;
   result.BlockDepth:=1;
  end;
  VK_FORMAT_R8G8_UNORM,VK_FORMAT_R8G8_SNORM,VK_FORMAT_R8G8_USCALED,VK_FORMAT_R8G8_SSCALED,VK_FORMAT_R8G8_UINT,VK_FORMAT_R8G8_SINT,VK_FORMAT_R8G8_SRGB:begin
   result.Flags:=[];
   result.PaletteSizeInBits:=0;
   result.BlockSizeInBits:=2*8;
   result.BlockWidth:=1;
   result.BlockHeight:=1;
   result.BlockDepth:=1;
  end;
  VK_FORMAT_R8G8B8_UNORM,VK_FORMAT_R8G8B8_SNORM,VK_FORMAT_R8G8B8_USCALED,VK_FORMAT_R8G8B8_SSCALED,VK_FORMAT_R8G8B8_UINT,VK_FORMAT_R8G8B8_SINT,VK_FORMAT_R8G8B8_SRGB,VK_FORMAT_B8G8R8_UNORM,VK_FORMAT_B8G8R8_SNORM,VK_FORMAT_B8G8R8_USCALED,VK_FORMAT_B8G8R8_SSCALED,VK_FORMAT_B8G8R8_UINT,VK_FORMAT_B8G8R8_SINT,VK_FORMAT_B8G8R8_SRGB:begin
   result.Flags:=[];
   result.PaletteSizeInBits:=0;
   result.BlockSizeInBits:=3*8;
   result.BlockWidth:=1;
   result.BlockHeight:=1;
   result.BlockDepth:=1;
  end;
  VK_FORMAT_R8G8B8A8_UNORM,
  VK_FORMAT_R8G8B8A8_SNORM,VK_FORMAT_R8G8B8A8_USCALED,VK_FORMAT_R8G8B8A8_SSCALED,VK_FORMAT_R8G8B8A8_UINT,VK_FORMAT_R8G8B8A8_SINT,VK_FORMAT_R8G8B8A8_SRGB,VK_FORMAT_B8G8R8A8_UNORM,VK_FORMAT_B8G8R8A8_SNORM,VK_FORMAT_B8G8R8A8_USCALED,VK_FORMAT_B8G8R8A8_SSCALED,VK_FORMAT_B8G8R8A8_UINT,VK_FORMAT_B8G8R8A8_SINT,VK_FORMAT_B8G8R8A8_SRGB:begin
   result.Flags:=[];
   result.PaletteSizeInBits:=0;
   result.BlockSizeInBits:=4*8;
   result.BlockWidth:=1;
   result.BlockHeight:=1;
   result.BlockDepth:=1;
  end;
  VK_FORMAT_A8B8G8R8_UNORM_PACK32,VK_FORMAT_A8B8G8R8_SNORM_PACK32,VK_FORMAT_A8B8G8R8_USCALED_PACK32,VK_FORMAT_A8B8G8R8_SSCALED_PACK32,VK_FORMAT_A8B8G8R8_UINT_PACK32,VK_FORMAT_A8B8G8R8_SINT_PACK32,VK_FORMAT_A8B8G8R8_SRGB_PACK32:begin
   result.Flags:=[vfsfPacked];
   result.PaletteSizeInBits:=0;
   result.BlockSizeInBits:=4*8;
   result.BlockWidth:=1;
   result.BlockHeight:=1;
   result.BlockDepth:=1;
  end;
  VK_FORMAT_A2R10G10B10_UNORM_PACK32,VK_FORMAT_A2R10G10B10_SNORM_PACK32,VK_FORMAT_A2R10G10B10_USCALED_PACK32,VK_FORMAT_A2R10G10B10_SSCALED_PACK32,VK_FORMAT_A2R10G10B10_UINT_PACK32,VK_FORMAT_A2R10G10B10_SINT_PACK32,VK_FORMAT_A2B10G10R10_UNORM_PACK32,VK_FORMAT_A2B10G10R10_SNORM_PACK32,VK_FORMAT_A2B10G10R10_USCALED_PACK32,VK_FORMAT_A2B10G10R10_SSCALED_PACK32,VK_FORMAT_A2B10G10R10_UINT_PACK32,VK_FORMAT_A2B10G10R10_SINT_PACK32:begin
   result.Flags:=[vfsfPacked];
   result.PaletteSizeInBits:=0;
   result.BlockSizeInBits:=4*8;
   result.BlockWidth:=1;
   result.BlockHeight:=1;
   result.BlockDepth:=1;
  end;
  VK_FORMAT_R16_UNORM,VK_FORMAT_R16_SNORM,VK_FORMAT_R16_USCALED,VK_FORMAT_R16_SSCALED,VK_FORMAT_R16_UINT,VK_FORMAT_R16_SINT,VK_FORMAT_R16_SFLOAT:begin
   result.Flags:=[];
   result.PaletteSizeInBits:=0;
   result.BlockSizeInBits:=2*8;
   result.BlockWidth:=1;
   result.BlockHeight:=1;
   result.BlockDepth:=1;
  end;
  VK_FORMAT_R16G16_UNORM,VK_FORMAT_R16G16_SNORM,VK_FORMAT_R16G16_USCALED,VK_FORMAT_R16G16_SSCALED,VK_FORMAT_R16G16_UINT,VK_FORMAT_R16G16_SINT,VK_FORMAT_R16G16_SFLOAT:begin
   result.Flags:=[];
   result.PaletteSizeInBits:=0;
   result.BlockSizeInBits:=4*8;
   result.BlockWidth:=1;
   result.BlockHeight:=1;
   result.BlockDepth:=1;
  end;
  VK_FORMAT_R16G16B16_UNORM,VK_FORMAT_R16G16B16_SNORM,VK_FORMAT_R16G16B16_USCALED,VK_FORMAT_R16G16B16_SSCALED,VK_FORMAT_R16G16B16_UINT,VK_FORMAT_R16G16B16_SINT,VK_FORMAT_R16G16B16_SFLOAT:begin
   result.Flags:=[];
   result.PaletteSizeInBits:=0;
   result.BlockSizeInBits:=6*8;
   result.BlockWidth:=1;
   result.BlockHeight:=1;
   result.BlockDepth:=1;
  end;
  VK_FORMAT_R16G16B16A16_UNORM,VK_FORMAT_R16G16B16A16_SNORM,VK_FORMAT_R16G16B16A16_USCALED,VK_FORMAT_R16G16B16A16_SSCALED,VK_FORMAT_R16G16B16A16_UINT,VK_FORMAT_R16G16B16A16_SINT,VK_FORMAT_R16G16B16A16_SFLOAT:begin
   result.Flags:=[];
   result.PaletteSizeInBits:=0;
   result.BlockSizeInBits:=8*8;
   result.BlockWidth:=1;
   result.BlockHeight:=1;
   result.BlockDepth:=1;
  end;
  VK_FORMAT_R32_UINT,VK_FORMAT_R32_SINT,VK_FORMAT_R32_SFLOAT:begin
   result.Flags:=[];
   result.PaletteSizeInBits:=0;
   result.BlockSizeInBits:=4*8;
   result.BlockWidth:=1;
   result.BlockHeight:=1;
   result.BlockDepth:=1;
  end;
  VK_FORMAT_R32G32_UINT,VK_FORMAT_R32G32_SINT,VK_FORMAT_R32G32_SFLOAT:begin
   result.Flags:=[];
   result.PaletteSizeInBits:=0;
   result.BlockSizeInBits:=8*8;
   result.BlockWidth:=1;
   result.BlockHeight:=1;
   result.BlockDepth:=1;
  end;
  VK_FORMAT_R32G32B32_UINT,VK_FORMAT_R32G32B32_SINT,VK_FORMAT_R32G32B32_SFLOAT:begin
   result.Flags:=[];
   result.PaletteSizeInBits:=0;
   result.BlockSizeInBits:=12*8;
   result.BlockWidth:=1;
   result.BlockHeight:=1;
   result.BlockDepth:=1;
  end;
  VK_FORMAT_R32G32B32A32_UINT,VK_FORMAT_R32G32B32A32_SINT,VK_FORMAT_R32G32B32A32_SFLOAT:begin
   result.Flags:=[];
   result.PaletteSizeInBits:=0;
   result.BlockSizeInBits:=16*8;
   result.BlockWidth:=1;
   result.BlockHeight:=1;
   result.BlockDepth:=1;
  end;
  VK_FORMAT_R64_UINT,VK_FORMAT_R64_SINT,VK_FORMAT_R64_SFLOAT:begin
   result.Flags:=[];
   result.PaletteSizeInBits:=0;
   result.BlockSizeInBits:=8*8;
   result.BlockWidth:=1;
   result.BlockHeight:=1;
   result.BlockDepth:=1;
  end;
  VK_FORMAT_R64G64_UINT,VK_FORMAT_R64G64_SINT,VK_FORMAT_R64G64_SFLOAT:begin
   result.Flags:=[];
   result.PaletteSizeInBits:=0;
   result.BlockSizeInBits:=16*8;
   result.BlockWidth:=1;
   result.BlockHeight:=1;
   result.BlockDepth:=1;
  end;
  VK_FORMAT_R64G64B64_UINT,VK_FORMAT_R64G64B64_SINT,VK_FORMAT_R64G64B64_SFLOAT:begin
   result.Flags:=[];
   result.PaletteSizeInBits:=0;
   result.BlockSizeInBits:=24*8;
   result.BlockWidth:=1;
   result.BlockHeight:=1;
   result.BlockDepth:=1;
  end;
  VK_FORMAT_R64G64B64A64_UINT,VK_FORMAT_R64G64B64A64_SINT,VK_FORMAT_R64G64B64A64_SFLOAT:begin
   result.Flags:=[];
   result.PaletteSizeInBits:=0;
   result.BlockSizeInBits:=32*8;
   result.BlockWidth:=1;
   result.BlockHeight:=1;
   result.BlockDepth:=1;
  end;
  VK_FORMAT_B10G11R11_UFLOAT_PACK32,VK_FORMAT_E5B9G9R9_UFLOAT_PACK32:begin
   result.Flags:=[vfsfPacked];
   result.PaletteSizeInBits:=0;
   result.BlockSizeInBits:=4*8;
   result.BlockWidth:=1;
   result.BlockHeight:=1;
   result.BlockDepth:=1;
  end;
  VK_FORMAT_D16_UNORM:begin
   result.Flags:=[vfsfDepth];
   result.PaletteSizeInBits:=0;
   result.BlockSizeInBits:=2*8;
   result.BlockWidth:=1;
   result.BlockHeight:=1;
   result.BlockDepth:=1;
  end;
  VK_FORMAT_X8_D24_UNORM_PACK32:begin
   result.Flags:=[vfsfPacked,vfsfDepth];
   result.PaletteSizeInBits:=0;
   result.BlockSizeInBits:=4*8;
   result.BlockWidth:=1;
   result.BlockHeight:=1;
   result.BlockDepth:=1;
  end;
  VK_FORMAT_D32_SFLOAT:begin
   result.Flags:=[vfsfDepth];
   result.PaletteSizeInBits:=0;
   result.BlockSizeInBits:=4*8;
   result.BlockWidth:=1;
   result.BlockHeight:=1;
   result.BlockDepth:=1;
  end;
  VK_FORMAT_S8_UINT:begin
   result.Flags:=[vfsfStencil];
   result.PaletteSizeInBits:=0;
   result.BlockSizeInBits:=1*8;
   result.BlockWidth:=1;
   result.BlockHeight:=1;
   result.BlockDepth:=1;
  end;
  VK_FORMAT_D16_UNORM_S8_UINT:begin
   result.Flags:=[vfsfDepth,vfsfStencil];
   result.PaletteSizeInBits:=0;
   result.BlockSizeInBits:=3*8;
   result.BlockWidth:=1;
   result.BlockHeight:=1;
   result.BlockDepth:=1;
  end;
  VK_FORMAT_D24_UNORM_S8_UINT:begin
   result.Flags:=[vfsfDepth,vfsfStencil];
   result.PaletteSizeInBits:=0;
   result.BlockSizeInBits:=4*8;
   result.BlockWidth:=1;
   result.BlockHeight:=1;
   result.BlockDepth:=1;
  end;
  VK_FORMAT_D32_SFLOAT_S8_UINT:begin
   result.Flags:=[vfsfDepth,vfsfStencil];
   result.PaletteSizeInBits:=0;
   result.BlockSizeInBits:=8*8;
   result.BlockWidth:=1;
   result.BlockHeight:=1;
   result.BlockDepth:=1;
  end;
  VK_FORMAT_BC1_RGB_UNORM_BLOCK,VK_FORMAT_BC1_RGB_SRGB_BLOCK,VK_FORMAT_BC1_RGBA_UNORM_BLOCK,VK_FORMAT_BC1_RGBA_SRGB_BLOCK:begin
   result.Flags:=[vfsfCompressed];
   result.PaletteSizeInBits:=0;
   result.BlockSizeInBits:=8*8;
   result.BlockWidth:=4;
   result.BlockHeight:=4;
   result.BlockDepth:=1;
  end;
  VK_FORMAT_BC2_UNORM_BLOCK,VK_FORMAT_BC2_SRGB_BLOCK,VK_FORMAT_BC3_UNORM_BLOCK,VK_FORMAT_BC3_SRGB_BLOCK,VK_FORMAT_BC4_UNORM_BLOCK,VK_FORMAT_BC4_SNORM_BLOCK,VK_FORMAT_BC5_UNORM_BLOCK,VK_FORMAT_BC5_SNORM_BLOCK,VK_FORMAT_BC6H_UFLOAT_BLOCK,VK_FORMAT_BC6H_SFLOAT_BLOCK,VK_FORMAT_BC7_UNORM_BLOCK,VK_FORMAT_BC7_SRGB_BLOCK:begin
   result.Flags:=[vfsfCompressed];
   result.PaletteSizeInBits:=0;
   result.BlockSizeInBits:=16*8;
   result.BlockWidth:=4;
   result.BlockHeight:=4;
   result.BlockDepth:=1;
  end;
  VK_FORMAT_ETC2_R8G8B8_UNORM_BLOCK,VK_FORMAT_ETC2_R8G8B8_SRGB_BLOCK,VK_FORMAT_ETC2_R8G8B8A1_UNORM_BLOCK,VK_FORMAT_ETC2_R8G8B8A1_SRGB_BLOCK:begin
   result.Flags:=[vfsfCompressed];
   result.PaletteSizeInBits:=0;
   result.BlockSizeInBits:=8*8;
   result.BlockWidth:=4;
   result.BlockHeight:=4;
   result.BlockDepth:=1;
  end;
  VK_FORMAT_ETC2_R8G8B8A8_UNORM_BLOCK,VK_FORMAT_ETC2_R8G8B8A8_SRGB_BLOCK,VK_FORMAT_EAC_R11_UNORM_BLOCK,VK_FORMAT_EAC_R11_SNORM_BLOCK,VK_FORMAT_EAC_R11G11_UNORM_BLOCK,VK_FORMAT_EAC_R11G11_SNORM_BLOCK:begin
   result.Flags:=[vfsfCompressed];
   result.PaletteSizeInBits:=0;
   result.BlockSizeInBits:=16*8;
   result.BlockWidth:=4;
   result.BlockHeight:=4;
   result.BlockDepth:=1;
  end;
  VK_FORMAT_ASTC_4x4_UNORM_BLOCK,VK_FORMAT_ASTC_4x4_SRGB_BLOCK:begin
   result.Flags:=[vfsfCompressed];
   result.PaletteSizeInBits:=0;
   result.BlockSizeInBits:=16*8;
   result.BlockWidth:=4;
   result.BlockHeight:=4;
   result.BlockDepth:=1;
  end;
  VK_FORMAT_ASTC_5x4_UNORM_BLOCK,VK_FORMAT_ASTC_5x4_SRGB_BLOCK:begin
   result.Flags:=[vfsfCompressed];
   result.PaletteSizeInBits:=0;
   result.BlockSizeInBits:=16*8;
   result.BlockWidth:=5;
   result.BlockHeight:=4;
   result.BlockDepth:=1;
  end;
  VK_FORMAT_ASTC_5x5_UNORM_BLOCK,VK_FORMAT_ASTC_5x5_SRGB_BLOCK:begin
   result.Flags:=[vfsfCompressed];
   result.PaletteSizeInBits:=0;
   result.BlockSizeInBits:=16*8;
   result.BlockWidth:=5;
   result.BlockHeight:=5;
   result.BlockDepth:=1;
  end;
  VK_FORMAT_ASTC_6x5_UNORM_BLOCK,VK_FORMAT_ASTC_6x5_SRGB_BLOCK:begin
   result.Flags:=[vfsfCompressed];
   result.PaletteSizeInBits:=0;
   result.BlockSizeInBits:=16*8;
   result.BlockWidth:=6;
   result.BlockHeight:=5;
   result.BlockDepth:=1;
  end;
  VK_FORMAT_ASTC_6x6_UNORM_BLOCK,VK_FORMAT_ASTC_6x6_SRGB_BLOCK:begin
   result.Flags:=[vfsfCompressed];
   result.PaletteSizeInBits:=0;
   result.BlockSizeInBits:=16*8;
   result.BlockWidth:=6;
   result.BlockHeight:=6;
   result.BlockDepth:=1;
  end;
  VK_FORMAT_ASTC_8x5_UNORM_BLOCK,VK_FORMAT_ASTC_8x5_SRGB_BLOCK:begin
   result.Flags:=[vfsfCompressed];
   result.PaletteSizeInBits:=0;
   result.BlockSizeInBits:=16*8;
   result.BlockWidth:=8;
   result.BlockHeight:=5;
   result.BlockDepth:=1;
  end;
  VK_FORMAT_ASTC_8x6_UNORM_BLOCK,VK_FORMAT_ASTC_8x6_SRGB_BLOCK:begin
   result.Flags:=[vfsfCompressed];
   result.PaletteSizeInBits:=0;
   result.BlockSizeInBits:=16*8;
   result.BlockWidth:=8;
   result.BlockHeight:=6;
   result.BlockDepth:=1;
  end;
  VK_FORMAT_ASTC_8x8_UNORM_BLOCK,VK_FORMAT_ASTC_8x8_SRGB_BLOCK:begin
   result.Flags:=[vfsfCompressed];
   result.PaletteSizeInBits:=0;
   result.BlockSizeInBits:=16*8;
   result.BlockWidth:=8;
   result.BlockHeight:=8;
   result.BlockDepth:=1;
  end;
  VK_FORMAT_ASTC_10x5_UNORM_BLOCK,VK_FORMAT_ASTC_10x5_SRGB_BLOCK:begin
   result.Flags:=[vfsfCompressed];
   result.PaletteSizeInBits:=0;
   result.BlockSizeInBits:=16*8;
   result.BlockWidth:=10;
   result.BlockHeight:=5;
   result.BlockDepth:=1;
  end;
  VK_FORMAT_ASTC_10x6_UNORM_BLOCK,VK_FORMAT_ASTC_10x6_SRGB_BLOCK:begin
   result.Flags:=[vfsfCompressed];
   result.PaletteSizeInBits:=0;
   result.BlockSizeInBits:=16*8;
   result.BlockWidth:=10;
   result.BlockHeight:=6;
   result.BlockDepth:=1;
  end;
  VK_FORMAT_ASTC_10x8_UNORM_BLOCK,VK_FORMAT_ASTC_10x8_SRGB_BLOCK:begin
   result.Flags:=[vfsfCompressed];
   result.PaletteSizeInBits:=0;
   result.BlockSizeInBits:=16*8;
   result.BlockWidth:=10;
   result.BlockHeight:=8;
   result.BlockDepth:=1;
  end;
  VK_FORMAT_ASTC_10x10_UNORM_BLOCK,VK_FORMAT_ASTC_10x10_SRGB_BLOCK:begin
   result.Flags:=[vfsfCompressed];
   result.PaletteSizeInBits:=0;
   result.BlockSizeInBits:=16*8;
   result.BlockWidth:=10;
   result.BlockHeight:=10;
   result.BlockDepth:=1;
  end;
  VK_FORMAT_ASTC_12x10_UNORM_BLOCK,VK_FORMAT_ASTC_12x10_SRGB_BLOCK:begin
   result.Flags:=[vfsfCompressed];
   result.PaletteSizeInBits:=0;
   result.BlockSizeInBits:=16*8;
   result.BlockWidth:=12;
   result.BlockHeight:=10;
   result.BlockDepth:=1;
  end;
  VK_FORMAT_ASTC_12x12_UNORM_BLOCK,VK_FORMAT_ASTC_12x12_SRGB_BLOCK:begin
   result.Flags:=[vfsfCompressed];
   result.PaletteSizeInBits:=0;
   result.BlockSizeInBits:=16*8;
   result.BlockWidth:=12;
   result.BlockHeight:=12;
   result.BlockDepth:=1;
  end;
  else begin 
   result.Flags:=[];
   result.PaletteSizeInBits:=0;
   result.BlockSizeInBits:=0*8;
   result.BlockWidth:=1;
   result.BlockHeight:=1;
   result.BlockDepth:=1;
  end;
 end;
end;

function HashData(const Data:TVkPointer;const DataLength:TVkUInt32):TVkUInt32;
const m=TVkUInt32($57559429);
      n=TVkUInt32($5052acdb);
var b:PVkUInt8;
    h,k,len:TVkUInt32;
    p:TVkUInt64;
begin
 Len:=DataLength;
 h:=len;
 k:=h+n+1;
 if len>0 then begin
  b:=Data;
  while len>7 do begin
   begin
    p:=TVkUInt32(TVkPointer(b)^)*UInt64(n);
    h:=h xor TVkUInt32(p and $ffffffff);
    k:=k xor TVkUInt32(p shr 32);
    inc(b,4);
   end;
   begin
    p:=TVkUInt32(TVkPointer(b)^)*UInt64(m);
    k:=k xor TVkUInt32(p and $ffffffff);
    h:=h xor TVkUInt32(p shr 32);
    inc(b,4);
   end;
   dec(len,8);
  end;
  if len>3 then begin
   p:=TVkUInt32(TVkPointer(b)^)*UInt64(n);
   h:=h xor TVkUInt32(p and $ffffffff);
   k:=k xor TVkUInt32(p shr 32);
   inc(b,4);
   dec(len,4);
  end;
  if len>0 then begin
   if len>1 then begin
    p:=word(TVkPointer(b)^);
    inc(b,2);
    dec(len,2);
   end else begin
    p:=0;
   end;
   if len>0 then begin
    p:=p or (TVkUInt8(b^) shl 16);
   end;
   p:=p*TVkUInt64(m);
   k:=k xor TVkUInt32(p and $ffffffff);
   h:=h xor TVkUInt32(p shr 32);
  end;
 end;
 begin
  p:=(h xor (k+n))*TVkUInt64(n);
  h:=h xor TVkUInt32(p and $ffffffff);
  k:=k xor TVkUInt32(p shr 32);
 end;
 result:=k xor h;
end;

{$ifndef HasSAR}
function SARLongint(Value,Shift:TVkInt32):TVkInt32;
{$ifdef cpu386}
{$ifdef fpc} assembler; register; //inline;
asm
 mov ecx,edx
 sar eax,cl
end;// ['eax','edx','ecx'];
{$else} assembler; register;
asm
 mov ecx,edx
 sar eax,cl
end;
{$endif}
{$else}
{$ifdef cpuarm} assembler; //inline;
asm
 mov r0,r0,asr R1
end;// ['r0','R1'];
{$else}{$ifdef CAN_INLINE}inline;{$endif}
begin
 Shift:=Shift and 31;
 result:=(TVkUInt32(Value) shr Shift) or (TVkUInt32(TVkInt32(TVkUInt32(0-TVkUInt32(TVkUInt32(Value) shr 31)) and TVkUInt32(0-TVkUInt32(ord(Shift<>0) and 1)))) shl (32-Shift));
end;
{$endif}
{$endif}
{$endif}

{$ifndef HasSAR}
function SARInt64(Value:TVkInt64;Shift:TVkInt32):TVkInt64;{$ifdef UseRegister}register;{$endif}{$ifdef CAN_INLINE}inline;{$endif}
begin
 Shift:=Shift and 63;
 result:=TVkInt64(TVkUInt64(TVkUInt64(TVkUInt64(Value) shr Shift) or (TVkUInt64(TVkInt64(TVkUInt64(0-TVkUInt64(TVkUInt64(Value) shr 63)) and TVkUInt64(TVkInt64(0-(ord(Shift<>0) and 1))))) shl (64-Shift))));
end;
{$endif}

function RoundUpToPowerOfTwo(x:TVkUInt32):TVkUInt32;
begin
 dec(x);
 x:=x or (x shr 1);
 x:=x or (x shr 2);
 x:=x or (x shr 4);
 x:=x or (x shr 8);
 x:=x or (x shr 16);
 result:=x+1;
end;

function MulFix(a,b:TVkInt32):TVkInt32;
var s:TVkInt32;
begin
 s:=1;
 if a<0 then begin
  a:=-a;
  s:=-1;
 end;
 if b<0 then begin
  b:=-b;
  s:=-s;
 end;
 result:=((TVkInt64(a)*TVkInt64(b))+$8000) div 65536;
 if s<0 then begin
  result:=-result;
 end;
end;

function SQRTFixed(x:TVkInt32):TVkInt32;
var rh,rl,td:TVkUInt32;
    c:TVkInt32;
begin
 result:=0;
 if x>0 then begin
  rh:=0;
  rl:=x;
  c:=24;
  repeat
   rh:=(rh shl 2) or (rl shr 30);
   rl:=rl shl 2;
   result:=result shl 1;
   td:=(result shl 1)+1;
   if rh>=td then begin
    dec(rh,td);
    inc(result);
   end;
   dec(c);
  until c=0;
 end;
end;

function MSB(v:TVkUInt32):TVkInt32;
begin
 result:=0;
 if (v and $ffff0000)<>0 then begin
  v:=v shr 16;
  inc(result,16);
 end;
 if (v and $ff00)<>0 then begin
  v:=v shr 8;
  inc(result,8);
 end;
 if (v and $f0)<>0 then begin
  v:=v shr 4;
  inc(result,4);
 end;
 if (v and $c)<>0 then begin
  v:=v shr 2;
  inc(result,2);
 end;
 if (v and 2)<>0 then begin
  inc(result);
 end;
end;

procedure Transform(var x,y:TVkInt32;xx,yx,xy,yy:TVkInt32);
var xz,yz:TVkInt32;
begin
 xz:=MulFix(x,xx)+MulFix(y,xy);
 yz:=MulFix(x,yx)+MulFix(y,yy);
 x:=xz;
 y:=yz;
end;

function isqrt(x:TVkUInt32):TVkUInt32;
const isqrtLookUpTable:array[0..1023] of TVkUInt32=(
       0,2048,2896,3547,4096,4579,5017,5418,5793,6144,6476,6792,7094,7384,7663,7932,8192,8444,
       8689,8927,9159,9385,9606,9822,10033,10240,10443,10642,10837,11029,11217,11403,11585,
       11765,11942,12116,12288,12457,12625,12790,12953,13114,13273,13430,13585,13738,13890,
       14040,14189,14336,14482,14626,14768,14910,15050,15188,15326,15462,15597,15731,15864,
       15995,16126,16255,16384,16512,16638,16764,16888,17012,17135,17257,17378,17498,17618,
       17736,17854,17971,18087,18203,18318,18432,18545,18658,18770,18882,18992,19102,19212,
       19321,19429,19537,19644,19750,19856,19961,20066,20170,20274,20377,20480,20582,20684,
       20785,20886,20986,21085,21185,21283,21382,21480,21577,21674,21771,21867,21962,22058,
       22153,22247,22341,22435,22528,22621,22713,22806,22897,22989,23080,23170,23261,23351,
       23440,23530,23619,23707,23796,23884,23971,24059,24146,24232,24319,24405,24491,24576,
       24661,24746,24831,24915,24999,25083,25166,25249,25332,25415,25497,25580,25661,25743,
       25824,25905,25986,26067,26147,26227,26307,26387,26466,26545,26624,26703,26781,26859,
       26937,27015,27092,27170,27247,27324,27400,27477,27553,27629,27705,27780,27856,27931,
       28006,28081,28155,28230,28304,28378,28452,28525,28599,28672,28745,28818,28891,28963,
       29035,29108,29180,29251,29323,29394,29466,29537,29608,29678,29749,29819,29890,29960,
       30030,30099,30169,30238,30308,30377,30446,30515,30583,30652,30720,30788,30856,30924,
       30992,31059,31127,31194,31261,31328,31395,31462,31529,31595,31661,31727,31794,31859,
       31925,31991,32056,32122,32187,32252,32317,32382,32446,32511,32575,32640,32704,32768,
       32832,32896,32959,33023,33086,33150,33213,33276,33339,33402,33465,33527,33590,33652,
       33714,33776,33839,33900,33962,34024,34086,34147,34208,34270,34331,34392,34453,34514,
       34574,34635,34695,34756,34816,34876,34936,34996,35056,35116,35176,35235,35295,35354,
       35413,35472,35531,35590,35649,35708,35767,35825,35884,35942,36001,36059,36117,36175,
       36233,36291,36348,36406,36464,36521,36578,36636,36693,36750,36807,36864,36921,36978,
       37034,37091,37147,37204,37260,37316,37372,37429,37485,37540,37596,37652,37708,37763,
       37819,37874,37929,37985,38040,38095,38150,38205,38260,38315,38369,38424,38478,38533,
       38587,38642,38696,38750,38804,38858,38912,38966,39020,39073,39127,39181,39234,39287,
       39341,39394,39447,39500,39553,39606,39659,39712,39765,39818,39870,39923,39975,40028,
       40080,40132,40185,40237,40289,40341,40393,40445,40497,40548,40600,40652,40703,40755,
       40806,40857,40909,40960,41011,41062,41113,41164,41215,41266,41317,41368,41418,41469,
       41519,41570,41620,41671,41721,41771,41821,41871,41922,41972,42021,42071,42121,42171,
       42221,42270,42320,42369,42419,42468,42518,42567,42616,42665,42714,42763,42813,42861,
       42910,42959,43008,43057,43105,43154,43203,43251,43300,43348,43396,43445,43493,43541,
       43589,43637,43685,43733,43781,43829,43877,43925,43972,44020,44068,44115,44163,44210,
       44258,44305,44352,44400,44447,44494,44541,44588,44635,44682,44729,44776,44823,44869,
       44916,44963,45009,45056,45103,45149,45195,45242,45288,45334,45381,45427,45473,45519,
       45565,45611,45657,45703,45749,45795,45840,45886,45932,45977,46023,46069,46114,46160,
       46205,46250,46296,46341,46386,46431,46477,46522,46567,46612,46657,46702,46746,46791,
       46836,46881,46926,46970,47015,47059,47104,47149,47193,47237,47282,47326,47370,47415,
       47459,47503,47547,47591,47635,47679,47723,47767,47811,47855,47899,47942,47986,48030,
       48074,48117,48161,48204,48248,48291,48335,48378,48421,48465,48508,48551,48594,48637,
       48680,48723,48766,48809,48852,48895,48938,48981,49024,49067,49109,49152,49195,49237,
       49280,49322,49365,49407,49450,49492,49535,49577,49619,49661,49704,49746,49788,49830,
       49872,49914,49956,49998,50040,50082,50124,50166,50207,50249,50291,50332,50374,50416,
       50457,50499,50540,50582,50623,50665,50706,50747,50789,50830,50871,50912,50954,50995,
       51036,51077,51118,51159,51200,51241,51282,51323,51364,51404,51445,51486,51527,51567,
       51608,51649,51689,51730,51770,51811,51851,51892,51932,51972,52013,52053,52093,52134,
       52174,52214,52254,52294,52334,52374,52414,52454,52494,52534,52574,52614,52654,52694,
       52734,52773,52813,52853,52892,52932,52972,53011,53051,53090,53130,53169,53209,53248,
       53287,53327,53366,53405,53445,53484,53523,53562,53601,53640,53679,53719,53758,53797,
       53836,53874,53913,53952,53991,54030,54069,54108,54146,54185,54224,54262,54301,54340,
       54378,54417,54455,54494,54532,54571,54609,54647,54686,54724,54762,54801,54839,54877,
       54915,54954,54992,55030,55068,55106,55144,55182,55220,55258,55296,55334,55372,55410,
       55447,55485,55523,55561,55599,55636,55674,55712,55749,55787,55824,55862,55900,55937,
       55975,56012,56049,56087,56124,56162,56199,56236,56273,56311,56348,56385,56422,56459,
       56497,56534,56571,56608,56645,56682,56719,56756,56793,56830,56867,56903,56940,56977,
       57014,57051,57087,57124,57161,57198,57234,57271,57307,57344,57381,57417,57454,57490,
       57527,57563,57599,57636,57672,57709,57745,57781,57817,57854,57890,57926,57962,57999,
       58035,58071,58107,58143,58179,58215,58251,58287,58323,58359,58395,58431,58467,58503,
       58538,58574,58610,58646,58682,58717,58753,58789,58824,58860,58896,58931,58967,59002,
       59038,59073,59109,59144,59180,59215,59251,59286,59321,59357,59392,59427,59463,59498,
       59533,59568,59603,59639,59674,59709,59744,59779,59814,59849,59884,59919,59954,59989,
       60024,60059,60094,60129,60164,60199,60233,60268,60303,60338,60373,60407,60442,60477,
       60511,60546,60581,60615,60650,60684,60719,60753,60788,60822,60857,60891,60926,60960,
       60995,61029,61063,61098,61132,61166,61201,61235,61269,61303,61338,61372,61406,61440,
       61474,61508,61542,61576,61610,61644,61678,61712,61746,61780,61814,61848,61882,61916,
       61950,61984,62018,62051,62085,62119,62153,62186,62220,62254,62287,62321,62355,62388,
       62422,62456,62489,62523,62556,62590,62623,62657,62690,62724,62757,62790,62824,62857,
       62891,62924,62957,62991,63024,63057,63090,63124,63157,63190,63223,63256,63289,63323,
       63356,63389,63422,63455,63488,63521,63554,63587,63620,63653,63686,63719,63752,63785,
       63817,63850,63883,63916,63949,63982,64014,64047,64080,64113,64145,64178,64211,64243,
       64276,64309,64341,64374,64406,64439,64471,64504,64536,64569,64601,64634,64666,64699,
       64731,64763,64796,64828,64861,64893,64925,64957,64990,65022,65054,65086,65119,65151,
       65183,65215,65247,65279,65312,65344,65376,65408,65440,65472,65504);
      isqrtBitSliderLookUpTable:array[TVkUInt8] of TVkUInt8=(
       0,0,1,1,2,2,2,2,3,3,3,3,3,3,3,3,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,
       5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
       6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,
       6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,
       7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,
       7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,
       7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,
       7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7);
var bit:TVkInt32;
    t,shift:TVkUInt32;
begin
 t:=x;
 shift:=11;
 bit:=t shr 24;
 if bit<>0 then begin
  bit:=isqrtBitSliderLookUpTable[bit]+24;
 end else begin
  bit:=(t shr 16) and $ff;
  if bit<>0 then begin
   bit:=isqrtBitSliderLookUpTable[bit]+16;
  end else begin
   bit:=(t shr 8) and $ff;
   if bit<>0 then begin
    bit:=isqrtBitSliderLookUpTable[bit]+8;
   end else begin
    bit:=isqrtBitSliderLookUpTable[t];
   end;
  end;
 end;
 bit:=bit-9;
 if bit>0 then begin
  bit:=(SARLongint(bit,1))+(bit and 1);
  dec(shift,bit);
  x:=x shr (bit shl 1);
 end;
 result:=isqrtLookUpTable[x] shr shift;
end;

function VulkanIntLog2(aValue:TVkUInt32):TVkUInt32;{$ifdef fpc}{$ifdef caninline}inline;{$endif}
begin
 if aValue<>0 then begin
  result:=BSRWord(aValue);
 end else begin
  result:=0;
 end;
end;
{$else}
{$ifdef cpu386}assembler; {$ifdef fpc}nostackframe;{$else}register;{$endif}
asm
 test eax,eax
 jz @Done
 bsr eax,eax
 @Done:
end;{$else}{$ifdef cpux86_64}assembler; {$ifdef fpc}nostackframe;{$else}register;{$endif}
asm
{$ifdef Windows}
 mov eax,ecx
{$else}
 mov eax,edi
{$endif}
 test eax,eax
 jz @Done
 bsr eax,eax
 @Done:
end;
{$else}
begin
 result:=aValue or (aValue shr 1);
 result:=result or (result shr 2);
 result:=result or (result shr 4);
 result:=result or (result shr 8);
 result:=result or (result shr 16);
 result:=result shr 1;
 result:=result-((result shr 1) and $55555555);
 result:=((result shr 2) and $33333333)+(result and $33333333);
 result:=((result shr 4)+result) and $0f0f0f0f;
 result:=result+(result shr 8);
 result:=result+(result shr 16);
 result:=result and $3f;
end;
{$endif}
{$endif}
{$endif}

function VulkanRoundUpToPowerOfTwo(Value:TVkSize):TVkSize;
begin
 dec(Value);
 Value:=Value or (Value shr 1);
 Value:=Value or (Value shr 2);
 Value:=Value or (Value shr 4);
 Value:=Value or (Value shr 8);
 Value:=Value or (Value shr 16);
{$ifdef CPU64}
 Value:=Value or (Value shr 32);
{$endif}
 result:=Value+1;
end;

function VulkanDeviceSizeRoundUpToPowerOfTwo(Value:TVkDeviceSize):TVkDeviceSize;
begin
 dec(Value);
 Value:=Value or (Value shr 1);
 Value:=Value or (Value shr 2);
 Value:=Value or (Value shr 4);
 Value:=Value or (Value shr 8);
 Value:=Value or (Value shr 16);
 Value:=Value or (Value shr 32);
 result:=Value+1;
end;

{$if defined(fpc)}
function CTZDWord(Value:TVkUInt32):TVkUInt8; inline;
begin
 if Value=0 then begin
  result:=32;
 end else begin
  result:=BSFDWord(Value);
 end;
end;
{$elseif defined(cpu386)}
{$ifndef fpc}
function CTZDWord(Value:TVkUInt32):TVkUInt8; assembler; register; {$ifdef fpc}nostackframe;{$endif}
asm
 bsf eax,eax
 jnz @Done
 mov eax,32
@Done:
end;
{$endif}
{$elseif defined(cpux86_64)}
{$ifndef fpc}
function CTZDWord(Value:TVkUInt32):TVkUInt8; assembler; register; {$ifdef fpc}nostackframe;{$endif}
asm
{$ifndef fpc}
 .NOFRAME
{$endif}
{$ifdef Windows}
 bsf eax,ecx
{$else}
 bsf eax,edi
{$endif}
 jnz @Done
 mov eax,32
@Done:
end;
{$endif}
{$elseif not defined(fpc)}
function CTZDWord(Value:TVkUInt32):TVkUInt8;
const CTZDebruijn32Multiplicator=TVkUInt32($077cb531);
      CTZDebruijn32Shift=27;
      CTZDebruijn32Mask=31;
      CTZDebruijn32Table:array[0..31] of TVkUInt8=(0,1,28,2,29,14,24,3,30,22,20,15,25,17,4,8,31,27,13,23,21,19,16,7,26,12,18,6,11,5,10,9);
begin
 if Value=0 then begin
  result:=32;
 end else begin
  result:=CTZDebruijn32Table[((TVkUInt32(Value and (-Value))*CTZDebruijn32Multiplicator) shr CTZDebruijn32Shift) and CTZDebruijn32Mask];
 end;
end;
{$ifend}

type TSortCompareFunction=function(const a,b:TVkPointer):TVkInt32;

procedure MemorySwap(pA,pB:TVkPointer;pSize:TVkInt32);
var Temp:TVkInt32;
begin
 while pSize>=SizeOf(TVkInt32) do begin
  Temp:=TVkUInt32(pA^);
  TVkUInt32(pA^):=TVkUInt32(pB^);
  TVkUInt32(pB^):=Temp;
  inc(TVkPtrUInt(pA),SizeOf(TVkUInt32));
  inc(TVkPtrUInt(pB),SizeOf(TVkUInt32));
  dec(pSize,SizeOf(TVkUInt32));
 end;
 while pSize>=SizeOf(TVkUInt8) do begin
  Temp:=TVkUInt8(pA^);
  TVkUInt8(pA^):=TVkUInt8(pB^);
  TVkUInt8(pB^):=Temp;
  inc(TVkPtrUInt(pA),SizeOf(TVkUInt8));
  inc(TVkPtrUInt(pB),SizeOf(TVkUInt8));
  dec(pSize,SizeOf(TVkUInt8));
 end;
end;

procedure DirectIntroSort(const pItems:TVkPointer;const pLeft,pRight,pElementSize:TVkInt32;const pCompareFunc:TSortCompareFunction);
type PByteArray=^TByteArray;
     TByteArray=array[0..$3fffffff] of TVkUInt8;
     PStackItem=^TStackItem;
     TStackItem=record
      Left,Right,Depth:TVkInt32;
     end;
var Left,Right,Depth,i,j,Middle,Size,Parent,Child,Pivot,iA,iB,iC:TVkInt32;
    StackItem:PStackItem;
    Stack:array[0..31] of TStackItem;
begin
 if pLeft<pRight then begin
  StackItem:=@Stack[0];
  StackItem^.Left:=pLeft;
  StackItem^.Right:=pRight;
  StackItem^.Depth:=VulkanIntLog2((pRight-pLeft)+1) shl 1;
  inc(StackItem);
  while TVkPtrUInt(TVkPointer(StackItem))>TVkPtrUInt(TVkPointer(@Stack[0])) do begin
   dec(StackItem);
   Left:=StackItem^.Left;
   Right:=StackItem^.Right;
   Depth:=StackItem^.Depth;
   Size:=(Right-Left)+1;
   if Size<16 then begin
    // Insertion sort
    iA:=Left;
    iB:=iA+1;
    while iB<=Right do begin
     iC:=iB;
     while (iA>=Left) and
           (iC>=Left) and
           (pCompareFunc(TVkPointer(@PByteArray(pItems)^[iA*pElementSize]),TVkPointer(@PByteArray(pItems)^[iC*pElementSize]))>0) do begin
      MemorySwap(@PByteArray(pItems)^[iA*pElementSize],@PByteArray(pItems)^[iC*pElementSize],pElementSize);
      dec(iA);
      dec(iC);
     end;
     iA:=iB;
     inc(iB);
    end;
   end else begin
    if (Depth=0) or (TVkPtrUInt(TVkPointer(StackItem))>=TVkPtrUInt(TVkPointer(@Stack[high(Stack)-1]))) then begin
     // Heap sort
     i:=Size div 2;
     repeat
      if i>0 then begin
       dec(i);
      end else begin
       dec(Size);
       if Size>0 then begin
        MemorySwap(@PByteArray(pItems)^[(Left+Size)*pElementSize],@PByteArray(pItems)^[Left*pElementSize],pElementSize);
       end else begin
        break;
       end;
      end;
      Parent:=i;
      repeat
       Child:=(Parent*2)+1;
       if Child<Size then begin
        if (Child<(Size-1)) and (pCompareFunc(TVkPointer(@PByteArray(pItems)^[(Left+Child)*pElementSize]),TVkPointer(@PByteArray(pItems)^[(Left+Child+1)*pElementSize]))<0) then begin
         inc(Child);
        end;
        if pCompareFunc(TVkPointer(@PByteArray(pItems)^[(Left+Parent)*pElementSize]),TVkPointer(@PByteArray(pItems)^[(Left+Child)*pElementSize]))<0 then begin
         MemorySwap(@PByteArray(pItems)^[(Left+Parent)*pElementSize],@PByteArray(pItems)^[(Left+Child)*pElementSize],pElementSize);
         Parent:=Child;
         continue;
        end;
       end;
       break;
      until false;
     until false;
    end else begin
     // Quick sort width median-of-three optimization
     Middle:=Left+((Right-Left) shr 1);
     if (Right-Left)>3 then begin
      if pCompareFunc(TVkPointer(@PByteArray(pItems)^[Left*pElementSize]),TVkPointer(@PByteArray(pItems)^[Middle*pElementSize]))>0 then begin
       MemorySwap(@PByteArray(pItems)^[Left*pElementSize],@PByteArray(pItems)^[Middle*pElementSize],pElementSize);
      end;
      if pCompareFunc(TVkPointer(@PByteArray(pItems)^[Left*pElementSize]),TVkPointer(@PByteArray(pItems)^[Right*pElementSize]))>0 then begin
       MemorySwap(@PByteArray(pItems)^[Left*pElementSize],@PByteArray(pItems)^[Right*pElementSize],pElementSize);
      end;
      if pCompareFunc(TVkPointer(@PByteArray(pItems)^[Middle*pElementSize]),TVkPointer(@PByteArray(pItems)^[Right*pElementSize]))>0 then begin
       MemorySwap(@PByteArray(pItems)^[Middle*pElementSize],@PByteArray(pItems)^[Right*pElementSize],pElementSize);
      end;
     end;
     Pivot:=Middle;
     i:=Left;
     j:=Right;
     repeat
      while (i<Right) and (pCompareFunc(TVkPointer(@PByteArray(pItems)^[i*pElementSize]),TVkPointer(@PByteArray(pItems)^[Pivot*pElementSize]))<0) do begin
       inc(i);
      end;
      while (j>=i) and (pCompareFunc(TVkPointer(@PByteArray(pItems)^[j*pElementSize]),TVkPointer(@PByteArray(pItems)^[Pivot*pElementSize]))>0) do begin
       dec(j);
      end;
      if i>j then begin
       break;
      end else begin
       if i<>j then begin
        MemorySwap(@PByteArray(pItems)^[i*pElementSize],@PByteArray(pItems)^[j*pElementSize],pElementSize);
        if Pivot=i then begin
         Pivot:=j;
        end else if Pivot=j then begin
         Pivot:=i;
        end;
       end;
       inc(i);
       dec(j);
      end;
     until false;
     if i<Right then begin
      StackItem^.Left:=i;
      StackItem^.Right:=Right;
      StackItem^.Depth:=Depth-1;
      inc(StackItem);
     end;
     if Left<j then begin
      StackItem^.Left:=Left;
      StackItem^.Right:=j;
      StackItem^.Depth:=Depth-1;
      inc(StackItem);
     end;
    end;
   end;
  end;
 end;
end;

procedure IndirectIntroSort(const pItems:TVkPointer;const pLeft,pRight:TVkInt32;const pCompareFunc:TSortCompareFunction);
type PPointers=^TPointers;
     TPointers=array[0..$ffff] of TVkPointer;
     PStackItem=^TStackItem;
     TStackItem=record
      Left,Right,Depth:TVkInt32;
     end;
var Left,Right,Depth,i,j,Middle,Size,Parent,Child:TVkInt32;
    Pivot,Temp:TVkPointer;
    StackItem:PStackItem;
    Stack:array[0..31] of TStackItem;
begin
 if pLeft<pRight then begin
  StackItem:=@Stack[0];
  StackItem^.Left:=pLeft;
  StackItem^.Right:=pRight;
  StackItem^.Depth:=VulkanIntLog2((pRight-pLeft)+1) shl 1;
  inc(StackItem);
  while TVkPtrUInt(TVkPointer(StackItem))>TVkPtrUInt(TVkPointer(@Stack[0])) do begin
   dec(StackItem);
   Left:=StackItem^.Left;
   Right:=StackItem^.Right;
   Depth:=StackItem^.Depth;
   Size:=(Right-Left)+1;
   if Size<16 then begin
    // Insertion sort
    for i:=Left+1 to Right do begin
     Temp:=PPointers(pItems)^[i];
     j:=i-1;
     if (j>=Left) and (pCompareFunc(PPointers(pItems)^[j],Temp)>0) then begin
      repeat
       PPointers(pItems)^[j+1]:=PPointers(pItems)^[j];
       dec(j);
      until not ((j>=Left) and (pCompareFunc(PPointers(pItems)^[j],Temp)>0));
      PPointers(pItems)^[j+1]:=Temp;
     end;
    end;
   end else begin
    if (Depth=0) or (TVkPtrUInt(TVkPointer(StackItem))>=TVkPtrUInt(TVkPointer(@Stack[high(Stack)-1]))) then begin
     // Heap sort
     i:=Size div 2;
     Temp:=nil;
     repeat
      if i>0 then begin
       dec(i);
       Temp:=PPointers(pItems)^[Left+i];
      end else begin
       dec(Size);
       if Size>0 then begin
        Temp:=PPointers(pItems)^[Left+Size];
        PPointers(pItems)^[Left+Size]:=PPointers(pItems)^[Left];
       end else begin
        break;
       end;
      end;
      Parent:=i;
      Child:=(i*2)+1;
      while Child<Size do begin
       if ((Child+1)<Size) and (pCompareFunc(PPointers(pItems)^[Left+Child+1],PPointers(pItems)^[Left+Child])>0) then begin
        inc(Child);
       end;
       if pCompareFunc(PPointers(pItems)^[Left+Child],Temp)>0 then begin
        PPointers(pItems)^[Left+Parent]:=PPointers(pItems)^[Left+Child];
        Parent:=Child;
        Child:=(Parent*2)+1;
       end else begin
        break;
       end;
      end;
      PPointers(pItems)^[Left+Parent]:=Temp;
     until false;
    end else begin
     // Quick sort width median-of-three optimization
     Middle:=Left+((Right-Left) shr 1);
     if (Right-Left)>3 then begin
      if pCompareFunc(PPointers(pItems)^[Left],PPointers(pItems)^[Middle])>0 then begin
       Temp:=PPointers(pItems)^[Left];
       PPointers(pItems)^[Left]:=PPointers(pItems)^[Middle];
       PPointers(pItems)^[Middle]:=Temp;
      end;
      if pCompareFunc(PPointers(pItems)^[Left],PPointers(pItems)^[Right])>0 then begin
       Temp:=PPointers(pItems)^[Left];
       PPointers(pItems)^[Left]:=PPointers(pItems)^[Right];
       PPointers(pItems)^[Right]:=Temp;
      end;
      if pCompareFunc(PPointers(pItems)^[Middle],PPointers(pItems)^[Right])>0 then begin
       Temp:=PPointers(pItems)^[Middle];
       PPointers(pItems)^[Middle]:=PPointers(pItems)^[Right];
       PPointers(pItems)^[Right]:=Temp;
      end;
     end;
     Pivot:=PPointers(pItems)^[Middle];
     i:=Left;
     j:=Right;
     repeat
      while (i<Right) and (pCompareFunc(PPointers(pItems)^[i],Pivot)<0) do begin
       inc(i);
      end;
      while (j>=i) and (pCompareFunc(PPointers(pItems)^[j],Pivot)>0) do begin
       dec(j);
      end;
      if i>j then begin
       break;
      end else begin
       if i<>j then begin
        Temp:=PPointers(pItems)^[i];
        PPointers(pItems)^[i]:=PPointers(pItems)^[j];
        PPointers(pItems)^[j]:=Temp;
       end;
       inc(i);
       dec(j);
      end;
     until false;
     if i<Right then begin
      StackItem^.Left:=i;
      StackItem^.Right:=Right;
      StackItem^.Depth:=Depth-1;
      inc(StackItem);
     end;
     if Left<j then begin
      StackItem^.Left:=Left;
      StackItem^.Right:=j;
      StackItem^.Depth:=Depth-1;
      inc(StackItem);
     end;
    end;
   end;
  end;
 end;
end;

function HashString(const Str:TVulkanRawByteString):TVkUInt32;
{$ifdef cpuarm}
var b:PVulkanRawByteChar;
    len,h,i:TVkUInt32;
begin
 result:=2166136261;
 len:=length(Str);
 h:=len;
 if len>0 then begin
  b:=PVulkanRawByteChar(Str);
  while len>3 do begin
   i:=TVkUInt32(TVkPointer(b)^);
   h:=(h xor i) xor $2e63823a;
   inc(h,(h shl 15) or (h shr (32-15)));
   dec(h,(h shl 9) or (h shr (32-9)));
   inc(h,(h shl 4) or (h shr (32-4)));
   dec(h,(h shl 1) or (h shr (32-1)));
   h:=h xor (h shl 2) or (h shr (32-2));
   result:=result xor i;
   inc(result,(result shl 1)+(result shl 4)+(result shl 7)+(result shl 8)+(result shl 24));
   inc(b,4);
   dec(len,4);
  end;
  if len>1 then begin
   i:=word(TVkPointer(b)^);
   h:=(h xor i) xor $2e63823a;
   inc(h,(h shl 15) or (h shr (32-15)));
   dec(h,(h shl 9) or (h shr (32-9)));
   inc(h,(h shl 4) or (h shr (32-4)));
   dec(h,(h shl 1) or (h shr (32-1)));
   h:=h xor (h shl 2) or (h shr (32-2));
   result:=result xor i;
   inc(result,(result shl 1)+(result shl 4)+(result shl 7)+(result shl 8)+(result shl 24));
   inc(b,2);
   dec(len,2);
  end;
  if len>0 then begin
   i:=TVkUInt8(b^);
   h:=(h xor i) xor $2e63823a;
   inc(h,(h shl 15) or (h shr (32-15)));
   dec(h,(h shl 9) or (h shr (32-9)));
   inc(h,(h shl 4) or (h shr (32-4)));
   dec(h,(h shl 1) or (h shr (32-1)));
   h:=h xor (h shl 2) or (h shr (32-2));
   result:=result xor i;
   inc(result,(result shl 1)+(result shl 4)+(result shl 7)+(result shl 8)+(result shl 24));
  end;
 end;
 result:=result xor h;
 if result=0 then begin
  result:=$ffffffff;
 end;
end;
{$else}
const m=TVkUInt32($57559429);
      n=TVkUInt32($5052acdb);
var b:PVulkanRawByteChar;
    h,k,len:TVkUInt32;
    p:TVkUInt64;
begin
 len:=length(Str);
 h:=len;
 k:=h+n+1;
 if len>0 then begin
  b:=PVulkanRawByteChar(Str);
  while len>7 do begin
   begin
    p:=TVkUInt32(TVkPointer(b)^)*TVkUInt64(n);
    h:=h xor TVkUInt32(p and $ffffffff);
    k:=k xor TVkUInt32(p shr 32);
    inc(b,4);
   end;
   begin
    p:=TVkUInt32(TVkPointer(b)^)*TVkUInt64(m);
    k:=k xor TVkUInt32(p and $ffffffff);
    h:=h xor TVkUInt32(p shr 32);
    inc(b,4);
   end;
   dec(len,8);
  end;
  if len>3 then begin
   p:=TVkUInt32(TVkPointer(b)^)*TVkUInt64(n);
   h:=h xor TVkUInt32(p and $ffffffff);
   k:=k xor TVkUInt32(p shr 32);
   inc(b,4);
   dec(len,4);
  end;
  if len>0 then begin
   if len>1 then begin
    p:=word(TVkPointer(b)^);
    inc(b,2);
    dec(len,2);
   end else begin
    p:=0;
   end;
   if len>0 then begin
    p:=p or (TVkUInt8(b^) shl 16);
   end;
   p:=p*TVkUInt64(m);
   k:=k xor TVkUInt32(p and $ffffffff);
   h:=h xor TVkUInt32(p shr 32);
  end;
 end;
 begin
  p:=(h xor (k+n))*TVkUInt64(n);
  h:=h xor TVkUInt32(p and $ffffffff);
  k:=k xor TVkUInt32(p shr 32);
 end;
 result:=k xor h;
 if result=0 then begin
  result:=$ffffffff;
 end;
end;
{$endif}

function HashPointer(const p:TVkPointer):TVkUInt32; {$ifdef caninline}inline;{$endif}
{$ifdef cpu64}
var r:TVkPtrUInt;
begin
 r:=TVkPtrUInt(p);
 r:=(not r)+(r shl 18); // r:=((r shl 18)-r-)1;
 r:=r xor (r shr 31);
 r:=r*21; // r:=(r+(r shl 2))+(r shl 4);
 r:=r xor (r shr 11);
 r:=r+(r shl 6);
 result:=TVkUInt32(TVkPtrUInt(r xor (r shr 22)));
 if result=0 then begin
  result:=$ffffffff;
 end;
end;
{$else}
begin
 result:=TVkPtrUInt(p);
 result:=(not result)+(result shl 15);
 result:=result xor (result shr 15);
 inc(result,result shl 2);
 result:=(result xor (result shr 4))*2057;
 result:=result xor (result shr 16);
 if result=0 then begin
  result:=$ffffffff;
 end;
end;
{$endif}

function HashUInt32(const p:TVkUInt32):TVkUInt32; {$ifdef caninline}inline;{$endif}
begin
 result:=TVkUInt32(p);
 result:=(not result)+(result shl 15);
 result:=result xor (result shr 15);
 inc(result,result shl 2);
 result:=(result xor (result shr 4))*2057;
 result:=result xor (result shr 16);
 if result=0 then begin
  result:=$ffffffff;
 end;
end;

function HashUInt64(const p:TVkUInt64):TVkUInt32; {$ifdef caninline}inline;{$endif}
var r:TVkUInt64;
begin
 r:=TVkUInt64(p);
 r:=(not r)+(r shl 18); // r:=((r shl 18)-r-)1;
 r:=r xor (r shr 31);
 r:=r*21; // r:=(r+(r shl 2))+(r shl 4);
 r:=r xor (r shr 11);
 r:=r+(r shl 6);
 result:=TVkUInt32(TVkUInt64(r xor (r shr 22)));
 if result=0 then begin
  result:=$ffffffff;
 end;
end;

function CombineTwoUInt32IntoOneUInt64(const a,b:TVkUInt32):TVkUInt64; {$ifdef caninline}inline;{$endif}
begin
 result:=(TVkUInt64(a) shl 32) or b;
end;

function CRC32(data:TVkPointer;length:TVkUInt32):TVkUInt32;
const CRC32Table:array[0..15] of TVkUInt32=($00000000,$1db71064,$3b6e20c8,$26d930ac,$76dc4190,
                                           $6b6b51f4,$4db26158,$5005713c,$edb88320,$f00f9344,
                                           $d6d6a3e8,$cb61b38c,$9b64c2b0,$86d3d2d4,$a00ae278,
                                           $bdbdf21c);

var buf:PVulkanRawByteChar;
    i:TVkUInt32;
begin
 if length=0 then begin
  result:=0;
 end else begin
  buf:=data;
  result:=$ffffffff;
  for i:=1 to length do begin
   result:=result xor TVkUInt8(buf^);
   result:=CRC32Table[result and $f] xor (result shr 4);
   result:=CRC32Table[result and $f] xor (result shr 4);
   inc(buf);
  end;
  result:=result xor $ffffffff;
 end;
end;

function DoInflate(InData:TVkPointer;InLen:TVkUInt32;var DestData:TVkPointer;var DestLen:TVkUInt32;ParseHeader:boolean):boolean;
const CLCIndex:array[0..18] of TVkUInt8=(16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15);
type pword=^TVkUInt16;
     PTree=^TTree;
     TTree=packed record
      Table:array[0..15] of TVkUInt16;
      Translation:array[0..287] of TVkUInt16;
     end;
     PBuffer=^TBuffer;
     TBuffer=array[0..65535] of TVkUInt8;
     PLengths=^TLengths;
     TLengths=array[0..288+32-1] of TVkUInt8;
     POffsets=^TOffsets;
     TOffsets=array[0..15] of TVkUInt16;
     PBits=^TBits;
     TBits=array[0..29] of TVkUInt8;
     PBase=^TBase;
     TBase=array[0..29] of TVkUInt16;
var Tag,BitCount,DestSize:TVkUInt32;
    SymbolLengthTree,DistanceTree,FixedSymbolLengthTree,FixedDistanceTree:PTree;
    LengthBits,DistanceBits:PBits;
    LengthBase,DistanceBase:PBase;
    Source,SourceEnd:PVulkanRawByteChar;
    Dest:PVulkanRawByteChar;
 procedure IncSize(length:TVkUInt32);
 var j:TVkUInt32;
 begin
  if (DestLen+length)>=DestSize then begin
   if DestSize=0 then begin
    DestSize:=1;
   end;
   while (DestLen+length)>=DestSize do begin
    inc(DestSize,DestSize);
   end;
   j:=TVkPtrUInt(Dest)-TVkPtrUInt(DestData);
   ReAllocMem(DestData,DestSize);
   TVkPtrUInt(Dest):=TVkPtrUInt(DestData)+j;
  end;
 end;           
 function adler32(data:TVkPointer;length:TVkUInt32):TVkUInt32;
 const BASE=65521;
       NMAX=5552;
 var buf:PVulkanRawByteChar;
     s1,s2,k,i:TVkUInt32;
 begin
  s1:=1;
  s2:=0;
  buf:=data;
  while length>0 do begin
   if length<NMAX then begin
    k:=length;
   end else begin
    k:=NMAX;
   end;
   dec(length,k);
   for i:=1 to k do begin
    inc(s1,TVkUInt8(buf^));
    inc(s2,s1);
    inc(buf);
   end;
   s1:=s1 mod BASE;
   s2:=s2 mod BASE;
  end;
  result:=(s2 shl 16) or s1;
 end;
 procedure BuildBitsBase(Bits:PVulkanRawByteChar;Base:pword;Delta,First:TVkInt32);
 var i,Sum:TVkInt32;
 begin
  for i:=0 to Delta-1 do begin
   Bits[i]:=TVulkanRawByteChar(#0);
  end;
  for i:=0 to (30-Delta)-1 do begin
   Bits[i+Delta]:=TVulkanRawByteChar(TVkUInt8(i div Delta));
  end;
  Sum:=First;
  for i:=0 to 29 do begin
   Base^:=Sum;
   inc(Base);
   inc(Sum,1 shl TVkUInt8(Bits[i]));
  end;
 end;
 procedure BuildFixedTrees(var lt,dt:TTree);
 var i:TVkInt32;
 begin
  for i:=0 to 6 do begin
   lt.Table[i]:=0;
  end;
  lt.Table[7]:=24;
  lt.Table[8]:=152;
  lt.Table[9]:=112;
  for i:=0 to 23 do begin
   lt.Translation[i]:=256+i;
  end;
  for i:=0 to 143 do begin
   lt.Translation[24+i]:=i;
  end;
  for i:=0 to 7 do begin
   lt.Translation[168+i]:=280+i;
  end;
  for i:=0 to 111 do begin
   lt.Translation[176+i]:=144+i;
  end;
  for i:=0 to 4 do begin
   dt.Table[i]:=0;
  end;
  dt.Table[5]:=32;
  for i:=0 to 31 do begin
   dt.Translation[i]:=i;
  end;
 end;
 procedure BuildTree(var t:TTree;Lengths:PVulkanRawByteChar;Num:TVkInt32);
 var Offsets:POffsets;
     i:TVkInt32;
     Sum:TVkUInt32;
 begin
  New(Offsets);
  try
   for i:=0 to 15 do begin
    t.Table[i]:=0;
   end;
   for i:=0 to Num-1 do begin
    inc(t.Table[TVkUInt8(Lengths[i])]);
   end;
   t.Table[0]:=0;
   Sum:=0;
   for i:=0 to 15 do begin
    Offsets^[i]:=Sum;
    inc(Sum,t.Table[i]);
   end;
   for i:=0 to Num-1 do begin
    if lengths[i]<>TVulkanRawByteChar(#0) then begin
     t.Translation[Offsets^[TVkUInt8(lengths[i])]]:=i;
     inc(Offsets^[TVkUInt8(lengths[i])]);
    end;
   end;
  finally
   Dispose(Offsets);
  end;
 end;
 function GetBit:TVkUInt32;
 begin
  if BitCount=0 then begin
   Tag:=TVkUInt8(Source^);
   inc(Source);
   BitCount:=7;
  end else begin
   dec(BitCount);
  end;
  result:=Tag and 1;
  Tag:=Tag shr 1;
 end;
 function ReadBits(Num,Base:TVkUInt32):TVkUInt32;
 var Limit,Mask:TVkUInt32;
 begin
  result:=0;
  if Num<>0 then begin
   Limit:=1 shl Num;
   Mask:=1;
   while Mask<Limit do begin
    if GetBit<>0 then begin
     inc(result,Mask);
    end;
    Mask:=Mask shl 1;
   end;
  end;
  inc(result,Base);
 end;
 function DecodeSymbol(var t:TTree):TVkUInt32;
 var Sum,c,l:TVkInt32;
 begin
  Sum:=0;
  c:=0;
  l:=0;
  repeat
   c:=(c*2)+TVkInt32(GetBit);
   inc(l);
   inc(Sum,t.Table[l]);
   dec(c,t.Table[l]);
  until not (c>=0);
  result:=t.Translation[Sum+c];
 end;
 procedure DecodeTrees(var lt,dt:TTree);
 var CodeTree:PTree;
     Lengths:PLengths;
     hlit,hdist,hclen,i,num,length,clen,Symbol,Prev:TVkUInt32;
 begin
  New(CodeTree);
  New(Lengths);
  try
   FillChar(CodeTree^,sizeof(TTree),TVulkanRawByteChar(#0));
   FillChar(Lengths^,sizeof(TLengths),TVulkanRawByteChar(#0));
   hlit:=ReadBits(5,257);
   hdist:=ReadBits(5,1);
   hclen:=ReadBits(4,4);
   for i:=0 to 18 do begin
    lengths^[i]:=0;
   end;
   for i:=1 to hclen do begin
    clen:=ReadBits(3,0);
    lengths^[CLCIndex[i-1]]:=clen;
   end;
   BuildTree(CodeTree^,PVulkanRawByteChar(TVkPointer(@lengths^[0])),19);
   num:=0;
   while num<(hlit+hdist) do begin
    Symbol:=DecodeSymbol(CodeTree^);
    case Symbol of
     16:begin
      prev:=lengths^[num-1];
      length:=ReadBits(2,3);
      while length>0 do begin
       lengths^[num]:=prev;
       inc(num);
       dec(length);
      end;
     end;
     17:begin
      length:=ReadBits(3,3);
      while length>0 do begin
       lengths^[num]:=0;
       inc(num);
       dec(length);
      end;
     end;
     18:begin
      length:=ReadBits(7,11);
      while length>0 do begin
       lengths^[num]:=0;
       inc(num);
       dec(length);
      end;
     end;
     else begin
      lengths^[num]:=Symbol;
      inc(num);
     end;
    end;
   end;
   BuildTree(lt,PVulkanRawByteChar(TVkPointer(@lengths^[0])),hlit);
   BuildTree(dt,PVulkanRawByteChar(TVkPointer(@lengths^[hlit])),hdist);
  finally
   Dispose(CodeTree);
   Dispose(Lengths);
  end;
 end;
 function InflateBlockData(var lt,dt:TTree):boolean;
 var Symbol:TVkUInt32;
     Length,Distance,Offset,i:TVkInt32;
 begin
  result:=false;
  while (Source<SourceEnd) or (BitCount>0) do begin
   Symbol:=DecodeSymbol(lt);
   if Symbol=256 then begin
    result:=true;
    break;
   end;
   if Symbol<256 then begin
    IncSize(1);
    Dest^:=TVulkanRawByteChar(TVkUInt8(Symbol));
    inc(Dest);
    inc(DestLen);
   end else begin
    dec(Symbol,257);
    Length:=ReadBits(LengthBits^[Symbol],LengthBase^[Symbol]);
    Distance:=DecodeSymbol(dt);
    Offset:=ReadBits(DistanceBits^[Distance],DistanceBase^[Distance]);
    IncSize(length);
    for i:=0 to length-1 do begin
     Dest[i]:=Dest[i-Offset];
    end;
    inc(Dest,Length);
    inc(DestLen,Length);
   end;
  end;
 end;
 function InflateUncompressedBlock:boolean;
 var length,invlength:TVkUInt32;
 begin
  result:=false;
  length:=(TVkUInt8(source[1]) shl 8) or TVkUInt8(source[0]);
  invlength:=(TVkUInt8(source[3]) shl 8) or TVkUInt8(source[2]);
  if length<>((not invlength) and $ffff) then begin
   exit;
  end;
  IncSize(length);
  inc(Source,4);
  if Length>0 then begin
   Move(Source^,Dest^,Length);
   inc(Source,Length);
   inc(Dest,Length);
  end;
  BitCount:=0;
  inc(DestLen,Length);
  result:=true;
 end;
 function InflateFixedBlock:boolean;
 begin
  result:=InflateBlockData(FixedSymbolLengthTree^,FixedDistanceTree^);
 end;
 function InflateDynamicBlock:boolean;
 begin
  DecodeTrees(SymbolLengthTree^,DistanceTree^);
  result:=InflateBlockData(SymbolLengthTree^,DistanceTree^);
 end;
 function Uncompress:boolean;
 var Final,r:boolean;
     BlockType:TVkUInt32;
 begin
  result:=false;
  BitCount:=0;
  Final:=false;
  while not Final do begin
   Final:=GetBit<>0;
   BlockType:=ReadBits(2,0);
   case BlockType of
    0:begin
     r:=InflateUncompressedBlock;
    end;
    1:begin
     r:=InflateFixedBlock;
    end;
    2:begin
     r:=InflateDynamicBlock;
    end;
    else begin
     r:=false;
    end;
   end;
   if not r then begin
    exit;
   end;
  end;
  result:=true;
 end;
 function UncompressZLIB:boolean;
 var cmf,flg:TVkUInt8;
     a32:TVkUInt32;
 begin
  result:=false;
  Source:=InData;
  cmf:=TVkUInt8(Source[0]);
  flg:=TVkUInt8(Source[1]);
  if ((((cmf shl 8)+flg) mod 31)<>0) or ((cmf and $f)<>8) or ((cmf shr 4)>7) or ((flg and $20)<>0) then begin
   exit;
  end;
  a32:=(TVkUInt8(Source[InLen-4]) shl 24) or (TVkUInt8(Source[InLen-3]) shl 16) or (TVkUInt8(Source[InLen-2]) shl 8) or (TVkUInt8(Source[InLen-1]) shl 0);
  inc(Source,2);
  dec(InLen,6);
  SourceEnd:=@Source[InLen];
  result:=Uncompress;
  if not result then begin
   exit;
  end;
  result:=adler32(DestData,DestLen)=a32;
 end;
 function UncompressDirect:boolean;
 begin
  Source:=InData;
  SourceEnd:=@Source[InLen];
  result:=Uncompress;
 end;
begin
 DestData:=nil;
 LengthBits:=nil;
 DistanceBits:=nil;
 LengthBase:=nil;
 DistanceBase:=nil;
 SymbolLengthTree:=nil;
 DistanceTree:=nil;
 FixedSymbolLengthTree:=nil;
 FixedDistanceTree:=nil;
 try
  New(LengthBits);
  New(DistanceBits);
  New(LengthBase);
  New(DistanceBase);
  New(SymbolLengthTree);
  New(DistanceTree);
  New(FixedSymbolLengthTree);
  New(FixedDistanceTree);
  try
   begin
    FillChar(LengthBits^,sizeof(TBits),TVulkanRawByteChar(#0));
    FillChar(DistanceBits^,sizeof(TBits),TVulkanRawByteChar(#0));
    FillChar(LengthBase^,sizeof(TBase),TVulkanRawByteChar(#0));
    FillChar(DistanceBase^,sizeof(TBase),TVulkanRawByteChar(#0));
    FillChar(SymbolLengthTree^,sizeof(TTree),TVulkanRawByteChar(#0));
    FillChar(DistanceTree^,sizeof(TTree),TVulkanRawByteChar(#0));
    FillChar(FixedSymbolLengthTree^,sizeof(TTree),TVulkanRawByteChar(#0));
    FillChar(FixedDistanceTree^,sizeof(TTree),TVulkanRawByteChar(#0));
   end;
   begin
    BuildFixedTrees(FixedSymbolLengthTree^,FixedDistanceTree^);
    BuildBitsBase(PVulkanRawByteChar(TVkPointer(@LengthBits^[0])),pword(TVkPointer(@LengthBase^[0])),4,3);
    BuildBitsBase(PVulkanRawByteChar(TVkPointer(@DistanceBits^[0])),pword(TVkPointer(@DistanceBase^[0])),2,1);
    LengthBits^[28]:=0;
    LengthBase^[28]:=258;
   end;
   begin
    GetMem(DestData,4096);
    DestSize:=4096;
    Dest:=DestData;
    DestLen:=0;
    if ParseHeader then begin
     result:=UncompressZLIB;
    end else begin
     result:=UncompressDirect;
    end;
    if result then begin
     ReAllocMem(DestData,DestLen);
    end else if assigned(DestData) then begin
     FreeMem(DestData);
     DestData:=nil;
    end;
   end;
  finally
   if assigned(LengthBits) then begin
    Dispose(LengthBits);
   end;
   if assigned(DistanceBits) then begin
    Dispose(DistanceBits);
   end;
   if assigned(LengthBase) then begin
    Dispose(LengthBase);
   end;
   if assigned(DistanceBase) then begin
    Dispose(DistanceBase);
   end;
   if assigned(SymbolLengthTree) then begin
    Dispose(SymbolLengthTree);
   end;
   if assigned(DistanceTree) then begin
    Dispose(DistanceTree);
   end;
   if assigned(FixedSymbolLengthTree) then begin
    Dispose(FixedSymbolLengthTree);
   end;
   if assigned(FixedDistanceTree) then begin
    Dispose(FixedDistanceTree);
   end;
  end;
 except
  result:=false;
 end;
end;

type ELoadPNGImage=class(Exception);

     PPNGPixelFormat=^TPNGPixelFormat;
     TPNGPixelFormat=
      (
       ppfUnknown,
       ppfR8G8B8A8,
       ppfR16G16B16A16
      );

function LoadPNGImage(DataPointer:TVkPointer;DataSize:TVkUInt32;var ImageData:TVkPointer;var ImageWidth,ImageHeight:TVkInt32;const HeaderOnly:boolean;var PixelFormat:TPNGPixelFormat):boolean;
type TBitsUsed=array[0..7] of TVkUInt32;
     PByteArray=^TByteArray;
     TByteArray=array[0..65535] of TVkUInt8;
     TColorData=TVkUInt64;
     TPixelColorType=
      (
       pctUnknown,
       pctPalette1,
       pctPalette2,
       pctPalette4,
       pctPalette8,
       pctGray1,
       pctGray2,
       pctGray4,
       pctGray8,
       pctGray16,
       pctGrayAlpha8,
       pctGrayAlpha16,
       pctColor8,
       pctColor16,
       pctColorAlpha8,
       pctColorAlpha16
      );
     PPNGPixelUI8=^TPNGPixelUI8;
     TPNGPixelUI8=packed record
      r,g,b,a:TVkUInt8;
     end;
     PPNGPixelUI16=^TPNGPixelUI16;
     TPNGPixelUI16=packed record
      r,g,b,a:TVkUInt16;
     end;
const StartPoints:array[0..7,0..1] of TVkUInt16=((0,0),(0,0),(4,0),(0,4),(2,0),(0,2),(1,0),(0,1));
      Delta:array[0..7,0..1] of TVkUInt16=((1,1),(8,8),(8,8),(4,8),(4,4),(2,4),(2,2),(1,2));
      BitsUsed1Depth:TBitsUsed=($80,$40,$20,$10,$08,$04,$02,$01);
      BitsUsed2Depth:TBitsUsed=($c0,$30,$0c,$03,0,0,0,0);
      BitsUsed4Depth:TBitsUsed=($f0,$0f,0,0,0,0,0,0);
var DataEnd,DataPtr,DataNextChunk,DataPtrEx:TVkPointer;
    PixelColorType:TPixelColorType;
    ByteWidth:TVkInt32;
    CountBitsUsed,BitShift:TVkUInt32;
    BitDepth,StartX,StartY,DeltaX,DeltaY,OutputBitsPerPixel,WidthHeight:TVkInt32;
    BitsUsed:TBitsUsed;
    SwitchLine,CurrentLine,PreviousLine:PByteArray;
    CountScanlines,ScanLineLength:array[0..7] of TVkUInt32;
    ChunkLength,ChunkType,Width,Height,ColorType,Comp,Filter,Interlace,CRC,
    PalImgBytes,ImgBytes,PaletteSize,l,ml:TVkUInt32;
    First,HasTransparent,CgBI:boolean;
    Palette:array of TPNGPixelUI16;
    TransparentColor:array of TVkUInt16;
    i,rx,ry,y{,BitsPerPixel,ImageLineWidth,ImageSize},StartPass,EndPass,d:TVkInt32;
    idata,DecompressPtr:TVkPointer;
    idatasize,idatacapacity,idataexpandedsize,LineFilter:TVkUInt32;
    idataexpanded:TVkPointer;
 procedure RaiseError;
 begin
  raise ELoadPNGImage.Create('Invalid or corrupt PNG stream');
 end;
 function Swap16(x:TVkUInt16):TVkUInt16;
 begin
  result:=((x and $ff) shl 8) or ((x and $ff00) shr 8);
 end;
 function Swap32(x:TVkUInt32):TVkUInt32;
 begin
  result:=(Swap16(x and $ffff) shl 16) or Swap16((x and $ffff0000) shr 16);
 end;
 function Swap64(x:TVkUInt64):TVkUInt64;
 begin
  result:=(TVkUInt64(Swap32(x and TVkUInt64($ffffffff))) shl 32) or Swap32((x and TVkUInt64($ffffffff00000000)) shr 32);
 end;
 function GetU8(var p:TVkPointer):TVkUInt8;
 begin
  result:=TVkUInt8(p^);
  inc(PVulkanRawByteChar(p),sizeof(TVkUInt8));
 end;
 function GetU16(var p:TVkPointer):TVkUInt16;
 begin
  result:=GetU8(p) shl 8;
  result:=result or GetU8(p);
 end;
 function GetU32(var p:TVkPointer):TVkUInt32;
 begin
  result:=GetU16(p) shl 16;
  result:=result or GetU16(p);
 end;
 procedure HandleScanLine(const y,CurrentPass:TVkInt32;const ScanLine:PByteArray);
 var x,l,pc:TVkInt32;
     UsingBitGroup,DataIndex:TVkUInt32;
     c:TColorData;
     pe:TPNGPixelUI16;
     pui8:PPNGPixelUI8;
     pui16:PPNGPixelUI16;
  function CalcColor:TColorData;
  var i:TVkInt32;
      p:TVkPointer;
      w:PVkUInt16;
      v:TVkUInt16;
  begin
   if UsingBitGroup=0 then begin
{$ifdef big_endian}
    result:=0;
    Move(CurrentLine^[DataIndex],result,ByteWidth);
{$else}
    p:=@CurrentLine^[DataIndex];
    case ByteWidth of
     1:begin
      result:=TVKUInt8(p^);
     end;
     2:begin
      result:=TVKUInt16(p^);
     end;
     4:begin
      result:=TVKUInt32(p^);
     end;
     8:begin
      result:=TVKUInt64(p^);
     end;
     else begin
      result:=0;
      Move(p^,result,ByteWidth);
     end;
    end;
{$endif}
    if BitDepth=16 then begin
     p:=@result;
     w:=p;
     for i:=1 to ByteWidth div SizeOf(TVkUInt16) do begin
      v:=w^;
      w^:=((v and $ff) shl 8) or ((v and $ff00) shr 8);
      inc(w);
     end;
    end;
{$ifdef big_endian}
    result:=Swap64(result);
{$endif}
    inc(DataIndex,ByteWidth);
   end else begin
    result:=0;
   end;
   if ByteWidth=1 then begin
    result:=(TVkUInt32(result and BitsUsed[UsingBitGroup]) and $ffffffff) shr (((CountBitsUsed-UsingBitGroup)-1)*BitShift);
    inc(UsingBitgroup);
    if UsingBitGroup>=CountBitsUsed then begin
     UsingBitGroup:=0;
    end;
   end;
  end;
 begin
  UsingBitGroup:=0;
  DataIndex:=0;
  pc:=length(Palette);
  l:=length(TransparentColor);
  for x:=0 to ScanlineLength[CurrentPass]-1 do begin
   case PixelColorType of
    pctPalette1:begin
     c:=CalcColor;
     if c<pc then begin
      pe:=Palette[c];
     end else begin
      pe.r:=0;
      pe.g:=0;
      pe.b:=0;
      pe.a:=0;
     end;
    end;
    pctPalette2:begin
     c:=CalcColor;
     if c<pc then begin
      pe:=Palette[c];
     end else begin
      pe.r:=0;
      pe.g:=0;
      pe.b:=0;
      pe.a:=0;
     end;
    end;
    pctPalette4:begin
     c:=CalcColor;
     if c<pc then begin
      pe:=Palette[c];
     end else begin
      pe.r:=0;
      pe.g:=0;
      pe.b:=0;
      pe.a:=0;
     end;
    end;
    pctPalette8:begin
     c:=CalcColor;
     if c<pc then begin
      pe:=Palette[c];
     end else begin
      pe.r:=0;
      pe.g:=0;
      pe.b:=0;
      pe.a:=0;
     end;
    end;
    pctGray1:begin
     c:=CalcColor;
     pe.r:=(0-(c and 1)) and $ffff;
     pe.g:=(0-(c and 1)) and $ffff;
     pe.b:=(0-(c and 1)) and $ffff;
     pe.a:=$ffff;
    end;
    pctGray2:begin
     c:=CalcColor;
     pe.r:=(c and 3) or ((c and 3) shl 2) or ((c and 3) shl 4) or ((c and 3) shl 6) or ((c and 3) shl 8) or ((c and 3) shl 10) or ((c and 3) shl 12) or ((c and 3) shl 14);
     pe.g:=(c and 3) or ((c and 3) shl 2) or ((c and 3) shl 4) or ((c and 3) shl 6) or ((c and 3) shl 8) or ((c and 3) shl 10) or ((c and 3) shl 12) or ((c and 3) shl 14);
     pe.b:=(c and 3) or ((c and 3) shl 2) or ((c and 3) shl 4) or ((c and 3) shl 6) or ((c and 3) shl 8) or ((c and 3) shl 10) or ((c and 3) shl 12) or ((c and 3) shl 14);
     pe.a:=$ffff;
    end;
    pctGray4:begin
     c:=CalcColor;
     pe.r:=(c and $f) or ((c and $f) shl 4) or ((c and $f) shl 8) or ((c and $f) shl 12);
     pe.g:=(c and $f) or ((c and $f) shl 4) or ((c and $f) shl 8) or ((c and $f) shl 12);
     pe.b:=(c and $f) or ((c and $f) shl 4) or ((c and $f) shl 8) or ((c and $f) shl 12);
     pe.a:=$ffff;
    end;
    pctGray8:begin
     pe.r:=TVkUInt8(TVkPointer(@CurrentLine^[DataIndex+0])^) or (TVkUInt16(TVkUInt8(TVkPointer(@CurrentLine^[DataIndex+0])^)) shl 8);
     pe.g:=pe.r;
     pe.b:=pe.r;
     pe.a:=$ffff; 
     inc(DataIndex);
    end;
    pctGray16:begin
     pe.r:=(TVkUInt16(TVkUInt8(TVkPointer(@CurrentLine^[DataIndex+0])^)) shl 8) or TVkUInt8(TVkPointer(@CurrentLine^[DataIndex+1])^);
     pe.g:=pe.r;
     pe.b:=pe.r;
     pe.a:=$ffff;
     inc(DataIndex,2);
    end;
    pctGrayAlpha8:begin
     c:=CalcColor;
     pe.r:=(c and $00ff) or ((c and $00ff) shl 8);
     pe.g:=(c and $00ff) or ((c and $00ff) shl 8);
     pe.b:=(c and $00ff) or ((c and $00ff) shl 8);
     pe.a:=(c and $ff00) or ((c and $ff00) shr 8);
    end;         
    pctGrayAlpha16:begin
     c:=CalcColor;
     pe.r:=(c shr 16) and $ffff;
     pe.g:=(c shr 16) and $ffff;
     pe.b:=(c shr 16) and $ffff;
     pe.a:=c and $ffff;
    end;
    pctColor8:begin
     pe.r:=TVkUInt8(TVkPointer(@CurrentLine^[DataIndex+0])^) or (TVkUInt16(TVkUInt8(TVkPointer(@CurrentLine^[DataIndex+0])^)) shl 8);
     pe.g:=TVkUInt8(TVkPointer(@CurrentLine^[DataIndex+1])^) or (TVkUInt16(TVkUInt8(TVkPointer(@CurrentLine^[DataIndex+1])^)) shl 8);
     pe.b:=TVkUInt8(TVkPointer(@CurrentLine^[DataIndex+2])^) or (TVkUInt16(TVkUInt8(TVkPointer(@CurrentLine^[DataIndex+2])^)) shl 8);
     pe.a:=$ffff;
     inc(DataIndex,3);
    end;
    pctColor16:begin
     pe.r:=(TVkUInt8(TVkPointer(@CurrentLine^[DataIndex+0])^) shl 8) or
           (TVkUInt8(TVkPointer(@CurrentLine^[DataIndex+1])^) shl 0);
     pe.g:=(TVkUInt8(TVkPointer(@CurrentLine^[DataIndex+2])^) shl 8) or
           (TVkUInt8(TVkPointer(@CurrentLine^[DataIndex+3])^) shl 0);
     pe.b:=(TVkUInt8(TVkPointer(@CurrentLine^[DataIndex+4])^) shl 8) or
           (TVkUInt8(TVkPointer(@CurrentLine^[DataIndex+5])^) shl 0);
     pe.a:=$ffff;
     inc(DataIndex,6);
    end;
    pctColorAlpha8:begin
     pe.r:=TVkUInt8(TVkPointer(@CurrentLine^[DataIndex+0])^) or (TVkUInt16(TVkUInt8(TVkPointer(@CurrentLine^[DataIndex+0])^)) shl 8);
     pe.g:=TVkUInt8(TVkPointer(@CurrentLine^[DataIndex+1])^) or (TVkUInt16(TVkUInt8(TVkPointer(@CurrentLine^[DataIndex+1])^)) shl 8);
     pe.b:=TVkUInt8(TVkPointer(@CurrentLine^[DataIndex+2])^) or (TVkUInt16(TVkUInt8(TVkPointer(@CurrentLine^[DataIndex+2])^)) shl 8);
     pe.a:=TVkUInt8(TVkPointer(@CurrentLine^[DataIndex+3])^) or (TVkUInt16(TVkUInt8(TVkPointer(@CurrentLine^[DataIndex+3])^)) shl 8);
     inc(DataIndex,4);
    end;
    pctColorAlpha16:begin
     pe.r:=(TVkUInt8(TVkPointer(@CurrentLine^[DataIndex+0])^) shl 8) or
           (TVkUInt8(TVkPointer(@CurrentLine^[DataIndex+1])^) shl 0);
     pe.g:=(TVkUInt8(TVkPointer(@CurrentLine^[DataIndex+2])^) shl 8) or
           (TVkUInt8(TVkPointer(@CurrentLine^[DataIndex+3])^) shl 0);
     pe.b:=(TVkUInt8(TVkPointer(@CurrentLine^[DataIndex+4])^) shl 8) or
           (TVkUInt8(TVkPointer(@CurrentLine^[DataIndex+5])^) shl 0);
     pe.a:=(TVkUInt8(TVkPointer(@CurrentLine^[DataIndex+6])^) shl 8) or
           (TVkUInt8(TVkPointer(@CurrentLine^[DataIndex+7])^) shl 0);
     inc(DataIndex,8);
    end;
    else begin
     pe.r:=0;
     pe.g:=0;
     pe.b:=0;
     pe.a:=0;
     RaiseError;
    end;
   end;
   if (((l=1) and ((pe.r=TransparentColor[0]) and (pe.r=TransparentColor[0]) and (pe.b=TransparentColor[0])))) or
      (((l=3) and ((pe.r=TransparentColor[0]) and (pe.r=TransparentColor[1]) and (pe.b=TransparentColor[2])))) then begin
    pe.a:=0;
   end;
   case PixelFormat of
    ppfR8G8B8A8:begin
     pui8:=PPNGPixelUI8(TVkPointer(@PVulkanRawByteChar(ImageData)[((y*TVkInt32(Width))+(StartX+(x*DeltaX)))*sizeof(TPNGPixelUI8)]));
     pui8^.r:=pe.r shr 8;
     pui8^.g:=pe.g shr 8;
     pui8^.b:=pe.b shr 8;
     pui8^.a:=pe.a shr 8;
    end;
    ppfR16G16B16A16:begin
     pui16:=PPNGPixelUI16(TVkPointer(@PVulkanRawByteChar(ImageData)[((y*TVkInt32(Width))+(StartX+(x*DeltaX)))*sizeof(TPNGPixelUI16)]));
     pui16^.r:=pe.r;
     pui16^.g:=pe.g;
     pui16^.b:=pe.b;
     pui16^.a:=pe.a;
    end;
    else begin
     RaiseError;
    end;
   end;
  end;
 end;
 procedure CgBISwapBGR2RGBandUnpremultiply;
 var i,b,a:TVkInt32;
     pui8:PPNGPixelUI8;
     pui16:PPNGPixelUI16;
 begin
  case PixelFormat of
   ppfR8G8B8A8:begin
    a:=255;
    pui8:=PPNGPixelUI8(TVkPointer(@PVulkanRawByteChar(ImageData)[0]));
    for i:=0 to WidthHeight-1 do begin
     a:=a and pui8^.a;
     inc(pui8);
    end;
    if ((ColorType and 4)<>0) or (a<>255) or HasTransparent then begin
     pui8:=PPNGPixelUI8(TVkPointer(@PVulkanRawByteChar(ImageData)[0]));
     for i:=0 to WidthHeight-1 do begin
      a:=pui8^.a;
      if a<>0 then begin
       b:=pui8^.b;
       pui8^.b:=(pui8^.r*255) div a;
       pui8^.r:=(b*255) div a;
       pui8^.g:=(pui8^.g*255) div a;
      end else begin
       b:=pui8^.b;
       pui8^.b:=pui8^.r;
       pui8^.r:=b;
      end;
      inc(pui8);
     end;
    end else begin
     pui8:=PPNGPixelUI8(TVkPointer(@PVulkanRawByteChar(ImageData)[0]));
     for i:=0 to WidthHeight-1 do begin
      b:=pui8^.b;
      pui8^.b:=pui8^.r;
      pui8^.r:=b;
      inc(pui8);
     end;
    end;
   end;
   ppfR16G16B16A16:begin
    a:=65535;
    pui16:=PPNGPixelUI16(TVkPointer(@PVulkanRawByteChar(ImageData)[0]));
    for i:=0 to WidthHeight-1 do begin
     a:=a and pui16^.a;
     inc(pui16);
    end;
    if ((ColorType and 4)<>0) or (a<>65535) or HasTransparent then begin
     pui16:=PPNGPixelUI16(TVkPointer(@PVulkanRawByteChar(ImageData)[0]));
     for i:=0 to WidthHeight-1 do begin
      a:=pui16^.a;
      if a<>0 then begin
       b:=pui16^.b;
       pui16^.b:=(pui16^.r*65535) div a;
       pui16^.r:=(b*65535) div a;
       pui16^.g:=(pui16^.g*65535) div a;
      end else begin
       b:=pui16^.b;
       pui16^.b:=pui16^.r;
       pui16^.r:=b;
      end;
      inc(pui16);
     end;
    end else begin
     pui16:=PPNGPixelUI16(TVkPointer(@PVulkanRawByteChar(ImageData)[0]));
     for i:=0 to WidthHeight-1 do begin
      b:=pui16^.b;
      pui16^.b:=pui16^.r;
      pui16^.r:=b;
      inc(pui16);
     end;
    end;
   end;
   else begin
    RaiseError;
   end;
  end;
 end;
 function Paeth(a,b,c:TVkInt32):TVkInt32;
 var p,pa,pb,pc:TVkInt32;
 begin
  p:=(a+b)-c;
  pa:=abs(p-a);
  pb:=abs(p-b);
  pc:=abs(p-c);
  if (pa<=pb) and (pa<=pc) then begin
   result:=a;
  end else if pb<=pc then begin
   result:=b;
  end else begin
   result:=c;
  end;
 end;
begin
 result:=false;
 ImageData:=nil;
 try
  Palette:=nil;
  TransparentColor:=nil;
  idataexpanded:=nil;
  idata:=nil;
  idataexpanded:=nil;
  try
   try
    if (assigned(DataPointer) and (DataSize>8)) and
       ((PVulkanRawByteChar(DataPointer)[0]=#$89) and (PVulkanRawByteChar(DataPointer)[1]=#$50) and (PVulkanRawByteChar(DataPointer)[2]=#$4e) and (PVulkanRawByteChar(DataPointer)[3]=#$47) and
        (PVulkanRawByteChar(DataPointer)[4]=#$0d) and (PVulkanRawByteChar(DataPointer)[5]=#$0a) and (PVulkanRawByteChar(DataPointer)[6]=#$1a) and (PVulkanRawByteChar(DataPointer)[7]=#$0a)) then begin
     DataEnd:=@PVulkanRawByteChar(DataPointer)[DataSize];
     First:=true;
     PalImgBytes:=0;
     ImgBytes:=0;
     DataPtr:=@PVulkanRawByteChar(DataPointer)[8];
     Width:=0;
     Height:=0;
     idatasize:=0;
     idatacapacity:=0;
     PaletteSize:=0;
     idataexpandedsize:=0;
     BitDepth:=0;
     ColorType:=0;
     Interlace:=0;
     WidthHeight:=0;
     CgBI:=false;
     HasTransparent:=false;
     while (PVulkanRawByteChar(DataPtr)+11)<PVulkanRawByteChar(DataEnd) do begin
      ChunkLength:=GetU32(DataPtr);
      if (PVulkanRawByteChar(DataPtr)+(4+ChunkLength))>PVulkanRawByteChar(DataEnd) then begin
       result:=false;
       break;
      end;
      DataPtrEx:=DataPtr;
      ChunkType:=GetU32(DataPtr);
      DataNextChunk:=@PVulkanRawByteChar(DataPtr)[ChunkLength];
      CRC:=GetU32(DataNextChunk);
      if CRC32(DataPtrEx,ChunkLength+4)<>CRC then begin
       result:=false;
       break;
      end;
      case ChunkType of
       TVkUInt32((ord('C') shl 24) or (ord('g') shl 16) or (ord('B') shl 8) or ord('I')):begin // CgBI
        CgBI:=true;
       end;
       TVkUInt32((ord('I') shl 24) or (ord('H') shl 16) or (ord('D') shl 8) or ord('R')):begin // IHDR
        if ChunkLength=13 then begin
         if not First then begin
          result:=false;
          break;
         end;
         First:=false;
         Width:=GetU32(DataPtr);
         Height:=GetU32(DataPtr);
         if ((Width>(1 shl 24)) or (Height>(1 shl 24))) or ((Width=0) or (Height=0)) then begin
          result:=false;
          break;
         end;
         if HeaderOnly then begin
          result:=true;
          break;
         end;
         BitDepth:=GetU8(DataPtr);
         if not (BitDepth in [1,2,4,8,16]) then begin
          result:=false;
          break;
         end;
         ColorType:=GetU8(DataPtr);
         if (ColorType>6) or ((ColorType<>3) and ((ColorType and 1)<>0)) then begin
          result:=false;
          exit;
         end else if ColorType=3 then begin
          PalImgBytes:=3;
         end;
         Comp:=GetU8(DataPtr);
         if Comp<>0 then begin
          result:=false;
          break;
         end;
         Filter:=GetU8(DataPtr);
         if Filter<>0 then begin
          result:=false;
          break;
         end;
         Interlace:=GetU8(DataPtr);
         if Interlace>1 then begin
          result:=false;
          break;
         end;
         if PalImgBytes=0 then begin
          if (ColorType and 2)<>0 then begin
           ImgBytes:=3;
          end else begin
           ImgBytes:=1;
          end;
          if (ColorType and 4)<>0 then begin
           inc(ImgBytes);
          end;
          if (((1 shl 30) div Width) div ImgBytes)<Height then begin
           result:=false;
           break;
          end;
         end else begin
          ImgBytes:=1;
          if (((1 shl 30) div Width) div 4)<Height then begin
           result:=false;
           break;
          end;
         end;
        end else begin
         result:=false;
         break;
        end;
       end;
       TVkUInt32((ord('P') shl 24) or (ord('L') shl 16) or (ord('T') shl 8) or ord('E')):begin // PLTE
        if First then begin
         result:=false;
         break;
        end;
        case PalImgBytes of
         3:begin
          PaletteSize:=ChunkLength div 3;
          if (PaletteSize*3)<>ChunkLength then begin
           result:=false;
           break;
          end;
          SetLength(Palette,PaletteSize);
          for i:=0 to PaletteSize-1 do begin
           d:=GetU8(DataPtr);
           Palette[i].r:=d or (d shl 8);
           d:=GetU8(DataPtr);
           Palette[i].g:=d or (d shl 8);
           d:=GetU8(DataPtr);
           Palette[i].b:=d or (d shl 8);
           Palette[i].a:=$ff;
          end;
         end;
         4:begin
          PaletteSize:=ChunkLength div 4;
          if (PaletteSize*4)<>ChunkLength then begin
           result:=false;
           exit;
          end;
          SetLength(Palette,PaletteSize);
          for i:=0 to PaletteSize-1 do begin
           d:=GetU8(DataPtr);
           Palette[i].r:=d or (d shl 8);
           d:=GetU8(DataPtr);
           Palette[i].g:=d or (d shl 8);
           d:=GetU8(DataPtr);
           Palette[i].b:=d or (d shl 8);
           d:=GetU8(DataPtr);
           Palette[i].a:=d or (d shl 8);
          end;
         end;
         else begin
          result:=false;
          break;
         end;
        end;
       end;
       TVkUInt32((ord('t') shl 24) or (ord('R') shl 16) or (ord('N') shl 8) or ord('S')):begin // tRNS
        if First or assigned(idata) then begin
         result:=false;
         break;
        end;
        if PalImgBytes<>0 then begin
         if (length(Palette)=0) or (TVkInt32(ChunkLength)>length(Palette)) then begin
          result:=false;
          break;
         end;
         PalImgBytes:=4;
         for i:=0 to PaletteSize-1 do begin
          d:=GetU8(DataPtr);
          Palette[i].a:=d or (d shl 8);
         end;
        end else begin
         if ChunkLength=ImgBytes then begin
          SetLength(TransparentColor,TVkInt32(ImgBytes));
          for i:=0 to TVkInt32(ImgBytes)-1 do begin
           d:=GetU8(DataPtr);
           TransparentColor[i]:=d or (d shl 8);
          end;
         end else begin
          if ((ImgBytes and 1)=0) or (ChunkLength<>(ImgBytes*2)) then begin
           result:=false;
           break;
          end;
          HasTransparent:=true;
          SetLength(TransparentColor,TVkInt32(ImgBytes));
          for i:=0 to TVkInt32(ImgBytes)-1 do begin
           TransparentColor[i]:=GetU16(DataPtr);
          end;
         end;
        end;
       end;
       TVkUInt32((ord('I') shl 24) or (ord('D') shl 16) or (ord('A') shl 8) or ord('T')):begin // IDAT
        if First or ((PalImgBytes<>0) and (length(Palette)=0)) then begin
         result:=false;
         break;
        end;
        if (idatasize=0) or (idatacapacity=0) or not assigned(idata) then begin
         idatasize:=ChunkLength;
         idatacapacity:=ChunkLength;
         GetMem(idata,idatacapacity);
         Move(DataPtr^,idata^,ChunkLength);
        end else begin
         if (idatasize+ChunkLength)>=idatacapacity then begin
          if idatacapacity=0 then begin
           idatacapacity:=1;
          end;
          while (idatasize+ChunkLength)>=idatacapacity do begin
           inc(idatacapacity,idatacapacity);
          end;
          ReallocMem(idata,idatacapacity);
         end;
         Move(DataPtr^,PVulkanRawByteChar(idata)[idatasize],ChunkLength);
         inc(idatasize,ChunkLength);
        end;
       end;
       TVkUInt32((ord('I') shl 24) or (ord('E') shl 16) or (ord('N') shl 8) or ord('D')):begin // IEND
        if First or ((PalImgBytes<>0) and (length(Palette)=0)) or not assigned(idata) then begin
         result:=false;
         break;
        end;
        if not DoInflate(idata,idatasize,idataexpanded,idataexpandedsize,not CgBI) then begin
         result:=false;
         break;
        end;
//      BitsPerPixel:=TVkInt32(ImgBytes)*BitDepth;
        ImageWidth:=Width;
        ImageHeight:=Height;
        WidthHeight:=Width*Height;
        case BitDepth of
         16:begin
          OutputBitsPerPixel:=64;
          PixelFormat:=ppfR16G16B16A16;
         end;
         else begin
          OutputBitsPerPixel:=32;
          PixelFormat:=ppfR8G8B8A8;
         end;
        end;
//      ImageBytesPerPixel:=((TVkInt32(ImgBytes)*TVkInt32(BitDepth))+7) shr 3;
//      ImageLineWidth:=((ImageWidth*BitsPerPixel)+7) shr 3;
//      ImageSize:=(((ImageWidth*ImageHeight)*BitsPerPixel)+7) shr 3;
        GetMem(ImageData,(((ImageWidth*ImageHeight)*OutputBitsPerPixel)+7) shr 3);
        try
         CountBitsUsed:=0;
         case Interlace of
          0:begin
           StartPass:=0;
           EndPass:=0;
           CountScanlines[0]:=Height;
           ScanLineLength[0]:=Width;
          end;
          1:begin
           StartPass:=1;
           EndPass:=7;
           for i:=1 to 7 do begin
            d:=Height div Delta[i,1];
            if (Height mod Delta[i,1])>StartPoints[i,1] then begin
             inc(d);
            end;
            CountScanLines[i]:=d;
            d:=Width div Delta[i,0];
            if (Width mod Delta[i,0])>StartPoints[i,0] then begin
             inc(d);
            end;
            ScanLineLength[i]:=d;
           end;
          end;
          else begin
           if assigned(ImageData) then begin
            FreeMem(ImageData);
            ImageData:=nil;
           end;
           result:=false;
           break;
          end;
         end;
         ByteWidth:=0;
         PixelColorType:=pctUnknown;
         case ColorType of
          0:begin
           case BitDepth of
            1:begin
             PixelColorType:=pctGray1;
             ByteWidth:=1;
            end;
            2:begin
             PixelColorType:=pctGray2;
             ByteWidth:=1;
            end;
            4:begin
             PixelColorType:=pctGray4;
             ByteWidth:=1;
            end;
            8:begin
             PixelColorType:=pctGray8;
             ByteWidth:=1;
            end;
            16:begin
             PixelColorType:=pctGray16;
             ByteWidth:=2;
            end;
           end;
          end;
          2:begin
           if BitDepth=8 then begin
            PixelColorType:=pctColor8;
            ByteWidth:=3;
           end else begin
            PixelColorType:=pctColor16;
            ByteWidth:=6;
           end;
          end;
          3:begin
           case BitDepth of
            1:begin
             PixelColorType:=pctPalette1;
            end;
            2:begin
             PixelColorType:=pctPalette2;
            end;
            4:begin
             PixelColorType:=pctPalette4;
            end;
            8:begin
             PixelColorType:=pctPalette8;
            end;
           end;
           if BitDepth=16 then begin
            ByteWidth:=2;
           end else begin
            ByteWidth:=1;
           end;
          end;
          4:begin
           if BitDepth=8 then begin
            PixelColorType:=pctGrayAlpha8;
            ByteWidth:=2;
           end else begin
            PixelColorType:=pctGrayAlpha16;
            ByteWidth:=4;
           end;
          end;
          6:begin
           if BitDepth=8 then begin
            PixelColorType:=pctColorAlpha8;
            ByteWidth:=4;
           end else begin
            PixelColorType:=pctColorAlpha16;
            ByteWidth:=8;
           end;
          end;
         end;
         case BitDepth of
          1:begin
           CountBitsUsed:=8;
           BitShift:=1;
           BitsUsed:=BitsUsed1Depth;
          end;
          2:begin
           CountBitsUsed:=4;
           BitShift:=2;
           BitsUsed:=BitsUsed2Depth;
          end;
          4:begin
           CountBitsUsed:=2;
           BitShift:=4;
           BitsUsed:=BitsUsed4Depth;
          end;
          8:begin
           CountBitsUsed:=1;
           BitShift:=0;
           BitsUsed[0]:=$ff;
          end;
         end;
         DecompressPtr:=idataexpanded;
         ml:=16;
         try
          GetMem(PreviousLine,16);
          GetMem(CurrentLine,16);
          for i:=StartPass to EndPass do begin
           StartX:=StartPoints[i,0];
           StartY:=StartPoints[i,1];
           DeltaX:=Delta[i,0];
           DeltaY:=Delta[i,1];
           if ByteWidth=1 then begin
            l:=ScanLineLength[i] div CountBitsUsed;
            if (ScanLineLength[i] mod CountBitsUsed)>0 then begin
             inc(l);
            end;
           end else begin
            l:=ScanLineLength[i]*TVkUInt32(ByteWidth);
           end;
           if ml=0 then begin
            GetMem(PreviousLine,l);
            GetMem(CurrentLine,l);
           end else if ml<l then begin
            ReallocMem(PreviousLine,l);
            ReallocMem(CurrentLine,l);
           end;
           ml:=l;
           FillChar(CurrentLine^,l,TVulkanRawByteChar(#0));
           for ry:=0 to CountScanlines[i]-1 do begin
            SwitchLine:=CurrentLine;
            CurrentLine:=PreviousLine;
            PreviousLine:=SwitchLine;
            y:=StartY+(ry*DeltaY);
            LineFilter:=GetU8(DecompressPtr);
            Move(DecompressPtr^,CurrentLine^,l);
            inc(PVulkanRawByteChar(DecompressPtr),l);
            case LineFilter of
             1:begin // Sub
              for rx:=0 to l-1 do begin
               if rx<ByteWidth then begin
                CurrentLine^[rx]:=CurrentLine^[rx] and $ff;
               end else begin
                CurrentLine^[rx]:=(CurrentLine^[rx]+CurrentLine^[rx-ByteWidth]) and $ff;
               end;
              end;
             end;
             2:begin // Up
              for rx:=0 to l-1 do begin
               CurrentLine^[rx]:=(CurrentLine^[rx]+PreviousLine^[rx]) and $ff;
              end;
             end;
             3:begin // Average
              for rx:=0 to l-1 do begin
               if rx<ByteWidth then begin
                CurrentLine^[rx]:=(CurrentLine^[rx]+(PreviousLine^[rx] div 2)) and $ff;
               end else begin
                CurrentLine^[rx]:=(CurrentLine^[rx]+((CurrentLine^[rx-ByteWidth]+PreviousLine^[rx]) div 2)) and $ff;
               end;
              end;
             end;
             4:begin // Paeth
              for rx:=0 to l-1 do begin
               if rx<ByteWidth then begin             
                CurrentLine^[rx]:=(CurrentLine^[rx]+Paeth(0,PreviousLine^[rx],0)) and $ff;
               end else begin
                CurrentLine^[rx]:=(CurrentLine^[rx]+Paeth(CurrentLine^[rx-ByteWidth],PreviousLine^[rx],PreviousLine^[rx-ByteWidth])) and $ff;
               end;
              end;
             end;
            end;
            HandleScanLine(y,i,CurrentLine);
           end;
          end;
         finally
          FreeMem(PreviousLine);
          FreeMem(CurrentLine);
         end;
         if CgBI then begin
          CgBISwapBGR2RGBandUnpremultiply;
         end;
        finally
        end;
        result:=true;
        break;
       end;
       else begin
       end;
      end;
      DataPtr:=DataNextChunk;
     end;
    end;
   except
    on e:ELoadPNGImage do begin
     result:=false;
    end;
    on e:Exception do begin
     raise;
    end;
   end;
  finally
   SetLength(Palette,0);
   SetLength(TransparentColor,0);
   if assigned(idata) then begin
    FreeMem(idata);
    idata:=nil;
   end;
   if assigned(idataexpanded) then begin
    FreeMem(idataexpanded);
    idataexpanded:=nil;
   end;
  end;
 except
  if assigned(ImageData) then begin
   FreeMem(ImageData);
   ImageData:=nil;
  end;
  result:=false;
 end;
end;

type ELoadJPEGImage=class(Exception);

function LoadJPEGImage(DataPointer:TVkPointer;DataSize:TVkUInt32;var ImageData:TVkPointer;var ImageWidth,ImageHeight:TVkInt32;const HeaderOnly:boolean):boolean;
type PIDCTInputBlock=^TIDCTInputBlock;
     TIDCTInputBlock=array[0..63] of TVkInt32;
     PIDCTOutputBlock=^TIDCTOutputBlock;
     TIDCTOutputBlock=array[0..65535] of TVkUInt8;
     PByteArray=^TByteArray;
     TByteArray=array[0..65535] of TVkUInt8;
     TPixels=array of TVkUInt8;
     PHuffmanCode=^THuffmanCode;
     THuffmanCode=record
      Bits:TVkUInt8;
      Code:TVkUInt8;
     end;
     PHuffmanCodes=^THuffmanCodes;
     THuffmanCodes=array[0..65535] of THuffmanCode;
     PComponent=^TComponent;
     TComponent=record
      Width:TVkInt32;
      Height:TVkInt32;
      Stride:TVkInt32;
      Pixels:TPixels;
      ID:TVkInt32;
      SSX:TVkInt32;
      SSY:TVkInt32;
      QTSel:TVkInt32;
      ACTabSel:TVkInt32;
      DCTabSel:TVkInt32;
      DCPred:TVkInt32;
     end;
     PContext=^TContext;
     TContext=record
      Valid:boolean;
      NoDecode:boolean;
      FastChroma:boolean;
      Len:TVkInt32;
      Size:TVkInt32;
      Width:TVkInt32;
      Height:TVkInt32;
      MBWidth:TVkInt32;
      MBHeight:TVkInt32;
      MBSizeX:TVkInt32;
      MBSizeY:TVkInt32;
      Components:array[0..2] of TComponent;
      CountComponents:TVkInt32;
      QTUsed:TVkInt32;
      QTAvailable:TVkInt32;
      QTable:array[0..3,0..63] of TVKUInt8;
      HuffmanCodeTable:array[0..3] of THuffmanCodes;
      Buf:TVkInt32;
      BufBits:TVkInt32;
      RSTInterval:TVkInt32;
      EXIFLE:boolean;
      CoSitedChroma:boolean;
      Block:TIDCTInputBlock;
     end;
const ZigZagOrderToRasterOrderConversionTable:array[0..63] of TVkUInt8=
       (
        0,1,8,16,9,2,3,10,17,24,32,25,18,11,4,5,
        12,19,26,33,40,48,41,34,27,20,13,6,7,14,21,28,
        35,42,49,56,57,50,43,36,29,22,15,23,30,37,44,51,
        58,59,52,45,38,31,39,46,53,60,61,54,47,55,62,63
       );
      ClipTable:array[0..$3ff] of TVkUInt8=
       (
        // 0..255
        0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,
        32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,
        64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,
        96,97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,127,
        128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,144,145,146,147,148,149,150,151,152,153,154,155,156,157,158,159,
        160,161,162,163,164,165,166,167,168,169,170,171,172,173,174,175,176,177,178,179,180,181,182,183,184,185,186,187,188,189,190,191,
        192,193,194,195,196,197,198,199,200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,
        224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,239,240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255,
        // 256..511
        255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
        255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
        255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
        255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
        255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
        255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
        255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
        255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
        // -512..-257
        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
        // -256..-1
        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
       );
      CF4A=-9;
      CF4B=111;
      CF4C=29;
      CF4D=-3;
      CF3A=28;
      CF3B=109;
      CF3C=-9;
      CF3X=104;
      CF3Y=27;
      CF3Z=-3;
      CF2A=139;
      CF2B=-11;
var Context:PContext;
    DataPosition:TVkUInt32;
 procedure RaiseError;
 begin
  raise ELoadJPEGImage.Create('Invalid or corrupt JPEG data stream');
 end;
 procedure ProcessIDCT(const aInputBlock:PIDCTInputBlock;const aOutputBlock:PIDCTOutputBlock;const aOutputStride:TVkInt32);
 const W1=2841;
       W2=2676;
       W3=2408;
       W5=1609;
       W6=1108;
       W7=565;
 var i,v0,v1,v2,v3,v4,v5,v6,v7,v8:TVkInt32;
     WorkBlock:PIDCTInputBlock;
     OutputBlock:PIDCTOutputBlock;
 begin
  for i:=0 to 7 do begin
   WorkBlock:=@aInputBlock^[i shl 3];
   v0:=WorkBlock^[0];
   v1:=WorkBlock^[4] shl 11;
   v2:=WorkBlock^[6];
   v3:=WorkBlock^[2];
   v4:=WorkBlock^[1];
   v5:=WorkBlock^[7];
   v6:=WorkBlock^[5];
   v7:=WorkBlock^[3];
   if (v1=0) and (v2=0) and (v3=0) and (v4=0) and (v5=0) and (v6=0) and (v7=0) then begin
    v0:=v0 shl 3;
    WorkBlock^[0]:=v0;
    WorkBlock^[1]:=v0;
    WorkBlock^[2]:=v0;
    WorkBlock^[3]:=v0;
    WorkBlock^[4]:=v0;
    WorkBlock^[5]:=v0;
    WorkBlock^[6]:=v0;
    WorkBlock^[7]:=v0;
   end else begin
    v0:=(v0 shl 11)+128;
    v8:=W7*(v4+v5);
    v4:=v8+((W1-W7)*v4);
    v5:=v8-((W1+W7)*v5);
    v8:=W3*(v6+v7);
    v6:=v8-((W3-W5)*v6);
    v7:=v8-((W3+W5)*v7);
    v8:=v0+v1;
    dec(v0,v1);
    v1:=W6*(v3+v2);
    v2:=v1-((W2+W6)*v2);
    v3:=v1+((W2-W6)*v3);
    v1:=v4+v6;
    dec(v4,v6);
    v6:=v5+v7;
    dec(v5,v7);
    v7:=v8+v3;
    dec(v8,v3);
    v3:=v0+v2;
    dec(v0,v2);
    v2:=SARLongint(((v4+v5)*181)+128,8);
    v4:=SARLongint(((v4-v5)*181)+128,8);
    WorkBlock^[0]:=SARLongint(v7+v1,8);
    WorkBlock^[1]:=SARLongint(v3+v2,8);
    WorkBlock^[2]:=SARLongint(v0+v4,8);
    WorkBlock^[3]:=SARLongint(v8+v6,8);
    WorkBlock^[4]:=SARLongint(v8-v6,8);
    WorkBlock^[5]:=SARLongint(v0-v4,8);
    WorkBlock^[6]:=SARLongint(v3-v2,8);
    WorkBlock^[7]:=SARLongint(v7-v1,8);
   end;
  end;
  for i:=0 to 7 do begin
   WorkBlock:=@aInputBlock^[i];
   v0:=WorkBlock^[0 shl 3];
   v1:=WorkBlock^[4 shl 3] shl 8;
   v2:=WorkBlock^[6 shl 3];
   v3:=WorkBlock^[2 shl 3];
   v4:=WorkBlock^[1 shl 3];
   v5:=WorkBlock^[7 shl 3];
   v6:=WorkBlock^[5 shl 3];
   v7:=WorkBlock^[3 shl 3];
   if (v1=0) and (v2=0) and (v3=0) and (v4=0) and (v5=0) and (v6=0) and (v7=0) then begin
    v0:=ClipTable[(SARLongint(v0+32,6)+128) and $3ff];
    OutputBlock:=@aOutputBlock^[i];
    OutputBlock^[aOutputStride*0]:=v0;
    OutputBlock^[aOutputStride*1]:=v0;
    OutputBlock^[aOutputStride*2]:=v0;
    OutputBlock^[aOutputStride*3]:=v0;
    OutputBlock^[aOutputStride*4]:=v0;
    OutputBlock^[aOutputStride*5]:=v0;
    OutputBlock^[aOutputStride*6]:=v0;
    OutputBlock^[aOutputStride*7]:=v0;
   end else begin
    v0:=(v0 shl 8)+8192;
    v8:=((v4+v5)*W7)+4;
    v4:=SARLongint(v8+((W1-W7)*v4),3);
    v5:=SARLongint(v8-((W1+W7)*v5),3);
    v8:=((v6+v7)*W3)+4;
    v6:=SARLongint(v8-((W3-W5)*v6),3);
    v7:=SARLongint(v8-((W3+W5)*v7),3);
    v8:=v0+v1;
    dec(v0,v1);
    v1:=((v3+v2)*w6)+4;
    v2:=SARLongint(v1-((W2+W6)*v2),3);
    v3:=SARLongint(v1+((W2-W6)*v3),3);
    v1:=v4+v6;
    dec(v4,v6);
    v6:=v5+v7;
    dec(v5,v7);
    v7:=v8+v3;
    dec(v8,v3);
    v3:=v0+v2;
    dec(v0,v2);
    v2:=SARLongint(((v4+v5)*181)+128,8);
    v4:=SARLongint(((v4-v5)*181)+128,8);
    OutputBlock:=@aOutputBlock^[i];
    OutputBlock^[aOutputStride*0]:=ClipTable[(SARLongint(v7+v1,14)+128) and $3ff];
    OutputBlock^[aOutputStride*1]:=ClipTable[(SARLongint(v3+v2,14)+128) and $3ff];
    OutputBlock^[aOutputStride*2]:=ClipTable[(SARLongint(v0+v4,14)+128) and $3ff];
    OutputBlock^[aOutputStride*3]:=ClipTable[(SARLongint(v8+v6,14)+128) and $3ff];
    OutputBlock^[aOutputStride*4]:=ClipTable[(SARLongint(v8-v6,14)+128) and $3ff];
    OutputBlock^[aOutputStride*5]:=ClipTable[(SARLongint(v0-v4,14)+128) and $3ff];
    OutputBlock^[aOutputStride*6]:=ClipTable[(SARLongint(v3-v2,14)+128) and $3ff];
    OutputBlock^[aOutputStride*7]:=ClipTable[(SARLongint(v7-v1,14)+128) and $3ff];
   end;
  end;
 end;
 function PeekBits(Bits:TVkInt32):TVkInt32;
 var NewByte,Marker:TVkInt32;
 begin
  if Bits>0 then begin
   while Context^.BufBits<Bits do begin
    if DataPosition>=DataSize then begin
     Context^.Buf:=(Context^.Buf shl 8) or $ff;
     inc(Context^.BufBits,8);
    end else begin
     NewByte:=PByteArray(DataPointer)^[DataPosition];
     inc(DataPosition);
     Context^.Buf:=(Context^.Buf shl 8) or NewByte;
     inc(Context^.BufBits,8);
     if NewByte=$ff then begin
      if DataPosition<DataSize then begin
       Marker:=PByteArray(DataPointer)^[DataPosition];
       inc(DataPosition);
       case Marker of
        $00,$ff:begin
        end;
        $d9:begin
         DataPosition:=DataSize;
        end;
        else begin
         if (Marker and $f8)=$d0 then begin
          Context^.Buf:=(Context^.Buf shl 8) or Marker;
          inc(Context^.BufBits,8);
         end else begin
          RaiseError;
         end;
        end;
       end;
      end else begin
       RaiseError;
      end;
     end;
    end;
   end;
   result:=(Context^.Buf shr (Context^.BufBits-Bits)) and ((1 shl Bits)-1);
  end else begin
   result:=0;
  end;
 end;
 procedure SkipBits(Bits:TVkInt32);
 begin
  if Context^.BufBits<Bits then begin
   PeekBits(Bits);
  end;
  dec(Context^.BufBits,Bits);
 end;
 function GetBits(Bits:TVkInt32):TVkInt32;
 begin
  result:=PeekBits(Bits);
  if Context^.BufBits<Bits then begin
   PeekBits(Bits);
  end;
  dec(Context^.BufBits,Bits);
 end;
 function GetHuffmanCode(const Huffman:PHuffmanCodes;const Code:PVkInt32):TVkInt32;
 var Bits:TVkInt32;
 begin
  result:=PeekBits(16);
  Bits:=Huffman^[result].Bits;
  if Bits=0 then begin
// writeln(result);
   RaiseError;
   result:=0;
  end else begin
   SkipBits(Bits);
   result:=Huffman^[result].Code;
   if assigned(Code) then begin
    Code^:=result and $ff;
   end;
   Bits:=result and $0f;
   if Bits=0 then begin
    result:=0;
   end else begin
    result:=GetBits(Bits);
    if result<(1 shl (Bits-1)) then begin
     inc(result,(TVkInt32(-1) shl Bits)+1);
    end;
   end;
  end;
 end;
 procedure UpsampleHCoSited(const Component:PComponent);
 var MaxX,x,y:TVkInt32;
     NewPixels:TPixels;
     ip,op:PByteArray;
 begin
  MaxX:=Component^.Width-1;
  NewPixels:=nil;
  try
   SetLength(NewPixels,(Component^.Width*Component^.Height) shl 1);
   ip:=@Component^.Pixels[0];
   op:=@NewPixels[0];
   for y:=0 to Component^.Height-1 do begin
    op^[0]:=ip^[0];
    op^[1]:=ClipTable[SARLongint(((((ip^[0] shl 3)+(9*ip^[1]))-ip^[2]))+8,4) and $3ff];
    op^[2]:=ip^[1];
    for x:=2 to MaxX-1 do begin
     op^[(x shl 1)-1]:=ClipTable[SARLongint(((9*(ip^[x-1]+ip^[x]))-(ip^[x-2]+ip^[x+1]))+8,4) and $3ff];
     op^[x shl 1]:=ip^[x];
    end;
    ip:=@ip^[Component^.Stride-3];
    op:=@op^[(Component^.Width shl 1)-3];
    op^[0]:=ClipTable[SARLongint(((((ip^[2] shl 3)+(9*ip^[1]))-ip^[0]))+8,4) and $3ff];
    op^[1]:=ip^[2];
    op^[2]:=ClipTable[SARLongint(((ip^[2]*17)-ip^[1])+8,4) and $3ff];
    ip:=@ip^[3];
    op:=@op^[3];
   end;
  finally
   Component^.Width:=Component^.Width shl 1;
   Component^.Stride:=Component^.Width;
   Component^.Pixels:=NewPixels;
   NewPixels:=nil;
  end;
 end;
 procedure UpsampleHCentered(const Component:PComponent);
 var MaxX,x,y:TVkInt32;
     NewPixels:TPixels;
     ip,op:PByteArray;
 begin
  MaxX:=Component^.Width-3;
  NewPixels:=nil;
  try
   SetLength(NewPixels,(Component^.Width*Component^.Height) shl 1);
   ip:=@Component^.Pixels[0];
   op:=@NewPixels[0];
   for y:=0 to Component^.Height-1 do begin
    op^[0]:=ClipTable[SARLongint(((CF2A*ip^[0])+(CF2B*ip^[1]))+64,7) and $3ff];
    op^[1]:=ClipTable[SARLongint(((CF3X*ip^[0])+(CF3Y*ip^[1])+(CF3Z*ip^[2]))+64,7) and $3ff];
    op^[2]:=ClipTable[SARLongint(((CF3A*ip^[0])+(CF3B*ip^[1])+(CF3C*ip^[2]))+64,7) and $3ff];
    for x:=0 to MaxX-1 do begin
     op^[(x shl 1)+3]:=ClipTable[SARLongint(((CF4A*ip^[x])+(CF4B*ip^[x+1])+(CF4C*ip^[x+2])+(CF4D*ip^[x+3]))+64,7) and $3ff];
     op^[(x shl 1)+4]:=ClipTable[SARLongint(((CF4D*ip^[x])+(CF4C*ip^[x+1])+(CF4B*ip^[x+2])+(CF4A*ip^[x+3]))+64,7) and $3ff];
    end;
    ip:=@ip^[Component^.Stride-3];
    op:=@op^[(Component^.Width shl 1)-3];
    op^[0]:=ClipTable[SARLongint(((CF3A*ip^[2])+(CF3B*ip^[1])+(CF3C*ip^[0]))+64,7) and $3ff];
    op^[1]:=ClipTable[SARLongint(((CF3X*ip^[2])+(CF3Y*ip^[1])+(CF3Z*ip^[0]))+64,7) and $3ff];
    op^[2]:=ClipTable[SARLongint(((CF2A*ip^[2])+(CF2B*ip^[1]))+64,7) and $3ff];
    ip:=@ip^[3];
    op:=@op^[3];
   end;
  finally
   Component^.Width:=Component^.Width shl 1;
   Component^.Stride:=Component^.Width;
   Component^.Pixels:=NewPixels;
   NewPixels:=nil;
  end;
 end;
 procedure UpsampleVCoSited(const Component:PComponent);
 var w,h,s1,s2,x,y:TVkInt32;
     NewPixels:TPixels;
     ip,op:PByteArray;
 begin
  w:=Component^.Width;
  h:=Component^.Height;
  s1:=Component^.Stride;
  s2:=s1 shl 1;
  NewPixels:=nil;
  try
   SetLength(NewPixels,(Component^.Width*Component^.Height) shl 1);
   for x:=0 to w-1 do begin
    ip:=@Component^.Pixels[x];
    op:=@NewPixels[x];
    op^[0]:=ip^[0];
    op:=@op^[w];
    op^[0]:=ClipTable[SARLongint(((((ip^[0] shl 3)+(9*ip^[s1]))-ip^[s2]))+8,4) and $3ff];
    op:=@op^[w];
    op^[0]:=ip^[s1];
    op:=@op^[w];
    ip:=@ip^[s1];
    for y:=0 to h-4 do begin
     op^[0]:=ClipTable[SARLongint((((9*(ip^[0]+ip^[s1]))-(ip^[-s1]+ip^[s2])))+8,4) and $3ff];
     op:=@op^[w];
     op^[0]:=ip^[s1];
     op:=@op^[w];
     ip:=@ip^[s1];
    end;
    op^[0]:=ClipTable[SARLongint(((ip^[s1] shl 3)+(9*ip^[0])-(ip^[-s1]))+8,4) and $3ff];
    op:=@op^[w];
    op^[0]:=ip[-s1];
    op:=@op^[w];
    op^[0]:=ClipTable[SARLongint(((17*ip^[s1])-ip^[0])+8,4) and $3ff];
   end;
  finally
   Component^.Height:=Component^.Height shl 1;
   Component^.Pixels:=NewPixels;
   NewPixels:=nil;
  end;
 end;
 procedure UpsampleVCentered(const Component:PComponent);
 var w,h,s1,s2,x,y:TVkInt32;
     NewPixels:TPixels;
     ip,op:PByteArray;
 begin
  w:=Component^.Width;
  h:=Component^.Height;
  s1:=Component^.Stride;
  s2:=s1 shl 1;
  NewPixels:=nil;
  try
   SetLength(NewPixels,(Component^.Width*Component^.Height) shl 1);
   for x:=0 to w-1 do begin
    ip:=@Component^.Pixels[x];
    op:=@NewPixels[x];
    op^[0]:=ClipTable[SARLongint(((CF2A*ip^[0])+(CF2B*ip^[s1]))+64,7) and $3ff];
    op:=@op^[w];
    op^[0]:=ClipTable[SARLongint(((CF3X*ip^[0])+(CF3Y*ip^[s1])+(CF3Z*ip^[s2]))+64,7) and $3ff];
    op:=@op^[w];
    op^[0]:=ClipTable[SARLongint(((CF3A*ip^[0])+(CF3B*ip^[s1])+(CF3C*ip^[s2]))+64,7) and $3ff];
    op:=@op^[w];
    ip:=@ip^[s1];
    for y:=0 to h-4 do begin
     op^[0]:=ClipTable[SARLongint(((CF4A*ip^[-s1])+(CF4B*ip^[0])+(CF4C*ip^[s1])+(CF4D*ip^[s2]))+64,7) and $3ff];
     op:=@op^[w];
     op^[0]:=ClipTable[SARLongint(((CF4D*ip^[-s1])+(CF4C*ip^[0])+(CF4B*ip^[s1])+(CF4A*ip^[s2]))+64,7) and $3ff];
     op:=@op^[w];
     ip:=@ip^[s1];
    end;
    ip:=@ip^[s1];
    op^[0]:=ClipTable[SARLongint(((CF3A*ip^[0])+(CF3B*ip^[-s1])+(CF3C*ip^[-s2]))+64,7) and $3ff];
    op:=@op^[w];
    op^[0]:=ClipTable[SARLongint(((CF3X*ip^[0])+(CF3Y*ip^[-s1])+(CF3Z*ip^[-s2]))+64,7) and $3ff];
    op:=@op^[w];
    op^[0]:=ClipTable[SARLongint(((CF2A*ip^[0])+(CF2B*ip^[-s1]))+64,7) and $3ff];
   end;
  finally
   Component^.Height:=Component^.Height shl 1;
   Component^.Pixels:=NewPixels;
   NewPixels:=nil;
  end;
 end;
var Index,SubIndex,Len,MaxSSX,MaxSSY,Value,Remain,Spread,CodeLen,DHTCurrentCount,Code,Coef,
    NextDataPosition,Count,v0,v1,v2,v3,mbx,mby,sbx,sby,RSTCount,NextRST,x,y,vY,vCb,vCr:TVkInt32;
    ChunkTag:TVkUInt8;
    Component:PComponent;
    DHTCounts:array[0..15] of TVkUInt8;
    Huffman:PHuffmanCode;
    pY,aCb,aCr,oRGBX:PVkUInt8;
begin
 result:=false;
 ImageData:=nil;
 if (DataSize>=2) and (((PByteArray(DataPointer)^[0] xor $ff) or (PByteArray(DataPointer)^[1] xor $d8))=0) then begin
  DataPosition:=2;
  GetMem(Context,SizeOf(TContext));
  try
   FillChar(Context^,SizeOf(TContext),#0);
   Initialize(Context^);
   try
    while ((DataPosition+2)<DataSize) and (PByteArray(DataPointer)^[DataPosition]=$ff) do begin
     ChunkTag:=PByteArray(DataPointer)^[DataPosition+1];
     inc(DataPosition,2);
     case ChunkTag of
      $c0{SQF}:begin

       if (DataPosition+2)>=DataSize then begin
        RaiseError;
       end;

       Len:=(TVKUInt16(PByteArray(DataPointer)^[DataPosition+0]) shl 8) or PByteArray(DataPointer)^[DataPosition+1];

       if ((DataPosition+TVkUInt32(Len))>=DataSize) or
          (Len<9) or
          (PByteArray(DataPointer)^[DataPosition+2]<>8) then begin
        RaiseError;
       end;

       inc(DataPosition,2);
       dec(Len,2);

       Context^.Width:=(TVKUInt16(PByteArray(DataPointer)^[DataPosition+1]) shl 8) or PByteArray(DataPointer)^[DataPosition+2];
       Context^.Height:=(TVKUInt16(PByteArray(DataPointer)^[DataPosition+3]) shl 8) or PByteArray(DataPointer)^[DataPosition+4];
       Context^.CountComponents:=PByteArray(DataPointer)^[DataPosition+5];

       if (Context^.Width=0) or (Context^.Height=0) or not (Context^.CountComponents in [1,3]) then begin
        RaiseError;
       end;

       inc(DataPosition,6);
       dec(Len,6);

       if Len<(Context^.CountComponents*3) then begin
        RaiseError;
       end;

       MaxSSX:=0;
       MaxSSY:=0;

       for Index:=0 to Context^.CountComponents-1 do begin
        Component:=@Context^.Components[Index];
        Component^.ID:=PByteArray(DataPointer)^[DataPosition+0];
        Component^.SSX:=PByteArray(DataPointer)^[DataPosition+1] shr 4;
        Component^.SSY:=PByteArray(DataPointer)^[DataPosition+1] and 15;
        Component^.QTSel:=PByteArray(DataPointer)^[DataPosition+2];
        inc(DataPosition,3);
        dec(Len,3);
        if (Component^.SSX=0) or ((Component^.SSX and (Component^.SSX-1))<>0) or
           (Component^.SSY=0) or ((Component^.SSY and (Component^.SSY-1))<>0) or
           ((Component^.QTSel and $fc)<>0) then begin
         RaiseError;
        end;
        Context^.QTUsed:=Context^.QTUsed or (1 shl Component^.QTSel);
        MaxSSX:=Max(MaxSSX,Component^.SSX);
        MaxSSY:=Max(MaxSSY,Component^.SSY);
       end;

       if Context^.CountComponents=1 then begin
        Component:=@Context^.Components[0];
        Component^.SSX:=1;
        Component^.SSY:=1;
        MaxSSX:=0;
        MaxSSY:=0;
       end;

       Context^.MBSizeX:=MaxSSX shl 3;
       Context^.MBSizeY:=MaxSSY shl 3;

       Context^.MBWidth:=(Context^.Width+(Context^.MBSizeX-1)) div Context^.MBSizeX;
       Context^.MBHeight:=(Context^.Height+(Context^.MBSizeY-1)) div Context^.MBSizeY;

       for Index:=0 to Context^.CountComponents-1 do begin
        Component:=@Context^.Components[Index];
        Component^.Width:=((Context^.Width*Component^.SSX)+(MaxSSX-1)) div MaxSSX;
        Component^.Height:=((Context^.Height*Component^.SSY)+(MaxSSY-1)) div MaxSSY;
        Component^.Stride:=(Context^.MBWidth*Component^.SSX) shl 3;
        if ((Component^.Width<3) and (Component^.SSX<>MaxSSX)) or
           ((Component^.Height<3) and (Component^.SSY<>MaxSSY)) then begin
         RaiseError;
        end;
        Count:=Component^.Stride*((Context^.MBHeight*Component^.ssy) shl 3);
//       Count:=(Component^.Stride*((Context^.MBHeight*Context^.MBSizeY*Component^.ssy) div MaxSSY)) shl 3;
        if not HeaderOnly then begin
         SetLength(Component^.Pixels,Count);
         FillChar(Component^.Pixels[0],Count,#$80);
        end;
       end;

       inc(DataPosition,Len);

      end;
      $c4{DHT}:begin

       if (DataPosition+2)>=DataSize then begin
        RaiseError;
       end;

       Len:=(TVKUInt16(PByteArray(DataPointer)^[DataPosition+0]) shl 8) or PByteArray(DataPointer)^[DataPosition+1];

       if (DataPosition+TVkUInt32(Len))>=DataSize then begin
        RaiseError;
       end;

       inc(DataPosition,2);
       dec(Len,2);

       while Len>=17 do begin

        Value:=PByteArray(DataPointer)^[DataPosition];
        if (Value and ($ec or $02))<>0 then begin
         RaiseError;
        end;

        Value:=(Value or (Value shr 3)) and 3;
        for CodeLen:=1 to 16 do begin
         DHTCounts[CodeLen-1]:=PByteArray(DataPointer)^[DataPosition+TVkUInt32(CodeLen)];
        end;
        inc(DataPosition,17);
        dec(Len,17);

        Huffman:=@Context^.HuffmanCodeTable[Value,0];
        Remain:=65536;
        Spread:=65536;
        for CodeLen:=1 to 16 do begin
         Spread:=Spread shr 1;
         DHTCurrentCount:=DHTCounts[CodeLen-1];
         if DHTCurrentCount<>0 then begin
          dec(Remain,DHTCurrentCount shl (16-CodeLen));
          if (Len<DHTCurrentCount) or
             (Remain<0) then begin
           RaiseError;
          end;
          for Index:=0 to DHTCurrentCount-1 do begin
           Code:=PByteArray(DataPointer)^[DataPosition+TVKUInt32(Index)];
           for SubIndex:=0 to Spread-1 do begin
            Huffman^.Bits:=CodeLen;
            Huffman^.Code:=Code;
            inc(Huffman);
           end;
          end;
          inc(DataPosition,DHTCurrentCount);
          dec(Len,DHTCurrentCount);
         end;
        end;
        while Remain>0 do begin
         dec(Remain);
         Huffman^.Bits:=0;
         inc(Huffman);
        end;
       end;

       if Len>0 then begin
        RaiseError;
       end;

       inc(DataPosition,Len);

      end;
      $da{SOS}:begin

       if (DataPosition+2)>=DataSize then begin
        RaiseError;
       end;

       Len:=(TVKUInt16(PByteArray(DataPointer)^[DataPosition+0]) shl 8) or PByteArray(DataPointer)^[DataPosition+1];

       if ((DataPosition+TVkUInt32(Len))>=DataSize) or (Len<2) then begin
        RaiseError;
       end;

       inc(DataPosition,2);
       dec(Len,2);

       if (Len<(4+(2*Context^.CountComponents))) or
          (PByteArray(DataPointer)^[DataPosition+0]<>Context^.CountComponents) then begin
        RaiseError;
       end;

       inc(DataPosition);
       dec(Len);

       for Index:=0 to Context^.CountComponents-1 do begin
        Component:=@Context^.Components[Index];
        if (PByteArray(DataPointer)^[DataPosition+0]<>Component^.ID) or
           ((PByteArray(DataPointer)^[DataPosition+1] and $ee)<>0) then begin
         RaiseError;
        end;
        Component^.DCTabSel:=PByteArray(DataPointer)^[DataPosition+1] shr 4;
        Component^.ACTabSel:=(PByteArray(DataPointer)^[DataPosition+1] and 1) or 2;
        inc(DataPosition,2);
        dec(Len,2);
       end;

       if (PByteArray(DataPointer)^[DataPosition+0]<>0) or
          (PByteArray(DataPointer)^[DataPosition+1]<>63) or
          (PByteArray(DataPointer)^[DataPosition+2]<>0) then begin
        RaiseError;
       end;

       inc(DataPosition,Len);

       if not HeaderOnly then begin

        mbx:=0;
        mby:=0;
        RSTCount:=Context^.RSTInterval;
        NextRST:=0;
        repeat

         for Index:=0 to Context^.CountComponents-1 do begin
          Component:=@Context^.Components[Index];
          for sby:=0 to Component^.ssy-1 do begin
           for sbx:=0 to Component^.ssx-1 do begin
            Code:=0;
            Coef:=0;
            FillChar(Context^.Block,SizeOf(Context^.Block),#0);
            inc(Component^.DCPred,GetHuffmanCode(@Context^.HuffmanCodeTable[Component^.DCTabSel],nil));
            Context^.Block[0]:=Component^.DCPred*Context^.QTable[Component^.QTSel,0];
            repeat
             Value:=GetHuffmanCode(@Context^.HuffmanCodeTable[Component^.ACTabSel],@Code);
             if Code=0 then begin
              // EOB
              break;
             end else if ((Code and $0f)=0) and (Code<>$f0) then begin
              RaiseError;
             end else begin
              inc(Coef,(Code shr 4)+1);
              if Coef>63 then begin
               RaiseError;
              end else begin
               Context^.Block[ZigZagOrderToRasterOrderConversionTable[Coef]]:=Value*Context^.QTable[Component^.QTSel,Coef];
              end;
             end;
            until Coef>=63;
            ProcessIDCT(@Context^.Block,
                        @Component^.Pixels[((((mby*Component^.ssy)+sby)*Component^.Stride)+
                                            ((mbx*Component^.ssx)+sbx)) shl 3],
                        Component^.Stride);
           end;
          end;
         end;

         inc(mbx);
         if mbx>=Context^.MBWidth then begin
          mbx:=0;
          inc(mby);
          if mby>=Context^.MBHeight then begin
           mby:=0;
           ImageWidth:=Context^.Width;
           ImageHeight:=Context^.Height;
           GetMem(ImageData,(Context^.Width*Context^.Height) shl 2);
           FillChar(ImageData^,(Context^.Width*Context^.Height) shl 2,#0);
           for Index:=0 to Context^.CountComponents-1 do begin
            Component:=@Context^.Components[Index];
            while (Component^.Width<Context^.Width) or (Component^.Height<Context^.Height) do begin
             if Component^.Width<Context^.Width then begin
              if Context^.CoSitedChroma then begin
               UpsampleHCoSited(Component);
              end else begin
               UpsampleHCentered(Component);
              end;
             end;
             if Component^.Height<Context^.Height then begin
              if Context^.CoSitedChroma then begin
               UpsampleVCoSited(Component);
              end else begin
               UpsampleVCentered(Component);
              end;
             end;
            end;
            if (Component^.Width<Context^.Width) or (Component^.Height<Context^.Height) then begin
             RaiseError;
            end;
           end;
           case Context^.CountComponents of
            3:begin
             pY:=@Context^.Components[0].Pixels[0];
             aCb:=@Context^.Components[1].Pixels[0];
             aCr:=@Context^.Components[2].Pixels[0];
             oRGBX:=ImageData;
             for y:=0 to Context^.Height-1 do begin
              for x:=0 to Context^.Width-1 do begin
               vY:=PByteArray(pY)^[x] shl 8;
               vCb:=PByteArray(aCb)^[x]-128;
               vCr:=PByteArray(aCr)^[x]-128;
               PByteArray(oRGBX)^[0]:=ClipTable[SARLongint((vY+(vCr*359))+128,8) and $3ff];
               PByteArray(oRGBX)^[1]:=ClipTable[SARLongint(((vY-(vCb*88))-(vCr*183))+128,8) and $3ff];
               PByteArray(oRGBX)^[2]:=ClipTable[SARLongint((vY+(vCb*454))+128,8) and $3ff];
               PByteArray(oRGBX)^[3]:=$ff;
               inc(oRGBX,4);
              end;
              inc(pY,Context^.Components[0].Stride);
              inc(aCb,Context^.Components[1].Stride);
              inc(aCr,Context^.Components[2].Stride);
             end;
            end;
            else begin
             pY:=@Context^.Components[0].Pixels[0];
             oRGBX:=ImageData;
             for y:=0 to Context^.Height-1 do begin
              for x:=0 to Context^.Width-1 do begin
               vY:=ClipTable[PByteArray(pY)^[x] and $3ff];
               PByteArray(oRGBX)^[0]:=vY;
               PByteArray(oRGBX)^[1]:=vY;
               PByteArray(oRGBX)^[2]:=vY;
               PByteArray(oRGBX)^[3]:=$ff;
               inc(oRGBX,4);
              end;
              inc(pY,Context^.Components[0].Stride);
             end;
            end;
           end;
           result:=true;
           break;
          end;
         end;

         if Context^.RSTInterval<>0 then begin
          dec(RSTCount);
          if RSTCount=0 then begin
           Context^.BufBits:=Context^.BufBits and $f8;
           Value:=GetBits(16);
           if (((Value and $fff8)<>$ffd0) or ((Value and 7)<>NextRST)) then begin
            RaiseError;
           end;
           NextRST:=(NextRST+1) and 7;
           RSTCount:=Context^.RSTInterval;
           for Index:=0 to 2 do begin
            Context^.Components[Index].DCPred:=0;
           end;
          end;
         end;

        until false;

       end;

       break;

      end;
      $db{DQT}:begin

       if (DataPosition+2)>=DataSize then begin
        RaiseError;
       end;

       Len:=(TVKUInt16(PByteArray(DataPointer)^[DataPosition+0]) shl 8) or PByteArray(DataPointer)^[DataPosition+1];

       if (DataPosition+TVkUInt32(Len))>=DataSize then begin
        RaiseError;
       end;

       inc(DataPosition,2);
       dec(Len,2);

       while Len>=65 do begin
        Value:=PByteArray(DataPointer)^[DataPosition];
        inc(DataPosition);
        dec(Len);
        if (Value and $fc)<>0 then begin
         RaiseError;
        end;
        Context^.QTUsed:=Context^.QTUsed or (1 shl Value);
        for Index:=0 to 63 do begin
         Context^.QTable[Value,Index]:=PByteArray(DataPointer)^[DataPosition];
         inc(DataPosition);
         dec(Len);
        end;
       end;

       inc(DataPosition,Len);

      end;
      $dd{DRI}:begin

       if (DataPosition+2)>=DataSize then begin
        RaiseError;
       end;

       Len:=(TVKUInt16(PByteArray(DataPointer)^[DataPosition+0]) shl 8) or PByteArray(DataPointer)^[DataPosition+1];

       if ((DataPosition+TVkUInt32(Len))>=DataSize) or
          (Len<4) then begin
        RaiseError;
       end;

       inc(DataPosition,2);
       dec(Len,2);

       Context^.RSTInterval:=(TVKUInt16(PByteArray(DataPointer)^[DataPosition+0]) shl 8) or PByteArray(DataPointer)^[DataPosition+1];

       inc(DataPosition,Len);

      end;
      $e1{EXIF}:begin

       if (DataPosition+2)>=DataSize then begin
        RaiseError;
       end;

       Len:=(TVKUInt16(PByteArray(DataPointer)^[DataPosition+0]) shl 8) or PByteArray(DataPointer)^[DataPosition+1];

       if ((DataPosition+TVkUInt32(Len))>=DataSize) or
          (Len<18) then begin
        RaiseError;
       end;

       inc(DataPosition,2);
       dec(Len,2);

       NextDataPosition:=DataPosition+TVkUInt32(Len);

       if (TVulkanRawByteChar(TVkUInt8(PByteArray(DataPointer)^[DataPosition+0]))='E') and
          (TVulkanRawByteChar(TVkUInt8(PByteArray(DataPointer)^[DataPosition+1]))='x') and
          (TVulkanRawByteChar(TVkUInt8(PByteArray(DataPointer)^[DataPosition+2]))='i') and
          (TVulkanRawByteChar(TVkUInt8(PByteArray(DataPointer)^[DataPosition+3]))='f') and
          (TVulkanRawByteChar(TVkUInt8(PByteArray(DataPointer)^[DataPosition+4]))=#0) and
          (TVulkanRawByteChar(TVkUInt8(PByteArray(DataPointer)^[DataPosition+5]))=#0) and
          (TVulkanRawByteChar(TVkUInt8(PByteArray(DataPointer)^[DataPosition+6]))=TVulkanRawByteChar(TVkUInt8(PByteArray(DataPointer)^[DataPosition+7]))) and
          (((TVulkanRawByteChar(TVkUInt8(PByteArray(DataPointer)^[DataPosition+6]))='I') and
            (TVulkanRawByteChar(TVkUInt8(PByteArray(DataPointer)^[DataPosition+8]))='*') and
            (TVulkanRawByteChar(TVkUInt8(PByteArray(DataPointer)^[DataPosition+9]))=#0)) or
           ((TVulkanRawByteChar(TVkUInt8(PByteArray(DataPointer)^[DataPosition+6]))='M') and
            (TVulkanRawByteChar(TVkUInt8(PByteArray(DataPointer)^[DataPosition+8]))=#0) and
            (TVulkanRawByteChar(TVkUInt8(PByteArray(DataPointer)^[DataPosition+9]))='*'))) then begin
        Context^.EXIFLE:=TVulkanRawByteChar(TVkUInt8(PByteArray(DataPointer)^[DataPosition+6]))='I';
        if Len>=14 then begin
         if Context^.EXIFLE then begin
          Value:=(TVkInt32(PByteArray(DataPointer)^[DataPosition+10]) shl 0) or
                 (TVkInt32(PByteArray(DataPointer)^[DataPosition+11]) shl 8) or
                 (TVkInt32(PByteArray(DataPointer)^[DataPosition+12]) shl 16) or
                 (TVkInt32(PByteArray(DataPointer)^[DataPosition+13]) shl 24);
         end else begin
          Value:=(TVkInt32(PByteArray(DataPointer)^[DataPosition+10]) shl 24) or
                 (TVkInt32(PByteArray(DataPointer)^[DataPosition+11]) shl 16) or
                 (TVkInt32(PByteArray(DataPointer)^[DataPosition+12]) shl 8) or
                 (TVkInt32(PByteArray(DataPointer)^[DataPosition+13]) shl 0);
         end;
         inc(Value,6);
         if (Value>=14) and ((Value+2)<Len) then begin
          inc(DataPosition,Value);
          dec(Len,Value);
          if Context^.EXIFLE then begin
           Count:=(TVkInt32(PByteArray(DataPointer)^[DataPosition+0]) shl 0) or
                  (TVkInt32(PByteArray(DataPointer)^[DataPosition+1]) shl 8);
          end else begin
           Count:=(TVkInt32(PByteArray(DataPointer)^[DataPosition+0]) shl 8) or
                  (TVkInt32(PByteArray(DataPointer)^[DataPosition+1]) shl 0);
          end;
          inc(DataPosition,2);
          dec(Len,2);
          if Count<=(Len div 12) then begin
           while Count>0 do begin
            dec(Count);
            if Context^.EXIFLE then begin
             v0:=(TVkInt32(PByteArray(DataPointer)^[DataPosition+0]) shl 0) or
                 (TVkInt32(PByteArray(DataPointer)^[DataPosition+1]) shl 8);
             v1:=(TVkInt32(PByteArray(DataPointer)^[DataPosition+2]) shl 0) or
                 (TVkInt32(PByteArray(DataPointer)^[DataPosition+3]) shl 8);
             v2:=(TVkInt32(PByteArray(DataPointer)^[DataPosition+4]) shl 0) or
                 (TVkInt32(PByteArray(DataPointer)^[DataPosition+5]) shl 8) or
                 (TVkInt32(PByteArray(DataPointer)^[DataPosition+6]) shl 16) or
                 (TVkInt32(PByteArray(DataPointer)^[DataPosition+7]) shl 24);
             v3:=(TVkInt32(PByteArray(DataPointer)^[DataPosition+8]) shl 0) or
                 (TVkInt32(PByteArray(DataPointer)^[DataPosition+9]) shl 8);
            end else begin
             v0:=(TVkInt32(PByteArray(DataPointer)^[DataPosition+0]) shl 8) or
                 (TVkInt32(PByteArray(DataPointer)^[DataPosition+1]) shl 0);
             v1:=(TVkInt32(PByteArray(DataPointer)^[DataPosition+2]) shl 8) or
                 (TVkInt32(PByteArray(DataPointer)^[DataPosition+3]) shl 0);
             v2:=(TVkInt32(PByteArray(DataPointer)^[DataPosition+4]) shl 24) or
                 (TVkInt32(PByteArray(DataPointer)^[DataPosition+5]) shl 16) or
                 (TVkInt32(PByteArray(DataPointer)^[DataPosition+6]) shl 8) or
                 (TVkInt32(PByteArray(DataPointer)^[DataPosition+7]) shl 0);
             v3:=(TVkInt32(PByteArray(DataPointer)^[DataPosition+8]) shl 8) or
                 (TVkInt32(PByteArray(DataPointer)^[DataPosition+9]) shl 0);
            end;
            if (v0=$0213{YCbCrPositioning}) and (v1=$0003{SHORT}) and (v2=1{LENGTH}) then begin
             Context^.CoSitedChroma:=v3=2;
             break;
            end;
            inc(DataPosition,12);
            dec(Len,12);
           end;
          end;
         end;
        end;
       end;

       DataPosition:=NextDataPosition;

      end;
      $e0,$e2..$ef,$fe{Skip}:begin
       if (DataPosition+2)>=DataSize then begin
        RaiseError;
       end;
       Len:=(TVKUInt16(PByteArray(DataPointer)^[DataPosition+0]) shl 8) or PByteArray(DataPointer)^[DataPosition+1];
       if (DataPosition+TVkUInt32(Len))>=DataSize then begin
        RaiseError;
       end;
       inc(DataPosition,Len);
      end;
      else begin
       RaiseError;
      end;
     end;
    end;
   except
    on e:ELoadJPEGImage do begin
     result:=false;
    end;
    on e:Exception do begin
     raise;
    end;
   end;
  finally
   if assigned(ImageData) and not result then begin
    FreeMem(ImageData);
    ImageData:=nil;
   end;
   Finalize(Context^);
   FreeMem(Context);
  end;
 end;
end;

function LoadBMPImage(DataPointer:TVkPointer;DataSize:TVkUInt32;var ImageData:TVkPointer;var ImageWidth,ImageHeight:TVkInt32;const HeaderOnly:boolean):boolean;
const BI_RGB=0;
      BI_RLE8=1;
      BI_RLE4=2;
      BI_BITFIELDS=3;
      BI_ALPHABITFIELDS=6;
type PByteArray=^TByteArray;
     TByteArray=array[0..65535] of TVkUInt8;
     PBMPHeaderMagic=^TBMPHeaderMagic;
     TBMPHeaderMagic=array[0..1] of AnsiChar;
     PBMPHeader=^TBMPHeader;
     TBMPHeader=packed record
      Magic:TBMPHeaderMagic;
      FileSize:TVkUInt32;
      Unused:TVkUInt32;
      DataOffset:TVkUInt32;
     end;
     PBMPInfo=^TBMPInfo;
     TBMPInfo=packed record
      InfoSize:TVkUInt32;
      Width:TVkInt32;
      Height:TVkInt32;
      Planes:TVkUInt16;
      Bits:TVkUInt16;
      Compression:TVkUInt32;
      SizeImage:TVkUInt32;
      XPelsPerMeter:TVkInt32;
      YPelsPerMeter:TVkInt32;
      ClrUsed:TVkUInt32;
      ClrImportant:TVkUInt32;
     end;
     PBMPPaletteEntry=^TBMPPaletteEntry;
     TBMPPaletteEntry=packed record
      Blue:TVkUInt8;
      Green:TVkUInt8;
      Red:TVkUInt8;
      Unused:TVkUInt8;
     end;
     TBMPPalette=array of TBMPPaletteEntry;
     TDynamicByteArray=array of TVkUInt8;
var RawDataSize,LineSize,x,y,c,MaskSize,
    RedShiftLeft,RedShiftRight,
    GreenShiftLeft,GreenShiftRight,
    BlueShiftLeft,BlueShiftRight,
    AlphaShiftLeft,AlphaShiftRight:TVkInt32;
    BMPHeader:TBMPHeader;
    BMPInfo:TBMPInfo;
    BMPPalette:TBMPPalette;
    RedMask,BlueMask,GreenMask,AlphaMask:TVKUInt32;
    RawData,ip,op:PByteArray;
    VFlip:boolean;
    NewData:TDynamicByteArray;
 function Swap16IfBigEndian(const Value:TVkUInt16):TVkUInt16;
 begin
{$ifdef big_endian}
  result:=(((Value shr 8) and $ff) shl 0) or
          (((Value shr 0) and $ff) shl 8);
{$else}
  result:=Value;
{$endif}
 end;
 function Swap32IfBigEndian(const Value:TVkUInt32):TVkUInt32;
 begin
{$ifdef big_endian}
  result:=(((Value shr 24) and $ff) shl 0) or
          (((Value shr 16) and $ff) shl 8) or
          (((Value shr 8) and $ff) shl 16) or
          (((Value shr 0) and $ff) shl 24);
{$else}
  result:=Value;
{$endif}
 end;
 procedure DecompressRLE8(const Data:TVkPointer;const Size,Width,Height,Pitch:TVkInt32);
 var Line,Count:TVkInt32;
     p,d,DestEnd:PVkUInt8;
     Value:TVkUInt8;
 begin
  p:=Data;
  SetLength(NewData,(Width+Pitch)*Height);
  d:=@NewData[0];
  DestEnd:=@NewData[(Width+Pitch)*Height];
  Line:=0;
  while (TVkPtrInt(TVkPtrUInt(Data)-TVkPtrUInt(p))<Size) and (TVkPtrUInt(d)<TVkPtrUInt(DestEnd)) do begin
   if p^=0 then begin
    inc(p);
    case p^ of
     0:begin
      // End of line
      inc(p);
      inc(Line);
      d:=@NewData[(Width+Pitch)*Line];
     end;
     1:begin
      // End of bitmap
      exit;
     end;
     2:begin
      // Delta
      inc(p);
      inc(d,p^);
      inc(p);
      inc(d,p^*(Width+Pitch));
      inc(p);
     end;
     else begin
      // Absolute mode
      Count:=p^;
      inc(p);
      Move(p^,d^,Count);
      inc(p,Count+((2-(Count and 1)) and 1));
      inc(d,Count);
     end;
    end;
   end else begin
    Count:=p^;
    inc(p);
    Value:=p^;
    inc(p);
    FillChar(p^,Count,Value);
    inc(d,Count);
   end;
  end;
 end;
 procedure DecompressRLE4(const Data:TVkPointer;const Size,Width,Height,Pitch:TVkInt32);
 var LineWidth,Line,Shift,Count,x,y,ReadAdditional,ReadShift,i,Mask:TVkInt32;
     p,d,DestEnd:PVkUInt8;
     Value,OtherValue:TVkUInt8;
 begin
  LineWidth:=((Width+1) shr 1)+Pitch;
  p:=Data;
  SetLength(NewData,LineWidth*Height);
  d:=@NewData[0];
  DestEnd:=@NewData[LineWidth*Height];
  Line:=0;
  Shift:=4;
  while (TVkPtrInt(TVkPtrUInt(Data)-TVkPtrUInt(p))<Size) and (TVkPtrUInt(d)<TVkPtrUInt(DestEnd)) do begin
   if p^=0 then begin
    inc(p);
    case p^ of
     0:begin
      // End of line
      inc(p);
      inc(Line);
      d:=@NewData[LineWidth*Line];
      Shift:=4;
     end;
     1:begin
      // End of bitmap
      exit;
     end;
     2:begin
      // Delta
      inc(p);
      x:=p^;
      inc(p);
      y:=p^;
      inc(p);
      inc(d,(x shr 1)+(y*LineWidth));
      Shift:=(x and 1) shl 2;
     end;
     else begin
      // Absolute mode
      Count:=p^;
      inc(p);
      ReadAdditional:=(2-(Count and 1)) and 1;
      ReadShift:=4;
      for i:=1 to Count do begin
       Value:=(p^ shr ReadShift) and $0f;
       dec(ReadShift,4);
       if ReadShift<0 then begin
        inc(p);
        ReadShift:=4;
       end;
       Mask:=$0f shl Shift;
       d^:=(d^ and not Mask) or ((Value shl Shift) and Mask);
       dec(Shift,4);
       if Shift<0 then begin
        Shift:=4;
        inc(d);
       end;
      end;
      inc(p,ReadAdditional);
     end;
    end;
   end else begin
    Count:=p^;
    inc(p);
    Value:=p^;
    inc(p);
    OtherValue:=Value shr 4;
    Value:=Value and $0f;
    for i:=1 to Count do begin
     Mask:=$0f shl Shift;
     if Shift=0 then begin
      d^:=(d^ and not Mask) or ((Value shl Shift) and Mask);
     end else begin
      d^:=(d^ and not Mask) or ((OtherValue shl Shift) and Mask);
     end;
     dec(Shift,4);
     if Shift<0 then begin
      Shift:=4;
      inc(d);
     end;
    end;
   end;
  end;
 end;
begin
 result:=false;
 ImageData:=nil;
 if (DataSize>=(SizeOf(TBMPHeader)+SizeOf(TBMPInfo))) and
    (PBMPHeader(DataPointer)^.Magic[0]='B') and
    (PBMPHeader(DataPointer)^.Magic[1]='M') and
    (Swap32IfBigEndian(PBMPHeader(DataPointer)^.FileSize)<=DataSize) and
    (Swap32IfBigEndian(PBMPHeader(DataPointer)^.DataOffset)<Swap32IfBigEndian(PBMPHeader(DataPointer)^.FileSize)) then begin

  BMPPalette:=nil;
  try

   BMPHeader:=PBMPHeader(DataPointer)^;
   BMPHeader.FileSize:=Swap32IfBigEndian(BMPHeader.FileSize);
   BMPHeader.DataOffset:=Swap32IfBigEndian(BMPHeader.DataOffset);

   BMPInfo:=PBMPInfo(TVkPointer(@PByteArray(DataPointer)^[SizeOf(TBMPHeader)]))^;
   BMPInfo.InfoSize:=Swap32IfBigEndian(BMPInfo.InfoSize);
   BMPInfo.Width:=Swap32IfBigEndian(BMPInfo.Width);
   BMPInfo.Height:=Swap32IfBigEndian(BMPInfo.Height);
   BMPInfo.Planes:=Swap16IfBigEndian(BMPInfo.Planes);
   BMPInfo.Bits:=Swap16IfBigEndian(BMPInfo.Bits);
   BMPInfo.Compression:=Swap32IfBigEndian(BMPInfo.Compression);
   BMPInfo.SizeImage:=Swap32IfBigEndian(BMPInfo.SizeImage);
   BMPInfo.XPelsPerMeter:=Swap32IfBigEndian(BMPInfo.XPelsPerMeter);
   BMPInfo.YPelsPerMeter:=Swap32IfBigEndian(BMPInfo.YPelsPerMeter);
   BMPInfo.ClrUsed:=Swap32IfBigEndian(BMPInfo.ClrUsed);
   BMPInfo.ClrImportant:=Swap32IfBigEndian(BMPInfo.ClrImportant);

   if BMPInfo.Height<0 then begin
    BMPInfo.Height:=-BMPInfo.Height;
    VFlip:=true;
   end else begin
    VFlip:=false;
   end;

   if (BMPInfo.Width<=0) or (BMPInfo.Height<=0) or not (BMPInfo.Bits in [1,2,4,8,16,24,32]) then begin
    exit;
   end;

   case BMPInfo.Compression of
    BI_BITFIELDS:begin
     if not (BMPInfo.Bits in [16,32]) then begin
      exit;
     end;
     MaskSize:=SizeOf(TVkUInt32)*3;
     RedMask:=PVkUInt32(TVkPointer(@PByteArray(DataPointer)^[SizeOf(TBMPHeader)+BMPInfo.InfoSize+TVkUInt32(SizeOf(TVkUInt32)*0)]))^;
     BlueMask:=PVkUInt32(TVkPointer(@PByteArray(DataPointer)^[SizeOf(TBMPHeader)+BMPInfo.InfoSize+TVkUInt32(SizeOf(TVkUInt32)*1)]))^;
     GreenMask:=PVkUInt32(TVkPointer(@PByteArray(DataPointer)^[SizeOf(TBMPHeader)+BMPInfo.InfoSize+TVkUInt32(SizeOf(TVkUInt32)*2)]))^;
     AlphaMask:=$ff000000;
     RedShiftRight:=CTZDWord(RedMask);
     GreenShiftRight:=CTZDWord(GreenMask);
     BlueShiftRight:=CTZDWord(BlueMask);
     AlphaShiftRight:=24;
     RedShiftLeft:=VulkanIntLog2(RedMask shr RedShiftRight);
     GreenShiftLeft:=VulkanIntLog2(GreenMask shr GreenShiftRight);
     BlueShiftLeft:=VulkanIntLog2(BlueMask shr BlueShiftRight);
     AlphaShiftLeft:=0;
    end;
    BI_ALPHABITFIELDS:begin
     if not (BMPInfo.Bits in [16,32]) then begin
      exit;
     end;
     MaskSize:=SizeOf(TVkUInt32)*4;
     RedMask:=PVkUInt32(TVkPointer(@PByteArray(DataPointer)^[SizeOf(TBMPHeader)+BMPInfo.InfoSize+TVkUInt32(SizeOf(TVkUInt32)*0)]))^;
     BlueMask:=PVkUInt32(TVkPointer(@PByteArray(DataPointer)^[SizeOf(TBMPHeader)+BMPInfo.InfoSize+TVkUInt32(SizeOf(TVkUInt32)*1)]))^;
     GreenMask:=PVkUInt32(TVkPointer(@PByteArray(DataPointer)^[SizeOf(TBMPHeader)+BMPInfo.InfoSize+TVkUInt32(SizeOf(TVkUInt32)*2)]))^;
     AlphaMask:=PVkUInt32(TVkPointer(@PByteArray(DataPointer)^[SizeOf(TBMPHeader)+BMPInfo.InfoSize+TVkUInt32(SizeOf(TVkUInt32)*3)]))^;
     RedShiftRight:=CTZDWord(RedMask);
     GreenShiftRight:=CTZDWord(GreenMask);
     BlueShiftRight:=CTZDWord(BlueMask);
     AlphaShiftRight:=CTZDWord(AlphaMask);
     RedShiftLeft:=VulkanIntLog2(RedMask shr RedShiftRight);
     GreenShiftLeft:=VulkanIntLog2(GreenMask shr GreenShiftRight);
     BlueShiftLeft:=VulkanIntLog2(BlueMask shr BlueShiftRight);
     AlphaShiftLeft:=VulkanIntLog2(AlphaMask shr AlphaShiftRight);
    end;
    else begin
     MaskSize:=0;
     RedMask:=$00ff0000;
     BlueMask:=$0000ff00;
     GreenMask:=$00000ff;
     AlphaMask:=$ff000000;
     RedShiftRight:=16;
     GreenShiftRight:=8;
     BlueShiftRight:=0;
     AlphaShiftRight:=24;
     RedShiftLeft:=0;
     GreenShiftLeft:=0;
     BlueShiftLeft:=0;
     AlphaShiftLeft:=0;
     case BMPInfo.Compression of
      BI_RLE8:begin
       if BMPInfo.Bits<>8 then begin
        exit;
       end;
      end;
      BI_RLE4:begin
       if not (BMPInfo.Bits in [1,4]) then begin
        exit;
       end;
      end;
     end;
    end;
   end;

   if BMPInfo.Bits<=8 then begin
    c:=BMPInfo.ClrUsed;
    if c=0 then begin
     c:=1 shl BMPInfo.Bits;
    end else if c>(1 shl BMPInfo.Bits) then begin
     exit;
    end;
    if TVkUInt64(SizeOf(TBMPHeader)+BMPInfo.InfoSize+TVkUInt64(MaskSize)+TVkUInt64((1 shl BMPInfo.Bits)*SizeOf(TBMPPaletteEntry)))>=BMPHeader.FileSize then begin
     exit;
    end;
    if not HeaderOnly then begin
     SetLength(BMPPalette,1 shl BMPInfo.Bits);
     Move(PByteArray(DataPointer)^[SizeOf(TBMPHeader)+BMPInfo.InfoSize+TVkUInt64(MaskSize)],BMPPalette[0],length(BMPPalette)*SizeOf(TBMPPaletteEntry));
    end;
   end;

   if HeaderOnly then begin

    result:=true;

   end else begin
    
    try
     case BMPInfo.Compression of
      BI_RGB:begin
       LineSize:=(((BMPInfo.Width*BMPInfo.Bits)+31) and not TVKUInt32(31)) shr 3;
       RawDataSize:=LineSize*BMPInfo.Height;
       if TVkInt64(BMPHeader.DataOffset+TVkInt64(RawDataSize))>TVkInt64(BMPHeader.FileSize) then begin
        exit;
       end;
       ImageWidth:=BMPInfo.Width;
       ImageHeight:=BMPInfo.Height;
       GetMem(ImageData,ImageWidth*ImageHeight*4);
       RawData:=@PByteArray(DataPointer)^[BMPHeader.DataOffset];
       case BMPInfo.Bits of
        1:begin
         for y:=ImageHeight-1 downto 0 do begin
          ip:=@PByteArray(RawData)^[y*LineSize];
          if VFlip then begin
           op:=@PByteArray(ImageData)^[y*ImageWidth*4];
          end else begin
           op:=@PByteArray(ImageData)^[(ImageHeight-(y+1))*ImageWidth*4];
          end;
          for x:=0 to ImageWidth-1 do begin
           c:=ip^[x shr 3] and (1 shl (x and 7));
           op^[0]:=BMPPalette[c].Red;
           op^[1]:=BMPPalette[c].Green;
           op^[2]:=BMPPalette[c].Blue;
           op^[3]:=$ff;
           op:=@op[4];
          end;
         end;
        end;
        2:begin
         for y:=ImageHeight-1 downto 0 do begin
          ip:=@PByteArray(RawData)^[y*LineSize];
          if VFlip then begin
           op:=@PByteArray(ImageData)^[y*ImageWidth*4];
          end else begin
           op:=@PByteArray(ImageData)^[(ImageHeight-(y+1))*ImageWidth*4];
          end;
          for x:=0 to ImageWidth-1 do begin
           c:=ip^[x shr 2] and (1 shl (x and 3));
           op^[0]:=BMPPalette[c].Red;
           op^[1]:=BMPPalette[c].Green;
           op^[2]:=BMPPalette[c].Blue;
           op^[3]:=$ff;
           op:=@op[4];
          end;
         end;
        end;
        4:begin
         for y:=ImageHeight-1 downto 0 do begin
          ip:=@PByteArray(RawData)^[y*LineSize];
          if VFlip then begin
           op:=@PByteArray(ImageData)^[y*ImageWidth*4];
          end else begin
           op:=@PByteArray(ImageData)^[(ImageHeight-(y+1))*ImageWidth*4];
          end;
          for x:=0 to ImageWidth-1 do begin
           c:=ip^[x shr 1] and (1 shl ((x and 1) shl 2));
           op^[0]:=BMPPalette[c].Red;
           op^[1]:=BMPPalette[c].Green;
           op^[2]:=BMPPalette[c].Blue;
           op^[3]:=$ff;
           op:=@op[4];
          end;
         end;
        end;
        8:begin
         for y:=ImageHeight-1 downto 0 do begin
          ip:=@PByteArray(RawData)^[y*LineSize];
          if VFlip then begin
           op:=@PByteArray(ImageData)^[y*ImageWidth*4];
          end else begin
           op:=@PByteArray(ImageData)^[(ImageHeight-(y+1))*ImageWidth*4];
          end;
          for x:=0 to ImageWidth-1 do begin
           c:=ip^[x];
           op^[0]:=BMPPalette[c].Red;
           op^[1]:=BMPPalette[c].Green;
           op^[2]:=BMPPalette[c].Blue;
           op^[3]:=$ff;
           op:=@op[4];
          end;
         end;
        end;
        16:begin
         for y:=ImageHeight-1 downto 0 do begin
          ip:=@PByteArray(RawData)^[y*LineSize];
          if VFlip then begin
           op:=@PByteArray(ImageData)^[y*ImageWidth*4];
          end else begin
           op:=@PByteArray(ImageData)^[(ImageHeight-(y+1))*ImageWidth*4];
          end;
          for x:=0 to ImageWidth-1 do begin
           c:=ip[0] or (TVkUInt16(TVkUInt8(ip^[1])) shl 8);
           op^[0]:=(c and $f800) shr 11;
           op^[1]:=(c and $07e0) shr 5;
           op^[2]:=(c and $001f) shr 0;
           op^[3]:=$ff;
           ip:=@ip[2];
           op:=@op[4];
          end;
         end;
        end;
        24:begin
         for y:=ImageHeight-1 downto 0 do begin
          ip:=@PByteArray(RawData)^[y*LineSize];
          if VFlip then begin
           op:=@PByteArray(ImageData)^[y*ImageWidth*4];
          end else begin
           op:=@PByteArray(ImageData)^[(ImageHeight-(y+1))*ImageWidth*4];
          end;
          for x:=0 to ImageWidth-1 do begin
           op^[0]:=ip^[2];
           op^[1]:=ip^[1];
           op^[2]:=ip^[0];
           op^[3]:=$ff;
           ip:=@ip[3];
           op:=@op[4];
          end;
         end;
        end;
        32:begin
         for y:=ImageHeight-1 downto 0 do begin
          ip:=@PByteArray(RawData)^[y*LineSize];
          if VFlip then begin
           op:=@PByteArray(ImageData)^[y*ImageWidth*4];
          end else begin
           op:=@PByteArray(ImageData)^[(ImageHeight-(y+1))*ImageWidth*4];
          end;
          for x:=0 to ImageWidth-1 do begin
           op^[0]:=ip^[2];
           op^[1]:=ip^[1];
           op^[2]:=ip^[0];
           op^[3]:=ip^[3];
           ip:=@ip[4];
           op:=@op[4];
          end;
         end;
        end;
       end;
      end;
      BI_RLE8:begin
       ImageWidth:=BMPInfo.Width;
       ImageHeight:=BMPInfo.Height;
       GetMem(ImageData,ImageWidth*ImageHeight*4);
       NewData:=nil;
       try
        LineSize:=(((BMPInfo.Width*BMPInfo.Bits)+31) and not TVKUInt32(31)) shr 3;
        DecompressRLE8(@PByteArray(DataPointer)^[BMPHeader.DataOffset],BMPHeader.FileSize-BMPHeader.DataOffset,ImageWidth,ImageHeight,LineSize-ImageWidth);
        RawData:=@NewData[0];
        for y:=ImageHeight-1 downto 0 do begin
         ip:=@PByteArray(RawData)^[y*LineSize];
         if VFlip then begin
          op:=@PByteArray(ImageData)^[y*ImageWidth*4];
         end else begin
          op:=@PByteArray(ImageData)^[(ImageHeight-(y+1))*ImageWidth*4];
         end;
         for x:=0 to ImageWidth-1 do begin
          c:=ip^[x];
          op^[0]:=BMPPalette[c].Red;
          op^[1]:=BMPPalette[c].Green;
          op^[2]:=BMPPalette[c].Blue;
          op^[3]:=$ff;
          op:=@op[4];
         end;
        end;
       finally
        NewData:=nil;
       end;
      end;
      BI_RLE4:begin
       ImageWidth:=BMPInfo.Width;
       ImageHeight:=BMPInfo.Height;
       GetMem(ImageData,ImageWidth*ImageHeight*4);
       NewData:=nil;
       try
        LineSize:=(((BMPInfo.Width*BMPInfo.Bits)+31) and not TVKUInt32(31)) shr 3;
        DecompressRLE4(@PByteArray(DataPointer)^[BMPHeader.DataOffset],BMPHeader.FileSize-BMPHeader.DataOffset,ImageWidth,ImageHeight,LineSize-ImageWidth);
        RawData:=@NewData[0];
        case BMPInfo.Bits of
         1:begin
          for y:=ImageHeight-1 downto 0 do begin
           ip:=@PByteArray(RawData)^[y*LineSize];
           if VFlip then begin
            op:=@PByteArray(ImageData)^[y*ImageWidth*4];
           end else begin
            op:=@PByteArray(ImageData)^[(ImageHeight-(y+1))*ImageWidth*4];
           end;
           for x:=0 to ImageWidth-1 do begin
            c:=ip^[x shr 3] and (1 shl (x and 7));
            op^[0]:=BMPPalette[c].Red;
            op^[1]:=BMPPalette[c].Green;
            op^[2]:=BMPPalette[c].Blue;
            op^[3]:=$ff;
            op:=@op[4];
           end;
          end;
         end;
         2:begin
          for y:=ImageHeight-1 downto 0 do begin
           ip:=@PByteArray(RawData)^[y*LineSize];
           if VFlip then begin
            op:=@PByteArray(ImageData)^[y*ImageWidth*4];
           end else begin
            op:=@PByteArray(ImageData)^[(ImageHeight-(y+1))*ImageWidth*4];
           end;
           for x:=0 to ImageWidth-1 do begin
            c:=ip^[x shr 2] and (1 shl (x and 3));
            op^[0]:=BMPPalette[c].Red;
            op^[1]:=BMPPalette[c].Green;
            op^[2]:=BMPPalette[c].Blue;
            op^[3]:=$ff;
            op:=@op[4];
           end;
          end;
         end;
         4:begin
          for y:=ImageHeight-1 downto 0 do begin
           ip:=@PByteArray(RawData)^[y*LineSize];
           if VFlip then begin
            op:=@PByteArray(ImageData)^[y*ImageWidth*4];
           end else begin
            op:=@PByteArray(ImageData)^[(ImageHeight-(y+1))*ImageWidth*4];
           end;
           for x:=0 to ImageWidth-1 do begin
            c:=ip^[x shr 1] and (1 shl ((x and 1) shl 2));
            op^[0]:=BMPPalette[c].Red;
            op^[1]:=BMPPalette[c].Green;
            op^[2]:=BMPPalette[c].Blue;
            op^[3]:=$ff;
            op:=@op[4];
           end;
          end;
         end;
        end;
       finally
        NewData:=nil;
       end;
      end;
      BI_BITFIELDS:begin
       LineSize:=(((BMPInfo.Width*BMPInfo.Bits)+31) and not TVKUInt32(31)) shr 3;
       RawDataSize:=LineSize*BMPInfo.Height;
       if TVkInt64(BMPHeader.DataOffset+TVkInt64(RawDataSize))>TVkInt64(BMPHeader.FileSize) then begin
        exit;
       end;
       ImageWidth:=BMPInfo.Width;
       ImageHeight:=BMPInfo.Height;
       GetMem(ImageData,ImageWidth*ImageHeight*4);
       RawData:=@PByteArray(DataPointer)^[BMPHeader.DataOffset];
       case BMPInfo.Bits of
        16:begin
         for y:=ImageHeight-1 downto 0 do begin
          ip:=@PByteArray(RawData)^[y*LineSize];
          if VFlip then begin
           op:=@PByteArray(ImageData)^[y*ImageWidth*4];
          end else begin
           op:=@PByteArray(ImageData)^[(ImageHeight-(y+1))*ImageWidth*4];
          end;
          for x:=0 to ImageWidth-1 do begin
           c:=ip[0] or (TVkUInt16(TVkUInt8(ip^[1])) shl 8);
           op^[0]:=((c and RedMask) shr RedShiftRight) shl RedShiftLeft;
           op^[1]:=((c and GreenMask) shr GreenShiftRight) shl GreenShiftLeft;
           op^[2]:=((c and BlueMask) shr BlueShiftRight) shl BlueShiftLeft;
           op^[3]:=$ff;
           ip:=@ip[2];
           op:=@op[4];
          end;
         end;
        end;
        32:begin
         for y:=ImageHeight-1 downto 0 do begin
          ip:=@PByteArray(RawData)^[y*LineSize];
          if VFlip then begin
           op:=@PByteArray(ImageData)^[y*ImageWidth*4];
          end else begin
           op:=@PByteArray(ImageData)^[(ImageHeight-(y+1))*ImageWidth*4];
          end;
          for x:=0 to ImageWidth-1 do begin
           c:=ip[0] or (TVkUInt16(TVkUInt8(ip^[1])) shl 8) or (TVkUInt16(TVkUInt8(ip^[2])) shl 16) or (TVkUInt16(TVkUInt8(ip^[3])) shl 24);
           op^[0]:=((c and RedMask) shr RedShiftRight) shl RedShiftLeft;
           op^[1]:=((c and GreenMask) shr GreenShiftRight) shl GreenShiftLeft;
           op^[2]:=((c and BlueMask) shr BlueShiftRight) shl BlueShiftLeft;
           op^[3]:=$ff;
           ip:=@ip[4];
           op:=@op[4];
          end;
         end;
        end;
       end;
      end;
      BI_ALPHABITFIELDS:begin
       LineSize:=(((BMPInfo.Width*BMPInfo.Bits)+31) and not TVKUInt32(31)) shr 3;
       RawDataSize:=LineSize*BMPInfo.Height;
       if TVkInt64(BMPHeader.DataOffset+TVkInt64(RawDataSize))>TVkInt64(BMPHeader.FileSize) then begin
        exit;
       end;
       ImageWidth:=BMPInfo.Width;
       ImageHeight:=BMPInfo.Height;
       GetMem(ImageData,ImageWidth*ImageHeight*4);
       RawData:=@PByteArray(DataPointer)^[BMPHeader.DataOffset];
       case BMPInfo.Bits of
        16:begin
         for y:=ImageHeight-1 downto 0 do begin
          ip:=@PByteArray(RawData)^[y*LineSize];
          if VFlip then begin
           op:=@PByteArray(ImageData)^[y*ImageWidth*4];
          end else begin
           op:=@PByteArray(ImageData)^[(ImageHeight-(y+1))*ImageWidth*4];
          end;
          for x:=0 to ImageWidth-1 do begin
           c:=ip[0] or (TVkUInt16(TVkUInt8(ip^[1])) shl 8);
           op^[0]:=((c and RedMask) shr RedShiftRight) shl RedShiftLeft;
           op^[1]:=((c and GreenMask) shr GreenShiftRight) shl GreenShiftLeft;
           op^[2]:=((c and BlueMask) shr BlueShiftRight) shl BlueShiftLeft;
           op^[3]:=((c and AlphaMask) shr AlphaShiftRight) shl AlphaShiftLeft;
           ip:=@ip[2];
           op:=@op[4];
          end;
         end;
        end;
        32:begin
         for y:=ImageHeight-1 downto 0 do begin
          ip:=@PByteArray(RawData)^[y*LineSize];
          if VFlip then begin
           op:=@PByteArray(ImageData)^[y*ImageWidth*4];
          end else begin
           op:=@PByteArray(ImageData)^[(ImageHeight-(y+1))*ImageWidth*4];
          end;
          for x:=0 to ImageWidth-1 do begin
           c:=ip[0] or (TVkUInt16(TVkUInt8(ip^[1])) shl 8) or (TVkUInt16(TVkUInt8(ip^[2])) shl 16) or (TVkUInt16(TVkUInt8(ip^[3])) shl 24);
           op^[0]:=((c and RedMask) shr RedShiftRight) shl RedShiftLeft;
           op^[1]:=((c and GreenMask) shr GreenShiftRight) shl GreenShiftLeft;
           op^[2]:=((c and BlueMask) shr BlueShiftRight) shl BlueShiftLeft;
           op^[3]:=((c and AlphaMask) shr AlphaShiftRight) shl AlphaShiftLeft;
           ip:=@ip[4];
           op:=@op[4];
          end;
         end;
        end;
       end;
      end;
      else begin
       // Another compressions not supported (yet)
       exit;
      end;
     end;

     result:=true;

    except

     if assigned(ImageData) then begin
      FreeMem(ImageData);
      ImageData:=nil;
     end;

     raise

    end;

   end;

  finally
   BMPPalette:=nil;
  end;

 end;
end;

function LoadTGAImage(DataPointer:TVkPointer;DataSize:TVkUInt32;var ImageData:TVkPointer;var ImageWidth,ImageHeight:TVkInt32;const HeaderOnly:boolean):boolean;
type PLongwords=^TLongwords;
     TLongwords=array[0..65536] of TVkUInt32;
     TTGAHeader=packed record
      ImageID:TVkUInt8;
      ColorMapType:TVkUInt8;
      ImageType:TVkUInt8;
      CMapSpec:packed record
       FirstEntryIndex:TVkUInt16;
       Length:TVkUInt16;
       EntrySize:TVkUInt8;
      end;
      OrigX:array[0..1] of TVkUInt8;
      OrigY:array[0..1] of TVkUInt8;
      Width:array[0..1] of TVkUInt8;
      Height:array[0..1] of TVkUInt8;
      BPP:TVkUInt8;
      ImageInfo:TVkUInt8;
     end;
     TBGR=packed record
      b,g,r:TVkUInt8;
     end;
     TBGRA=packed record
      b,g,r,a:TVkUInt8;
     end;
     TRGBA=packed record
      r,g,b,a:TVkUInt8;
     end;
var TGAHeader:TTGAHeader;
    ImageSize,Width,Height:TVkUInt32;
    ImagePointer,NewImagePointer,Pixel:PVkUInt32;
    B8:TVkUInt8;
    Palette:array of TVkUInt8;
    Stream:TVulkanDataStream;
 function PaletteEncode(Index:TVkUInt32):TVkUInt32;
 var r:TRGBA;
     l:TVkUInt32 ABSOLUTE r;
     Offset:TVkUInt32;
     w:TVkUInt16;
 begin
  l:=0;
  if (B8+TGAHeader.CMapSpec.FirstEntryIndex)<TGAHeader.CMapSpec.Length then begin
   Offset:=Index*(TGAHeader.CMapSpec.EntrySize div 8);
   case TGAHeader.CMapSpec.EntrySize of
    8:begin
     l:=Palette[Offset];
    end;
    16:begin
     w:=Palette[Offset] or (Palette[Offset+1] shl 8);
     l:=(((w and $8000) shl 16) or ((w and $7C00) shl 9) or ((w and $3e0) shl 6) or ((w and $1f) shl 3)) or $0f0f0f0f;
    end;
    24:begin
     r.r:=Palette[Offset+2];
     r.g:=Palette[Offset+1];
     r.b:=Palette[Offset];
     if TGAHeader.ImageType=3 then begin
      r.a:=(r.r+r.g+r.b) div 3;
     end else begin
      r.a:=255;
     end;
    end;
    32:begin
     r.r:=Palette[Offset+3];
     r.g:=Palette[Offset+2];
     r.b:=Palette[Offset+1];
     r.a:=Palette[Offset];
    end;
   end;
  end;
  result:=(r.a shl 24) or (r.b shl 16) or (r.g shl 8) or r.r;
 end;
 procedure FlipAndCorrectImage;
 var x,y,o:TVkUInt32;
     Line,NewLine:PLongwords;
 begin
  if (Width<>0) and (Height<>0) then begin
   if (TGAHeader.ImageInfo and $10)<>0 then begin
    GetMem(NewImagePointer,ImageSize);
    for y:=0 to Height-1 do begin
     o:=y*Width*SizeOf(TVkUInt32);
     Line:=PLongwords(TVkPointer(@PVulkanRawByteChar(TVkPointer(ImagePointer))[o]));
     NewLine:=PLongwords(TVkPointer(@PVulkanRawByteChar(TVkPointer(NewImagePointer))[o]));
     for x:=0 to Width-1 do begin
      NewLine^[Width-(x+1)]:=Line^[x];
     end;
    end;
    FreeMem(ImagePointer);
    ImagePointer:=NewImagePointer;
   end;
   if (TGAHeader.ImageInfo and $20)=0 then begin
    GetMem(NewImagePointer,ImageSize);
    for y:=0 to Height-1 do begin
     Move(TVkPointer(@PVulkanRawByteChar(TVkPointer(ImagePointer))[y*Width*SizeOf(TVkUInt32)])^,
          TVkPointer(@PVulkanRawByteChar(TVkPointer(NewImagePointer))[(Height-(y+1))*Width*SizeOf(TVkUInt32)])^,
          Width*SizeOf(TVkUInt32));
    end;
    FreeMem(ImagePointer);
    ImagePointer:=NewImagePointer;
   end;
  end;
 end;
 function DoIt:boolean;
 var PixelCounter,i,l,j:TVkUInt32;
     BGR:TBGR;
     BGRA:TBGRA;
     b,B1:TVkUInt8;
     w:TVkUInt16;
     HasPalette:BOOLEAN;
 begin
  result:=false;
  if Stream.Read(TGAHeader,SizeOf(TGAHeader))<>SizeOf(TGAHeader) then begin
   exit;
  end;
  if (not (TGAHeader.ColorMapType in [0,1])) or (not (TGAHeader.ImageType in [1,2,3,9,10,11])) then begin
   exit;
  end;
  Stream.Seek(TGAHeader.ImageID,soCurrent);
  Palette:=nil;
  HasPalette:=TGAHeader.ColorMapType=1;
  if HasPalette then begin
   SetLength(Palette,TGAHeader.CMapSpec.Length*TGAHeader.CMapSpec.EntrySize div 8);
   if Stream.Read(Palette[0],length(Palette))<>length(Palette) then begin
    exit;
   end;
  end;
  if HasPalette and not (TGAHeader.CMapSpec.EntrySize in [8,16,24,32]) then begin
   SetLength(Palette,0);
   result:=false;
   exit;
  end;
  Width:=(TGAHeader.Width[1] shl 8) or TGAHeader.Width[0];
  Height:=(TGAHeader.Height[1] shl 8) or TGAHeader.Height[0];
  if HeaderOnly then begin
   result:=true;
   exit;
  end;
  if TGAHeader.ImageType in [1,2,3] then begin
   ImageSize:=(Width*Height)*SizeOf(TBGRA);
   GetMem(ImagePointer,ImageSize);
   Pixel:=ImagePointer;
   if TGAHeader.BPP=8 then begin
    if (Width*Height)>0 then begin
     case TGAHeader.ImageType of
      1:begin
       for i:=0 to (Width*Height)-1 do begin
        Stream.Read(B8,SizeOf(TVkUInt8));
        Pixel^:=PaletteEncode(B8);
        inc(Pixel);
       end;
      end;
      2:begin
       for i:=0 to (Width*Height)-1 do begin
        Stream.Read(B8,SizeOf(TVkUInt8));
        Pixel^:=B8;
        inc(Pixel);
       end;
      end;
      3:begin
       for i:=0 to (Width*Height)-1 do begin
        Stream.Read(B8,SizeOf(TVkUInt8));
        Pixel^:=(B8 shl 24) or (B8 shl 16) or (B8 shl 8) or B8;
        inc(Pixel);
       end;
      end;
     end;
    end;
   end else if TGAHeader.BPP=16 then begin
    if (Width*Height)>0 then begin
     for i:=0 to (Width*Height)-1 do begin
      Stream.Read(w,SizeOf(TVkUInt16));
      Pixel^:=(((w and $8000) shl 16) or ((w and $7C00) shl 9) or ((w and $3E0) shl 6) or ((w and $1F) shl 3)) or $0F0F0F0F;
      inc(Pixel);
     end;
    end;
   end else if TGAHeader.BPP=24 then begin
    if (Width*Height)>0 then begin
     for i:=0 to (Width*Height)-1 do begin
      Stream.Read(BGR,SizeOf(TBGR));
      if TGAHeader.ImageType=3 then begin
       Pixel^:=(((BGR.r+BGR.g+BGR.b) div 3)  shl 24) or (BGR.b shl 16) or (BGR.g shl 8) or BGR.r;
      end else begin
       Pixel^:=(255 shl 24) or (BGR.b shl 16) or (BGR.g shl 8) or BGR.r;
      end;
      inc(Pixel);
     end;
    end;
   end else if TGAHeader.BPP=32 then begin
    if (Width*Height)>0 then begin
     for i:=0 to (Width*Height)-1 do begin
      Stream.Read(BGRA,SizeOf(TBGRA));
      Pixel^:=(BGRA.a shl 24) or (BGRA.b shl 16) or (BGRA.g shl 8) or BGRA.r;
      inc(Pixel);
     end;
    end;
   end;
   FlipAndCorrectImage;
  end else if TGAHeader.ImageType in [9,10,11] then begin
   ImageSize:=(Width*Height)*SizeOf(TBGRA);
   GetMem(ImagePointer,ImageSize);
   Pixel:=ImagePointer;
   PixelCounter:=0;
   j:=Width*Height;
   if TGAHeader.BPP=8 then begin
    while PixelCounter<j do begin
     Stream.Read(B1,SizeOf(TVkUInt8));
     b:=(B1 and $7f)+1;
     if (B1 and $80)<>0 then begin
      Stream.Read(B8,SizeOf(TVkUInt8));
      case TGAHeader.ImageType of
       9:begin
        l:=PaletteEncode(B8);
       end;
       10:begin
        l:=B8;
       end;
       11:begin
        BGR.b:=B8;
        BGR.g:=B8;
        BGR.r:=B8;
        l:=(255 shl 24) or (BGR.b shl 16) or (BGR.g shl 8) or BGR.r;
       end;
       else begin
        l:=0;
       end;
      end;
      i:=0;
      while i<b do begin
       Pixel^:=l;
       inc(Pixel);
       inc(PixelCounter);
       inc(i);
      end;
     end else begin
      i:=0;
      while i<b do begin
       Stream.Read(B8,SizeOf(TVkUInt8));
       case TGAHeader.ImageType of
        9:begin
         l:=PaletteEncode(B8);
        end;
        10:begin
         l:=B8;
        end;
        11:begin
         BGR.b:=B8;
         BGR.g:=B8;
         BGR.r:=B8;
         l:=(255 shl 24) or (BGR.b shl 16) or (BGR.g shl 8) or BGR.r;
        end;
        else begin
         l:=0;
        end;
       end;
       Pixel^:=l;
       inc(Pixel);
       inc(PixelCounter);
       inc(i);
      end;
     end;
    end;
   end else if TGAHeader.BPP=16 then begin
    while PixelCounter<j do begin
     Stream.Read(B1,SizeOf(TVkUInt8));
     b:=(B1 and $7f)+1;
     if (B1 and $80)<>0 then begin
      Stream.Read(w,SizeOf(TVkUInt16));
      l:=(((w and $8000) shl 16) or ((w and $7C00) shl 9) or ((w and $3E0) shl 6) or ((w and $1F) shl 3)) or $0F0F0F0F;
      i:=0;
      while i<b do begin
       Pixel^:=l;
       inc(Pixel);
       inc(PixelCounter);
       inc(i);
      end;
     end else begin
      i:=0;
      while i<b do begin
       Stream.Read(w,SizeOf(TVkUInt16));
       Pixel^:=(((w and $8000) shl 16) or ((w and $7C00) shl 9) or ((w and $3E0) shl 6) or ((w and $1F) shl 3)) or $0F0F0F0F;
       inc(Pixel);
       inc(PixelCounter);
       inc(i);
      end;
     end;
    end;
   end else if TGAHeader.BPP=24 then begin
    while PixelCounter<j do begin
     Stream.Read(B1,SizeOf(TVkUInt8));
     b:=(B1 and $7f)+1;
     if (B1 and $80)<>0 then begin
      Stream.Read(BGR,SizeOf(TBGR));
      l:=(255 shl 24) or (BGR.b shl 16) or (BGR.g shl 8) or BGR.r;;
      i:=0;
      while i<b do begin
       Pixel^:=l;
       inc(Pixel);
       inc(PixelCounter);
       inc(i);
      end;
     end else begin
      i:=0;
      while i<b do begin
       Stream.Read(BGR,SizeOf(TBGR));
       Pixel^:=(255 shl 24) or (BGR.b shl 16) or (BGR.g shl 8) or BGR.r;;
       inc(Pixel);
       inc(PixelCounter);
       inc(i);
      end;
     end;
    end;
   end else if TGAHeader.BPP=32 then begin
    while PixelCounter<j do begin
     Stream.Read(B1,SizeOf(TVkUInt8));
     b:=(B1 and $7f)+1;
     if (B1 and $80)<>0 then begin
      Stream.Read(BGRA,SizeOf(TBGRA));
      l:=(BGRA.a shl 24) or (BGRA.b shl 16) or (BGRA.g shl 8) or BGRA.r;
      i:=0;
      while i<b do begin
       Pixel^:=l;
       inc(Pixel);
       inc(PixelCounter);
       inc(i);
      end;
     end else begin
      i:=0;
      while i<b do begin
       Stream.Read(BGRA,SizeOf(TBGRA));
       Pixel^:=(BGRA.a shl 24) or (BGRA.b shl 16) or (BGRA.g shl 8) or BGRA.r;
       inc(Pixel);
       inc(PixelCounter);
       inc(i);
      end;
     end;
    end;
   end;
   FlipAndCorrectImage;
  end;
  SetLength(Palette,0);
  ImageData:=ImagePointer;
  ImageWidth:=Width;
  ImageHeight:=Height;
  result:=true;
 end;
begin
 result:=false;
 if DataSize>0 then begin
  Stream:=TVulkanDataStream.Create(DataPointer,DataSize);
  try
   result:=DoIt;
  finally
   Stream.Free;
  end;
 end;
end;

function VulkanErrorToString(const ErrorCode:TVkResult):TVulkanCharString;
begin
 case ErrorCode of
  VK_SUCCESS:begin
   result:='VK_SUCCESS';
  end;
  VK_NOT_READY:begin
   result:='VK_NOT_READY';
  end;
  VK_TIMEOUT:begin
   result:='VK_TIMEOUT';
  end;
  VK_EVENT_SET:begin
   result:='VK_EVENT_SET';
  end;
  VK_EVENT_RESET:begin
   result:='VK_EVENT_RESET';
  end;
  VK_INCOMPLETE:begin
   result:='VK_INCOMPLETE';
  end;
  VK_ERROR_OUT_OF_HOST_MEMORY:begin
   result:='VK_ERROR_OUT_OF_HOST_MEMORY';
  end;
  VK_ERROR_OUT_OF_DEVICE_MEMORY:begin
   result:='VK_ERROR_OUT_OF_DEVICE_MEMORY';
  end;
  VK_ERROR_INITIALIZATION_FAILED:begin
   result:='VK_ERROR_INITIALIZATION_FAILED';
  end;
  VK_ERROR_DEVICE_LOST:begin
   result:='VK_ERROR_DEVICE_LOST';
  end;
  VK_ERROR_MEMORY_MAP_FAILED:begin
   result:='VK_ERROR_MEMORY_MAP_FAILED';
  end;
  VK_ERROR_LAYER_NOT_PRESENT:begin
   result:='VK_ERROR_LAYER_NOT_PRESENT';
  end;
  VK_ERROR_EXTENSION_NOT_PRESENT:begin
   result:='VK_ERROR_EXTENSION_NOT_PRESENT';
  end;
  VK_ERROR_FEATURE_NOT_PRESENT:begin
   result:='VK_ERROR_FEATURE_NOT_PRESENT';
  end;
  VK_ERROR_INCOMPATIBLE_DRIVER:begin
   result:='VK_ERROR_INCOMPATIBLE_DRIVER';
  end;
  VK_ERROR_TOO_MANY_OBJECTS:begin
   result:='VK_ERROR_TOO_MANY_OBJECTS';
  end;
  VK_ERROR_FORMAT_NOT_SUPPORTED:begin
   result:='VK_ERROR_FORMAT_NOT_SUPPORTED';
  end;
  VK_ERROR_SURFACE_LOST_KHR:begin
   result:='VK_ERROR_SURFACE_LOST_KHR';
  end;
  VK_ERROR_NATIVE_WINDOW_IN_USE_KHR:begin
   result:='VK_ERROR_NATIVE_WINDOW_IN_USE_KHR';
  end;
  VK_SUBOPTIMAL_KHR:begin
   result:='VK_SUBOPTIMAL_KHR';
  end;
  VK_ERROR_OUT_OF_DATE_KHR:begin
   result:='VK_ERROR_OUT_OF_DATE_KHR';
  end;
  VK_ERROR_INCOMPATIBLE_DISPLAY_KHR:begin
   result:='VK_ERROR_INCOMPATIBLE_DISPLAY_KHR';
  end;
  VK_ERROR_VALIDATION_FAILED_EXT:begin
   result:='VK_ERROR_VALIDATION_FAILED_EXT';
  end;
  VK_ERROR_INVALID_SHADER_NV:begin
   result:='VK_ERROR_INVALID_SHADER_NV';
  end;
  else begin
   result:='Unknown error code detected ('+TVulkanCharString(IntToStr(TVkInt32(ErrorCode)))+')';
  end;
 end;
end;

function StringListToVulkanCharStringArray(const StringList:TStringList):TVulkanCharStringArray;
var i:TVkInt32;
begin
 result:=nil;
 SetLength(result,StringList.Count);
 for i:=0 to StringList.Count-1 do begin
  result[i]:=TVulkanCharString(StringList.Strings[i]);
 end;
end;

procedure HandleResultCode(const ResultCode:TVkResult);
begin
 if ResultCode<>VK_SUCCESS then begin
  raise EVulkanResultException.Create(ResultCode);
 end;
end;

procedure VulkanSetImageLayout(const aImage:TVkImage;
                               const aAspectMask:TVkImageAspectFlags;
                               const aOldImageLayout:TVkImageLayout;
                               const aNewImageLayout:TVkImageLayout;
                               const aRange:PVkImageSubresourceRange;
                               const aCommandBuffer:TVulkanCommandBuffer;
                               const aQueue:TVulkanQueue=nil;
                               const aFence:TVulkanFence=nil;
                               const aBeginAndExecuteCommandBuffer:boolean=false;
                               const aSrcQueueFamilyIndex:TVkQueue=TVkQueue(VK_QUEUE_FAMILY_IGNORED);
                               const aDstQueueFamilyIndex:TVkQueue=TVkQueue(VK_QUEUE_FAMILY_IGNORED));
var ImageMemoryBarrier:TVkImageMemoryBarrier;
    SrcStages,DestStages:TVkPipelineStageFlags;
begin

 if aBeginAndExecuteCommandBuffer then begin
  aCommandBuffer.Reset(TVkCommandBufferResetFlags(VK_COMMAND_BUFFER_RESET_RELEASE_RESOURCES_BIT));
  aCommandBuffer.BeginRecording;
 end;

 FillChar(ImageMemoryBarrier,SizeOf(TVkImageMemoryBarrier),#0);
 ImageMemoryBarrier.sType:=VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER;
 ImageMemoryBarrier.oldLayout:=aOldImageLayout;
 ImageMemoryBarrier.newLayout:=aNewImageLayout;
 ImageMemoryBarrier.srcQueueFamilyIndex:=aSrcQueueFamilyIndex;
 ImageMemoryBarrier.dstQueueFamilyIndex:=aDstQueueFamilyIndex;
 ImageMemoryBarrier.image:=aImage;

 if assigned(aRange) then begin
  ImageMemoryBarrier.subresourceRange:=aRange^;
 end else begin
  ImageMemoryBarrier.subresourceRange.aspectMask:=aAspectMask;
  ImageMemoryBarrier.subresourceRange.baseMipLevel:=0;
  ImageMemoryBarrier.subresourceRange.levelCount:=1;
  ImageMemoryBarrier.subresourceRange.baseArrayLayer:=0;
  ImageMemoryBarrier.subresourceRange.layerCount:=1;
 end;

 case aOldImageLayout of
  VK_IMAGE_LAYOUT_UNDEFINED:begin
   ImageMemoryBarrier.srcAccessMask:=0; //TVkAccessFlags(VK_ACCESS_HOST_WRITE_BIT) or TVkAccessFlags(VK_ACCESS_TRANSFER_WRITE_BIT);
  end;
  VK_IMAGE_LAYOUT_GENERAL:begin
  end;
  VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL:begin
   ImageMemoryBarrier.srcAccessMask:=TVkAccessFlags(VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT);
  end;
  VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL:begin
   ImageMemoryBarrier.srcAccessMask:=TVkAccessFlags(VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT);
  end;
  VK_IMAGE_LAYOUT_DEPTH_STENCIL_READ_ONLY_OPTIMAL:begin
  end;
  VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL:begin
   ImageMemoryBarrier.srcAccessMask:=TVkAccessFlags(VK_ACCESS_SHADER_READ_BIT);
  end;
  VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL:begin
   ImageMemoryBarrier.srcAccessMask:=TVkAccessFlags(VK_ACCESS_TRANSFER_READ_BIT);
  end;
  VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL:begin
   ImageMemoryBarrier.srcAccessMask:=TVkAccessFlags(VK_ACCESS_TRANSFER_WRITE_BIT);
  end;
  VK_IMAGE_LAYOUT_PREINITIALIZED:begin
   ImageMemoryBarrier.srcAccessMask:=TVkAccessFlags(VK_ACCESS_HOST_WRITE_BIT);
  end;
  VK_IMAGE_LAYOUT_PRESENT_SRC_KHR:begin
  end;
 end;

 case aNewImageLayout of
  VK_IMAGE_LAYOUT_UNDEFINED:begin
  end;
  VK_IMAGE_LAYOUT_GENERAL:begin
   if aOldImageLayout=VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL then begin
    ImageMemoryBarrier.srcAccessMask:=TVkAccessFlags(VK_ACCESS_TRANSFER_WRITE_BIT);
   end;
  end;
  VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL:begin
   if aOldImageLayout=VK_IMAGE_LAYOUT_PRESENT_SRC_KHR then begin
    ImageMemoryBarrier.srcAccessMask:=TVkAccessFlags(VK_ACCESS_MEMORY_READ_BIT);
   end;
   ImageMemoryBarrier.dstAccessMask:=TVkAccessFlags(VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT);
  end;
  VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL:begin
   ImageMemoryBarrier.dstAccessMask:=TVkAccessFlags(VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT);
  end;
  VK_IMAGE_LAYOUT_DEPTH_STENCIL_READ_ONLY_OPTIMAL:begin
  end;
  VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL:begin
   if aOldImageLayout=VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL then begin
    ImageMemoryBarrier.srcAccessMask:=TVkAccessFlags(VK_ACCESS_TRANSFER_WRITE_BIT);
   end;
   ImageMemoryBarrier.dstAccessMask:=TVkAccessFlags(VK_ACCESS_SHADER_READ_BIT) or TVkAccessFlags(VK_ACCESS_INPUT_ATTACHMENT_READ_BIT);
  end;
  VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL:begin
   ImageMemoryBarrier.srcAccessMask:=ImageMemoryBarrier.srcAccessMask or TVkAccessFlags(VK_ACCESS_TRANSFER_READ_BIT);
   ImageMemoryBarrier.dstAccessMask:=TVkAccessFlags(VK_ACCESS_TRANSFER_READ_BIT);
  end;
  VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL:begin
   ImageMemoryBarrier.dstAccessMask:=TVkAccessFlags(VK_ACCESS_TRANSFER_WRITE_BIT);
  end;
  VK_IMAGE_LAYOUT_PREINITIALIZED:begin
  end;
  VK_IMAGE_LAYOUT_PRESENT_SRC_KHR:begin
   if aOldImageLayout=VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL then begin
    ImageMemoryBarrier.srcAccessMask:=TVkAccessFlags(VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT);
   end;
   ImageMemoryBarrier.dstAccessMask:=TVkAccessFlags(VK_ACCESS_MEMORY_READ_BIT);
  end;
 end;

 if aOldImageLayout=VK_IMAGE_LAYOUT_PRESENT_SRC_KHR then begin
  SrcStages:=TVkPipelineStageFlags(VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT);
  DestStages:=TVkPipelineStageFlags(VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT);
 end else if aNewImageLayout=VK_IMAGE_LAYOUT_PRESENT_SRC_KHR then begin
  SrcStages:=TVkPipelineStageFlags(VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT);
  DestStages:=TVkPipelineStageFlags(VK_PIPELINE_STAGE_BOTTOM_OF_PIPE_BIT);
 end else begin
  SrcStages:=TVkPipelineStageFlags(VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT);
  DestStages:=TVkPipelineStageFlags(VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT);
 end;

 aCommandBuffer.CmdPipelineBarrier(SrcStages,DestStages,0,0,nil,0,nil,1,@ImageMemoryBarrier);

 if aBeginAndExecuteCommandBuffer then begin
  aCommandBuffer.EndRecording;
  aCommandBuffer.Execute(aQueue,TVkPipelineStageFlags(VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT),nil,nil,aFence,true);
 end;

end;

procedure VulkanDisableFloatingPointExceptions;
begin
{$if declared(SetExceptionMask)}
 SetExceptionMask([exInvalidOp,exDenormalized,exZeroDivide,exOverflow,exUnderflow,exPrecision]);
{$ifend}
end;

function VulkanSpritePoint(const x,y:single):TVulkanSpritePoint;
begin
 result.x:=x;
 result.y:=y;
end;

function VulkanSpriteRect(const Left,Top,Right,Bottom:single):TVulkanSpriteRect;
begin
 result.Left:=Left;
 result.Top:=Top;
 result.Right:=Right;
 result.Bottom:=Bottom;
end;

function VulkanSpriteColor(const r,g,b,a:single):TVulkanSpriteColor;
begin
 result.r:=r;
 result.g:=g;
 result.b:=b;
 result.a:=a;
end;

function VulkanUTF32CharToUTF8(CharValue:TVulkanUTF32Char):TVulkanRawByteString;
var Data:array[0..5] of TVulkanRawByteChar;
    ResultLen:TVkInt32;
begin
 if CharValue=0 then begin
  result:=#0;
 end else begin
  if CharValue<=$7f then begin
   Data[0]:=TVulkanRawByteChar(TVkUInt8(CharValue));
   ResultLen:=1;
  end else if CharValue<=$7ff then begin
   Data[0]:=TVulkanRawByteChar(TVkUInt8($c0 or ((CharValue shr 6) and $1f)));
   Data[1]:=TVulkanRawByteChar(TVkUInt8($80 or (CharValue and $3f)));
   ResultLen:=2;
  end else if CharValue<=$ffff then begin
   Data[0]:=TVulkanRawByteChar(TVkUInt8($e0 or ((CharValue shr 12) and $0f)));
   Data[1]:=TVulkanRawByteChar(TVkUInt8($80 or ((CharValue shr 6) and $3f)));
   Data[2]:=TVulkanRawByteChar(TVkUInt8($80 or (CharValue and $3f)));
   ResultLen:=3;
  end else if CharValue<=$1fffff then begin
   Data[0]:=TVulkanRawByteChar(TVkUInt8($f0 or ((CharValue shr 18) and $07)));
   Data[1]:=TVulkanRawByteChar(TVkUInt8($80 or ((CharValue shr 12) and $3f)));
   Data[2]:=TVulkanRawByteChar(TVkUInt8($80 or ((CharValue shr 6) and $3f)));
   Data[3]:=TVulkanRawByteChar(TVkUInt8($80 or (CharValue and $3f)));
   ResultLen:=4;
  end else if CharValue<=$3ffffff then begin
   Data[0]:=TVulkanRawByteChar(TVkUInt8($f8 or ((CharValue shr 24) and $03)));
   Data[1]:=TVulkanRawByteChar(TVkUInt8($80 or ((CharValue shr 18) and $3f)));
   Data[2]:=TVulkanRawByteChar(TVkUInt8($80 or ((CharValue shr 12) and $3f)));
   Data[3]:=TVulkanRawByteChar(TVkUInt8($80 or ((CharValue shr 6) and $3f)));
   Data[4]:=TVulkanRawByteChar(TVkUInt8($80 or (CharValue and $3f)));
   ResultLen:=5;
  end else if CharValue<=$7fffffff then begin
   Data[0]:=TVulkanRawByteChar(TVkUInt8($fc or ((CharValue shr 30) and $01)));
   Data[1]:=TVulkanRawByteChar(TVkUInt8($80 or ((CharValue shr 24) and $3f)));
   Data[2]:=TVulkanRawByteChar(TVkUInt8($80 or ((CharValue shr 18) and $3f)));
   Data[3]:=TVulkanRawByteChar(TVkUInt8($80 or ((CharValue shr 12) and $3f)));
   Data[4]:=TVulkanRawByteChar(TVkUInt8($80 or ((CharValue shr 6) and $3f)));
   Data[5]:=TVulkanRawByteChar(TVkUInt8($80 or (CharValue and $3f)));
   ResultLen:=6;
  end else begin
   Data[0]:=#$ef; // $fffd
   Data[1]:=#$bf;
   Data[2]:=#$bd;
   ResultLen:=3;
  end;
  SetLength(result,ResultLen);
  Move(Data[0],result[1],ResultLen);
 end;
end;

function VulkanUTF32CharToUTF8At(CharValue:TVulkanUTF32Char;var s:TVulkanRawByteString;const Index:TVkInt32):TVkInt32;
var Data:array[0..5] of TVulkanRawByteChar;
    ResultLen:TVkInt32;
begin
 if CharValue=0 then begin
  result:=0;
 end else begin
  if CharValue<=$7f then begin
   Data[0]:=TVulkanRawByteChar(TVkUInt8(CharValue));
   ResultLen:=1;
  end else if CharValue<=$7ff then begin
   Data[0]:=TVulkanRawByteChar(TVkUInt8($c0 or ((CharValue shr 6) and $1f)));
   Data[1]:=TVulkanRawByteChar(TVkUInt8($80 or (CharValue and $3f)));
   ResultLen:=2;
  end else if CharValue<=$ffff then begin
   Data[0]:=TVulkanRawByteChar(TVkUInt8($e0 or ((CharValue shr 12) and $0f)));
   Data[1]:=TVulkanRawByteChar(TVkUInt8($80 or ((CharValue shr 6) and $3f)));
   Data[2]:=TVulkanRawByteChar(TVkUInt8($80 or (CharValue and $3f)));
   ResultLen:=3;
  end else if CharValue<=$1fffff then begin
   Data[0]:=TVulkanRawByteChar(TVkUInt8($f0 or ((CharValue shr 18) and $07)));
   Data[1]:=TVulkanRawByteChar(TVkUInt8($80 or ((CharValue shr 12) and $3f)));
   Data[2]:=TVulkanRawByteChar(TVkUInt8($80 or ((CharValue shr 6) and $3f)));
   Data[3]:=TVulkanRawByteChar(TVkUInt8($80 or (CharValue and $3f)));
   ResultLen:=4;
  end else if CharValue<=$3ffffff then begin
   Data[0]:=TVulkanRawByteChar(TVkUInt8($f8 or ((CharValue shr 24) and $03)));
   Data[1]:=TVulkanRawByteChar(TVkUInt8($80 or ((CharValue shr 18) and $3f)));
   Data[2]:=TVulkanRawByteChar(TVkUInt8($80 or ((CharValue shr 12) and $3f)));
   Data[3]:=TVulkanRawByteChar(TVkUInt8($80 or ((CharValue shr 6) and $3f)));
   Data[4]:=TVulkanRawByteChar(TVkUInt8($80 or (CharValue and $3f)));
   ResultLen:=5;
  end else if CharValue<=$7fffffff then begin
   Data[0]:=TVulkanRawByteChar(TVkUInt8($fc or ((CharValue shr 30) and $01)));
   Data[1]:=TVulkanRawByteChar(TVkUInt8($80 or ((CharValue shr 24) and $3f)));
   Data[2]:=TVulkanRawByteChar(TVkUInt8($80 or ((CharValue shr 18) and $3f)));
   Data[3]:=TVulkanRawByteChar(TVkUInt8($80 or ((CharValue shr 12) and $3f)));
   Data[4]:=TVulkanRawByteChar(TVkUInt8($80 or ((CharValue shr 6) and $3f)));
   Data[5]:=TVulkanRawByteChar(TVkUInt8($80 or (CharValue and $3f)));
   ResultLen:=6;
  end else begin
   Data[0]:=#$ef; // $fffd
   Data[1]:=#$bf;
   Data[2]:=#$bd;
   ResultLen:=3;
  end;
  if (Index+ResultLen)>length(s) then begin
   SetLength(s,Index+ResultLen);
  end;
  Move(Data[0],s[Index],ResultLen);
  result:=ResultLen;
 end;
end;

function VulkanUTF8Validate(const s:TVulkanRawByteString):boolean;
var CodeUnit:TVkInt32;
    State:TVkUInt32;
begin
 State:=ucACCEPT;
 for CodeUnit:=1 to length(s) do begin
  State:=VulkanUTF8DFATransitions[State+VulkanUTF8DFACharClasses[s[CodeUnit]]];
  if State=ucERROR then begin
   result:=false;
   exit;
  end;
 end;
 result:=State=ucACCEPT;
end;

function VulkanUTF8Correct(const Str:TVulkanRawByteString):TVulkanRawByteString;
var CodeUnit,Len,ResultLen:TVkInt32;
    StartCodeUnit,Value,CharClass,State,CharValue:TVkUInt32;
    Data:PVulkanRawByteChar;
begin
 if (length(Str)=0) or VulkanUTF8Validate(Str) then begin
  result:=Str;
 end else begin
  result:='';
  CodeUnit:=1;
  Len:=length(Str);
  SetLength(result,Len*6);
  Data:=@result[1];
  ResultLen:=0;
  while CodeUnit<=Len do begin
   StartCodeUnit:=CodeUnit;
   State:=ucACCEPT;
   CharValue:=0;
   while CodeUnit<=Len do begin
    Value:=TVkUInt8(TVulkanRawByteChar(Str[CodeUnit]));
    inc(CodeUnit);
    CharClass:=VulkanUTF8DFACharClasses[TVulkanRawByteChar(Value)];
    if State=ucACCEPT then begin
     CharValue:=Value and ($ff shr CharClass);
    end else begin
     CharValue:=(CharValue shl 6) or (Value and $3f);
    end;
    State:=VulkanUTF8DFATransitions[State+CharClass];
    if State<=ucERROR then begin
     break;
    end;
   end;
   if State<>ucACCEPT then begin
    CharValue:=TVkUInt8(TVulkanRawByteChar(Str[StartCodeUnit]));
    CodeUnit:=StartCodeUnit+1;
   end;
   if CharValue<=$7f then begin
    Data[ResultLen]:=TVulkanRawByteChar(TVkUInt8(CharValue));
    inc(ResultLen);
   end else if CharValue<=$7ff then begin
    Data[ResultLen]:=TVulkanRawByteChar(TVkUInt8($c0 or ((CharValue shr 6) and $1f)));
    Data[ResultLen+1]:=TVulkanRawByteChar(TVkUInt8($80 or (CharValue and $3f)));
    inc(ResultLen,2);
   end else if CharValue<=$ffff then begin
    Data[ResultLen]:=TVulkanRawByteChar(TVkUInt8($e0 or ((CharValue shr 12) and $0f)));
    Data[ResultLen+1]:=TVulkanRawByteChar(TVkUInt8($80 or ((CharValue shr 6) and $3f)));
    Data[ResultLen+2]:=TVulkanRawByteChar(TVkUInt8($80 or (CharValue and $3f)));
    inc(ResultLen,3);
   end else if CharValue<=$1fffff then begin
    Data[ResultLen]:=TVulkanRawByteChar(TVkUInt8($f0 or ((CharValue shr 18) and $07)));
    Data[ResultLen+1]:=TVulkanRawByteChar(TVkUInt8($80 or ((CharValue shr 12) and $3f)));
    Data[ResultLen+2]:=TVulkanRawByteChar(TVkUInt8($80 or ((CharValue shr 6) and $3f)));
    Data[ResultLen+3]:=TVulkanRawByteChar(TVkUInt8($80 or (CharValue and $3f)));
    inc(ResultLen,4);
   end else if CharValue<=$3ffffff then begin
    Data[ResultLen]:=TVulkanRawByteChar(TVkUInt8($f8 or ((CharValue shr 24) and $03)));
    Data[ResultLen+1]:=TVulkanRawByteChar(TVkUInt8($80 or ((CharValue shr 18) and $3f)));
    Data[ResultLen+2]:=TVulkanRawByteChar(TVkUInt8($80 or ((CharValue shr 12) and $3f)));
    Data[ResultLen+3]:=TVulkanRawByteChar(TVkUInt8($80 or ((CharValue shr 6) and $3f)));
    Data[ResultLen+4]:=TVulkanRawByteChar(TVkUInt8($80 or (CharValue and $3f)));
    inc(ResultLen,5);
   end else if CharValue<=$7fffffff then begin
    Data[ResultLen]:=TVulkanRawByteChar(TVkUInt8($fc or ((CharValue shr 30) and $01)));
    Data[ResultLen+1]:=TVulkanRawByteChar(TVkUInt8($80 or ((CharValue shr 24) and $3f)));
    Data[ResultLen+2]:=TVulkanRawByteChar(TVkUInt8($80 or ((CharValue shr 18) and $3f)));
    Data[ResultLen+3]:=TVulkanRawByteChar(TVkUInt8($80 or ((CharValue shr 12) and $3f)));
    Data[ResultLen+4]:=TVulkanRawByteChar(TVkUInt8($80 or ((CharValue shr 6) and $3f)));
    Data[ResultLen+5]:=TVulkanRawByteChar(TVkUInt8($80 or (CharValue and $3f)));
    inc(ResultLen,6);
   end else begin
    Data[ResultLen]:=#$ef; // $fffd
    Data[ResultLen+1]:=#$bf;
    Data[ResultLen+2]:=#$bd;
    inc(ResultLen,3);
   end;
  end;
  SetLength(result,ResultLen);
 end;
end;

function VulkanUTF8CodeUnitGetCharAndIncFallback(const s:TVulkanRawByteString;var CodeUnit:TVkInt32):TVkUInt32;
var Len:TVkInt32;
    StartCodeUnit,Value,CharClass,State:TVkUInt32;
begin
 result:=0;
 Len:=length(s);
 if (CodeUnit>0) and (CodeUnit<=Len) then begin
  StartCodeUnit:=CodeUnit;
  State:=ucACCEPT;
  while CodeUnit<=Len do begin
   Value:=TVkUInt8(TVulkanRawByteChar(s[CodeUnit]));
   inc(CodeUnit);
   CharClass:=VulkanUTF8DFACharClasses[TVulkanRawByteChar(Value)];
   if State=ucACCEPT then begin
    result:=Value and ($ff shr CharClass);
   end else begin
    result:=(result shl 6) or (Value and $3f);
   end;
   State:=VulkanUTF8DFATransitions[State+CharClass];
   if State<=ucERROR then begin
    break;
   end;
  end;
  if State<>ucACCEPT then begin
   result:=TVkUInt8(TVulkanRawByteChar(s[StartCodeUnit]));
   CodeUnit:=StartCodeUnit+1;
  end;
 end;
end;

constructor EVulkanResultException.Create(const aResultCode:TVkResult);
begin
 fResultCode:=aResultCode;
 inherited Create(String(VulkanErrorToString(fResultCode)));
end;

destructor EVulkanResultException.Destroy;
begin
 inherited Destroy;
end;

constructor TVulkanBaseList.Create(const aItemSize:TVkSizeInt);
begin
 inherited Create;
 fItemSize:=aItemSize;
 fCount:=0;
 fAllocated:=0;
 fMemory:=nil;
end;

destructor TVulkanBaseList.Destroy;
begin
 Clear;
 inherited Destroy;
end;

procedure TVulkanBaseList.SetCount(const NewCount:TVkSizeInt);
var Index,NewAllocated:TVkSizeInt;
    Item:TVkPointer;
begin
 if fCount<NewCount then begin
  NewAllocated:=TVkSizeInt(VulkanRoundUpToPowerOfTwo(NewCount));
  if fAllocated<NewAllocated then begin
   if assigned(fMemory) then begin
    ReallocMem(fMemory,NewAllocated*fItemSize);
   end else begin
    GetMem(fMemory,NewAllocated*fItemSize);
   end;
   FillChar(TVkPointer(TVkPtrUInt(TVkPtrUInt(fMemory)+(TVkPtrUInt(fAllocated)*TVkPtrUInt(fItemSize))))^,(NewAllocated-fAllocated)*fItemSize,#0);
   fAllocated:=NewAllocated;
  end;
  Item:=fMemory;
  Index:=fCount;
  inc(TVkPtrUInt(Item),Index*fItemSize);
  while Index<NewCount do begin
   FillChar(Item^,fItemSize,#0);
   InitializeItem(Item^);
   inc(TVkPtrUInt(Item),fItemSize);
   inc(Index);
  end;
  fCount:=NewCount;
 end else if fCount>NewCount then begin
  Item:=fMemory;
  Index:=NewCount;
  inc(TVkPtrUInt(Item),Index*fItemSize);
  while Index<fCount do begin
   FinalizeItem(Item^);
   FillChar(Item^,fItemSize,#0);
   inc(TVkPtrUInt(Item),fItemSize);
   inc(Index);
  end;
  fCount:=NewCount;
  if NewCount<(fAllocated shr 2) then begin
   if NewCount=0 then begin
    if assigned(fMemory) then begin
     FreeMem(fMemory);
     fMemory:=nil;
    end;
    fAllocated:=0;
   end else begin                             
    NewAllocated:=fAllocated shr 1;
    if assigned(fMemory) then begin
     ReallocMem(fMemory,NewAllocated*fItemSize);
    end else begin
     GetMem(fMemory,NewAllocated*fItemSize);
    end;
    fAllocated:=NewAllocated;
   end;
  end;
 end;
end;

function TVulkanBaseList.GetItem(const Index:TVkSizeInt):TVkPointer;
begin
 if (Index>=0) and (Index<fCount) then begin
  result:=TVkPointer(TVkPtrUInt(TVkPtrUInt(fMemory)+(TVkPtrUInt(Index)*TVkPtrUInt(fItemSize))));
 end else begin
  result:=nil;
 end;
end;

procedure TVulkanBaseList.InitializeItem(var Item);
begin
end;

procedure TVulkanBaseList.FinalizeItem(var Item);
begin
end;

procedure TVulkanBaseList.CopyItem(const Source;var Destination);
begin
 Move(Source,Destination,fItemSize);
end;

procedure TVulkanBaseList.ExchangeItem(var Source,Destination);
var a,b:PVkUInt8;
    c8:TVkUInt8;
    c32:TVkUInt32;
    Index:TVkInt32;
begin
 a:=@Source;
 b:=@Destination;
 for Index:=1 to fItemSize shr 2 do begin
  c32:=PVkUInt32(a)^;
  PVkUInt32(a)^:=PVkUInt32(b)^;
  PVkUInt32(b)^:=c32;
  inc(PVkUInt32(a));
  inc(PVkUInt32(b));
 end;
 for Index:=1 to fItemSize and 3 do begin
  c8:=a^;
  a^:=b^;
  b^:=c8;
  inc(a);
  inc(b);
 end;
end;

function TVulkanBaseList.CompareItem(const Source,Destination):TVkInt32;
var a,b:PVkUInt8;
    Index:TVkInt32;
begin
 result:=0;
 a:=@Source;
 b:=@Destination;
 for Index:=1 to fItemSize do begin
  result:=a^-b^;
  if result<>0 then begin
   exit;
  end;
  inc(a);
  inc(b);
 end;
end;

procedure TVulkanBaseList.Clear;
var Index:TVkSizeInt;
    Item:TVkPointer;
begin
 Item:=fMemory;
 Index:=0;
 while Index<fCount do begin
  FinalizeItem(Item^);
  inc(TVkPtrInt(Item),fItemSize);
  inc(Index);
 end;
 if assigned(fMemory) then begin
  FreeMem(fMemory);
  fMemory:=nil;
 end;
 fCount:=0;
 fAllocated:=0;
end;

procedure TVulkanBaseList.FillWith(const SourceData;const SourceCount:TVkSizeInt);
var Index:TVkSizeInt;
    SourceItem,Item:TVkPointer;
begin
 SourceItem:=@SourceData;
 if assigned(SourceItem) and (SourceCount>0) then begin
  SetCount(SourceCount);
  Item:=fMemory;
  Index:=0;
  while Index<fCount do begin
   CopyItem(SourceItem^,Item^);
   inc(TVkPtrInt(SourceItem),fItemSize);
   inc(TVkPtrInt(Item),fItemSize);
   inc(Index);
  end;
 end else begin
  SetCount(0);
 end;
end;

function TVulkanBaseList.Add(const Item):TVkSizeInt;
begin
 result:=fCount;
 SetCount(result+1);
 CopyItem(Item,TVkPointer(TVkPtrUInt(TVkPtrUInt(fMemory)+(TVkPtrUInt(result)*TVkPtrUInt(fItemSize))))^);
end;

function TVulkanBaseList.Find(const Item):TVkSizeInt;
var Index:TVkSizeInt;
begin
 result:=-1;
 Index:=0;
 while Index<fCount do begin
  if CompareItem(Item,TVkPointer(TVkPtrUInt(TVkPtrUInt(fMemory)+(TVkPtrUInt(Index)*TVkPtrUInt(fItemSize))))^)=0 then begin
   result:=Index;
   break;
  end;
  inc(Index);
 end;
end;

procedure TVulkanBaseList.Insert(const Index:TVkSizeInt;const Item);
begin
 if Index>=0 then begin
  if Index<fCount then begin
   SetCount(fCount+1);
   Move(TVkPointer(TVkPtrInt(TVkPtrUInt(fMemory)+(TVkPtrUInt(Index)*TVkPtrUInt(fItemSize))))^,TVkPointer(TVkPtrUInt(TVkPtrUInt(fMemory)+(TVkPtrUInt(Index+1)*TVkPtrUInt(fItemSize))))^,(fCount-Index)*fItemSize);
   FillChar(TVkPointer(TVkPtrInt(TVkPtrUInt(fMemory)+(TVkPtrUInt(Index)*TVkPtrUInt(fItemSize))))^,fItemSize,#0);
  end else begin
   SetCount(Index+1);
  end;
  CopyItem(Item,TVkPointer(TVkPtrUInt(TVkPtrUInt(fMemory)+(TVkPtrUInt(Index)*TVkPtrUInt(fItemSize))))^);
 end;
end;

procedure TVulkanBaseList.Delete(const Index:TVkSizeInt);
begin
 if (Index>=0) and (Index<fCount) then begin
  FinalizeItem(TVkPointer(TVkPtrUInt(TVkPtrUInt(fMemory)+(TVkPtrUInt(Index)*TVkPtrUInt(fItemSize))))^);
  Move(TVkPointer(TVkPtrUInt(TVkPtruInt(fMemory)+(TVkPtrUInt(Index+1)*TVkPtrUInt(fItemSize))))^,TVkPointer(TVkPtrUInt(TVkPtrUInt(fMemory)+(TVkPtrUInt(Index)*TVkPtrUInt(fItemSize))))^,(fCount-Index)*fItemSize);
  FillChar(TVkPointer(TVkPtrUInt(TVkPtrUInt(fMemory)+(TVkPtrUInt(fCount-1)*TVkPtrUInt(fItemSize))))^,fItemSize,#0);
  SetCount(fCount-1);
 end;
end;

procedure TVulkanBaseList.Remove(const Item);
var Index:TVkSizeInt;
begin
 repeat
  Index:=Find(Item);
  if Index>=0 then begin
   Delete(Index);
  end else begin
   break;
  end;
 until false;
end;

procedure TVulkanBaseList.Exchange(const Index,WithIndex:TVkSizeInt);
begin
 if (Index>=0) and (Index<fCount) and (WithIndex>=0) and (WithIndex<fCount) then begin
  ExchangeItem(TVkPointer(TVkPtrUInt(TVkPtrUInt(fMemory)+(TVkPtrUInt(Index)*TVkPtrUInt(fItemSize))))^,TVkPointer(TVkPtrUInt(TVkPtrUInt(fMemory)+(TVkPtrUInt(WithIndex)*TVkPtrUInt(fItemSize))))^);
 end;
end;

constructor TVulkanObjectList.Create;
begin
 fOwnObjects:=true;
 inherited Create(SizeOf(TVulkanObject));
end;

destructor TVulkanObjectList.Destroy;
begin
 inherited Destroy;
end;

procedure TVulkanObjectList.Clear;
begin
 inherited Clear;
end;

function TVulkanObjectList.GetItem(const Index:TVkSizeInt):TVulkanObject;
begin
 if (Index>=0) and (Index<fCount) then begin
  result:=TVulkanObject(TVkPointer(TVkPtrUInt(TVkPtrUInt(fMemory)+(TVkPtrUInt(Index)*TVkPtrUInt(fItemSize))))^);
 end else begin
  result:=nil;
 end;
end;

procedure TVulkanObjectList.SetItem(const Index:TVkSizeInt;const Item:TVulkanObject);
begin
 if (Index>=0) and (Index<fCount) then begin
  TVulkanObject(TVkPointer(TVkPtrUInt(TVkPtrUInt(fMemory)+(TVkPtrUInt(Index)*TVkPtrUInt(fItemSize))))^):=Item;
 end;
end;

procedure TVulkanObjectList.InitializeItem(var Item);
begin
 TVulkanObject(TVkPointer(Item)):=nil;
end;

procedure TVulkanObjectList.FinalizeItem(var Item);
begin
 if fOwnObjects then begin
  TVulkanObject(TVkPointer(Item)).Free;
 end;
 TVulkanObject(TVkPointer(Item)):=nil;
end;

procedure TVulkanObjectList.CopyItem(const Source;var Destination);
begin
 TVulkanObject(TVkPointer(Destination)):=TVulkanObject(TVkPointer(Source));
end;

procedure TVulkanObjectList.ExchangeItem(var Source,Destination);
var Temporary:TVulkanObject;
begin
 Temporary:=TVulkanObject(TVkPointer(Source));
 TVulkanObject(TVkPointer(Source)):=TVulkanObject(TVkPointer(Destination));
 TVulkanObject(TVkPointer(Destination)):=Temporary;
end;

function TVulkanObjectList.CompareItem(const Source,Destination):TVkInt32;
begin
 result:=TVkPtrDiff(Source)-TVkPtrDiff(Destination);
end;

function TVulkanObjectList.Add(const Item:TVulkanObject):TVkSizeInt;
begin
 result:=inherited Add(Item);
end;

function TVulkanObjectList.Find(const Item:TVulkanObject):TVkSizeInt;
begin
 result:=inherited Find(Item);
end;

procedure TVulkanObjectList.Insert(const Index:TVkSizeInt;const Item:TVulkanObject);
begin
 inherited Insert(Index,Item);
end;

procedure TVulkanObjectList.Remove(const Item:TVulkanObject);
begin
 inherited Remove(Item);
end;

constructor TVkUInt32List.Create;
begin
 inherited Create(SizeOf(TVkUInt32));
end;

destructor TVkUInt32List.Destroy;
begin
 inherited Destroy;
end;

function TVkUInt32List.GetItem(const Index:TVkSizeInt):TVkUInt32;
begin
 if (Index>=0) and (Index<fCount) then begin
  result:=TVkUInt32(TVkPointer(TVkPtrUInt(TVkPtrUInt(fMemory)+(TVkPtrUInt(Index)*TVkPtrUInt(fItemSize))))^);
 end else begin
  result:=0;
 end;
end;

procedure TVkUInt32List.SetItem(const Index:TVkSizeInt;const Item:TVkUInt32);
begin
 if (Index>=0) and (Index<fCount) then begin
  TVkUInt32(TVkPointer(TVkPtrUInt(TVkPtrUInt(fMemory)+(TVkPtrUInt(Index)*TVkPtrUInt(fItemSize))))^):=Item;
 end;
end;

procedure TVkUInt32List.InitializeItem(var Item);
begin
 TVkUInt32(Item):=0;
end;

procedure TVkUInt32List.FinalizeItem(var Item);
begin
 TVkUInt32(Item):=0;
end;

procedure TVkUInt32List.CopyItem(const Source;var Destination);
begin
 TVkUInt32(Destination):=TVkUInt32(Source);
end;

procedure TVkUInt32List.ExchangeItem(var Source,Destination);
var Temporary:TVkUInt32;
begin
 Temporary:=TVkUInt32(Source);
 TVkUInt32(Source):=TVkUInt32(Destination);
 TVkUInt32(Destination):=Temporary;
end;

function TVkUInt32List.CompareItem(const Source,Destination):TVkInt32;
begin
 result:=TVkUInt32(Source)-TVkUInt32(Destination);
end;

function TVkUInt32List.Add(const Item:TVkUInt32):TVkSizeInt;
begin
 result:=inherited Add(Item);
end;

function TVkUInt32List.Find(const Item:TVkUInt32):TVkSizeInt;
begin
 result:=inherited Find(Item);
end;

procedure TVkUInt32List.Insert(const Index:TVkSizeInt;const Item:TVkUInt32);
begin
 inherited Insert(Index,Item);
end;

procedure TVkUInt32List.Remove(const Item:TVkUInt32);
begin
 inherited Remove(Item);
end;

constructor TVkFloatList.Create;
begin
 inherited Create(SizeOf(TVkFloat));
end;

destructor TVkFloatList.Destroy;
begin
 inherited Destroy;
end;

function TVkFloatList.GetItem(const Index:TVkSizeInt):TVkFloat;
begin
 if (Index>=0) and (Index<fCount) then begin
  result:=TVkFloat(TVkPointer(TVkPtrUInt(TVkPtrUInt(fMemory)+(TVkPtrUInt(Index)*TVkPtrUInt(fItemSize))))^);
 end else begin
  result:=0;
 end;
end;

procedure TVkFloatList.SetItem(const Index:TVkSizeInt;const Item:TVkFloat);
begin
 if (Index>=0) and (Index<fCount) then begin
  TVkFloat(TVkPointer(TVkPtrUInt(TVkPtrUInt(fMemory)+(TVkPtrUInt(Index)*TVkPtrUInt(fItemSize))))^):=Item;
 end;
end;

procedure TVkFloatList.InitializeItem(var Item);
begin
 TVkFloat(Item):=0;
end;

procedure TVkFloatList.FinalizeItem(var Item);
begin
 TVkFloat(Item):=0;
end;

procedure TVkFloatList.CopyItem(const Source;var Destination);
begin
 TVkFloat(Destination):=TVkFloat(Source);
end;

procedure TVkFloatList.ExchangeItem(var Source,Destination);
var Temporary:TVkFloat;
begin
 Temporary:=TVkFloat(Source);
 TVkFloat(Source):=TVkFloat(Destination);
 TVkFloat(Destination):=Temporary;
end;

function TVkFloatList.CompareItem(const Source,Destination):TVkInt32;
begin
 result:=TVkInt32(Source)-TVkInt32(Destination);
end;

function TVkFloatList.Add(const Item:TVkFloat):TVkSizeInt;
begin
 result:=inherited Add(Item);
end;

function TVkFloatList.Find(const Item:TVkFloat):TVkSizeInt;
begin
 result:=inherited Find(Item);
end;

procedure TVkFloatList.Insert(const Index:TVkSizeInt;const Item:TVkFloat);
begin
 inherited Insert(Index,Item);
end;

procedure TVkFloatList.Remove(const Item:TVkFloat);
begin
 inherited Remove(Item);
end;

constructor TVkImageViewList.Create;
begin
 inherited Create(SizeOf(TVkImageView));
end;

destructor TVkImageViewList.Destroy;
begin
 inherited Destroy;
end;

function TVkImageViewList.GetItem(const Index:TVkSizeInt):TVkImageView;
begin
 if (Index>=0) and (Index<fCount) then begin
  result:=TVkImageView(TVkPointer(TVkPtrUInt(TVkPtrUInt(fMemory)+(TVkPtrUInt(Index)*TVkPtrUInt(fItemSize))))^);
 end else begin
  result:=0;
 end;
end;

procedure TVkImageViewList.SetItem(const Index:TVkSizeInt;const Item:TVkImageView);
begin
 if (Index>=0) and (Index<fCount) then begin
  TVkImageView(TVkPointer(TVkPtrUInt(TVkPtrUInt(fMemory)+(TVkPtrUInt(Index)*TVkPtrUInt(fItemSize))))^):=Item;
 end;
end;

procedure TVkImageViewList.InitializeItem(var Item);
begin
 TVkImageView(Item):=0;
end;

procedure TVkImageViewList.FinalizeItem(var Item);
begin
 TVkImageView(Item):=0;
end;

procedure TVkImageViewList.CopyItem(const Source;var Destination);
begin
 TVkImageView(Destination):=TVkImageView(Source);
end;

procedure TVkImageViewList.ExchangeItem(var Source,Destination);
var Temporary:TVkImageView;
begin
 Temporary:=TVkImageView(Source);
 TVkImageView(Source):=TVkImageView(Destination);
 TVkImageView(Destination):=Temporary;
end;

function TVkImageViewList.CompareItem(const Source,Destination):TVkInt32;
begin
 result:=TVkImageView(Source)-TVkImageView(Destination);
end;

function TVkImageViewList.Add(const Item:TVkImageView):TVkSizeInt;
begin
 result:=inherited Add(Item);
end;

function TVkImageViewList.Find(const Item:TVkImageView):TVkSizeInt;
begin
 result:=inherited Find(Item);
end;

procedure TVkImageViewList.Insert(const Index:TVkSizeInt;const Item:TVkImageView);
begin
 inherited Insert(Index,Item);
end;

procedure TVkImageViewList.Remove(const Item:TVkImageView);
begin
 inherited Remove(Item);
end;

constructor TVkSamplerList.Create;
begin
 inherited Create(SizeOf(TVkSampler));
end;

destructor TVkSamplerList.Destroy;
begin
 inherited Destroy;
end;

function TVkSamplerList.GetItem(const Index:TVkSizeInt):TVkSampler;
begin
 if (Index>=0) and (Index<fCount) then begin
  result:=TVkSampler(TVkPointer(TVkPtrUInt(TVkPtrUInt(fMemory)+(TVkPtrUInt(Index)*TVkPtrUInt(fItemSize))))^);
 end else begin
  result:=0;
 end;
end;

procedure TVkSamplerList.SetItem(const Index:TVkSizeInt;const Item:TVkSampler);
begin
 if (Index>=0) and (Index<fCount) then begin
  TVkSampler(TVkPointer(TVkPtrUInt(TVkPtrUInt(fMemory)+(TVkPtrUInt(Index)*TVkPtrUInt(fItemSize))))^):=Item;
 end;
end;

procedure TVkSamplerList.InitializeItem(var Item);
begin
 TVkSampler(Item):=0;
end;

procedure TVkSamplerList.FinalizeItem(var Item);
begin
 TVkSampler(Item):=0;
end;

procedure TVkSamplerList.CopyItem(const Source;var Destination);
begin
 TVkSampler(Destination):=TVkSampler(Source);
end;

procedure TVkSamplerList.ExchangeItem(var Source,Destination);
var Temporary:TVkSampler;
begin
 Temporary:=TVkSampler(Source);
 TVkSampler(Source):=TVkSampler(Destination);
 TVkSampler(Destination):=Temporary;
end;

function TVkSamplerList.CompareItem(const Source,Destination):TVkInt32;
begin
 result:=TVkSampler(Source)-TVkSampler(Destination);
end;

function TVkSamplerList.Add(const Item:TVkSampler):TVkSizeInt;
begin
 result:=inherited Add(Item);
end;

function TVkSamplerList.Find(const Item:TVkSampler):TVkSizeInt;
begin
 result:=inherited Find(Item);
end;

procedure TVkSamplerList.Insert(const Index:TVkSizeInt;const Item:TVkSampler);
begin
 inherited Insert(Index,Item);
end;

procedure TVkSamplerList.Remove(const Item:TVkSampler);
begin
 inherited Remove(Item);
end;

constructor TVkDescriptorSetLayoutList.Create;
begin
 inherited Create(SizeOf(TVkDescriptorSetLayout));
end;

destructor TVkDescriptorSetLayoutList.Destroy;
begin
 inherited Destroy;
end;

function TVkDescriptorSetLayoutList.GetItem(const Index:TVkSizeInt):TVkDescriptorSetLayout;
begin
 if (Index>=0) and (Index<fCount) then begin
  result:=TVkDescriptorSetLayout(TVkPointer(TVkPtrUInt(TVkPtrUInt(fMemory)+(TVkPtrUInt(Index)*TVkPtrUInt(fItemSize))))^);
 end else begin
  result:=0;
 end;
end;

procedure TVkDescriptorSetLayoutList.SetItem(const Index:TVkSizeInt;const Item:TVkDescriptorSetLayout);
begin
 if (Index>=0) and (Index<fCount) then begin
  TVkDescriptorSetLayout(TVkPointer(TVkPtrUInt(TVkPtrUInt(fMemory)+(TVkPtrUInt(Index)*TVkPtrUInt(fItemSize))))^):=Item;
 end;
end;

procedure TVkDescriptorSetLayoutList.InitializeItem(var Item);
begin
 TVkDescriptorSetLayout(Item):=0;
end;

procedure TVkDescriptorSetLayoutList.FinalizeItem(var Item);
begin
 TVkDescriptorSetLayout(Item):=0;
end;

procedure TVkDescriptorSetLayoutList.CopyItem(const Source;var Destination);
begin
 TVkDescriptorSetLayout(Destination):=TVkDescriptorSetLayout(Source);
end;

procedure TVkDescriptorSetLayoutList.ExchangeItem(var Source,Destination);
var Temporary:TVkDescriptorSetLayout;
begin
 Temporary:=TVkDescriptorSetLayout(Source);
 TVkDescriptorSetLayout(Source):=TVkDescriptorSetLayout(Destination);
 TVkDescriptorSetLayout(Destination):=Temporary;
end;

function TVkDescriptorSetLayoutList.CompareItem(const Source,Destination):TVkInt32;
begin
 result:=TVkDescriptorSetLayout(Source)-TVkDescriptorSetLayout(Destination);
end;

function TVkDescriptorSetLayoutList.Add(const Item:TVkDescriptorSetLayout):TVkSizeInt;
begin
 result:=inherited Add(Item);
end;

function TVkDescriptorSetLayoutList.Find(const Item:TVkDescriptorSetLayout):TVkSizeInt;
begin
 result:=inherited Find(Item);
end;

procedure TVkDescriptorSetLayoutList.Insert(const Index:TVkSizeInt;const Item:TVkDescriptorSetLayout);
begin
 inherited Insert(Index,Item);
end;

procedure TVkDescriptorSetLayoutList.Remove(const Item:TVkDescriptorSetLayout);
begin
 inherited Remove(Item);
end;

constructor TVkSampleMaskList.Create;
begin
 inherited Create(SizeOf(TVkSampleMask));
end;

destructor TVkSampleMaskList.Destroy;
begin
 inherited Destroy;
end;

function TVkSampleMaskList.GetItem(const Index:TVkSizeInt):TVkSampleMask;
begin
 if (Index>=0) and (Index<fCount) then begin
  result:=TVkSampleMask(TVkPointer(TVkPtrUInt(TVkPtrUInt(fMemory)+(TVkPtrUInt(Index)*TVkPtrUInt(fItemSize))))^);
 end else begin
  result:=0;
 end;
end;

procedure TVkSampleMaskList.SetItem(const Index:TVkSizeInt;const Item:TVkSampleMask);
begin
 if (Index>=0) and (Index<fCount) then begin
  TVkSampleMask(TVkPointer(TVkPtrUInt(TVkPtrUInt(fMemory)+(TVkPtrUInt(Index)*TVkPtrUInt(fItemSize))))^):=Item;
 end;
end;

procedure TVkSampleMaskList.InitializeItem(var Item);
begin
 TVkSampleMask(Item):=0;
end;

procedure TVkSampleMaskList.FinalizeItem(var Item);
begin
 TVkSampleMask(Item):=0;
end;

procedure TVkSampleMaskList.CopyItem(const Source;var Destination);
begin
 TVkSampleMask(Destination):=TVkSampleMask(Source);
end;

procedure TVkSampleMaskList.ExchangeItem(var Source,Destination);
var Temporary:TVkSampleMask;
begin
 Temporary:=TVkSampleMask(Source);
 TVkSampleMask(Source):=TVkSampleMask(Destination);
 TVkSampleMask(Destination):=Temporary;
end;

function TVkSampleMaskList.CompareItem(const Source,Destination):TVkInt32;
begin
 result:=TVkSampleMask(Source)-TVkSampleMask(Destination);
end;

function TVkSampleMaskList.Add(const Item:TVkSampleMask):TVkSizeInt;
begin
 result:=inherited Add(Item);
end;

function TVkSampleMaskList.Find(const Item:TVkSampleMask):TVkSizeInt;
begin
 result:=inherited Find(Item);
end;

procedure TVkSampleMaskList.Insert(const Index:TVkSizeInt;const Item:TVkSampleMask);
begin
 inherited Insert(Index,Item);
end;

procedure TVkSampleMaskList.Remove(const Item:TVkSampleMask);
begin
 inherited Remove(Item);
end;

constructor TVkDynamicStateList.Create;
begin
 inherited Create(SizeOf(TVkDynamicState));
end;

destructor TVkDynamicStateList.Destroy;
begin
 inherited Destroy;
end;

function TVkDynamicStateList.GetItem(const Index:TVkSizeInt):TVkDynamicState;
begin
 if (Index>=0) and (Index<fCount) then begin
  result:=TVkDynamicState(TVkPointer(TVkPtrUInt(TVkPtrUInt(fMemory)+(TVkPtrUInt(Index)*TVkPtrUInt(fItemSize))))^);
 end else begin
  result:=TVkDynamicState(0);
 end;
end;

procedure TVkDynamicStateList.SetItem(const Index:TVkSizeInt;const Item:TVkDynamicState);
begin
 if (Index>=0) and (Index<fCount) then begin
  TVkDynamicState(TVkPointer(TVkPtrUInt(TVkPtrUInt(fMemory)+(TVkPtrUInt(Index)*TVkPtrUInt(fItemSize))))^):=Item;
 end;
end;

procedure TVkDynamicStateList.InitializeItem(var Item);
begin
 Initialize(TVkDynamicState(Item));
end;

procedure TVkDynamicStateList.FinalizeItem(var Item);
begin
 Finalize(TVkDynamicState(Item));
end;

procedure TVkDynamicStateList.CopyItem(const Source;var Destination);
begin
 TVkDynamicState(Destination):=TVkDynamicState(Source);
end;

procedure TVkDynamicStateList.ExchangeItem(var Source,Destination);
var Temporary:TVkDynamicState;
begin
 Temporary:=TVkDynamicState(Source);
 TVkDynamicState(Source):=TVkDynamicState(Destination);
 TVkDynamicState(Destination):=Temporary;
end;

function TVkDynamicStateList.CompareItem(const Source,Destination):TVkInt32;
begin
 result:=TVkSize(TVkDynamicState(Source))-TVkSize(TVkDynamicState(Destination));
end;

function TVkDynamicStateList.Add(const Item:TVkDynamicState):TVkSizeInt;
begin
 result:=inherited Add(Item);
end;

function TVkDynamicStateList.Find(const Item:TVkDynamicState):TVkSizeInt;
begin
 result:=inherited Find(Item);
end;

procedure TVkDynamicStateList.Insert(const Index:TVkSizeInt;const Item:TVkDynamicState);
begin
 inherited Insert(Index,Item);
end;

procedure TVkDynamicStateList.Remove(const Item:TVkDynamicState);
begin
 inherited Remove(Item);
end;

constructor TVkBufferViewList.Create;
begin
 inherited Create(SizeOf(TVkBufferView));
end;

destructor TVkBufferViewList.Destroy;
begin
 inherited Destroy;
end;

function TVkBufferViewList.GetItem(const Index:TVkSizeInt):TVkBufferView;
begin
 if (Index>=0) and (Index<fCount) then begin
  result:=TVkBufferView(TVkPointer(TVkPtrUInt(TVkPtrUInt(fMemory)+(TVkPtrUInt(Index)*TVkPtrUInt(fItemSize))))^);
 end else begin
  result:=TVkBufferView(0);
 end;
end;

procedure TVkBufferViewList.SetItem(const Index:TVkSizeInt;const Item:TVkBufferView);
begin
 if (Index>=0) and (Index<fCount) then begin
  TVkBufferView(TVkPointer(TVkPtrUInt(TVkPtrUInt(fMemory)+(TVkPtrUInt(Index)*TVkPtrUInt(fItemSize))))^):=Item;
 end;
end;

procedure TVkBufferViewList.InitializeItem(var Item);
begin
 Initialize(TVkBufferView(Item));
end;

procedure TVkBufferViewList.FinalizeItem(var Item);
begin
 Finalize(TVkBufferView(Item));
end;

procedure TVkBufferViewList.CopyItem(const Source;var Destination);
begin
 TVkBufferView(Destination):=TVkBufferView(Source);
end;

procedure TVkBufferViewList.ExchangeItem(var Source,Destination);
var Temporary:TVkBufferView;
begin
 Temporary:=TVkBufferView(Source);
 TVkBufferView(Source):=TVkBufferView(Destination);
 TVkBufferView(Destination):=Temporary;
end;

function TVkBufferViewList.CompareItem(const Source,Destination):TVkInt32;
begin
 result:=TVkSize(TVkBufferView(Source))-TVkSize(TVkBufferView(Destination));
end;

function TVkBufferViewList.Add(const Item:TVkBufferView):TVkSizeInt;
begin
 result:=inherited Add(Item);
end;

function TVkBufferViewList.Find(const Item:TVkBufferView):TVkSizeInt;
begin
 result:=inherited Find(Item);
end;

procedure TVkBufferViewList.Insert(const Index:TVkSizeInt;const Item:TVkBufferView);
begin
 inherited Insert(Index,Item);
end;

procedure TVkBufferViewList.Remove(const Item:TVkBufferView);
begin
 inherited Remove(Item);
end;

constructor TVkClearValueList.Create;
begin
 inherited Create(SizeOf(TVkClearValue));
end;

destructor TVkClearValueList.Destroy;
begin
 inherited Destroy;
end;

function TVkClearValueList.GetItem(const Index:TVkSizeInt):TVkClearValue;
begin
 if (Index>=0) and (Index<fCount) then begin
  result:=TVkClearValue(TVkPointer(TVkPtrUInt(TVkPtrUInt(fMemory)+(TVkPtrUInt(Index)*TVkPtrUInt(fItemSize))))^);
 end else begin
  FillChar(result,SizeOf(TVkClearValue),#0);
 end;
end;

procedure TVkClearValueList.SetItem(const Index:TVkSizeInt;const Item:TVkClearValue);
begin
 if (Index>=0) and (Index<fCount) then begin
  TVkClearValue(TVkPointer(TVkPtrUInt(TVkPtrUInt(fMemory)+(TVkPtrUInt(Index)*TVkPtrUInt(fItemSize))))^):=Item;
 end;
end;

procedure TVkClearValueList.InitializeItem(var Item);
begin
 Initialize(TVkClearValue(Item));
end;

procedure TVkClearValueList.FinalizeItem(var Item);
begin
 Finalize(TVkClearValue(Item));
end;

procedure TVkClearValueList.CopyItem(const Source;var Destination);
begin
 TVkClearValue(Destination):=TVkClearValue(Source);
end;

procedure TVkClearValueList.ExchangeItem(var Source,Destination);
var Temporary:TVkClearValue;
begin
 Temporary:=TVkClearValue(Source);
 TVkClearValue(Source):=TVkClearValue(Destination);
 TVkClearValue(Destination):=Temporary;
end;

function TVkClearValueList.CompareItem(const Source,Destination):TVkInt32;
begin
 result:=inherited CompareItem(Source,Destination);
end;

function TVkClearValueList.Add(const Item:TVkClearValue):TVkSizeInt;
begin
 result:=inherited Add(Item);
end;

function TVkClearValueList.Find(const Item:TVkClearValue):TVkSizeInt;
begin
 result:=inherited Find(Item);
end;

procedure TVkClearValueList.Insert(const Index:TVkSizeInt;const Item:TVkClearValue);
begin
 inherited Insert(Index,Item);
end;

procedure TVkClearValueList.Remove(const Item:TVkClearValue);
begin
 inherited Remove(Item);
end;

constructor TVulkanDataStream.Create(const AData:TVkPointer;const ASize:TVkInt64);
begin
 inherited Create;
 fData:=AData;
 fSize:=ASize;
 fPosition:=0;
end;

destructor TVulkanDataStream.Destroy;
begin
 inherited Destroy;
end;

function TVulkanDataStream.Read(var Buffer;Count:TVkInt32):TVkInt32;
begin
 if (fPosition+Count)>fSize then begin
  Count:=fSize-fPosition;
 end;
 if Count>0 then begin
  Move(PVulkanBytes(fData)^[fPosition],Buffer,Count);
  inc(fPosition,Count);
  result:=Count;
 end else begin
  result:=0;
 end;
end;

function TVulkanDataStream.Write(const Buffer;Count:TVkInt32):TVkInt32;
begin
 if (fPosition+Count)>fSize then begin
  Count:=fSize-fPosition;
 end;
 if Count>0 then begin
  Move(Buffer,PVulkanBytes(fData)^[fPosition],Count);
  inc(fPosition,Count);
  result:=Count;
 end else begin
  result:=0;
 end;
end;

function TVulkanDataStream.Seek(Offset:TVkInt32;Origin:TVkUInt16):TVkInt32;
begin
 case Origin of
  soFromBeginning:begin
   fPosition:=Offset;
  end;
  soFromCurrent:begin
   inc(fPosition,Offset);
  end;
  soFromEnd:begin
   fPosition:=fSize+Offset;
  end;
 end;
 if (fPosition<0) or (fPosition>fSize) then begin
  raise EVulkanDataStream.Create('Stream seek error');
 end;
 result:=fPosition;
end;

function TVulkanDataStream.Seek(const Offset:TVkInt64;Origin:TSeekOrigin):TVkInt64;
begin
 case Origin of
  soBeginning:begin
   fPosition:=Offset;
  end;
  soCurrent:begin
   inc(fPosition,Offset);
  end;
  soEnd:begin
   fPosition:=fSize+Offset;
  end;
 end;
 if (fPosition<0) or (fPosition>fSize) then begin
  raise EVulkanDataStream.Create('Stream seek error');
 end;
 result:=fPosition;
end;

procedure TVulkanDataStream.SetSize(NewSize:TVkInt32);
begin
 if fSize<>NewSize then begin
  raise EVulkanDataStream.Create('Stream set size error');
 end;
end;

procedure TVulkanDataStream.SetSize(const NewSize:TVkInt64);
begin
 if fSize<>NewSize then begin
  raise EVulkanDataStream.Create('Stream set size error');
 end;
end;

constructor TVulkanStringHashMap.Create;
begin
 inherited Create;
 RealSize:=0;
 LogSize:=0;
 Size:=0;
 Entities:=nil;
 EntityToCellIndex:=nil;
 CellToEntityIndex:=nil;
 Resize;
end;

destructor TVulkanStringHashMap.Destroy;
var Counter:TVkInt32;
begin
 Clear;
 for Counter:=0 to length(Entities)-1 do begin
  Entities[Counter].Key:='';
 end;
 SetLength(Entities,0);
 SetLength(EntityToCellIndex,0);
 SetLength(CellToEntityIndex,0);
 inherited Destroy;
end;

procedure TVulkanStringHashMap.Clear;
var Counter:TVkInt32;
begin
 for Counter:=0 to length(Entities)-1 do begin
  Entities[Counter].Key:='';
 end;
 RealSize:=0;
 LogSize:=0;
 Size:=0;
 SetLength(Entities,0);
 SetLength(EntityToCellIndex,0);
 SetLength(CellToEntityIndex,0);
 Resize;
end;

function TVulkanStringHashMap.FindCell(const Key:TVulkanRawByteString):TVkUInt32;
var HashCode,Mask,Step:TVkUInt32;
    Entity:TVkInt32;
begin
 HashCode:=HashString(Key);
 Mask:=(2 shl LogSize)-1;
 Step:=((HashCode shl 1)+1) and Mask;
 if LogSize<>0 then begin
  result:=HashCode shr (32-LogSize);
 end else begin
  result:=0;
 end;
 repeat
  Entity:=CellToEntityIndex[result];
  if (Entity=ENT_EMPTY) or ((Entity<>ENT_DELETED) and (Entities[Entity].Key=Key)) then begin
   exit;
  end;
  result:=(result+Step) and Mask;
 until false;
end;

procedure TVulkanStringHashMap.Resize;
var NewLogSize,NewSize,Cell,Entity,Counter:TVkInt32;
    OldEntities:TVulkanStringHashMapEntities;
    OldCellToEntityIndex:TVulkanStringHashMapEntityIndices;
    OldEntityToCellIndex:TVulkanStringHashMapEntityIndices;
begin
 NewLogSize:=0;
 NewSize:=RealSize;
 while NewSize<>0 do begin
  NewSize:=NewSize shr 1;
  inc(NewLogSize);
 end;
 if NewLogSize<1 then begin
  NewLogSize:=1;
 end;
 Size:=0;
 RealSize:=0;
 LogSize:=NewLogSize;
 OldEntities:=Entities;
 OldCellToEntityIndex:=CellToEntityIndex;
 OldEntityToCellIndex:=EntityToCellIndex;
 Entities:=nil;
 CellToEntityIndex:=nil;
 EntityToCellIndex:=nil;
 SetLength(Entities,2 shl LogSize);
 SetLength(CellToEntityIndex,2 shl LogSize);
 SetLength(EntityToCellIndex,2 shl LogSize);
 for Counter:=0 to length(CellToEntityIndex)-1 do begin
  CellToEntityIndex[Counter]:=ENT_EMPTY;
 end;
 for Counter:=0 to length(EntityToCellIndex)-1 do begin
  EntityToCellIndex[Counter]:=CELL_EMPTY;
 end;
 for Counter:=0 to length(OldEntityToCellIndex)-1 do begin
  Cell:=OldEntityToCellIndex[Counter];
  if Cell>=0 then begin
   Entity:=OldCellToEntityIndex[Cell];
   if Entity>=0 then begin
    Add(OldEntities[Counter].Key,OldEntities[Counter].Value);
   end;
  end;
 end;
 for Counter:=0 to length(OldEntities)-1 do begin
  OldEntities[Counter].Key:='';
 end;
 SetLength(OldEntities,0);
 SetLength(OldCellToEntityIndex,0);
 SetLength(OldEntityToCellIndex,0);
end;

function TVulkanStringHashMap.Add(const Key:TVulkanRawByteString;Value:TVulkanStringHashMapData):PVulkanStringHashMapEntity;
var Entity:TVkInt32;
    Cell:TVkUInt32;
begin
 result:=nil;
 while RealSize>=(1 shl LogSize) do begin
  Resize;
 end;
 Cell:=FindCell(Key);
 Entity:=CellToEntityIndex[Cell];
 if Entity>=0 then begin
  result:=@Entities[Entity];
  result^.Key:=Key;
  result^.Value:=Value;
  exit;
 end;
 Entity:=Size;
 inc(Size);
 if Entity<(2 shl LogSize) then begin
  CellToEntityIndex[Cell]:=Entity;
  EntityToCellIndex[Entity]:=Cell;
  inc(RealSize);
  result:=@Entities[Entity];
  result^.Key:=Key;
  result^.Value:=Value;
 end;
end;

function TVulkanStringHashMap.Get(const Key:TVulkanRawByteString;CreateIfNotExist:boolean=false):PVulkanStringHashMapEntity;
var Entity:TVkInt32;
    Cell:TVkUInt32;
begin
 result:=nil;
 Cell:=FindCell(Key);
 Entity:=CellToEntityIndex[Cell];
 if Entity>=0 then begin
  result:=@Entities[Entity];
 end else if CreateIfNotExist then begin
  result:=Add(Key,nil);
 end;
end;

function TVulkanStringHashMap.TryGet(const Key:TVulkanRawByteString;out Value:TVulkanStringHashMapData):boolean;
var Entity:TVkInt32;
    Cell:TVkUInt32;
begin
 Cell:=FindCell(Key);
 Entity:=CellToEntityIndex[Cell];
 result:=Entity>=0;
 if result then begin
  Value:=Entities[Entity].Value;
 end else begin
  Value:=nil;
 end;
end;

function TVulkanStringHashMap.ExistKey(const Key:TVulkanRawByteString):boolean;
begin
 result:=CellToEntityIndex[FindCell(Key)]>=0;
end;

function TVulkanStringHashMap.Delete(const Key:TVulkanRawByteString):boolean;
var Entity:TVkInt32;
    Cell:TVkUInt32;
begin
 result:=false;
 Cell:=FindCell(Key);
 Entity:=CellToEntityIndex[Cell];
 if Entity>=0 then begin
  Entities[Entity].Key:='';
  Entities[Entity].Value:=nil;
  EntityToCellIndex[Entity]:=CELL_DELETED;
  CellToEntityIndex[Cell]:=ENT_DELETED;
  result:=true;
 end;
end;

function TVulkanStringHashMap.GetValue(const Key:TVulkanRawByteString):TVulkanStringHashMapData;
var Entity:TVkInt32;
    Cell:TVkUInt32;
begin
 Cell:=FindCell(Key);
 Entity:=CellToEntityIndex[Cell];
 if Entity>=0 then begin
  result:=Entities[Entity].Value;
 end else begin
  result:=nil;
 end;
end;

procedure TVulkanStringHashMap.SetValue(const Key:TVulkanRawByteString;const Value:TVulkanStringHashMapData);
begin
 Add(Key,Value);
end;

constructor TVulkanPointerHashMap.Create;
begin
 inherited Create;
 RealSize:=0;
 LogSize:=0;
 Size:=0;
 Entities:=nil;
 EntityToCellIndex:=nil;
 CellToEntityIndex:=nil;
 Resize;
end;

destructor TVulkanPointerHashMap.Destroy;
var Counter:TVkInt32;
begin
 Clear;
 SetLength(Entities,0);
 SetLength(EntityToCellIndex,0);
 SetLength(CellToEntityIndex,0);
 inherited Destroy;
end;

procedure TVulkanPointerHashMap.Clear;
var Counter:TVkInt32;
begin
 RealSize:=0;
 LogSize:=0;
 Size:=0;
 SetLength(Entities,0);
 SetLength(EntityToCellIndex,0);
 SetLength(CellToEntityIndex,0);
 Resize;
end;

function TVulkanPointerHashMap.FindCell(const Key:TVkPointer):TVkUInt32;
var HashCode,Mask,Step:TVkUInt32;
    Entity:TVkInt32;
begin
 HashCode:=HashPointer(Key);
 Mask:=(2 shl LogSize)-1;
 Step:=((HashCode shl 1)+1) and Mask;
 if LogSize<>0 then begin
  result:=HashCode shr (32-LogSize);
 end else begin
  result:=0;
 end;
 repeat
  Entity:=CellToEntityIndex[result];
  if (Entity=ENT_EMPTY) or ((Entity<>ENT_DELETED) and (Entities[Entity].Key=Key)) then begin
   exit;
  end;
  result:=(result+Step) and Mask;
 until false;
end;

procedure TVulkanPointerHashMap.Resize;
var NewLogSize,NewSize,Cell,Entity,Counter:TVkInt32;
    OldEntities:TVulkanPointerHashMapEntities;
    OldCellToEntityIndex:TVulkanPointerHashMapEntityIndices;
    OldEntityToCellIndex:TVulkanPointerHashMapEntityIndices;
begin
 NewLogSize:=0;
 NewSize:=RealSize;
 while NewSize<>0 do begin
  NewSize:=NewSize shr 1;
  inc(NewLogSize);
 end;
 if NewLogSize<1 then begin
  NewLogSize:=1;
 end;
 Size:=0;
 RealSize:=0;
 LogSize:=NewLogSize;
 OldEntities:=Entities;
 OldCellToEntityIndex:=CellToEntityIndex;
 OldEntityToCellIndex:=EntityToCellIndex;
 Entities:=nil;
 CellToEntityIndex:=nil;
 EntityToCellIndex:=nil;
 SetLength(Entities,2 shl LogSize);
 SetLength(CellToEntityIndex,2 shl LogSize);
 SetLength(EntityToCellIndex,2 shl LogSize);
 for Counter:=0 to length(CellToEntityIndex)-1 do begin
  CellToEntityIndex[Counter]:=ENT_EMPTY;
 end;
 for Counter:=0 to length(EntityToCellIndex)-1 do begin
  EntityToCellIndex[Counter]:=CELL_EMPTY;
 end;
 for Counter:=0 to length(OldEntityToCellIndex)-1 do begin
  Cell:=OldEntityToCellIndex[Counter];
  if Cell>=0 then begin
   Entity:=OldCellToEntityIndex[Cell];
   if Entity>=0 then begin
    Add(OldEntities[Counter].Key,OldEntities[Counter].Value);
   end;
  end;
 end;
 SetLength(OldEntities,0);
 SetLength(OldCellToEntityIndex,0);
 SetLength(OldEntityToCellIndex,0);
end;

function TVulkanPointerHashMap.Add(const Key:TVkPointer;Value:TVulkanPointerHashMapData):PVulkanPointerHashMapEntity;
var Entity:TVkInt32;
    Cell:TVkUInt32;
begin
 result:=nil;
 while RealSize>=(1 shl LogSize) do begin
  Resize;
 end;
 Cell:=FindCell(Key);
 Entity:=CellToEntityIndex[Cell];
 if Entity>=0 then begin
  result:=@Entities[Entity];
  result^.Key:=Key;
  result^.Value:=Value;
  exit;
 end;
 Entity:=Size;
 inc(Size);
 if Entity<(2 shl LogSize) then begin
  CellToEntityIndex[Cell]:=Entity;
  EntityToCellIndex[Entity]:=Cell;
  inc(RealSize);
  result:=@Entities[Entity];
  result^.Key:=Key;
  result^.Value:=Value;
 end;
end;

function TVulkanPointerHashMap.Get(const Key:TVkPointer;CreateIfNotExist:boolean=false):PVulkanPointerHashMapEntity;
var Entity:TVkInt32;
    Cell:TVkUInt32;
begin
 result:=nil;
 Cell:=FindCell(Key);
 Entity:=CellToEntityIndex[Cell];
 if Entity>=0 then begin
  result:=@Entities[Entity];
 end else if CreateIfNotExist then begin
  result:=Add(Key,nil);
 end;
end;

function TVulkanPointerHashMap.TryGet(const Key:TVkPointer;out Value:TVulkanPointerHashMapData):boolean;
var Entity:TVkInt32;
    Cell:TVkUInt32;
begin
 Cell:=FindCell(Key);
 Entity:=CellToEntityIndex[Cell];
 result:=Entity>=0;
 if result then begin
  Value:=Entities[Entity].Value;
 end else begin
  Value:=nil;
 end;
end;

function TVulkanPointerHashMap.ExistKey(const Key:TVkPointer):boolean;
begin
 result:=CellToEntityIndex[FindCell(Key)]>=0;
end;

function TVulkanPointerHashMap.Delete(const Key:TVkPointer):boolean;
var Entity:TVkInt32;
    Cell:TVkUInt32;
begin
 result:=false;
 Cell:=FindCell(Key);
 Entity:=CellToEntityIndex[Cell];
 if Entity>=0 then begin
  Entities[Entity].Key:=nil;
  Entities[Entity].Value:=nil;
  EntityToCellIndex[Entity]:=CELL_DELETED;
  CellToEntityIndex[Cell]:=ENT_DELETED;
  result:=true;
 end;
end;

function TVulkanPointerHashMap.GetValue(const Key:TVkPointer):TVulkanPointerHashMapData;
var Entity:TVkInt32;
    Cell:TVkUInt32;
begin
 Cell:=FindCell(Key);
 Entity:=CellToEntityIndex[Cell];
 if Entity>=0 then begin
  result:=Entities[Entity].Value;
 end else begin
  result:=nil;
 end;
end;

procedure TVulkanPointerHashMap.SetValue(const Key:TVkPointer;const Value:TVulkanPointerHashMapData);
begin
 Add(Key,Value);
end;

constructor TVulkanInt64HashMap.Create;
begin
 inherited Create;
 RealSize:=0;
 LogSize:=0;
 Size:=0;
 Entities:=nil;
 EntityToCellIndex:=nil;
 CellToEntityIndex:=nil;
 Resize;
end;

destructor TVulkanInt64HashMap.Destroy;
var Counter:TVkInt32;
begin
 Clear;
 SetLength(Entities,0);
 SetLength(EntityToCellIndex,0);
 SetLength(CellToEntityIndex,0);
 inherited Destroy;
end;

procedure TVulkanInt64HashMap.Clear;
var Counter:TVkInt32;
begin
 RealSize:=0;
 LogSize:=0;
 Size:=0;
 SetLength(Entities,0);
 SetLength(EntityToCellIndex,0);
 SetLength(CellToEntityIndex,0);
 Resize;
end;

function TVulkanInt64HashMap.FindCell(const Key:TVkInt64):TVkUInt32;
var HashCode,Mask,Step:TVkUInt32;
    Entity:TVkInt32;
begin
 HashCode:=HashUInt64(Key);
 Mask:=(2 shl LogSize)-1;
 Step:=((HashCode shl 1)+1) and Mask;
 if LogSize<>0 then begin
  result:=HashCode shr (32-LogSize);
 end else begin
  result:=0;
 end;
 repeat
  Entity:=CellToEntityIndex[result];
  if (Entity=ENT_EMPTY) or ((Entity<>ENT_DELETED) and (Entities[Entity].Key=Key)) then begin
   exit;
  end;
  result:=(result+Step) and Mask;
 until false;
end;

procedure TVulkanInt64HashMap.Resize;
var NewLogSize,NewSize,Cell,Entity,Counter:TVkInt32;
    OldEntities:TVulkanInt64HashMapEntities;
    OldCellToEntityIndex:TVulkanInt64HashMapEntityIndices;
    OldEntityToCellIndex:TVulkanInt64HashMapEntityIndices;
begin
 NewLogSize:=0;
 NewSize:=RealSize;
 while NewSize<>0 do begin
  NewSize:=NewSize shr 1;
  inc(NewLogSize);
 end;
 if NewLogSize<1 then begin
  NewLogSize:=1;
 end;
 Size:=0;
 RealSize:=0;
 LogSize:=NewLogSize;
 OldEntities:=Entities;
 OldCellToEntityIndex:=CellToEntityIndex;
 OldEntityToCellIndex:=EntityToCellIndex;
 Entities:=nil;
 CellToEntityIndex:=nil;
 EntityToCellIndex:=nil;
 SetLength(Entities,2 shl LogSize);
 SetLength(CellToEntityIndex,2 shl LogSize);
 SetLength(EntityToCellIndex,2 shl LogSize);
 for Counter:=0 to length(CellToEntityIndex)-1 do begin
  CellToEntityIndex[Counter]:=ENT_EMPTY;
 end;
 for Counter:=0 to length(EntityToCellIndex)-1 do begin
  EntityToCellIndex[Counter]:=CELL_EMPTY;
 end;
 for Counter:=0 to length(OldEntityToCellIndex)-1 do begin
  Cell:=OldEntityToCellIndex[Counter];
  if Cell>=0 then begin
   Entity:=OldCellToEntityIndex[Cell];
   if Entity>=0 then begin
    Add(OldEntities[Counter].Key,OldEntities[Counter].Value);
   end;
  end;
 end;
 SetLength(OldEntities,0);
 SetLength(OldCellToEntityIndex,0);
 SetLength(OldEntityToCellIndex,0);
end;

function TVulkanInt64HashMap.Add(const Key:TVkInt64;Value:TVulkanInt64HashMapData):PVulkanInt64HashMapEntity;
var Entity:TVkInt32;
    Cell:TVkUInt32;
begin
 result:=nil;
 while RealSize>=(1 shl LogSize) do begin
  Resize;
 end;
 Cell:=FindCell(Key);
 Entity:=CellToEntityIndex[Cell];
 if Entity>=0 then begin
  result:=@Entities[Entity];
  result^.Key:=Key;
  result^.Value:=Value;
  exit;
 end;
 Entity:=Size;
 inc(Size);
 if Entity<(2 shl LogSize) then begin
  CellToEntityIndex[Cell]:=Entity;
  EntityToCellIndex[Entity]:=Cell;
  inc(RealSize);
  result:=@Entities[Entity];
  result^.Key:=Key;
  result^.Value:=Value;
 end;
end;

function TVulkanInt64HashMap.Get(const Key:TVkInt64;CreateIfNotExist:boolean=false):PVulkanInt64HashMapEntity;
var Entity:TVkInt32;
    Cell:TVkUInt32;
begin
 result:=nil;
 Cell:=FindCell(Key);
 Entity:=CellToEntityIndex[Cell];
 if Entity>=0 then begin
  result:=@Entities[Entity];
 end else if CreateIfNotExist then begin
  result:=Add(Key,nil);
 end;
end;

function TVulkanInt64HashMap.TryGet(const Key:TVkInt64;out Value:TVulkanInt64HashMapData):boolean;
var Entity:TVkInt32;
    Cell:TVkUInt32;
begin
 Cell:=FindCell(Key);
 Entity:=CellToEntityIndex[Cell];
 result:=Entity>=0;
 if result then begin
  Value:=Entities[Entity].Value;
 end else begin
  Value:=nil;
 end;
end;

function TVulkanInt64HashMap.ExistKey(const Key:TVkInt64):boolean;
begin
 result:=CellToEntityIndex[FindCell(Key)]>=0;
end;

function TVulkanInt64HashMap.Delete(const Key:TVkInt64):boolean;
var Entity:TVkInt32;
    Cell:TVkUInt32;
begin
 result:=false;
 Cell:=FindCell(Key);
 Entity:=CellToEntityIndex[Cell];
 if Entity>=0 then begin
  Entities[Entity].Key:=0;
  Entities[Entity].Value:=nil;
  EntityToCellIndex[Entity]:=CELL_DELETED;
  CellToEntityIndex[Cell]:=ENT_DELETED;
  result:=true;
 end;
end;

function TVulkanInt64HashMap.GetValue(const Key:TVkInt64):TVulkanInt64HashMapData;
var Entity:TVkInt32;
    Cell:TVkUInt32;
begin
 Cell:=FindCell(Key);
 Entity:=CellToEntityIndex[Cell];
 if Entity>=0 then begin
  result:=Entities[Entity].Value;
 end else begin
  result:=nil;
 end;
end;

procedure TVulkanInt64HashMap.SetValue(const Key:TVkInt64;const Value:TVulkanInt64HashMapData);
begin
 Add(Key,Value);
end;

function VulkanAllocationCallback(UserData:PVkVoid;Size:TVkSize;Alignment:TVkSize;Scope:TVkSystemAllocationScope):PVkVoid; {$ifdef Windows}stdcall;{$else}{$ifdef Android}{$ifdef cpuarm}hardfloat;{$else}cdecl;{$endif}{$else}cdecl;{$endif}{$endif}
begin
 result:=TVulkanAllocationManager(UserData).AllocationCallback(Size,Alignment,Scope);
end;

function VulkanReallocationCallback(UserData,Original:PVkVoid;Size:TVkSize;Alignment:TVkSize;Scope:TVkSystemAllocationScope):PVkVoid; {$ifdef Windows}stdcall;{$else}{$ifdef Android}{$ifdef cpuarm}hardfloat;{$else}cdecl;{$endif}{$else}cdecl;{$endif}{$endif}
begin
 result:=TVulkanAllocationManager(UserData).ReallocationCallback(Original,Size,Alignment,Scope);
end;

procedure VulkanFreeCallback(UserData,Memory:PVkVoid); {$ifdef Windows}stdcall;{$else}{$ifdef Android}{$ifdef cpuarm}hardfloat;{$else}cdecl;{$endif}{$else}cdecl;{$endif}{$endif}
begin
 TVulkanAllocationManager(UserData).FreeCallback(Memory);
end;
                                         
procedure VulkanInternalAllocationCallback(UserData:PVkVoid;Size:TVkSize;Type_:TVkInternalAllocationType;Scope:TVkSystemAllocationScope); {$ifdef Windows}stdcall;{$else}{$ifdef Android}{$ifdef cpuarm}hardfloat;{$else}cdecl;{$endif}{$else}cdecl;{$endif}{$endif}
begin
 TVulkanAllocationManager(UserData).InternalAllocationCallback(Size,Type_,Scope);
end;

procedure VulkanInternalFreeCallback(UserData:PVkVoid;Size:TVkSize;Type_:TVkInternalAllocationType;Scope:TVkSystemAllocationScope); {$ifdef Windows}stdcall;{$else}{$ifdef Android}{$ifdef cpuarm}hardfloat;{$else}cdecl;{$endif}{$else}cdecl;{$endif}{$endif}
begin
 TVulkanAllocationManager(UserData).InternalFreeCallback(Size,Type_,Scope);
end;

constructor TVulkanXMLClass.Create;
begin
 inherited Create;
 Previous:=nil;
 Next:=nil;
 Core:=nil;
end;

destructor TVulkanXMLClass.Destroy;
begin
 inherited Destroy;
end;

constructor TVulkanXMLClassList.Create;
begin
 inherited Create;
 ClearWithContentDestroying:=false;
 InternalCount:=0;
 InternalCapacity:=0;
 InternalList:=nil;
 CapacityMinimium:=0;
 Clear;
end;

destructor TVulkanXMLClassList.Destroy;
begin
 Clear;
 if assigned(InternalList) and (InternalCapacity<>0) then begin
  FreeMem(InternalList);
 end;
 inherited Destroy;
end;

procedure TVulkanXMLClassList.Clear;
begin
 if ClearWithContentDestroying then begin
  ClearWithFree;
 end else begin
  ClearNoFree;
 end;
end;

procedure TVulkanXMLClassList.ClearNoFree;
begin
 SetCount(0);
end;

procedure TVulkanXMLClassList.ClearWithFree;
var Counter:TVkUInt16;
begin
 for Counter:=0 to InternalCount-1 do begin
  if assigned(InternalList^[Counter]) then begin
   try
    InternalList^[Counter].Destroy;
   except
   end;
  end;
 end;
 SetCount(0);
end;

procedure TVulkanXMLClassList.SetCapacity(NewCapacity:TVkInt32);
begin
 if (InternalCapacity<>NewCapacity) and
    ((NewCapacity>=0) and (NewCapacity<VulkanXMLMaxListSize)) then begin
  ReallocMem(InternalList,NewCapacity*SizeOf(TVulkanXMLClass));
  if InternalCapacity<NewCapacity then begin
   FillChar(InternalList^[InternalCapacity],(NewCapacity-InternalCapacity)*SizeOf(TVulkanXMLClass),#0);
  end;
  InternalCapacity:=NewCapacity;
 end;
end;

procedure TVulkanXMLClassList.SetOptimalCapacity(TargetCapacity:TVkInt32);
var CapacityMask:TVkInt32;
begin
 if (TargetCapacity>=0) and (TargetCapacity<VulkanXMLMaxListSize) then begin
  if TargetCapacity<256 then begin
   CapacityMask:=15;
  end else if TargetCapacity<1024 then begin
   CapacityMask:=255;
  end else if TargetCapacity<4096 then begin
   CapacityMask:=1023;
  end else if TargetCapacity<16384 then begin
   CapacityMask:=4095;
  end else if TargetCapacity<65536 then begin
   CapacityMask:=16383;
  end else begin
   CapacityMask:=65535;
  end;
  SetCapacity((TargetCapacity+CapacityMask+CapacityMinimium) and not CapacityMask);
 end;
end;

procedure TVulkanXMLClassList.SetCount(NewCount:TVkInt32);
begin
 if (NewCount>=0) and (NewCount<VulkanXMLMaxListSize) then begin
  SetOptimalCapacity(NewCount);
  if InternalCount<NewCount then begin
   FillChar(InternalList^[InternalCount],(NewCount-InternalCount)*SizeOf(TVulkanXMLClass),#0);
  end;
  InternalCount:=NewCount;
 end;
end;

function TVulkanXMLClassList.Add(Item:TVulkanXMLClass):TVkInt32;
begin
 result:=InternalCount;
 SetCount(result+1);
 InternalList^[result]:=Item;
end;

function TVulkanXMLClassList.Append(Item:TVulkanXMLClass):TVkInt32;
begin
 result:=Add(Item);
end;

function TVulkanXMLClassList.AddList(List:TVulkanXMLClassList):TVkInt32;
var Counter,Index:TVkInt32;
begin
 result:=-1;
 for Counter:=0 to List.Count-1 do begin
  Index:=Add(List[Counter]);
  if Counter=0 then begin
   result:=Index;
  end;
 end;
end;

function TVulkanXMLClassList.AppendList(List:TVulkanXMLClassList):TVkInt32;
begin
 result:=AddList(List);
end;

function TVulkanXMLClassList.NewClass:TVulkanXMLClass;
var Item:TVulkanXMLClass;
begin
 Item:=TVulkanXMLClass.Create;
 Add(Item);
 result:=Item;
end;

procedure TVulkanXMLClassList.Insert(Index:TVkInt32;Item:TVulkanXMLClass);
var Counter:TVkInt32;
begin
 if (Index>=0) and (Index<InternalCount) then begin
  SetCount(InternalCount+1);
  for Counter:=InternalCount-1 downto Index do begin
   InternalList^[Counter+1]:=InternalList^[Counter];
  end;
  InternalList^[Index]:=Item;
 end else if Index=InternalCount then begin
  Add(Item);
 end else if Index>InternalCount then begin
  SetCount(Index);
  Add(Item);
 end;
end;

procedure TVulkanXMLClassList.Delete(Index:TVkInt32);
var i,j:TVkInt32;
begin
 if (Index>=0) and (Index<InternalCount) then begin
  j:=InternalCount-1;
  i:=Index;
  Move(InternalList^[i+1],InternalList^[i],(j-i)*SizeOf(TVulkanXMLClass));
  SetCount(j);
 end;
end;

procedure TVulkanXMLClassList.DeleteClass(Index:TVkInt32);
var i,j:TVkInt32;
begin
 if (Index>=0) and (Index<InternalCount) then begin
  j:=InternalCount-1;
  i:=Index;
  if assigned(InternalList^[i]) then begin
   InternalList^[i].Free;
   InternalList^[i]:=nil;
  end;
  Move(InternalList^[i+1],InternalList^[i],(j-i)*SizeOf(TVulkanXMLClass));
  SetCount(j);
 end;
end;

function TVulkanXMLClassList.Remove(Item:TVulkanXMLClass):TVkInt32;
var i,j,k:TVkInt32;
begin
 result:=-1;
 k:=InternalCount;
 j:=-1;
 for i:=0 to k-1 do begin
  if InternalList^[i]=Item then begin
   j:=i;
   break;
  end;
 end;
 if j>=0 then begin
  dec(k);
  Move(InternalList^[j+1],InternalList^[j],(k-j)*SizeOf(TVulkanXMLClass));
  SetCount(k);
  result:=j;
 end;
end;

function TVulkanXMLClassList.RemoveClass(Item:TVulkanXMLClass):TVkInt32;
var i,j,k:TVkInt32;
begin
 result:=-1;
 k:=InternalCount;
 j:=-1;
 for i:=0 to k-1 do begin
  if InternalList^[i]=Item then begin
   j:=i;
   break;
  end;
 end;
 if j>=0 then begin
  dec(k);
  Move(InternalList^[j+1],InternalList^[j],(k-j)*SizeOf(TVulkanXMLClass));
  SetCount(k);
  Item.Free;
  result:=j;
 end;
end;

function TVulkanXMLClassList.Find(Item:TVulkanXMLClass):TVkInt32;
var i:TVkInt32;
begin
 result:=-1;
 for i:=0 to InternalCount-1 do begin
  if InternalList^[i]=Item then begin
   result:=i;
   exit;
  end;
 end;
end;

function TVulkanXMLClassList.IndexOf(Item:TVulkanXMLClass):TVkInt32;
var i:TVkInt32;
begin
 result:=-1;
 for i:=0 to InternalCount-1 do begin
  if InternalList^[i]=Item then begin
   result:=i;
   exit;
  end;
 end;
end;

procedure TVulkanXMLClassList.Exchange(Index1,Index2:TVkInt32);
var TempPointer:TVulkanXMLClass;
begin
 if (Index1>=0) and (Index1<InternalCount) and (Index2>=0) and (Index2<InternalCount) then begin
  TempPointer:=InternalList^[Index1];
  InternalList^[Index1]:=InternalList^[Index2];
  InternalList^[Index2]:=TempPointer;
 end;
end;

function TVulkanXMLClassList.Push(Item:TVulkanXMLClass):TVkInt32;
begin
 result:=Add(Item);
end;

function TVulkanXMLClassList.Pop(var Item:TVulkanXMLClass):boolean;
begin
 result:=InternalCount>0;
 if result then begin
  Item:=InternalList^[InternalCount-1];
  Delete(InternalCount-1);
 end;
end;

function TVulkanXMLClassList.Pop:TVulkanXMLClass;
begin
 if InternalCount>0 then begin
  result:=InternalList^[InternalCount-1];
  Delete(InternalCount-1);
 end else begin
  result:=nil;
 end;
end;

function TVulkanXMLClassList.Last:TVulkanXMLClass;
begin
 if InternalCount>0 then begin
  result:=InternalList^[InternalCount-1];
 end else begin
  result:=nil;
 end;
end;

function TVulkanXMLClassList.GetItem(Index:TVkInt32):TVulkanXMLClass;
begin
 if (Index>=0) and (Index<InternalCount) then begin
  result:=InternalList^[Index];
 end else begin
  result:=nil;
 end;
end;

procedure TVulkanXMLClassList.SetItem(Index:TVkInt32;Value:TVulkanXMLClass);
begin
 if (Index>=0) and (Index<InternalCount) then begin
  InternalList^[Index]:=Value;
 end;
end;

function TVulkanXMLClassList.GetItemPointer(Index:TVkInt32):TVulkanXMLClass;
begin
 if (Index>=0) and (Index<InternalCount) then begin
  result:=@InternalList^[Index];
 end else begin
  result:=nil;
 end;
end;

constructor TVulkanXMLClassLinkedList.Create;
begin
 inherited Create;
 ClearWithContentDestroying:=false;
 ClearNoFree;
end;

destructor TVulkanXMLClassLinkedList.Destroy;
begin
 Clear;
 inherited Destroy;
end;

procedure TVulkanXMLClassLinkedList.Clear;
begin
 if ClearWithContentDestroying then begin
  ClearWithFree;
 end else begin
  ClearNoFree;
 end;
end;

procedure TVulkanXMLClassLinkedList.ClearNoFree;
var Current,Next:TVulkanXMLClass;
begin
 Current:=First;
 while assigned(Current) do begin
  Next:=Current.Next;
  Remove(Current);
  Current:=Next;
 end;
 First:=nil;
 Last:=nil;
end;

procedure TVulkanXMLClassLinkedList.ClearWithFree;
var Current,Next:TVulkanXMLClass;
begin
 Current:=First;
 while assigned(Current) do begin
  Next:=Current.Next;
  RemoveClass(Current);
  Current:=Next;
 end;
 First:=nil;
 Last:=nil;
end;

procedure TVulkanXMLClassLinkedList.Add(Item:TVulkanXMLClass);
begin
 Item.Next:=nil;
 if assigned(Last) then begin
  Last.Next:=Item;
  Item.Previous:=Last;
 end else begin
  Item.Previous:=nil;
  First:=Item;
 end;
 Last:=Item;
end;

procedure TVulkanXMLClassLinkedList.Append(Item:TVulkanXMLClass);
begin
 Add(Item);
end;

procedure TVulkanXMLClassLinkedList.AddLinkedList(List:TVulkanXMLClassLinkedList);
begin
 Last.Next:=List.First;
 if assigned(List.First) then begin
  List.First.Previous:=Last;
 end;
 Last:=List.Last;
 List.First:=nil;
 List.Last:=nil;
end;

procedure TVulkanXMLClassLinkedList.AppendLinkedList(List:TVulkanXMLClassLinkedList);
begin
 AddLinkedList(List);
end;

procedure TVulkanXMLClassLinkedList.Remove(Item:TVulkanXMLClass);
begin
 if assigned(Item) then begin
  if assigned(Item.Next) then begin
   Item.Next.Previous:=Item.Previous;
  end else if Last=Item then begin
   Last:=Item.Previous;
  end;
  if assigned(Item.Previous) then begin
   Item.Previous.Next:=Item.Next;
  end else if First=Item then begin
   First:=Item.Next;
  end;
  Item.Previous:=nil;
  Item.Next:=nil;
 end;
end;

procedure TVulkanXMLClassLinkedList.RemoveClass(Item:TVulkanXMLClass);
begin
 if assigned(Item) then begin
  Remove(Item);
  Item.Destroy;
 end;
end;

procedure TVulkanXMLClassLinkedList.Push(Item:TVulkanXMLClass);
begin
 Add(Item);
end;

function TVulkanXMLClassLinkedList.Pop(var Item:TVulkanXMLClass):boolean;
begin
 result:=assigned(Last);
 if result then begin
  Item:=Last;
  Remove(Last);
 end;
end;

function TVulkanXMLClassLinkedList.Pop:TVulkanXMLClass;
begin
 result:=Last;
 if assigned(Last) then begin
  Remove(Last);
 end;
end;

function TVulkanXMLClassLinkedList.Count:TVkInt32;
var Current:TVulkanXMLClass;
begin
 result:=0;
 Current:=First;
 while assigned(Current) do begin
  inc(result);
  Current:=Current.Next;
 end;
end;

constructor TVulkanXMLItem.Create;
begin
 inherited Create;
 Items:=TVulkanXMLItemList.Create;
end;

destructor TVulkanXMLItem.Destroy;
begin
 Items.Destroy;
 inherited Destroy;
end;

procedure TVulkanXMLItem.Clear;
begin
 Items.Clear;
end;

procedure TVulkanXMLItem.Add(Item:TVulkanXMLItem);
begin
 Items.Add(Item);
end;

procedure TVulkanXMLItem.Assign(From:TVulkanXMLItem);
var i:TVkInt32;
    NewItem:TVulkanXMLItem;
begin
 Items.ClearWithFree;
 NewItem:=nil;
 for i:=0 to Items.Count-1 do begin
  if Items[i] is TVulkanXMLTag then begin
   NewItem:=TVulkanXMLTag.Create;
  end else if Items[i] is TVulkanXMLCommentTag then begin
   NewItem:=TVulkanXMLCommentTag.Create;
  end else if Items[i] is TVulkanXMLScriptTag then begin
   NewItem:=TVulkanXMLScriptTag.Create;
  end else if Items[i] is TVulkanXMLProcessTag then begin
   NewItem:=TVulkanXMLProcessTag.Create;
  end else if Items[i] is TVulkanXMLCDATATag then begin
   NewItem:=TVulkanXMLCDATATag.Create;
  end else if Items[i] is TVulkanXMLDOCTYPETag then begin
   NewItem:=TVulkanXMLDOCTYPETag.Create;
  end else if Items[i] is TVulkanXMLExtraTag then begin
   NewItem:=TVulkanXMLExtraTag.Create;
  end else if Items[i] is TVulkanXMLText then begin
   NewItem:=TVulkanXMLText.Create;
  end else if Items[i] is TVulkanXMLItem then begin
   NewItem:=Items[i].Create;
  end else begin
   continue;
  end;
  NewItem.Assign(Items[i]);
  Items.Add(NewItem);
 end;
end;

function TVulkanXMLItem.FindTag(const TagName:TVulkanRawByteString):TVulkanXMLTag;
begin
 result:=Items.FindTag(TagName);
end;

constructor TVulkanXMLItemList.Create;
begin
 inherited Create;
 ClearWithContentDestroying:=true;
//CapacityMask:=$f;
 CapacityMinimium:=0;
end;

destructor TVulkanXMLItemList.Destroy;
begin
 ClearWithFree;
 inherited Destroy;
end;

function TVulkanXMLItemList.NewClass:TVulkanXMLItem;
begin
 result:=TVulkanXMLItem.Create;
 Add(result);
end;

function TVulkanXMLItemList.GetItem(Index:TVkInt32):TVulkanXMLItem;
begin
 result:=TVulkanXMLItem(inherited Items[Index]);
end;

procedure TVulkanXMLItemList.SetItem(Index:TVkInt32;Value:TVulkanXMLItem);
begin
 inherited Items[Index]:=Value;
end;

function TVulkanXMLItemList.FindTag(const TagName:TVulkanRawByteString):TVulkanXMLTag;
var i:TVkInt32;
    Item:TVulkanXMLItem;
begin
 result:=nil;
 for i:=0 to Count-1 do begin
  Item:=TVulkanXMLItem(inherited Items[i]);
  if (assigned(Item) and (Item is TVulkanXMLTag)) and (TVulkanXMLTag(Item).Name=TagName) then begin
   result:=TVulkanXMLTag(Item);
   break;
  end;
 end;
end;

constructor TVulkanXMLParameter.Create;
begin
 inherited Create;
 Name:='';
 Value:='';
end;

destructor TVulkanXMLParameter.Destroy;
begin
 Name:='';
 Value:='';
 inherited Destroy;
end;

procedure TVulkanXMLParameter.Assign(From:TVulkanXMLParameter);
begin
 Name:=From.Name;
 Value:=From.Value;
end;

constructor TVulkanXMLText.Create;
begin
 inherited Create;
 Text:='';
end;

destructor TVulkanXMLText.Destroy;
begin
 Text:='';
 inherited Destroy;
end;

procedure TVulkanXMLText.Assign(From:TVulkanXMLItem);
begin
 inherited Assign(From);
 if From is TVulkanXMLText then begin
  Text:=TVulkanXMLText(From).Text;
 end;
end;

procedure TVulkanXMLText.SetText(AText:TVulkanRawByteString);
begin
 Text:=AText;
end;

constructor TVulkanXMLCommentTag.Create;
begin
 inherited Create;
 Text:='';
end;

destructor TVulkanXMLCommentTag.Destroy;
begin
 Text:='';
 inherited Destroy;
end;

procedure TVulkanXMLCommentTag.Assign(From:TVulkanXMLItem);
begin
 inherited Assign(From);
 if From is TVulkanXMLCommentTag then begin
  Text:=TVulkanXMLCommentTag(From).Text;
 end;
end;

procedure TVulkanXMLCommentTag.SetText(AText:TVulkanRawByteString);
begin
 Text:=AText;
end;

constructor TVulkanXMLTag.Create;
begin
 inherited Create;
 Name:='';
 Parameter:=nil;
end;

destructor TVulkanXMLTag.Destroy;
begin
 Clear;
 inherited Destroy;
end;

procedure TVulkanXMLTag.Clear;
var Counter:TVkInt32;
begin
 inherited Clear;
 for Counter:=0 to length(Parameter)-1 do begin
  Parameter[Counter].Free;
 end;
 SetLength(Parameter,0);
 Name:='';
end;

procedure TVulkanXMLTag.Assign(From:TVulkanXMLItem);
var Counter:TVkInt32;
begin
 inherited Assign(From);
 if From is TVulkanXMLTag then begin
  for Counter:=0 to length(Parameter)-1 do begin
   Parameter[Counter].Free;
  end;
  SetLength(Parameter,0);
  Name:=TVulkanXMLTag(From).Name;
  for Counter:=0 to length(TVulkanXMLTag(From).Parameter)-1 do begin
   AddParameter(TVulkanXMLTag(From).Parameter[Counter].Name,TVulkanXMLTag(From).Parameter[Counter].Value);
  end;
 end;
end;

function TVulkanXMLTag.FindParameter(ParameterName:TVulkanRawByteString):TVulkanXMLParameter;
var i:TVkInt32;
begin
 for i:=0 to length(Parameter)-1 do begin
  if Parameter[i].Name=ParameterName then begin
   result:=Parameter[i];
   exit;
  end;
 end;
 result:=nil;
end;

function TVulkanXMLTag.GetParameter(ParameterName:TVulkanRawByteString;default:TVulkanRawByteString=''):TVulkanRawByteString;
var i:TVkInt32;
begin
 for i:=0 to length(Parameter)-1 do begin
  if Parameter[i].Name=ParameterName then begin
   result:=Parameter[i].Value;
   exit;
  end;
 end;
 result:=default;
end;

function TVulkanXMLTag.AddParameter(AParameter:TVulkanXMLParameter):boolean;
var Index:TVkInt32;
begin
 try
  Index:=length(Parameter);
  SetLength(Parameter,Index+1);
  Parameter[Index]:=AParameter;
  result:=true;
 except
  result:=false;
 end;
end;

function TVulkanXMLTag.AddParameter(Name:TVulkanRawByteString;Value:TVulkanXMLString):boolean;
var AParameter:TVulkanXMLParameter;
begin
 AParameter:=TVulkanXMLParameter.Create;
 AParameter.Name:=Name;
 AParameter.Value:=Value;
 result:=AddParameter(AParameter);
end;

function TVulkanXMLTag.RemoveParameter(AParameter:TVulkanXMLParameter):boolean;
var Found,Counter:TVkInt32;
begin
 result:=false;
 try
  Found:=-1;
  for Counter:=0 to length(Parameter)-1 do begin
   if Parameter[Counter]=AParameter then begin
    Found:=Counter;
    break;
   end;
  end;
  if Found>=0 then begin
   for Counter:=Found to length(Parameter)-2 do begin
    Parameter[Counter]:=Parameter[Counter+1];
   end;
   SetLength(Parameter,length(Parameter)-1);
   AParameter.Destroy;
   result:=true;
  end;
 except
 end;
end;

function TVulkanXMLTag.RemoveParameter(ParameterName:TVulkanRawByteString):boolean;
begin
 result:=RemoveParameter(FindParameter(ParameterName));
end;

constructor TVulkanXMLProcessTag.Create;
begin
 inherited Create;
end;

destructor TVulkanXMLProcessTag.Destroy;
begin
 inherited Destroy;
end;

procedure TVulkanXMLProcessTag.Assign(From:TVulkanXMLItem);
begin
 inherited Assign(From);
end;

constructor TVulkanXMLScriptTag.Create;
begin
 inherited Create;
 Text:='';
end;

destructor TVulkanXMLScriptTag.Destroy;
begin
 Text:='';
 inherited Destroy;
end;

procedure TVulkanXMLScriptTag.Assign(From:TVulkanXMLItem);
begin
 inherited Assign(From);
 if From is TVulkanXMLScriptTag then begin
  Text:=TVulkanXMLScriptTag(From).Text;
 end;
end;

procedure TVulkanXMLScriptTag.SetText(AText:TVulkanRawByteString);
begin
 Text:=AText;
end;

constructor TVulkanXMLCDataTag.Create;
begin
 inherited Create;
 Text:='';
end;

destructor TVulkanXMLCDataTag.Destroy;
begin
 Text:='';
 inherited Destroy;
end;

procedure TVulkanXMLCDataTag.Assign(From:TVulkanXMLItem);
begin
 inherited Assign(From);
 if From is TVulkanXMLCDataTag then begin
  Text:=TVulkanXMLCDataTag(From).Text;
 end;
end;

procedure TVulkanXMLCDataTag.SetText(AText:TVulkanRawByteString);
begin
 Text:=AText;
end;

constructor TVulkanXMLDOCTYPETag.Create;
begin
 inherited Create;
 Text:='';
end;

destructor TVulkanXMLDOCTYPETag.Destroy;
begin
 Text:='';
 inherited Destroy;
end;

procedure TVulkanXMLDOCTYPETag.Assign(From:TVulkanXMLItem);
begin
 inherited Assign(From);
 if From is TVulkanXMLDOCTYPETag then begin
  Text:=TVulkanXMLDOCTYPETag(From).Text;
 end;
end;

procedure TVulkanXMLDOCTYPETag.SetText(AText:TVulkanRawByteString);
begin
 Text:=AText;
end;

constructor TVulkanXMLExtraTag.Create;
begin
 inherited Create;
 Text:='';
end;

destructor TVulkanXMLExtraTag.Destroy;
begin
 Text:='';
 inherited Destroy;
end;

procedure TVulkanXMLExtraTag.Assign(From:TVulkanXMLItem);
begin
 inherited Assign(From);
 if From is TVulkanXMLExtraTag then begin
  Text:=TVulkanXMLExtraTag(From).Text;
 end;
end;

procedure TVulkanXMLExtraTag.SetText(AText:TVulkanRawByteString);
begin
 Text:=AText;
end;

const EntityChars:array[1..102,1..2] of TVulkanXMLString=(('&quot;',#34),('&amp;',#38),('&apos;',''''),
                                                    ('&lt;',#60),('&gt;',#62),('&euro;',#128),('&nbsp;',#160),('&iexcl;',#161),
                                                    ('&cent;',#162),('&pound;',#163),('&curren;',#164),('&yen;',#165),
                                                    ('&brvbar;',#166),('&sect;',#167),('&uml;',#168),('&copy;',#169),
                                                    ('&ordf;',#170),('&laquo;',#171),('&not;',#172),('&shy;',#173),
                                                    ('&reg;',#174),('&macr;',#175),('&deg;',#176),('&plusmn;',#177),
                                                    ('&sup2;',#178),('&sup3;',#179),('&acute;',#180),('&micro;',#181),
                                                    ('&para;',#182),('&middot;',#183),('&cedil;',#184),('&sup1;',#185),
                                                    ('&ordm;',#186),('&raquo;',#187),('&frac14;',#188),('&frac12;',#189),
                                                    ('&frac34;',#190),('&iquest;',#191),('&Agrave;',#192),('&Aacute;',#193),
                                                    ('&Acirc;',#194),('&Atilde;',#195),('&Auml;',#196),('&Aring;',#197),
                                                    ('&AElig;',#198),('&Ccedil;',#199),('&Egrave;',#200),('&Eacute;',#201),
                                                    ('&Ecirc;',#202),('&Euml;',#203),('&Igrave;',#204),('&Iacute;',#205),
                                                    ('&Icirc;',#206),('&Iuml;',#207),('&ETH;',#208),('&Ntilde;',#209),
                                                    ('&Ograve;',#210),('&Oacute;',#211),('&Ocirc;',#212),('&Otilde;',#213),
                                                    ('&Ouml;',#214),('&times;',#215),('&Oslash;',#216),('&Ugrave;',#217),
                                                    ('&Uacute;',#218),('&Ucirc;',#219),('&Uuml;',#220),('&Yacute;',#221),
                                                    ('&THORN;',#222),('&szlig;',#223),('&agrave;',#224),('&aacute;',#225),
                                                    ('&acirc;',#226),('&atilde;',#227),('&auml;',#228),('&aring;',#229),
                                                    ('&aelig;',#230),('&ccedil;',#231),('&egrave;',#232),('&eacute;',#233),
                                                    ('&ecirc;',#234),('&euml;',#235),('&igrave;',#236),('&iacute;',#237),
                                                    ('&icirc;',#238),('&iuml;',#239),('&eth;',#240),('&ntilde;',#241),
                                                    ('&ograve;',#242),('&oacute;',#243),('&ocirc;',#244),('&otilde;',#245),
                                                    ('&ouml;',#246),('&divide;',#247),('&oslash;',#248),('&ugrave;',#249),
                                                    ('&uacute;',#250),('&ucirc;',#251),('&uuml;',#252),('&yacute;',#253),
                                                    ('&thorn;',#254),('&yuml;',#255));

type TEntitiesCharLookUpItem=record
      IsEntity:boolean;
      Entity:TVulkanRawByteString;
     end;

     TEntitiesCharLookUpTable=array[0..{$ifdef VulkanXMLUnicode}65535{$else}255{$endif}] of TEntitiesCharLookUpItem;

var EntitiesCharLookUp:TEntitiesCharLookUpTable;
    EntityStringHashMap:TVulkanStringHashMap;

const EntityInitialized:boolean=false;

procedure InitializeEntites;
var EntityCounter:TVkInt32;
begin
 if not EntityInitialized then begin
  EntityInitialized:=true;
  EntityStringHashMap:=TVulkanStringHashMap.Create;
  FillChar(EntitiesCharLookUp,SizeOf(TEntitiesCharLookUpTable),#0);
  for EntityCounter:=low(EntityChars) to high(EntityChars) do begin
   EntityStringHashMap.Add(EntityChars[EntityCounter,1],pointer(TVkPtrInt(EntityCounter)));
   with EntitiesCharLookUp[ord(EntityChars[EntityCounter,2][1])] do begin
    IsEntity:=true;
    Entity:=EntityChars[EntityCounter,1];
   end;
  end;
 end;
end;

procedure FinalizeEntites;
begin
 FreeAndNil(EntityStringHashMap);
 EntityInitialized:=false;
end;

function ConvertToEntities(AString:TVulkanXMLString;IdentLevel:TVkInt32=0):TVulkanRawByteString;
var Counter,IdentCounter:TVkInt32;
    c:TVulkanXMLChar;
begin
 result:='';
 for Counter:=1 to length(AString) do begin
  c:=AString[Counter];
  if c=#13 then begin
   if ((Counter+1)<=length(AString)) and (AString[Counter+1]=#10) then begin
    continue;
   end;
   c:=#10;
  end;
  if EntitiesCharLookUp[ord(c)].IsEntity then begin
   result:=result+EntitiesCharLookUp[ord(c)].Entity;
  end else if (c=#9) or (c=#10) or (c=#13) or ((c>=#32) and (c<=#127)) then begin
   result:=result+c;
   if c=#10 then begin
    for IdentCounter:=1 to IdentLevel do begin
     result:=result+' ';
    end;
   end;
  end else begin
{$ifdef VulkanXMLUnicode}
   if c<#255 then begin
    result:=result+'&#'+TVulkanRawByteString(IntToStr(ord(c)))+';';
   end else begin
    result:=result+'&#x'+TVulkanRawByteString(IntToHex(ord(c),4))+';';
   end;
{$else}
   result:=result+'&#'+TVulkanRawByteString(IntToStr(TVkUInt8(c)))+';';
{$endif}
  end;
 end;
end;

constructor TVulkanXML.Create;
begin
 inherited Create;
 InitializeEntites;
 Root:=TVulkanXMLItem.Create;
 AutomaticAloneTagDetection:=true;
 FormatIndent:=true;
 FormatIndentText:=false;
end;

destructor TVulkanXML.Destroy;
begin
 Root.Free;
 inherited Destroy;
end;

procedure TVulkanXML.Assign(From:TVulkanXML);
begin
 Root.Assign(From.Root);
 AutomaticAloneTagDetection:=From.AutomaticAloneTagDetection;
 FormatIndent:=From.FormatIndent;
 FormatIndentText:=From.FormatIndentText;
end;

function TVulkanXML.Parse(Stream:TStream):boolean;
const NameCanBeginWithCharSet:set of TVulkanRawByteChar=['A'..'Z','a'..'z','_'];
      NameCanContainCharSet:set of TVulkanRawByteChar=['A'..'Z','a'..'z','0'..'9','.',':','_','-'];
      BlankCharSet:set of TVulkanRawByteChar=[#0..#$20];//[#$9,#$A,#$D,#$20];
type TEncoding=(etASCII,etUTF8,etUTF16);
var Errors:boolean;
    CurrentChar:TVulkanRawByteChar;
    StreamEOF:boolean;
    Encoding:TEncoding;

 function IsEOF:boolean;
 begin
  result:=StreamEOF or (Stream.Position>Stream.Size);
 end;

 function IsEOFOrErrors:boolean;
 begin
  result:=IsEOF or Errors;
 end;

 function NextChar:TVulkanRawByteChar;
 begin
  if Stream.Read(CurrentChar,SizeOf(TVulkanRawByteChar))<>SizeOf(TVulkanRawByteChar) then begin
   StreamEOF:=true;
   CurrentChar:=#0;
  end;
  result:=CurrentChar;
//system.Write(result);
 end;

 procedure SkipBlank;
 begin
  while (CurrentChar in BlankCharSet) and not IsEOFOrErrors do begin
   NextChar;
  end;
 end;

 function GetName:TVulkanRawByteString;
 var i:TVkInt32;
 begin
  result:='';
  i:=0;
  if (CurrentChar in NameCanBeginWithCharSet) and not IsEOFOrErrors then begin
   while (CurrentChar in NameCanContainCharSet) and not IsEOFOrErrors do begin
    inc(i);
    if (i+1)>length(result) then begin
     SetLength(result,VulkanRoundUpToPowerOfTwo(i+1));
    end;
    result[i]:=CurrentChar;
    NextChar;
   end;
  end;
  SetLength(result,i);
 end;

 function ExpectToken(const S:TVulkanRawByteString):boolean; overload;
 var i:TVkInt32;
 begin
  result:=true;
  for i:=1 to length(S) do begin
   if S[i]<>CurrentChar then begin
    result:=false;
    break;
   end;
   NextChar;
  end;
 end;

 function ExpectToken(const c:TVulkanRawByteChar):boolean; overload;
 begin
  result:=false;
  if c=CurrentChar then begin
   result:=true;
   NextChar;
  end;
 end;

 function GetUntil(var Content:TVulkanRawByteString;const TerminateToken:TVulkanRawByteString):boolean;
 var i,j,OldPosition:TVkInt32;
     OldEOF:boolean;
     OldChar:TVulkanRawByteChar;
 begin
  result:=false;
  j:=0;
  Content:='';
  while not IsEOFOrErrors do begin
   if (length(TerminateToken)>0) and (TerminateToken[1]=CurrentChar) and (((Stream.Size-Stream.Position)+1)>=length(TerminateToken)) then begin
    OldPosition:=Stream.Position;
    OldEOF:=StreamEOF;
    OldChar:=CurrentChar;
    for i:=1 to length(TerminateToken) do begin
     if TerminateToken[i]=CurrentChar then begin
      if i=length(TerminateToken) then begin
       NextChar;
       SetLength(Content,j);
       result:=true;
       exit;
      end;
     end else begin
      break;
     end;
     NextChar;
    end;
    Stream.Seek(OldPosition,soFromBeginning);
    StreamEOF:=OldEOF;
    CurrentChar:=OldChar;
   end;
   inc(j);
   if (j+1)>length(Content) then begin
    SetLength(Content,VulkanRoundUpToPowerOfTwo(j+1));
   end;
   Content[j]:=CurrentChar;
   NextChar;
  end;
  SetLength(Content,j);
 end;

 function GetDecimalValue:TVkInt32;
 var Negitive:boolean;
 begin
  Negitive:=CurrentChar='-';
  if Negitive then begin
   NextChar;
  end else if CurrentChar='+' then begin
   NextChar;
  end;
  result:=0;
  while (CurrentChar in ['0'..'9']) and not IsEOFOrErrors do begin
   result:=(result*10)+(ord(CurrentChar)-ord('0'));
   NextChar;
  end;
  if Negitive then begin
   result:=-result;
  end;
 end;

 function GetHeximalValue:TVkInt32;
 var Negitive:boolean;
     Value:TVkInt32;
 begin
  Negitive:=CurrentChar='-';
  if Negitive then begin
   NextChar;
  end else if CurrentChar='+' then begin
   NextChar;
  end;
  result:=0;
  Value:=0;
  while not IsEOFOrErrors do begin
   case CurrentChar of
    '0'..'9':begin
     Value:=TVkUInt8(CurrentChar)-ord('0');
    end;
    'A'..'F':begin
     Value:=TVkUInt8(CurrentChar)-ord('A')+$a;
    end;
    'a'..'f':begin
     Value:=TVkUInt8(CurrentChar)-ord('a')+$a;
    end;
    else begin
     break;
    end;
   end;
   result:=(result*16)+Value;
   NextChar;
  end;
  if Negitive then begin
   result:=-result;
  end;
 end;

 function GetEntity:TVulkanXMLString;
 var Value:TVkInt32;
     Entity:TVulkanRawByteString;
     c:TVulkanXMLChar;
     StringHashMapEntity:PVulkanStringHashMapEntity;
 begin
  result:='';
  if CurrentChar='&' then begin
   NextChar;
   if not IsEOF then begin
    if CurrentChar='#' then begin
     NextChar;
     if IsEOF then begin
      Errors:=true;
     end else begin
      if CurrentChar='x' then begin
       NextChar;
       Value:=GetHeximalValue;
      end else begin
       Value:=GetDecimalValue;
      end;
      if CurrentChar=';' then begin
       NextChar;
{$ifdef VulkanXMLUnicode}
       c:=widechar(word(Value));
{$else}
       c:=TVulkanRawByteChar(TVkUInt8(Value));
{$endif}
       result:=c;
      end else begin
       Errors:=true;
      end;
     end;
    end else begin
     Entity:='&';
     while (CurrentChar in ['a'..'z','A'..'Z','0'..'9','_']) and not IsEOFOrErrors do begin
      Entity:=Entity+CurrentChar;
      NextChar;
     end;
     if CurrentChar=';' then begin
      Entity:=Entity+CurrentChar;
      NextChar;
      StringHashMapEntity:=EntityStringHashMap.Get(Entity,false);
      if assigned(StringHashMapEntity) then begin
       result:=EntityChars[TVkPtrInt(TVkPtrUInt(pointer(StringHashMapEntity^.Value))),2];
      end else begin
       result:=Entity;
      end;
     end else begin
      Errors:=true;
     end;
    end;
   end;
  end;
 end;

 function ParseTagParameterValue(TerminateChar:TVulkanRawByteChar):TVulkanXMLString;
 var i,wc,c:TVkInt32;
 begin
  result:='';
  SkipBlank;
  i:=0;
  while (CurrentChar<>TerminateChar) and not IsEOFOrErrors do begin
   if (Encoding=etUTF8) and (ord(CurrentChar)>=$80) then begin
    wc:=ord(CurrentChar) and $3f;
    if (wc and $20)<>0 then begin
     NextChar;
     c:=ord(CurrentChar);
     if (c and $c0)<>$80 then begin
      break;
     end;
     wc:=(wc shl 6) or (c and $3f);
    end;
    NextChar;
    c:=ord(CurrentChar);
    if (c and $c0)<>$80 then begin
     break;
    end;
    wc:=(wc shl 6) or (c and $3f);
    NextChar;
    inc(i);
    if (i+1)>length(result) then begin
     SetLength(result,VulkanRoundUpToPowerOfTwo(i+1));
    end;
{$ifdef VulkanXMLUnicode}
    result[i]:=widechar(wc);
{$else}
    result[i]:=TVulkanRawByteChar(wc);
{$endif}
   end else if CurrentChar='&' then begin
    SetLength(result,i);
    result:=result+GetEntity;
    i:=length(result);
   end else begin
    inc(i);
    if (i+1)>length(result) then begin
     SetLength(result,VulkanRoundUpToPowerOfTwo(i+1));
    end;
{$ifdef VulkanXMLUnicode}
    result[i]:=widechar(word(TVkUInt8(CurrentChar)+0));
{$else}
    result[i]:=CurrentChar;
{$endif}
    NextChar;
   end;
  end;
  SetLength(result,i);
  NextChar;
 end;

 procedure ParseTagParameter(XMLTag:TVulkanXMLTag);
 var ParameterName,ParameterValue:TVulkanRawByteString;
     TerminateChar:TVulkanRawByteChar;
 begin
  SkipBlank;
  while (CurrentChar in NameCanBeginWithCharSet) and not IsEOFOrErrors do begin
   ParameterName:=GetName;
   SkipBlank;
   if CurrentChar='=' then begin
    NextChar;
    if IsEOFOrErrors then begin
     Errors:=true;
     break;
    end;
   end else begin
    Errors:=true;
    break;
   end;
   SkipBlank;
   if CurrentChar in ['''','"'] then begin
    TerminateChar:=CurrentChar;
    NextChar;
    if IsEOFOrErrors then begin
     Errors:=true;
     break;
    end;
    ParameterValue:=ParseTagParameterValue(TerminateChar);
    if Errors then begin
     break;
    end else begin
     XMLTag.AddParameter(ParameterName,ParameterValue);
     SkipBlank;
    end;
   end else begin
    Errors:=true;
    break;
   end;
  end;
 end;

 procedure Process(ParentItem:TVulkanXMLItem;Closed:boolean);
 var FinishLevel:boolean;

  procedure ParseText;
  var Text:TVulkanXMLString;
      XMLText:TVulkanXMLText;
      i,wc,c:TVkInt32;
{$ifndef VulkanXMLUnicode}
      w:TVulkanRawByteString;
{$endif}
  begin
   SkipBlank;
   if CurrentChar='<' then begin
    exit;
   end;
   i:=0;
   Text:='';
   SetLength(Text,16);
   while (CurrentChar<>'<') and not IsEOFOrErrors do begin
    if (Encoding=etUTF8) and (ord(CurrentChar)>=$80) then begin
     wc:=ord(CurrentChar) and $3f;
     if (wc and $20)<>0 then begin
      NextChar;
      c:=ord(CurrentChar);
      if (c and $c0)<>$80 then begin
       break;
      end;
      wc:=(wc shl 6) or (c and $3f);
     end;
     NextChar;
     c:=ord(CurrentChar);
     if (c and $c0)<>$80 then begin
      break;
     end;
     wc:=(wc shl 6) or (c and $3f);
     NextChar;
{$ifdef VulkanXMLUnicode}
     if wc<=$d7ff then begin
      inc(i);
      if (i+1)>length(Text) then begin
       SetLength(Text,VulkanRoundUpToPowerOfTwo(i+1));
      end;
      Text[i]:=widechar(word(wc));
     end else if wc<=$dfff then begin
      inc(i);
      if (i+1)>length(Text) then begin
       SetLength(Text,VulkanRoundUpToPowerOfTwo(i+1));
      end;
      Text[i]:=#$fffd;
     end else if wc<=$fffd then begin
      inc(i);
      if (i+1)>length(Text) then begin
       SetLength(Text,VulkanRoundUpToPowerOfTwo(i+1));
      end;
      Text[i]:=widechar(word(wc));
     end else if wc<=$ffff then begin
      inc(i);
      if (i+1)>length(Text) then begin
       SetLength(Text,VulkanRoundUpToPowerOfTwo(i+1));
      end;
      Text[i]:=#$fffd;
     end else if wc<=$10ffff then begin
      dec(wc,$10000);
      inc(i);
      if (i+1)>length(Text) then begin
       SetLength(Text,VulkanRoundUpToPowerOfTwo(i+1));
      end;
      Text[i]:=widechar(word((wc shr 10) or $d800));
      inc(i);
      if (i+1)>length(Text) then begin
       SetLength(Text,VulkanRoundUpToPowerOfTwo(i+1));
      end;
      Text[i]:=widechar(word((wc and $3ff) or $dc00));
     end else begin
      inc(i);
      if (i+1)>length(Text) then begin
       SetLength(Text,VulkanRoundUpToPowerOfTwo(i+1));
      end;
      Text[i]:=#$fffd;
     end;
{$else}
     if wc<$80 then begin
      inc(i);
      if (i+1)>length(Text) then begin
       SetLength(Text,VulkanRoundUpToPowerOfTwo(i+1));
      end;
      Text[i]:=TVulkanRawByteChar(TVkUInt8(wc));
     end else begin
      w:=VulkanUTF32CharToUTF8(wc);
      if length(w)>0 then begin
       inc(i);
       if (i+length(w)+1)>length(Text) then begin
        SetLength(Text,VulkanRoundUpToPowerOfTwo(i+length(w)+1));
       end;
       Move(w[1],Text[i],length(w));
       inc(i,length(w)-1);
      end;
     end;
{$endif}
    end else if CurrentChar='&' then begin
     SetLength(Text,i);
     Text:=Text+GetEntity;
     i:=length(Text);
    end else if CurrentChar in BlankCharSet then begin
{$ifdef VulkanXMLUnicode}
     inc(i);
     if (i+1)>length(Text) then begin
      SetLength(Text,VulkanRoundUpToPowerOfTwo(i+1));
     end;
     Text[i]:=widechar(word(TVkUInt8(CurrentChar)+0));
{$else}
     wc:=ord(CurrentChar);
     if wc<$80 then begin
      inc(i);
      if (i+1)>length(Text) then begin
       SetLength(Text,VulkanRoundUpToPowerOfTwo(i+1));
      end;
      Text[i]:=TVulkanRawByteChar(TVkUInt8(wc));
     end else begin
      w:=VulkanUTF32CharToUTF8(wc);
      if length(w)>0 then begin
       inc(i);
       if (i+length(w)+1)>length(Text) then begin
        SetLength(Text,VulkanRoundUpToPowerOfTwo(i+length(w)+1));
       end;
       Move(w[1],Text[i],length(w));
       inc(i,length(w)-1);
      end;
     end;
{$endif}
     SkipBlank;
    end else begin
{$ifdef VulkanXMLUnicode}
     inc(i);
     if (i+1)>length(Text) then begin
      SetLength(Text,VulkanRoundUpToPowerOfTwo(i+1));
     end;
     Text[i]:=widechar(word(TVkUInt8(CurrentChar)+0));
{$else}
     wc:=ord(CurrentChar);
     if wc<$80 then begin
      inc(i);
      if (i+1)>length(Text) then begin
       SetLength(Text,VulkanRoundUpToPowerOfTwo(i+1));
      end;
      Text[i]:=TVulkanRawByteChar(TVkUInt8(wc));
     end else begin
      w:=VulkanUTF32CharToUTF8(wc);
      if length(w)>0 then begin
       inc(i);
       if (i+length(w)+1)>length(Text) then begin
        SetLength(Text,VulkanRoundUpToPowerOfTwo(i+length(w)+1));
       end;
       Move(w[1],Text[i],length(w));
       inc(i,length(w)-1);
      end;
     end;
{$endif}
     NextChar;
    end;
   end;
   SetLength(Text,i);
   if length(Text)<>0 then begin
    XMLText:=TVulkanXMLText.Create;
    XMLText.Text:=Text;
    ParentItem.Add(XMLText);
   end;
  end;

  procedure ParseProcessTag;
  var TagName,EncodingName:TVulkanRawByteString;
      XMLProcessTag:TVulkanXMLProcessTag;
  begin
   if not ExpectToken('?') then begin
    Errors:=true;
    exit;
   end;
   TagName:=GetName;
   if IsEOF or Errors then begin
    Errors:=true;
    exit;
   end;
   XMLProcessTag:=TVulkanXMLProcessTag.Create;
   XMLProcessTag.Name:=TagName;
   ParentItem.Add(XMLProcessTag);
   ParseTagParameter(XMLProcessTag);
   if not ExpectToken('?>') then begin
    Errors:=true;
    exit;
   end;
   if XMLProcessTag.Name='xml' then begin
    EncodingName:=TVulkanRawByteString(UpperCase(String(XMLProcessTag.GetParameter('encoding','ascii'))));
    if EncodingName='UTF-8' then begin
     Encoding:=etUTF8;
    end else if EncodingName='UTF-16' then begin
     Encoding:=etUTF16;
    end else begin
     Encoding:=etASCII;
    end;
   end;
  end;

  procedure ParseScriptTag;
  var XMLScriptTag:TVulkanXMLScriptTag;
  begin
   if not ExpectToken('%') then begin
    Errors:=true;
    exit;
   end;
   if IsEOFOrErrors then begin
    Errors:=true;
    exit;
   end;
   XMLScriptTag:=TVulkanXMLScriptTag.Create;
   ParentItem.Add(XMLScriptTag);
   if not GetUntil(XMLScriptTag.Text,'%>') then begin
    Errors:=true;
   end;
  end;

  procedure ParseCommentTag;
  var XMLCommentTag:TVulkanXMLCommentTag;
  begin
   if not ExpectToken('--') then begin
    Errors:=true;
    exit;
   end;
   if IsEOFOrErrors then begin
    Errors:=true;
    exit;
   end;
   XMLCommentTag:=TVulkanXMLCommentTag.Create;
   ParentItem.Add(XMLCommentTag);
   if not GetUntil(XMLCommentTag.Text,'-->') then begin
    Errors:=true;
   end;
  end;

  procedure ParseCDATATag;
  var XMLCDataTag:TVulkanXMLCDataTag;
  begin
   if not ExpectToken('[CDATA[') then begin
    Errors:=true;
    exit;
   end;
   if IsEOFOrErrors then begin
    Errors:=true;
    exit;
   end;
   XMLCDataTag:=TVulkanXMLCDataTag.Create;
   ParentItem.Add(XMLCDataTag);
   if not GetUntil(XMLCDataTag.Text,']]>') then begin
    Errors:=true;
   end;
  end;

  procedure ParseDOCTYPEOrExtraTag;
  var Content:TVulkanRawByteString;
      XMLDOCTYPETag:TVulkanXMLDOCTYPETag;
      XMLExtraTag:TVulkanXMLExtraTag;
  begin
   Content:='';
   if not GetUntil(Content,'>') then begin
    Errors:=true;
    exit;
   end;
   if pos('DOCTYPE',String(Content))=1 then begin
    XMLDOCTYPETag:=TVulkanXMLDOCTYPETag.Create;
    ParentItem.Add(XMLDOCTYPETag);
    XMLDOCTYPETag.Text:=TVulkanRawByteString(TrimLeft(Copy(String(Content),8,length(String(Content))-7)));
   end else begin
    XMLExtraTag:=TVulkanXMLExtraTag.Create;
    ParentItem.Add(XMLExtraTag);
    XMLExtraTag.Text:=Content;
   end;
  end;

  procedure ParseTag;
  var TagName:TVulkanRawByteString;
      XMLTag:TVulkanXMLTag;
      IsAloneTag:boolean;
  begin
   if CurrentChar='/' then begin
    NextChar;
    if IsEOFOrErrors then begin
     Errors:=true;
     exit;
    end;
    TagName:='/'+GetName;
   end else begin
    TagName:=GetName;
   end;
   if IsEOFOrErrors then begin
    Errors:=true;
    exit;
   end;

   XMLTag:=TVulkanXMLTag.Create;
   XMLTag.Name:=TagName;
   ParseTagParameter(XMLTag);

   IsAloneTag:=CurrentChar='/';
   if IsAloneTag then begin
    NextChar;
    if IsEOFOrErrors then begin
     Errors:=true;
     exit;
    end;
   end;

   if CurrentChar<>'>' then begin
    Errors:=true;
    exit;
   end;
   NextChar;

   if (ParentItem<>Root) and (ParentItem is TVulkanXMLTag) and (XMLTag.Name='/'+TVulkanXMLTag(ParentItem).Name) then begin
    XMLTag.Destroy;
    FinishLevel:=true;
    Closed:=true;
   end else begin
    ParentItem.Add(XMLTag);
    if not IsAloneTag then begin
     Process(XMLTag,false);
    end;
   end;
// IsAloneTag:=false;
  end;

 begin
  FinishLevel:=false;
  while not (IsEOFOrErrors or FinishLevel) do begin
   ParseText;
   if CurrentChar='<' then begin
    NextChar;
    if not IsEOFOrErrors then begin
     if CurrentChar='/' then begin
      ParseTag;
     end else if CurrentChar='?' then begin
      ParseProcessTag;
     end else if CurrentChar='%' then begin
      ParseScriptTag;
     end else if CurrentChar='!' then begin
      NextChar;
      if not IsEOFOrErrors then begin
       if CurrentChar='-' then begin
        ParseCommentTag;
       end else if CurrentChar='[' then begin
        ParseCDATATag;
       end else begin
        ParseDOCTYPEOrExtraTag;
       end;
      end;
     end else begin
      ParseTag;
     end;
    end;
   end;
  end;
  if not Closed then begin
   Errors:=true;
  end;
 end;
begin
 Encoding:=etASCII;
 Errors:=false;
 CurrentChar:=#0;
 Root.Clear;
 StreamEOF:=false;
 Stream.Seek(0,soFromBeginning);
 NextChar;
 Process(Root,true);
 if Errors then begin
  Root.Clear;
 end;
 result:=not Errors;
end;

function TVulkanXML.Read(Stream:TStream):boolean;
begin
 result:=Parse(Stream);
end;

function TVulkanXML.Write(Stream:TStream;IdentSize:TVkInt32=2):boolean;
var IdentLevel:TVkInt32;
    Errors:boolean;
 procedure Process(Item:TVulkanXMLItem;DoIndent:boolean);
 var Line:TVulkanRawByteString;
     Counter:TVkInt32;
     TagWithSingleLineText,ItemsText:boolean;
  procedure WriteLineEx(Line:TVulkanRawByteString);
  begin
   if length(Line)>0 then begin
    if Stream.Write(Line[1],length(Line))<>length(Line) then begin
     Errors:=true;
    end;
   end;
  end;
  procedure WriteLine(Line:TVulkanRawByteString);
  begin
   if FormatIndent and DoIndent then begin
    Line:=Line+#10;
   end;
   if length(Line)>0 then begin
    if Stream.Write(Line[1],length(Line))<>length(Line) then begin
     Errors:=true;
    end;
   end;
  end;
 begin
  if not Errors then begin
   if assigned(Item) then begin
    inc(IdentLevel,IdentSize);
    Line:='';
    if FormatIndent and DoIndent then begin
     for Counter:=1 to IdentLevel do begin
      Line:=Line+' ';
     end;
    end;
    if Item is TVulkanXMLText then begin
     if FormatIndentText then begin
      Line:=Line+ConvertToEntities(TVulkanXMLText(Item).Text,IdentLevel);
     end else begin
      Line:=ConvertToEntities(TVulkanXMLText(Item).Text);
     end;
     WriteLine(Line);
     for Counter:=0 to Item.Items.Count-1 do begin
      Process(Item.Items[Counter],DoIndent);
     end;
    end else if Item is TVulkanXMLCommentTag then begin
     Line:=Line+'<!--'+TVulkanXMLCommentTag(Item).Text+'-->';
     WriteLine(Line);
     for Counter:=0 to Item.Items.Count-1 do begin
      Process(Item.Items[Counter],DoIndent);
     end;
    end else if Item is TVulkanXMLProcessTag then begin
     Line:=Line+'<?'+TVulkanXMLProcessTag(Item).Name;
     for Counter:=0 to length(TVulkanXMLProcessTag(Item).Parameter)-1 do begin
      if assigned(TVulkanXMLProcessTag(Item).Parameter[Counter]) then begin
       Line:=Line+' '+TVulkanXMLProcessTag(Item).Parameter[Counter].Name+'="'+ConvertToEntities(TVulkanXMLProcessTag(Item).Parameter[Counter].Value)+'"';
      end;
     end;
     Line:=Line+'?>';
     WriteLine(Line);
     for Counter:=0 to Item.Items.Count-1 do begin
      Process(Item.Items[Counter],DoIndent);
     end;
    end else if Item is TVulkanXMLScriptTag then begin
     Line:=Line+'<%'+TVulkanXMLScriptTag(Item).Text+'%>';
     WriteLine(Line);
     for Counter:=0 to Item.Items.Count-1 do begin
      Process(Item.Items[Counter],DoIndent);
     end;
    end else if Item is TVulkanXMLCDataTag then begin
     Line:=Line+'<![CDATA['+TVulkanXMLCDataTag(Item).Text+']]>';
     WriteLine(Line);
     for Counter:=0 to Item.Items.Count-1 do begin
      Process(Item.Items[Counter],DoIndent);
     end;
    end else if Item is TVulkanXMLDOCTYPETag then begin
     Line:=Line+'<!DOCTYPE '+TVulkanXMLDOCTYPETag(Item).Text+'>';
     WriteLine(Line);
     for Counter:=0 to Item.Items.Count-1 do begin
      Process(Item.Items[Counter],DoIndent);
     end;
    end else if Item is TVulkanXMLExtraTag then begin
     Line:=Line+'<!'+TVulkanXMLExtraTag(Item).Text+'>';
     WriteLine(Line);
     for Counter:=0 to Item.Items.Count-1 do begin
      Process(Item.Items[Counter],DoIndent);
     end;
    end else if Item is TVulkanXMLTag then begin
     if AutomaticAloneTagDetection then begin
      TVulkanXMLTag(Item).IsAloneTag:=TVulkanXMLTag(Item).Items.Count=0;
     end;
     Line:=Line+'<'+TVulkanXMLTag(Item).Name;
     for Counter:=0 to length(TVulkanXMLTag(Item).Parameter)-1 do begin
      if assigned(TVulkanXMLTag(Item).Parameter[Counter]) then begin
       Line:=Line+' '+TVulkanXMLTag(Item).Parameter[Counter].Name+'="'+ConvertToEntities(TVulkanXMLTag(Item).Parameter[Counter].Value)+'"';
      end;
     end;
     if TVulkanXMLTag(Item).IsAloneTag then begin
      Line:=Line+' />';
      WriteLine(Line);
     end else begin
      TagWithSingleLineText:=false;
      if Item.Items.Count=1 then begin
       if assigned(Item.Items[0]) then begin
        if Item.Items[0] is TVulkanXMLText then begin
         if ((Pos(#13,String(TVulkanXMLText(Item.Items[0]).Text))=0) and
             (Pos(#10,String(TVulkanXMLText(Item.Items[0]).Text))=0)) or not FormatIndentText then begin
          TagWithSingleLineText:=true;
         end;
        end;
       end;
      end;
      ItemsText:=false;
      for Counter:=0 to Item.Items.Count-1 do begin
       if assigned(Item.Items[Counter]) then begin
        if Item.Items[Counter] is TVulkanXMLText then begin
         ItemsText:=true;
        end;
       end;
      end;
      if TagWithSingleLineText then begin
       Line:=Line+'>'+ConvertToEntities(TVulkanXMLText(Item.Items[0]).Text)+'</'+TVulkanXMLTag(Item).Name+'>';
       WriteLine(Line);
      end else if Item.Items.Count<>0 then begin
       Line:=Line+'>';
       if assigned(Item.Items[0]) and (Item.Items[0] is TVulkanXMLText) and not FormatIndentText then begin
        WriteLineEx(Line);
       end else begin
        WriteLine(Line);
       end;
       for Counter:=0 to Item.Items.Count-1 do begin
        Process(Item.Items[Counter],DoIndent and ((not ItemsText) or (FormatIndent and FormatIndentText)));
       end;
       Line:='';
       if DoIndent and ((not ItemsText) or (FormatIndent and FormatIndentText)) then begin
        for Counter:=1 to IdentLevel do begin
         Line:=Line+' ';
        end;
       end;
       Line:=Line+'</'+TVulkanXMLTag(Item).Name+'>';
       WriteLine(Line);
      end else begin
       Line:=Line+'></'+TVulkanXMLTag(Item).Name+'>';
       WriteLine(Line);
      end;
     end;
    end else begin
     for Counter:=0 to Item.Items.Count-1 do begin
      Process(Item.Items[Counter],DoIndent);
     end;
    end;
    dec(IdentLevel,IdentSize);
   end;
  end;
 end;
begin
 IdentLevel:=-(2*IdentSize);
 if Stream is TMemoryStream then begin
  TMemoryStream(Stream).Clear;
 end;
 Errors:=false;
 Process(Root,FormatIndent);
 result:=not Errors;
end;

function TVulkanXML.ReadXMLText:TVulkanRawByteString;
var Stream:TMemoryStream;
begin
 Stream:=TMemoryStream.Create;
 Write(Stream);
 if Stream.Size>0 then begin
  SetLength(result,Stream.Size);
  Stream.Seek(0,soFromBeginning);
  Stream.Read(result[1],Stream.Size);
 end else begin
  result:='';
 end;
 Stream.Destroy;
end;

procedure TVulkanXML.WriteXMLText(Text:TVulkanRawByteString);
var Stream:TMemoryStream;
begin
 Stream:=TMemoryStream.Create;
 if length(Text)>0 then begin
  Stream.Write(Text[1],length(Text));
  Stream.Seek(0,soFromBeginning);
 end;
 Parse(Stream);
 Stream.Destroy;
end;

constructor TVulkanAllocationManager.Create;
begin
 inherited Create;
 FillChar(fAllocationCallbacks,SizeOf(TVkAllocationCallbacks),#0);
 fAllocationCallbacks.pUserData:=self;
 fAllocationCallbacks.pfnAllocation:=VulkanAllocationCallback;
 fAllocationCallbacks.pfnReallocation:=VulkanReallocationCallback;
 fAllocationCallbacks.pfnFree:=VulkanFreeCallback;
 fAllocationCallbacks.pfnInternalAllocation:=VulkanInternalAllocationCallback;
 fAllocationCallbacks.pfnInternalFree:=VulkanInternalFreeCallback;
end;

destructor TVulkanAllocationManager.Destroy;
begin
 inherited Destroy;
end;

function TVulkanAllocationManager.AllocationCallback(const Size:TVkSize;const Alignment:TVkSize;const Scope:TVkSystemAllocationScope):PVkVoid;
begin
 GetMem(result,Size);
end;

function TVulkanAllocationManager.ReallocationCallback(const Original:PVkVoid;const Size:TVkSize;const Alignment:TVkSize;const Scope:TVkSystemAllocationScope):PVkVoid;
begin
 result:=Original;
 ReallocMem(result,Size);
end;

procedure TVulkanAllocationManager.FreeCallback(const Memory:PVkVoid);
begin
 FreeMem(Memory);
end;

procedure TVulkanAllocationManager.InternalAllocationCallback(const Size:TVkSize;const Type_:TVkInternalAllocationType;const Scope:TVkSystemAllocationScope);
begin
end;

procedure TVulkanAllocationManager.InternalFreeCallback(const Size:TVkSize;const Type_:TVkInternalAllocationType;const Scope:TVkSystemAllocationScope);
begin
end;

constructor TVulkanInstance.Create(const aApplicationName:TVulkanCharString='Vulkan application';
                                      const aApplicationVersion:TVkUInt32=1;
                                      const aEngineName:TVulkanCharString='Vulkan engine';
                                      const aEngineVersion:TVkUInt32=1;
                                      const pAPIVersion:TVkUInt32=VK_API_VERSION_1_0;
                                      const aValidation:boolean=false;
                                      const aAllocationManager:TVulkanAllocationManager=nil);
var Index,SubIndex:TVkInt32;
    Count,SubCount:TVkUInt32;
    LayerName:PVkChar;
    LayerProperties:TVkLayerPropertiesArray;
    LayerProperty:PVulkanAvailableLayer;
    ExtensionProperties:TVkExtensionPropertiesArray;
    ExtensionProperty:PVulkanAvailableExtension;
begin
 inherited Create;

 if not Vulkan.LoadVulkanLibrary then begin
  raise EVulkanException.Create('Vulkan load error');
 end;

 if not Vulkan.LoadVulkanGlobalCommands then begin
  raise EVulkanException.Create('Vulkan load error');
 end;

 fVulkan:=vk;

 fApplicationName:=aApplicationName;
 fEngineName:=aEngineName;

 fEnabledLayerNameStrings:=nil;
 fEnabledExtensionNameStrings:=nil;

 fRawEnabledLayerNameStrings:=nil;
 fRawEnabledExtensionNameStrings:=nil;

 fInstanceHandle:=VK_NULL_INSTANCE;

 fDebugReportCallbackEXT:=VK_NULL_HANDLE;

 fOnInstanceDebugReportCallback:=nil;

 fInstanceVulkan:=nil;

 fPhysicalDevices:=TVulkanPhysicalDeviceList.Create;
 fNeedToEnumeratePhysicalDevices:=false;

 FillChar(fApplicationInfo,SizeOf(TVkApplicationInfo),#0);
 fApplicationInfo.sType:=VK_STRUCTURE_TYPE_APPLICATION_INFO;
 fApplicationInfo.pNext:=nil;
 fApplicationInfo.pApplicationName:=PVkChar(fApplicationName);
 fApplicationInfo.applicationVersion:=aApplicationVersion;
 fApplicationInfo.pEngineName:=PVkChar(fEngineName);
 fApplicationInfo.engineVersion:=aEngineVersion;
 fApplicationInfo.apiVersion:=pAPIVersion;

 fValidation:=aValidation;

 fAllocationManager:=aAllocationManager;

 if assigned(aAllocationManager) then begin
  fAllocationCallbacks:=@aAllocationManager.fAllocationCallbacks;
 end else begin
  fAllocationCallbacks:=nil;
 end;

 fAvailableLayerNames:=TStringList.Create;
 fAvailableExtensionNames:=TStringList.Create;

 fEnabledLayerNames:=TStringList.Create;
 fEnabledExtensionNames:=TStringList.Create;

 LayerProperties:=nil;
 try
  fAvailableLayers:=nil;
  HandleResultCode(fVulkan.EnumerateInstanceLayerProperties(@Count,nil));
  if Count>0 then begin
   SetLength(LayerProperties,Count);
   SetLength(fAvailableLayers,Count);
   HandleResultCode(fVulkan.EnumerateInstanceLayerProperties(@Count,@LayerProperties[0]));
   for Index:=0 to Count-1 do begin
    LayerProperty:=@fAvailableLayers[Index];
    LayerProperty^.LayerName:=LayerProperties[Index].layerName;
    LayerProperty^.SpecVersion:=LayerProperties[Index].specVersion;
    LayerProperty^.ImplementationVersion:=LayerProperties[Index].implementationVersion;
    LayerProperty^.Description:=LayerProperties[Index].description;
    fAvailableLayerNames.Add(String(LayerProperty^.LayerName));
   end;
  end;
 finally
  SetLength(LayerProperties,0);
 end;

 ExtensionProperties:=nil;
 try
  fAvailableExtensions:=nil;
  Count:=0;
  for Index:=-1 to length(fAvailableLayers)-1 do begin
   if Index<0 then begin
    LayerName:=nil;
   end else begin
    LayerName:=PVkChar(fAvailableLayers[Index].layerName);
   end;
   HandleResultCode(fVulkan.EnumerateInstanceExtensionProperties(LayerName,@SubCount,nil));
   if SubCount>0 then begin
    if SubCount>TVkUInt32(length(ExtensionProperties)) then begin
     SetLength(ExtensionProperties,SubCount);
    end;
    SetLength(fAvailableExtensions,Count+SubCount);
    HandleResultCode(fVulkan.EnumerateInstanceExtensionProperties(LayerName,@SubCount,@ExtensionProperties[0]));
    for SubIndex:=0 to SubCount-1 do begin
     ExtensionProperty:=@fAvailableExtensions[Count+TVkUInt32(SubIndex)];
     ExtensionProperty^.LayerIndex:=Index;
     ExtensionProperty^.ExtensionName:=ExtensionProperties[SubIndex].extensionName;
     ExtensionProperty^.SpecVersion:=ExtensionProperties[SubIndex].SpecVersion;
     if fAvailableExtensionNames.IndexOf(String(ExtensionProperty^.ExtensionName))<0 then begin
      fAvailableExtensionNames.Add(String(ExtensionProperty^.ExtensionName));
     end;
    end;
    inc(Count,SubCount);
   end;
  end;
 finally
  SetLength(ExtensionProperties,0);
 end;

 if fValidation then begin
{ if fAvailableExtensionNames.IndexOf('VK_LAYER_LUNARG_standard_validation')>=0 then begin
   fEnabledExtensionNames.Add(VK_EXT_DEBUG_REPORT_EXTENSION_NAME);
   fEnabledLayerNames.Add('VK_LAYER_LUNARG_standard_validation');
  end;{}
 end;

end;

destructor TVulkanInstance.Destroy;
begin
 if fDebugReportCallbackEXT<>VK_NULL_HANDLE then begin
  fInstanceVulkan.DestroyDebugReportCallbackEXT(fInstanceHandle,fDebugReportCallbackEXT,fAllocationCallbacks);
  fDebugReportCallbackEXT:=VK_NULL_HANDLE;
 end;
 fPhysicalDevices.Free;
 if fInstanceHandle<>VK_NULL_INSTANCE then begin
  fVulkan.DestroyInstance(fInstanceHandle,fAllocationCallbacks);
  fInstanceHandle:=VK_NULL_INSTANCE;
 end;
 fInstanceVulkan.Free;
 fApplicationName:='';
 fEngineName:='';
 fAvailableLayerNames.Free;
 fAvailableExtensionNames.Free;
 fEnabledLayerNames.Free;
 fEnabledExtensionNames.Free;
 SetLength(fAvailableLayers,0);
 SetLength(fAvailableExtensions,0);
 SetLength(fEnabledLayerNameStrings,0);
 SetLength(fRawEnabledLayerNameStrings,0);
 SetLength(fEnabledExtensionNameStrings,0);
 SetLength(fRawEnabledExtensionNameStrings,0);
 inherited Destroy;
end;

procedure TVulkanInstance.SetApplicationInfo(const NewApplicationInfo:TVkApplicationInfo);
begin
 fApplicationInfo:=NewApplicationInfo;
 fApplicationName:=fApplicationInfo.pApplicationName;
 fEngineName:=fApplicationInfo.pEngineName;
 fApplicationInfo.pApplicationName:=PVkChar(fApplicationName);
 fApplicationInfo.pEngineName:=PVkChar(fEngineName);
end;

function TVulkanInstance.GetApplicationName:TVulkanCharString;
begin
 result:=fApplicationName;
end;

procedure TVulkanInstance.SetApplicationName(const NewApplicationName:TVulkanCharString);
begin
 fApplicationName:=NewApplicationName;
 fApplicationInfo.pApplicationName:=PVkChar(fApplicationName);
end;

function TVulkanInstance.GetApplicationVersion:TVkUInt32;
begin
 result:=fApplicationInfo.applicationVersion;
end;

procedure TVulkanInstance.SetApplicationVersion(const NewApplicationVersion:TVkUInt32);
begin
 fApplicationInfo.applicationVersion:=NewApplicationVersion;
end;

function TVulkanInstance.GetEngineName:TVulkanCharString;
begin
 result:=fEngineName;
end;

procedure TVulkanInstance.SetEngineName(const NewEngineName:TVulkanCharString);
begin
 fEngineName:=NewEngineName;
 fApplicationInfo.pEngineName:=PVkChar(fEngineName);
end;

function TVulkanInstance.GetEngineVersion:TVkUInt32;
begin
 result:=fApplicationInfo.engineVersion;
end;

procedure TVulkanInstance.SetEngineVersion(const NewEngineVersion:TVkUInt32);
begin
 fApplicationInfo.engineVersion:=NewEngineVersion;
end;

function TVulkanInstance.GetAPIVersion:TVkUInt32;
begin
 result:=fApplicationInfo.apiVersion;
end;

procedure TVulkanInstance.SetAPIVersion(const NewAPIVersion:TVkUInt32);
begin
 fApplicationInfo.apiVersion:=NewAPIVersion;
end;

procedure TVulkanInstance.Initialize;
var i:TVkInt32;
    InstanceCommands:PVulkanCommands;
    InstanceCreateInfo:TVkInstanceCreateInfo;
begin

 if fInstanceHandle=VK_NULL_INSTANCE then begin

  SetLength(fEnabledLayerNameStrings,fEnabledLayerNames.Count);
  SetLength(fRawEnabledLayerNameStrings,fEnabledLayerNames.Count);
  for i:=0 to fEnabledLayerNames.Count-1 do begin
   fEnabledLayerNameStrings[i]:=TVulkanCharString(fEnabledLayerNames.Strings[i]);
   fRawEnabledLayerNameStrings[i]:=PVkChar(fEnabledLayerNameStrings[i]);
  end;

  SetLength(fEnabledExtensionNameStrings,fEnabledExtensionNames.Count);
  SetLength(fRawEnabledExtensionNameStrings,fEnabledExtensionNames.Count);
  for i:=0 to fEnabledExtensionNames.Count-1 do begin
   fEnabledExtensionNameStrings[i]:=TVulkanCharString(fEnabledExtensionNames.Strings[i]);
   fRawEnabledExtensionNameStrings[i]:=PVkChar(fEnabledExtensionNameStrings[i]);
  end;

  FillChar(InstanceCreateInfo,SizeOf(TVkInstanceCreateInfo),#0);
  InstanceCreateInfo.sType:=VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO;
  if length(fEnabledLayerNameStrings)>0 then begin
   InstanceCreateInfo.enabledLayerCount:=length(fEnabledLayerNameStrings);
   InstanceCreateInfo.ppEnabledLayerNames:=@fRawEnabledLayerNameStrings[0];
  end;
  if length(fEnabledExtensionNameStrings)>0 then begin
   InstanceCreateInfo.enabledExtensionCount:=length(fEnabledExtensionNameStrings);
   InstanceCreateInfo.ppEnabledExtensionNames:=@fRawEnabledExtensionNameStrings[0];
  end;

  HandleResultCode(fVulkan.CreateInstance(@InstanceCreateInfo,fAllocationCallbacks,@fInstanceHandle));

  GetMem(InstanceCommands,SizeOf(TVulkanCommands));
  try
   FillChar(InstanceCommands^,SizeOf(TVulkanCommands),#0);
   if LoadVulkanInstanceCommands(fVulkan.Commands.GetInstanceProcAddr,fInstanceHandle,InstanceCommands^) then begin
    fInstanceVulkan:=TVulkan.Create(InstanceCommands^);
   end else begin
    raise EVulkanException.Create('Couldn''t load vulkan instance commands');
   end;
  finally
   FreeMem(InstanceCommands);
  end;

  EnumeratePhysicalDevices;

 end;
end;

procedure TVulkanInstance.EnumeratePhysicalDevices;
var Index,SubIndex:TVkInt32;
    Count:TVkUInt32;
    PhysicalDevices:TVkPhysicalDeviceArray;
    PhysicalDevice:TVulkanPhysicalDevice;
    Found:boolean;
begin
 PhysicalDevices:=nil;
 try
  Count:=0;
  HandleResultCode(fInstanceVulkan.EnumeratePhysicalDevices(fInstanceHandle,@Count,nil));
  if Count>0 then begin
   SetLength(PhysicalDevices,Count);
   HandleResultCode(fInstanceVulkan.EnumeratePhysicalDevices(fInstanceHandle,@Count,@PhysicalDevices[0]));
   for Index:=fPhysicalDevices.Count-1 downto 0 do begin
    Found:=false;
    for SubIndex:=0 to Count-1 do begin
     if fPhysicalDevices[Index].fPhysicalDeviceHandle=PhysicalDevices[SubIndex] then begin
      Found:=true;
      break;
     end;
    end;
    if not Found then begin
     fPhysicalDevices.Delete(Index);
    end;
   end;
   for Index:=0 to Count-1 do begin
    Found:=false;
    for SubIndex:=0 to fPhysicalDevices.Count-1 do begin
     if fPhysicalDevices[SubIndex].fPhysicalDeviceHandle=PhysicalDevices[Index] then begin
      Found:=true;
      break;
     end;
    end;
    if not Found then begin
     PhysicalDevice:=TVulkanPhysicalDevice.Create(self,PhysicalDevices[Index]);
     fPhysicalDevices.Add(PhysicalDevice);
    end;
   end;
  end;
 finally
  SetLength(PhysicalDevices,0);
 end;
end;

function TVulkanInstanceDebugReportCallbackFunction(flags:TVkDebugReportFlagsEXT;objectType:TVkDebugReportObjectTypeEXT;object_:TVkUInt64;location:TVkSize;messageCode:TVkInt32;const aLayerPrefix:PVkChar;const aMessage:PVkChar;aUserData:PVkVoid):TVkBool32; {$ifdef Windows}stdcall;{$else}{$ifdef Android}{$ifdef cpuarm}hardfloat;{$else}cdecl;{$endif}{$else}cdecl;{$endif}{$endif}
begin
 result:=TVulkanInstance(aUserData).DebugReportCallback(flags,objectType,object_,location,messageCode,aLayerPrefix,aMessage);
end;

function TVulkanInstance.DebugReportCallback(const flags:TVkDebugReportFlagsEXT;const objectType:TVkDebugReportObjectTypeEXT;const object_:TVkUInt64;const location:TVkSize;messageCode:TVkInt32;const aLayerPrefix:TVulkaNCharString;const aMessage:TVulkanCharString):TVkBool32;
begin
 if assigned(fOnInstanceDebugReportCallback) then begin
  result:=fOnInstanceDebugReportCallback(flags,objectType,object_,location,messageCode,aLayerPrefix,aMessage);
 end else begin
  result:=VK_FALSE;
 end;
end;

procedure TVulkanInstance.InstallDebugReportCallback;
begin
 if (fDebugReportCallbackEXT=VK_NULL_HANDLE) and assigned(fInstanceVulkan.Commands.CreateDebugReportCallbackEXT) then begin
  FillChar(fDebugReportCallbackCreateInfoEXT,SizeOf(TVkDebugReportCallbackCreateInfoEXT),#0);
  fDebugReportCallbackCreateInfoEXT.sType:=VK_STRUCTURE_TYPE_DEBUG_REPORT_CREATE_INFO_EXT;
  fDebugReportCallbackCreateInfoEXT.flags:=TVkUInt32(VK_DEBUG_REPORT_ERROR_BIT_EXT) or TVkUInt32(VK_DEBUG_REPORT_WARNING_BIT_EXT) or TVkUInt32(VK_DEBUG_REPORT_PERFORMANCE_WARNING_BIT_EXT);
  fDebugReportCallbackCreateInfoEXT.pfnCallback:=@TVulkanInstanceDebugReportCallbackFunction;
  fDebugReportCallbackCreateInfoEXT.pUserData:=self;
  HandleResultCode(fInstanceVulkan.CreateDebugReportCallbackEXT(fInstanceHandle,@fDebugReportCallbackCreateInfoEXT,fAllocationCallbacks,@fDebugReportCallbackEXT));
 end;
end;

constructor TVulkanPhysicalDevice.Create(const aInstance:TVulkanInstance;const aPhysicalDevice:TVkPhysicalDevice);
var Index,SubIndex:TVkInt32;
    Count,SubCount:TVkUInt32;
    LayerName:PVkChar;
    LayerProperties:TVkLayerPropertiesArray;
    LayerProperty:PVulkanAvailableLayer;
    ExtensionProperties:TVkExtensionPropertiesArray;
    ExtensionProperty:PVulkanAvailableExtension;
begin
 inherited Create;

 fInstance:=aInstance;

 fPhysicalDeviceHandle:=aPhysicalDevice;

 fInstance.Commands.GetPhysicalDeviceProperties(fPhysicalDeviceHandle,@fProperties);

 fDeviceName:=fProperties.deviceName;

 fInstance.Commands.GetPhysicalDeviceMemoryProperties(fPhysicalDeviceHandle,@fMemoryProperties);

 fInstance.Commands.GetPhysicalDeviceFeatures(fPhysicalDeviceHandle,@fFeatures);

 fQueueFamilyProperties:=nil;
 Count:=0;
 fInstance.Commands.GetPhysicalDeviceQueueFamilyProperties(fPhysicalDeviceHandle,@Count,nil);
 if Count>0 then begin
  try
   SetLength(fQueueFamilyProperties,Count);
   fInstance.fVulkan.GetPhysicalDeviceQueueFamilyProperties(fPhysicalDeviceHandle,@Count,@fQueueFamilyProperties[0]);
  except
   SetLength(fQueueFamilyProperties,0);
   raise;
  end;
 end;

 fAvailableLayerNames:=TStringList.Create;
 fAvailableExtensionNames:=TStringList.Create;

 LayerProperties:=nil;
 try
  fAvailableLayers:=nil;
  HandleResultCode(fInstance.fVulkan.EnumerateDeviceLayerProperties(fPhysicalDeviceHandle,@Count,nil));
  if Count>0 then begin
   SetLength(LayerProperties,Count);
   SetLength(fAvailableLayers,Count);
   HandleResultCode(fInstance.fVulkan.EnumerateDeviceLayerProperties(fPhysicalDeviceHandle,@Count,@LayerProperties[0]));
   for Index:=0 to Count-1 do begin
    LayerProperty:=@fAvailableLayers[Index];
    LayerProperty^.LayerName:=LayerProperties[Index].layerName;
    LayerProperty^.SpecVersion:=LayerProperties[Index].specVersion;
    LayerProperty^.ImplementationVersion:=LayerProperties[Index].implementationVersion;
    LayerProperty^.Description:=LayerProperties[Index].description;
    fAvailableLayerNames.Add(String(LayerProperty^.LayerName));
   end;
  end;
 finally
  SetLength(LayerProperties,0);
 end;

 ExtensionProperties:=nil;
 try
  fAvailableExtensions:=nil;
  Count:=0;
  for Index:=-1 to length(fAvailableLayers)-1 do begin
   if Index<0 then begin
    LayerName:=nil;
   end else begin
    LayerName:=PVkChar(fAvailableLayers[Index].layerName);
   end;
   HandleResultCode(fInstance.fVulkan.EnumerateDeviceExtensionProperties(fPhysicalDeviceHandle,LayerName,@SubCount,nil));
   if SubCount>0 then begin
    if SubCount>TVkUInt32(length(ExtensionProperties)) then begin
     SetLength(ExtensionProperties,SubCount);
    end;
    SetLength(fAvailableExtensions,Count+SubCount);
    HandleResultCode(fInstance.fVulkan.EnumerateDeviceExtensionProperties(fPhysicalDeviceHandle,LayerName,@SubCount,@ExtensionProperties[0]));
    for SubIndex:=0 to SubCount-1 do begin
     ExtensionProperty:=@fAvailableExtensions[Count+TVkUInt32(SubIndex)];
     ExtensionProperty^.LayerIndex:=Index;
     ExtensionProperty^.ExtensionName:=ExtensionProperties[SubIndex].extensionName;
     ExtensionProperty^.SpecVersion:=ExtensionProperties[SubIndex].SpecVersion;
     if fAvailableExtensionNames.IndexOf(String(ExtensionProperty^.ExtensionName))<0 then begin
      fAvailableExtensionNames.Add(String(ExtensionProperty^.ExtensionName));
     end;
    end;
    inc(Count,SubCount);
   end;
  end;
 finally
  SetLength(ExtensionProperties,0);
 end;

end;

destructor TVulkanPhysicalDevice.Destroy;
begin
 SetLength(fQueueFamilyProperties,0);
 fAvailableLayerNames.Free;
 fAvailableExtensionNames.Free;
 SetLength(fAvailableLayers,0);
 SetLength(fAvailableExtensions,0);
 inherited Destroy;
end;

function TVulkanPhysicalDevice.HasQueueSupportForSparseBindings(const aQueueFamilyIndex:TVkUInt32):boolean;
var QueueFamilyProperties:PVkQueueFamilyProperties;
begin
 result:=false;
 if aQueueFamilyIndex<TVkUInt32(length(fQueueFamilyProperties)) then begin
  QueueFamilyProperties:=@fQueueFamilyProperties[aQueueFamilyIndex];
  if (QueueFamilyProperties.queueFlags and TVKUInt32(VK_QUEUE_SPARSE_BINDING_BIT))<>0 then begin
   result:=true;
  end;
 end;
end;

function TVulkanPhysicalDevice.GetFormatProperties(const aFormat:TVkFormat):TVkFormatProperties;
begin
 fInstance.Commands.GetPhysicalDeviceFormatProperties(fPhysicalDeviceHandle,aFormat,@result);
end;

function TVulkanPhysicalDevice.GetImageFormatProperties(const aFormat:TVkFormat;
                                                        const aType:TVkImageType;
                                                        const aTiling:TVkImageTiling;
                                                        const aUsageFlags:TVkImageUsageFlags;
                                                        const aCreateFlags:TVkImageCreateFlags):TVkImageFormatProperties;
begin
 fInstance.Commands.GetPhysicalDeviceImageFormatProperties(fPhysicalDeviceHandle,aFormat,aType,aTiling,aUsageFlags,aCreateFlags,@result);
end;

function TVulkanPhysicalDevice.GetSparseImageFormatProperties(const aFormat:TVkFormat;
                                                              const aType:TVkImageType;
                                                              const aSamples:TVkSampleCountFlagBits;
                                                              const aUsageFlags:TVkImageUsageFlags;
                                                              const aTiling:TVkImageTiling):TVkSparseImageFormatPropertiesArray;
var Count:TVkUInt32;
begin
 result:=nil;
 Count:=0;
 fInstance.Commands.GetPhysicalDeviceSparseImageFormatProperties(fPhysicalDeviceHandle,aFormat,aType,aSamples,aUsageFlags,aTiling,@Count,nil);
 if Count>0 then begin
  SetLength(result,Count);
  fInstance.Commands.GetPhysicalDeviceSparseImageFormatProperties(fPhysicalDeviceHandle,aFormat,aType,aSamples,aUsageFlags,aTiling,@Count,@result[0]);
 end;
end;

function TVulkanPhysicalDevice.GetSurfaceSupport(const aQueueFamilyIndex:TVkUInt32;const aSurface:TVulkanSurface):boolean;
var Supported:TVkBool32;
begin
 Supported:=0;
 fInstance.Commands.GetPhysicalDeviceSurfaceSupportKHR(fPhysicalDeviceHandle,aQueueFamilyIndex,aSurface.fSurfaceHandle,@Supported);
 result:=Supported<>0;
end;

function TVulkanPhysicalDevice.GetSurfaceCapabilities(const aSurface:TVulkanSurface):TVkSurfaceCapabilitiesKHR;
begin
 fInstance.Commands.GetPhysicalDeviceSurfaceCapabilitiesKHR(fPhysicalDeviceHandle,aSurface.fSurfaceHandle,@result);
end;

function TVulkanPhysicalDevice.GetSurfaceFormats(const aSurface:TVulkanSurface):TVkSurfaceFormatKHRArray;
var Count:TVKUInt32;
begin
 result:=nil;
 Count:=0;
 if fInstance.Commands.GetPhysicalDeviceSurfaceFormatsKHR(fPhysicalDeviceHandle,aSurface.fSurfaceHandle,@Count,nil)=VK_SUCCESS then begin
  if Count>0 then begin
   try
    SetLength(result,Count);
    HandleResultCode(fInstance.Commands.GetPhysicalDeviceSurfaceFormatsKHR(fPhysicalDeviceHandle,aSurface.fSurfaceHandle,@Count,@result[0]));
   except
    SetLength(result,0);
    raise;
   end;
  end;
 end;
end;

function TVulkanPhysicalDevice.GetSurfacePresentModes(const aSurface:TVulkanSurface):TVkPresentModeKHRArray;
var Count:TVKUInt32;
begin
 result:=nil;
 Count:=0;
 if fInstance.Commands.GetPhysicalDeviceSurfacePresentModesKHR(fPhysicalDeviceHandle,aSurface.fSurfaceHandle,@Count,nil)=VK_SUCCESS then begin
  if Count>0 then begin
   try
    SetLength(result,Count);
    HandleResultCode(fInstance.Commands.GetPhysicalDeviceSurfacePresentModesKHR(fPhysicalDeviceHandle,aSurface.fSurfaceHandle,@Count,@result[0]));
   except
    SetLength(result,0);
    raise;
   end;
  end;
 end;
end;

function TVulkanPhysicalDevice.GetDisplayProperties:TVkDisplayPropertiesKHRArray;
var Count:TVKUInt32;
begin
 result:=nil;
 Count:=0;
 if fInstance.Commands.GetPhysicalDeviceDisplayPropertiesKHR(fPhysicalDeviceHandle,@Count,nil)=VK_SUCCESS then begin
  if Count>0 then begin
   try
    SetLength(result,Count);
    HandleResultCode(fInstance.Commands.GetPhysicalDeviceDisplayPropertiesKHR(fPhysicalDeviceHandle,@Count,@result[0]));
   except
    SetLength(result,0);
    raise;
   end;
  end;
 end;
end;

function TVulkanPhysicalDevice.GetDisplayPlaneProperties:TVkDisplayPlanePropertiesKHRArray;
var Count:TVKUInt32;
begin
 result:=nil;
 Count:=0;
 if fInstance.Commands.GetPhysicalDeviceDisplayPlanePropertiesKHR(fPhysicalDeviceHandle,@Count,nil)=VK_SUCCESS then begin
  if Count>0 then begin
   try
    SetLength(result,Count);
    HandleResultCode(fInstance.Commands.GetPhysicalDeviceDisplayPlanePropertiesKHR(fPhysicalDeviceHandle,@Count,@result[0]));
   except
    SetLength(result,0);
    raise;
   end;
  end;
 end;
end;

function TVulkanPhysicalDevice.GetDisplayPlaneSupportedDisplays(const aPlaneIndex:TVkUInt32):TVkDisplayKHRArray;
var Count:TVKUInt32;
begin
 result:=nil;
 Count:=0;
 if fInstance.Commands.GetDisplayPlaneSupportedDisplaysKHR(fPhysicalDeviceHandle,aPlaneIndex,@Count,nil)=VK_SUCCESS then begin
  if Count>0 then begin
   try
    SetLength(result,Count);
    HandleResultCode(fInstance.Commands.GetDisplayPlaneSupportedDisplaysKHR(fPhysicalDeviceHandle,aPlaneIndex,@Count,@result[0]));
   except
    SetLength(result,0);
    raise;
   end;
  end;
 end;
end;

function TVulkanPhysicalDevice.GetDisplayModeProperties(const aDisplay:TVkDisplayKHR):TVkDisplayModePropertiesKHRArray;
var Count:TVKUInt32;
begin
 result:=nil;
 Count:=0;
 if fInstance.Commands.GetDisplayModePropertiesKHR(fPhysicalDeviceHandle,aDisplay,@Count,nil)=VK_SUCCESS then begin
  if Count>0 then begin
   try
    SetLength(result,Count);
    HandleResultCode(fInstance.Commands.GetDisplayModePropertiesKHR(fPhysicalDeviceHandle,aDisplay,@Count,@result[0]));
   except
    SetLength(result,0);
    raise;
   end;
  end;
 end;
end;

function TVulkanPhysicalDevice.GetMemoryType(const aTypeBits:TVkUInt32;const aProperties:TVkFlags):TVkUInt32;
var i:TVkUInt32;
    DeviceMemoryProperties:TVkPhysicalDeviceMemoryProperties;
begin
 result:=TVkUInt32(TVkInt32(-1));
 vkGetPhysicalDeviceMemoryProperties(fPhysicalDeviceHandle,@DeviceMemoryProperties);
 for i:=0 to 31 do begin
  if (aTypeBits and (TVkUInt32(1) shl i))<>0 then begin
   if (DeviceMemoryProperties.MemoryTypes[i].PropertyFlags and aProperties)=aProperties then begin
    result:=i;
    exit;
   end;
  end;
 end;
end;

function TVulkanPhysicalDevice.GetBestSupportedDepthFormat(const aWithStencil:boolean):TVkFormat;
const Formats:array[0..4] of TVkFormat=(VK_FORMAT_D32_SFLOAT_S8_UINT,
                                        VK_FORMAT_D32_SFLOAT,
                                        VK_FORMAT_D24_UNORM_S8_UINT,
                                        VK_FORMAT_D16_UNORM_S8_UINT,
                                        VK_FORMAT_D16_UNORM);
      WithStencilFormats:array[0..2] of TVkFormat=(VK_FORMAT_D32_SFLOAT_S8_UINT,
                                                   VK_FORMAT_D24_UNORM_S8_UINT,
                                                   VK_FORMAT_D16_UNORM_S8_UINT);
var i:TVkInt32;
    Format:TVkFormat;
    FormatProperties:TVkFormatProperties;
begin
 result:=VK_FORMAT_UNDEFINED;
 if aWithStencil then begin
  for i:=low(WithStencilFormats) to high(WithStencilFormats) do begin
   Format:=WithStencilFormats[i];
   fInstance.fVulkan.GetPhysicalDeviceFormatProperties(fPhysicalDeviceHandle,Format,@FormatProperties);
   if (FormatProperties.OptimalTilingFeatures and TVkFormatFeatureFlags(VK_FORMAT_FEATURE_DEPTH_STENCIL_ATTACHMENT_BIT))<>0 then begin
    result:=Format;
    exit;
   end;
  end;
 end else begin
  for i:=low(Formats) to high(Formats) do begin
   Format:=Formats[i];
   fInstance.fVulkan.GetPhysicalDeviceFormatProperties(fPhysicalDeviceHandle,Format,@FormatProperties);
   if (FormatProperties.OptimalTilingFeatures and TVkFormatFeatureFlags(VK_FORMAT_FEATURE_DEPTH_STENCIL_ATTACHMENT_BIT))<>0 then begin
    result:=Format;
    exit;
   end;
  end;
 end;
end;

function TVulkanPhysicalDevice.GetQueueNodeIndex(const aSurface:TVulkanSurface;const aQueueFlagBits:TVkQueueFlagBits):TVkInt32;
var Index:TVkInt32;
    QueueCount:TVkUInt32;
    QueueProperties:array of TVkQueueFamilyProperties;
    SupportsPresent:TVkBool32;
begin
 result:=-1;
 fInstance.fVulkan.GetPhysicalDeviceQueueFamilyProperties(fPhysicalDeviceHandle,@QueueCount,nil);
 QueueProperties:=nil;
 SetLength(QueueProperties,QueueCount);
 try
  fInstance.fVulkan.GetPhysicalDeviceQueueFamilyProperties(fPhysicalDeviceHandle,@QueueCount,@QueueProperties[0]);
  for Index:=0 to QueueCount-1 do begin
   fInstance.fVulkan.GetPhysicalDeviceSurfaceSupportKHR(fPhysicalDeviceHandle,Index,aSurface.fSurfaceHandle,@SupportsPresent);
   if ((QueueProperties[Index].QueueFlags and TVkQueueFlags(aQueueFlagBits))<>0) and (SupportsPresent=VK_TRUE) then begin
    result:=Index;
    break;
   end;
  end;
 finally
  SetLength(QueueProperties,0);
 end;
end;

function TVulkanPhysicalDevice.GetSurfaceFormat(const aSurface:TVulkanSurface):TVkSurfaceFormatKHR;
var FormatCount:TVkUInt32;
    SurfaceFormats:TVkSurfaceFormatKHRArray;
begin
 SurfaceFormats:=nil;
 try

  FormatCount:=0;
  HandleResultCode(vkGetPhysicalDeviceSurfaceFormatsKHR(fPhysicalDeviceHandle,aSurface.fSurfaceHandle,@FormatCount,nil));

  if FormatCount>0 then begin
   SetLength(SurfaceFormats,FormatCount);
   HandleResultCode(vkGetPhysicalDeviceSurfaceFormatsKHR(fPhysicalDeviceHandle,aSurface.fSurfaceHandle,@FormatCount,@SurfaceFormats[0]));
  end;

  if (FormatCount=0) or ((FormatCount=1) and (SurfaceFormats[0].Format=VK_FORMAT_UNDEFINED)) then begin
   result.Format:=VK_FORMAT_B8G8R8A8_UNORM;
   result.ColorSpace:=VK_COLORSPACE_SRGB_NONLINEAR_KHR;
  end else begin
   result:=SurfaceFormats[0];
  end;

 finally
  SetLength(SurfaceFormats,0);
 end;

end;

function TVulkanPhysicalDeviceList.GetItem(const Index:TVkSizeInt):TVulkanPhysicalDevice;
begin
 result:=TVulkanPhysicalDevice(inherited Items[Index]);
end;

procedure TVulkanPhysicalDeviceList.SetItem(const Index:TVkSizeInt;const Item:TVulkanPhysicalDevice);
begin
 inherited Items[Index]:=Item;
end;

(*constructor TVulkanSurface.Create(const aInstance:TVulkanInstance;
{$if defined(Android)}
                                  const aWindow:PANativeWindow
{$elseif defined(Mir)}
                                  const aConnection:PMirConnection;const aMirSurface:PMirSurface
{$elseif defined(Wayland)}
                                  const aDisplay:Pwl_display;const aSurface:Pwl_surface
{$elseif defined(Windows)}
                                  const aInstanceHandle,aWindowHandle:THandle
{$elseif defined(XLIB)}
                                  const aDisplay:PDisplay;const aWindow:TWindow
{$elseif defined(XCB)}
                                  const aConnection:Pxcb_connection;aWindow:Pxcb_window
{$ifend}
                                 );*)

constructor TVulkanSurface.Create(const aInstance:TVulkanInstance;const aSurfaceCreateInfo:TVulkanSurfaceCreateInfo);
begin
 inherited Create;

 fInstance:=aInstance;

 fSurfaceHandle:=VK_NULL_HANDLE;

 fSurfaceCreateInfo:=aSurfaceCreateInfo;

 case fSurfaceCreateInfo.sType of
{$if defined(Android)}
  VK_STRUCTURE_TYPE_ANDROID_SURFACE_CREATE_INFO_KHR:begin
   HandleResultCode(fInstance.fVulkan.CreateAndroidSurfaceKHR(fInstance.fInstanceHandle,@fSurfaceCreateInfo.Android,fInstance.fAllocationCallbacks,@fSurfaceHandle));
  end;
{$ifend}
{$if defined(Mir) and defined(Unix)}
  VK_STRUCTURE_TYPE_MIR_SURFACE_CREATE_INFO_KHR:begin
   HandleResultCode(fInstance.fVulkan.CreateMirSurfaceKHR(fInstance.fInstanceHandle,@fSurfaceCreateInfo.Mir,fInstance.fAllocationCallbacks,@fSurfaceHandle));
  end;
{$ifend}
{$if defined(Wayland) and defined(Unix)}
  VK_STRUCTURE_TYPE_WAYLAND_SURFACE_CREATE_INFO_KHR:begin
   HandleResultCode(fInstance.fVulkan.CreateWaylandSurfaceKHR(fInstance.fInstanceHandle,@fSurfaceCreateInfo.Wayland,fInstance.fAllocationCallbacks,@fSurfaceHandle));
  end;
{$ifend}
{$if defined(Windows)}
  VK_STRUCTURE_TYPE_WIN32_SURFACE_CREATE_INFO_KHR:begin
   HandleResultCode(fInstance.fVulkan.CreateWin32SurfaceKHR(fInstance.fInstanceHandle,@fSurfaceCreateInfo.Win32,fInstance.fAllocationCallbacks,@fSurfaceHandle));
  end;
{$ifend}
{$if defined(XCB) and defined(Unix)}
  VK_STRUCTURE_TYPE_XCB_SURFACE_CREATE_INFO_KHR:begin
   HandleResultCode(fInstance.fVulkan.CreateXCBSurfaceKHR(fInstance.fInstanceHandle,@fSurfaceCreateInfo.XCB,fInstance.fAllocationCallbacks,@fSurfaceHandle));
  end;
{$ifend}
{$if defined(XLIB) and defined(Unix)}
  VK_STRUCTURE_TYPE_XLIB_SURFACE_CREATE_INFO_KHR:begin
   HandleResultCode(fInstance.fVulkan.CreateXLIBSurfaceKHR(fInstance.fInstanceHandle,@fSurfaceCreateInfo.XLIB,fInstance.fAllocationCallbacks,@fSurfaceHandle));
  end;
{$ifend}
{$if defined(MoltenVK_IOS) and defined(Darwin)}
  VK_STRUCTURE_TYPE_IOS_SURFACE_CREATE_INFO_MVK:begin
   HandleResultCode(fInstance.fVulkan.CreateIOSSurfaceMVK(fInstance.fInstanceHandle,@fSurfaceCreateInfo.MoltenVK_IOS,fInstance.fAllocationCallbacks,@fSurfaceHandle));
  end;
{$ifend}
{$if defined(MoltenVK_MacOS) and defined(Darwin)}
  VK_STRUCTURE_TYPE_MACOS_SURFACE_CREATE_INFO_MVK:begin
   HandleResultCode(fInstance.fVulkan.CreateMacOSSurfaceMVK(fInstance.fInstanceHandle,@fSurfaceCreateInfo.MoltenVK_MacOS,fInstance.fAllocationCallbacks,@fSurfaceHandle));
  end;
{$ifend}
  else begin
   HandleResultCode(VK_ERROR_INCOMPATIBLE_DRIVER);
  end;
 end;

end;

{$if defined(Android)}
constructor TVulkanSurface.CreateAndroid(const aInstance:TVulkanInstance;const aWindow:PVkAndroidANativeWindow);
var SurfaceCreateInfo:TVulkanSurfaceCreateInfo;
begin
 FillChar(SurfaceCreateInfo,SizeOf(TVulkanSurfaceCreateInfo),#0);
 SurfaceCreateInfo.Android.sType:=VK_STRUCTURE_TYPE_ANDROID_SURFACE_CREATE_INFO_KHR;
 SurfaceCreateInfo.Android.window:=aWindow;
 Create(aInstance,SurfaceCreateInfo);
end;
{$ifend}

{$if defined(Mir) and defined(Unix)}
constructor TVulkanSurface.CreateMir(const aInstance:TVulkanInstance;const aConnection:PVkMirConnection;const aSurface:PVkMirSurface);
var SurfaceCreateInfo:TVulkanSurfaceCreateInfo;
begin
 FillChar(SurfaceCreateInfo,SizeOf(TVulkanSurfaceCreateInfo),#0);
 SurfaceCreateInfo.Mir.sType:=VK_STRUCTURE_TYPE_MIR_SURFACE_CREATE_INFO_KHR;
 SurfaceCreateInfo.Mir.connection:=aConnection;
 SurfaceCreateInfo.Mir.mirSurface:=aSurface;
 Create(aInstance,SurfaceCreateInfo);
end;
{$ifend}

{$if defined(Wayland) and defined(Unix)}
constructor TVulkanSurface.CreateWayland(const aInstance:TVulkanInstance;const aDisplay:PVkWaylandDisplay;const aSurface:PVkWaylandSurface);
var SurfaceCreateInfo:TVulkanSurfaceCreateInfo;
begin
 FillChar(SurfaceCreateInfo,SizeOf(TVulkanSurfaceCreateInfo),#0);
 SurfaceCreateInfo.Wayland.sType:=VK_STRUCTURE_TYPE_WAYLAND_SURFACE_CREATE_INFO_KHR;
 SurfaceCreateInfo.Wayland.display:=aDisplay;
 SurfaceCreateInfo.Wayland.surface:=aSurface;
 Create(aInstance,SurfaceCreateInfo);
end;
{$ifend}

{$if defined(Windows)}
constructor TVulkanSurface.CreateWin32(const aInstance:TVulkanInstance;const aInstanceHandle,aWindowHandle:THandle);
var SurfaceCreateInfo:TVulkanSurfaceCreateInfo;
begin
 FillChar(SurfaceCreateInfo,SizeOf(TVulkanSurfaceCreateInfo),#0);
 SurfaceCreateInfo.Win32.sType:=VK_STRUCTURE_TYPE_WIN32_SURFACE_CREATE_INFO_KHR;
 SurfaceCreateInfo.Win32.hinstance_:=aInstanceHandle;
 SurfaceCreateInfo.Win32.hwnd_:=aWindowHandle;
 Create(aInstance,SurfaceCreateInfo);
end;
{$ifend}

{$if defined(XCB) and defined(Unix)}
constructor TVulkanSurface.CreateXCB(const aInstance:TVulkanInstance;const aConnection:PVkXCBConnection;const aWindow:TVkXCBWindow);
var SurfaceCreateInfo:TVulkanSurfaceCreateInfo;
begin
 FillChar(SurfaceCreateInfo,SizeOf(TVulkanSurfaceCreateInfo),#0);
 SurfaceCreateInfo.XCB.sType:=VK_STRUCTURE_TYPE_XCB_SURFACE_CREATE_INFO_KHR;
 SurfaceCreateInfo.XCB.connection:=aConnection;
 SurfaceCreateInfo.XCB.window:=aWindow;
 Create(aInstance,SurfaceCreateInfo);
end;
{$ifend}

{$if defined(XLIB) and defined(Unix)}
constructor TVulkanSurface.CreateXLIB(const aInstance:TVulkanInstance;const aDisplay:PVkXLIBDisplay;const aWindow:TVkXLIBWindow);
var SurfaceCreateInfo:TVulkanSurfaceCreateInfo;
begin
 FillChar(SurfaceCreateInfo,SizeOf(TVulkanSurfaceCreateInfo),#0);
 SurfaceCreateInfo.XLIB.sType:=VK_STRUCTURE_TYPE_XLIB_SURFACE_CREATE_INFO_KHR;
 SurfaceCreateInfo.XLIB.dpy:=aDisplay;
 SurfaceCreateInfo.XLIB.window:=aWindow;
 Create(aInstance,SurfaceCreateInfo);
end;
{$ifend}

{$if defined(MoltenVK_IOS) and defined(Darwin)}
constructor TVulkanSurface.CreateMoltenVK_IOS(const aInstance:TVulkanInstance;const aView:PVkVoid);
var SurfaceCreateInfo:TVulkanSurfaceCreateInfo;
begin
 FillChar(SurfaceCreateInfo,SizeOf(TVulkanSurfaceCreateInfo),#0);
 SurfaceCreateInfo.MoltenVK_IOS.sType:=VK_STRUCTURE_TYPE_IOS_SURFACE_CREATE_INFO_MVK;
 SurfaceCreateInfo.MoltenVK_IOS.aView:=aView;
 Create(aInstance,SurfaceCreateInfo);
end;
{$ifend}

{$if defined(MoltenVK_MacOS) and defined(Darwin)}
constructor TVulkanSurface.CreateMoltenVK_MacOS(const aInstance:TVulkanInstance;const aView:PVkVoid);
var SurfaceCreateInfo:TVulkanSurfaceCreateInfo;
begin
 FillChar(SurfaceCreateInfo,SizeOf(TVulkanSurfaceCreateInfo),#0);
 SurfaceCreateInfo.MoltenVK_MacOS.sType:=VK_STRUCTURE_TYPE_MACOS_SURFACE_CREATE_INFO_MVK;
 SurfaceCreateInfo.MoltenVK_MacOS.aView:=aView;
 Create(aInstance,SurfaceCreateInfo);
end;
{$ifend}

destructor TVulkanSurface.Destroy;
begin
 if fSurfaceHandle<>VK_NULL_HANDLE then begin
  fInstance.fVulkan.DestroySurfaceKHR(fInstance.fInstanceHandle,fSurfaceHandle,fInstance.fAllocationCallbacks);
  fSurfaceHandle:=VK_NULL_HANDLE;
 end;
 inherited Destroy;
end;

constructor TVulkanDevice.Create(const aInstance:TVulkanInstance;
                                 const aPhysicalDevice:TVulkanPhysicalDevice=nil;
                                 const aSurface:TVulkanSurface=nil;
                                 const aAllocationManager:TVulkanAllocationManager=nil);
var Index,SubIndex:TVkInt32;
    BestPhysicalDevice,CurrentPhysicalDevice:TVulkanPhysicalDevice;
    BestScore,CurrentScore,Temp:int64;
    OK:boolean;
begin
 inherited Create;

 fInstance:=aInstance;

 fDeviceQueueCreateInfoList:=TVulkanDeviceQueueCreateInfoList.Create;

 fDeviceQueueCreateInfos:=nil;

 fEnabledLayerNameStrings:=nil;
 fEnabledExtensionNameStrings:=nil;

 fRawEnabledLayerNameStrings:=nil;
 fRawEnabledExtensionNameStrings:=nil;

 if assigned(aAllocationManager) then begin
  fAllocationManager:=aAllocationManager;
 end else begin
  fAllocationManager:=fInstance.fAllocationManager;
 end;

 if assigned(fAllocationManager) then begin
  fAllocationCallbacks:=@fAllocationManager.fAllocationCallbacks;
 end else begin
  fAllocationCallbacks:=nil;
 end;

 fSurface:=aSurface;

 fDeviceHandle:=VK_NULL_HANDLE;

 fDeviceVulkan:=nil;

 fQueues:=nil;

 fPresentQueueFamilyIndex:=-1;
 fGraphicsQueueFamilyIndex:=-1;
 fComputeQueueFamilyIndex:=-1;
 fTransferQueueFamilyIndex:=-1;

 fPresentQueue:=nil;
 fGraphicsQueue:=nil;
 fComputeQueue:=nil;
 fTransferQueue:=nil;

 if assigned(aPhysicalDevice) then begin
  fPhysicalDevice:=aPhysicalDevice;
 end else begin
  BestPhysicalDevice:=nil;
  BestScore:=-$7fffffffffffffff;
  for Index:=0 to fInstance.fPhysicalDevices.Count-1 do begin
   CurrentPhysicalDevice:=fInstance.fPhysicalDevices[Index];
   CurrentScore:=0;
   case CurrentPhysicalDevice.fProperties.deviceType of
    VK_PHYSICAL_DEVICE_TYPE_OTHER:begin
     CurrentScore:=CurrentScore or (int64(1) shl 60);
    end;
    VK_PHYSICAL_DEVICE_TYPE_INTEGRATED_GPU:begin
     CurrentScore:=CurrentScore or (int64(3) shl 60);
    end;
    VK_PHYSICAL_DEVICE_TYPE_DISCRETE_GPU:begin
     CurrentScore:=CurrentScore or (int64(4) shl 60);
    end;
    VK_PHYSICAL_DEVICE_TYPE_VIRTUAL_GPU:begin
     CurrentScore:=CurrentScore or (int64(2) shl 60);
    end;
    else begin
     CurrentScore:=CurrentScore or (int64(0) shl 60);
    end;
   end;
   OK:=false;
   for SubIndex:=0 to length(CurrentPhysicalDevice.fQueueFamilyProperties)-1 do begin
    if assigned(aSurface) and not CurrentPhysicalDevice.GetSurfaceSupport(SubIndex,aSurface) then begin
     continue;
    end;
    OK:=true;
    Temp:=0;
    if (CurrentPhysicalDevice.fQueueFamilyProperties[SubIndex].queueFlags and TVkInt32(VK_QUEUE_GRAPHICS_BIT))<>0 then begin
     inc(Temp);
    end;
    if (CurrentPhysicalDevice.fQueueFamilyProperties[SubIndex].queueFlags and TVkInt32(VK_QUEUE_COMPUTE_BIT))<>0 then begin
     inc(Temp);
    end;
    if (CurrentPhysicalDevice.fQueueFamilyProperties[SubIndex].queueFlags and TVkInt32(VK_QUEUE_TRANSFER_BIT))<>0 then begin
     inc(Temp);
    end;
    if (CurrentPhysicalDevice.fQueueFamilyProperties[SubIndex].queueFlags and TVkInt32(VK_QUEUE_SPARSE_BINDING_BIT))<>0 then begin
     inc(Temp);
    end;
    CurrentScore:=CurrentScore or (int64(Temp) shl 55);
   end;
   if not OK then begin
    continue;
   end;
   if (BestScore>CurrentScore) or not assigned(BestPhysicalDevice) then begin
    BestPhysicalDevice:=CurrentPhysicalDevice;
    BestScore:=CurrentScore;
   end;
  end;
  if assigned(BestPhysicalDevice) then begin
   fPhysicalDevice:=BestPhysicalDevice;
  end else begin
   raise EVulkanException.Create('No suitable vulkan device found');
  end;
 end;

 fEnabledLayerNames:=TStringList.Create;
 fEnabledExtensionNames:=TStringList.Create;

 fEnabledFeatures:=fPhysicalDevice.fFeatures;

 fPointerToEnabledFeatures:=@fEnabledFeatures;

 fMemoryManager:=TVulkanDeviceMemoryManager.Create(self);

end;

destructor TVulkanDevice.Destroy;
var Index:TVkInt32;
begin
 for Index:=0 to length(fQueues)-1 do begin
  if assigned(fQueues[Index]) then begin
   fQueues[Index].Free;
   fQueues[Index]:=nil;
  end;
 end;
 SetLength(fQueues,0);
 fMemoryManager.Free;
 fDeviceVulkan.Free;
 if fDeviceHandle<>VK_NULL_HANDLE then begin
  fInstance.Commands.DestroyDevice(fDeviceHandle,fAllocationCallbacks);
  fDeviceHandle:=VK_NULL_HANDLE;
 end;
 SetLength(fDeviceQueueCreateInfos,0);
 fDeviceQueueCreateInfoList.Free;
 fEnabledLayerNames.Free;
 fEnabledExtensionNames.Free;
 SetLength(fEnabledLayerNameStrings,0);
 SetLength(fRawEnabledLayerNameStrings,0);
 SetLength(fEnabledExtensionNameStrings,0);
 SetLength(fRawEnabledExtensionNameStrings,0);
 inherited Destroy;
end;

procedure TVulkanDevice.AddQueue(const aQueueFamilyIndex:TVkUInt32;const aQueuePriorities:array of TVkFloat;const aSurface:TVulkanSurface=nil);
var QueueFamilyProperties:PVkQueueFamilyProperties;
begin
 if aQueueFamilyIndex<TVkUInt32(length(fPhysicalDevice.fQueueFamilyProperties)) then begin
  QueueFamilyProperties:=@fPhysicalDevice.fQueueFamilyProperties[aQueueFamilyIndex];
  if (fPresentQueueFamilyIndex<0) and ((assigned(aSurface) and fPhysicalDevice.GetSurfaceSupport(aQueueFamilyIndex,aSurface)) or not assigned(aSurface)) then begin
   fPresentQueueFamilyIndex:=aQueueFamilyIndex;
  end;
  if ((QueueFamilyProperties.queueFlags and TVKUInt32(VK_QUEUE_GRAPHICS_BIT))<>0) and (fGraphicsQueueFamilyIndex<0) then begin
   fGraphicsQueueFamilyIndex:=aQueueFamilyIndex;
  end;
  if ((QueueFamilyProperties.queueFlags and TVKUInt32(VK_QUEUE_COMPUTE_BIT))<>0) and (fComputeQueueFamilyIndex<0) then begin
   fComputeQueueFamilyIndex:=aQueueFamilyIndex;
  end;
  if ((QueueFamilyProperties.queueFlags and TVKUInt32(VK_QUEUE_TRANSFER_BIT))<>0) and (fTransferQueueFamilyIndex<0) then begin
   fTransferQueueFamilyIndex:=aQueueFamilyIndex;
  end;
  fDeviceQueueCreateInfoList.Add(TVulkanDeviceQueueCreateInfo.Create(aQueueFamilyIndex,aQueuePriorities));
 end else begin
  raise EVulkanException.Create('Queue family index out of bounds');
 end;
end;

procedure TVulkanDevice.AddQueues(const aPresent:boolean=true;
                                  const aGraphics:boolean=true;
                                  const aCompute:boolean=true;
                                  const aTransfer:boolean=true;
                                  const aSparseBinding:boolean=false;
                                  const aSurface:TVulkanSurface=nil);
var Index:TVkInt32;
    DoAdd:boolean;
    QueueFamilyProperties:PVkQueueFamilyProperties;
begin
 for Index:=0 to length(fPhysicalDevice.fQueueFamilyProperties)-1 do begin
  DoAdd:=false;
  QueueFamilyProperties:=@fPhysicalDevice.fQueueFamilyProperties[Index];
  if (fPresentQueueFamilyIndex<0) and ((assigned(aSurface) and fPhysicalDevice.GetSurfaceSupport(Index,aSurface)) or not assigned(aSurface)) then begin
   fPresentQueueFamilyIndex:=Index;
   if aPresent then begin
    DoAdd:=true;
   end;
  end;
  if ((QueueFamilyProperties.queueFlags and TVKUInt32(VK_QUEUE_GRAPHICS_BIT))<>0) and (fGraphicsQueueFamilyIndex<0) then begin
   fGraphicsQueueFamilyIndex:=Index;
   if aGraphics then begin
    DoAdd:=true;
   end;
  end;
  if ((QueueFamilyProperties.queueFlags and TVKUInt32(VK_QUEUE_COMPUTE_BIT))<>0) and (fComputeQueueFamilyIndex<0) then begin
   fComputeQueueFamilyIndex:=Index;
   if aCompute then begin
    DoAdd:=true;
   end;
  end;
  if ((QueueFamilyProperties.queueFlags and TVKUInt32(VK_QUEUE_TRANSFER_BIT))<>0) and (fTransferQueueFamilyIndex<0) then begin
   fTransferQueueFamilyIndex:=Index;
   if aTransfer then begin
    DoAdd:=true;
   end;
  end;
  if ((QueueFamilyProperties.queueFlags and TVKUInt32(VK_QUEUE_SPARSE_BINDING_BIT))=0) and aSparseBinding then begin
   raise EVulkanException.Create('Only unsatisfactory device queue families available');
  end;
  if DoAdd then begin
   fDeviceQueueCreateInfoList.Add(TVulkanDeviceQueueCreateInfo.Create(Index,[1.0]));
  end;
 end;
 if ((fTransferQueueFamilyIndex<0) and aTransfer) and
    (((fGraphicsQueueFamilyIndex>=0) and aGraphics) or
     ((fComputeQueueFamilyIndex>=0) and aCompute)) then begin
  // https://www.khronos.org/registry/vulkan/specs/1.0/man/html/VkQueueFamilyProperties.html
  // Quote: "All commands that are allowed on a queue that supports transfer operations are
  //         also allowed on a queue that supports either graphics or compute operations thus
  //         if the capabilities of a queue family include VK_QUEUE_GRAPHICS_BIT or
  //         VK_QUEUE_COMPUTE_BIT then reporting the VK_QUEUE_TRANSFER_BIT capability separately
  //         for that queue family is optional."
  if (fGraphicsQueueFamilyIndex>=0) and aGraphics then begin
   fTransferQueueFamilyIndex:=fGraphicsQueueFamilyIndex;
  end else if (fComputeQueueFamilyIndex>=0) and aCompute then begin
   fTransferQueueFamilyIndex:=fComputeQueueFamilyIndex;
  end;
 end;
 if ((fPresentQueueFamilyIndex<0) and aPresent) or
    ((fGraphicsQueueFamilyIndex<0) and aGraphics) or
    ((fComputeQueueFamilyIndex<0) and aCompute) or
    ((fTransferQueueFamilyIndex<0) and aTransfer) then begin
  raise EVulkanException.Create('Only unsatisfactory device queue families available');
 end;
end;

procedure TVulkanDevice.Initialize;
var Index:TVkInt32;
    DeviceQueueCreateInfo:PVkDeviceQueueCreateInfo;
    SrcDeviceQueueCreateInfo:TVulkanDeviceQueueCreateInfo;
    DeviceCommands:PVulkanCommands;
    Queue:TVkQueue;
    DeviceCreateInfo:TVkDeviceCreateInfo;
begin
 if fDeviceHandle=VK_NULL_HANDLE then begin

  SetLength(fEnabledLayerNameStrings,fEnabledLayerNames.Count);
  SetLength(fRawEnabledLayerNameStrings,fEnabledLayerNames.Count);
  for Index:=0 to fEnabledLayerNames.Count-1 do begin
   fEnabledLayerNameStrings[Index]:=TVulkanCharString(fEnabledLayerNames.Strings[Index]);
   fRawEnabledLayerNameStrings[Index]:=PVkChar(fEnabledLayerNameStrings[Index]);
  end;

  SetLength(fEnabledExtensionNameStrings,fEnabledExtensionNames.Count);
  SetLength(fRawEnabledExtensionNameStrings,fEnabledExtensionNames.Count);
  for Index:=0 to fEnabledExtensionNames.Count-1 do begin
   fEnabledExtensionNameStrings[Index]:=TVulkanCharString(fEnabledExtensionNames.Strings[Index]);
   fRawEnabledExtensionNameStrings[Index]:=PVkChar(fEnabledExtensionNameStrings[Index]);
  end;

  SetLength(fDeviceQueueCreateInfos,fDeviceQueueCreateInfoList.Count);
  for Index:=0 to fDeviceQueueCreateInfoList.Count-1 do begin
   SrcDeviceQueueCreateInfo:=fDeviceQueueCreateInfoList[Index];
   DeviceQueueCreateInfo:=@fDeviceQueueCreateInfos[Index];
   FillChar(DeviceQueueCreateInfo^,SizeOf(TVkDeviceQueueCreateInfo),#0);
   DeviceQueueCreateInfo^.sType:=VK_STRUCTURE_TYPE_DEVICE_QUEUE_CREATE_INFO;
   DeviceQueueCreateInfo^.queueFamilyIndex:=SrcDeviceQueueCreateInfo.fQueueFamilyIndex;
   DeviceQueueCreateInfo^.queueCount:=length(SrcDeviceQueueCreateInfo.fQueuePriorities);
   if DeviceQueueCreateInfo^.queueCount>0 then begin
    DeviceQueueCreateInfo^.pQueuePriorities:=@SrcDeviceQueueCreateInfo.fQueuePriorities[0];
   end;
  end;

  FillChar(DeviceCreateInfo,SizeOf(TVkDeviceCreateInfo),#0);
  DeviceCreateInfo.sType:=VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO;
  if length(fDeviceQueueCreateInfos)>0 then begin
   DeviceCreateInfo.queueCreateInfoCount:=length(fDeviceQueueCreateInfos);
   DeviceCreateInfo.pQueueCreateInfos:=@fDeviceQueueCreateInfos[0];
  end;
  if length(fEnabledLayerNameStrings)>0 then begin
   DeviceCreateInfo.enabledLayerCount:=length(fEnabledLayerNameStrings);
   DeviceCreateInfo.ppEnabledLayerNames:=@fRawEnabledLayerNameStrings[0];
  end;
  if length(fEnabledExtensionNameStrings)>0 then begin
   DeviceCreateInfo.enabledExtensionCount:=length(fEnabledExtensionNameStrings);
   DeviceCreateInfo.ppEnabledExtensionNames:=@fRawEnabledExtensionNameStrings[0];
  end;
  DeviceCreateInfo.pEnabledFeatures:=@fEnabledFeatures;
  HandleResultCode(fInstance.Commands.CreateDevice(fPhysicalDevice.fPhysicalDeviceHandle,@DeviceCreateInfo,fAllocationCallbacks,@fDeviceHandle));

  GetMem(DeviceCommands,SizeOf(TVulkanCommands));
  try
   FillChar(DeviceCommands^,SizeOf(TVulkanCommands),#0);
   if LoadVulkanDeviceCommands(fInstance.Commands.Commands.GetDeviceProcAddr,fDeviceHandle,DeviceCommands^) then begin
    fDeviceVulkan:=TVulkan.Create(DeviceCommands^);
   end else begin
    raise EVulkanException.Create('Couldn''t load vulkan device commands');
   end;
  finally
   FreeMem(DeviceCommands);
  end;

  if (fTransferQueueFamilyIndex<0) and ((fGraphicsQueueFamilyIndex>=0) or (fComputeQueueFamilyIndex>=0)) then begin
   // https://www.khronos.org/registry/vulkan/specs/1.0/man/html/VkQueueFamilyProperties.html
   // Quote: "All commands that are allowed on a queue that supports transfer operations are
   //         also allowed on a queue that supports either graphics or compute operations thus
   //         if the capabilities of a queue family include VK_QUEUE_GRAPHICS_BIT or
   //         VK_QUEUE_COMPUTE_BIT then reporting the VK_QUEUE_TRANSFER_BIT capability separately
   //         for that queue family is optional."
   if fGraphicsQueueFamilyIndex>=0 then begin
    fTransferQueueFamilyIndex:=fGraphicsQueueFamilyIndex;
   end else if fComputeQueueFamilyIndex>=0 then begin
    fTransferQueueFamilyIndex:=fComputeQueueFamilyIndex;
   end;
  end;

  SetLength(fQueues,length(fPhysicalDevice.fQueueFamilyProperties));
  for Index:=0 to length(fPhysicalDevice.fQueueFamilyProperties)-1 do begin
   if (Index=fPresentQueueFamilyIndex) or
      (Index=fGraphicsQueueFamilyIndex) or
      (Index=fComputeQueueFamilyIndex) or
      (Index=fTransferQueueFamilyIndex) then begin
    fDeviceVulkan.GetDeviceQueue(fDeviceHandle,Index,0,@Queue);
    fQueues[Index]:=TVulkanQueue.Create(self,Queue,Index);
   end else begin
    fQueues[Index]:=nil;
   end;
  end;

  if fPresentQueueFamilyIndex>=0 then begin
   fPresentQueue:=fQueues[fPresentQueueFamilyIndex];
  end else begin
   fPresentQueue:=nil;
  end;
  if fGraphicsQueueFamilyIndex>=0 then begin
   fGraphicsQueue:=fQueues[fGraphicsQueueFamilyIndex];
  end else begin
   fGraphicsQueue:=nil;
  end;
  if fComputeQueueFamilyIndex>=0 then begin
   fComputeQueue:=fQueues[fComputeQueueFamilyIndex];
  end else begin
   fComputeQueue:=nil;
  end;
  if fTransferQueueFamilyIndex>=0 then begin
   fTransferQueue:=fQueues[fTransferQueueFamilyIndex];
  end else begin
   fTransferQueue:=nil;
  end;

 end;
end;

procedure TVulkanDevice.WaitIdle;
begin
 fDeviceVulkan.DeviceWaitIdle(fDeviceHandle);
end;

constructor TVulkanDeviceQueueCreateInfo.Create(const aQueueFamilyIndex:TVkUInt32;const aQueuePriorities:array of TVkFloat);
begin
 inherited Create;
 fQueueFamilyIndex:=aQueueFamilyIndex;
 SetLength(fQueuePriorities,length(aQueuePriorities));
 if length(aQueuePriorities)>0 then begin
  Move(aQueuePriorities[0],fQueuePriorities[0],length(aQueuePriorities)*SizeOf(TVkFloat));
 end;
end;

destructor TVulkanDeviceQueueCreateInfo.Destroy;
begin
 SetLength(fQueuePriorities,0);
 inherited Destroy;
end;

function TVulkanDeviceQueueCreateInfoList.GetItem(const Index:TVkSizeInt):TVulkanDeviceQueueCreateInfo;
begin
 result:=TVulkanDeviceQueueCreateInfo(inherited Items[Index]);
end;

procedure TVulkanDeviceQueueCreateInfoList.SetItem(const Index:TVkSizeInt;const Item:TVulkanDeviceQueueCreateInfo);
begin
 inherited Items[Index]:=Item;
end;

constructor TVulkanResource.Create;
begin
 inherited Create;
 fDevice:=nil;
 fOwnsResource:=false;
end;

destructor TVulkanResource.Destroy;
begin
 inherited Destroy;
end;

procedure TVulkanResource.Clear;
begin
 fDevice:=nil;
 fOwnsResource:=false;
end;

constructor TVulkanDeviceMemoryChunkBlockRedBlackTreeNode.Create(const aKey:TVkUInt64=0;
                                                                 const aValue:TVulkanDeviceMemoryChunkBlockRedBlackTreeValue=nil;
                                                                 const aLeft:TVulkanDeviceMemoryChunkBlockRedBlackTreeNode=nil;
                                                                 const aRight:TVulkanDeviceMemoryChunkBlockRedBlackTreeNode=nil;
                                                                 const aParent:TVulkanDeviceMemoryChunkBlockRedBlackTreeNode=nil;
                                                                 const aColor:boolean=false);
begin
 inherited Create;
 fKey:=aKey;
 fValue:=aValue;
 fLeft:=aLeft;
 fRight:=aRight;
 fParent:=aParent;
 fColor:=aColor;
end;

destructor TVulkanDeviceMemoryChunkBlockRedBlackTreeNode.Destroy;
begin
 FreeAndNil(fLeft);
 FreeAndNil(fRight);
 inherited Destroy;
end;

procedure TVulkanDeviceMemoryChunkBlockRedBlackTreeNode.Clear;
begin
 fKey:=0;
 fLeft:=nil;
 fRight:=nil;
 fParent:=nil;
 fColor:=false;
end;

function TVulkanDeviceMemoryChunkBlockRedBlackTreeNode.Minimum:TVulkanDeviceMemoryChunkBlockRedBlackTreeNode;
begin
 result:=self;
 while assigned(result.fLeft) do begin
  result:=result.fLeft;
 end;
end;

function TVulkanDeviceMemoryChunkBlockRedBlackTreeNode.Maximum:TVulkanDeviceMemoryChunkBlockRedBlackTreeNode;
begin
 result:=self;
 while assigned(result.fRight) do begin
  result:=result.fRight;
 end;
end;

function TVulkanDeviceMemoryChunkBlockRedBlackTreeNode.Predecessor:TVulkanDeviceMemoryChunkBlockRedBlackTreeNode;
var Last:TVulkanDeviceMemoryChunkBlockRedBlackTreeNode;
begin
 if assigned(fLeft) then begin
  result:=fLeft;
  while assigned(result) and assigned(result.fRight) do begin
   result:=result.fRight;
  end;
 end else begin
  Last:=self;
  result:=Parent;
  while assigned(result) and (result.fLeft=Last) do begin
   Last:=result;
   result:=result.Parent;
  end;
 end;
end;

function TVulkanDeviceMemoryChunkBlockRedBlackTreeNode.Successor:TVulkanDeviceMemoryChunkBlockRedBlackTreeNode;
var Last:TVulkanDeviceMemoryChunkBlockRedBlackTreeNode;
begin
 if assigned(fRight) then begin
  result:=fRight;
  while assigned(result) and assigned(result.fLeft) do begin
   result:=result.fLeft;
  end;
 end else begin
  Last:=self;
  result:=Parent;
  while assigned(result) and (result.fRight=Last) do begin
   Last:=result;
   result:=result.Parent;
  end;
 end;
end;

constructor TVulkanDeviceMemoryChunkBlockRedBlackTree.Create;
begin
 inherited Create;
 fRoot:=nil;
end;

destructor TVulkanDeviceMemoryChunkBlockRedBlackTree.Destroy;
begin
 Clear;
 inherited Destroy;
end;

procedure TVulkanDeviceMemoryChunkBlockRedBlackTree.Clear;
begin
 FreeAndNil(fRoot);
end;

procedure TVulkanDeviceMemoryChunkBlockRedBlackTree.RotateLeft(x:TVulkanDeviceMemoryChunkBlockRedBlackTreeNode);
var y:TVulkanDeviceMemoryChunkBlockRedBlackTreeNode;
begin
 y:=x.fRight;
 x.fRight:=y.fLeft;
 if assigned(y.fLeft) then begin
  y.fLeft.fParent:=x;
 end;
 y.fParent:=x.fParent;
 if x=fRoot then begin
  fRoot:=y;
 end else if x=x.fParent.fLeft then begin
  x.fparent.fLeft:=y;
 end else begin
  x.fParent.fRight:=y;
 end;
 y.fLeft:=x;
 x.fParent:=y;
end;

procedure TVulkanDeviceMemoryChunkBlockRedBlackTree.RotateRight(x:TVulkanDeviceMemoryChunkBlockRedBlackTreeNode);
var y:TVulkanDeviceMemoryChunkBlockRedBlackTreeNode;
begin
 y:=x.fLeft;
 x.fLeft:=y.fRight;
 if assigned(y.fRight) then begin
  y.fRight.fParent:=x;
 end;
 y.fParent:=x.fParent;
 if x=fRoot then begin
  fRoot:=y;
 end else if x=x.fParent.fRight then begin
  x.fParent.fRight:=y;
 end else begin
  x.fParent.fLeft:=y;
 end;
 y.fRight:=x;
 x.fParent:=y;
end;

function TVulkanDeviceMemoryChunkBlockRedBlackTree.Find(const aKey:TVulkanDeviceMemoryChunkBlockRedBlackTreeKey):TVulkanDeviceMemoryChunkBlockRedBlackTreeNode;
begin
 result:=fRoot;
 while assigned(result) do begin
  if aKey<result.fKey then begin
   result:=result.fLeft;
  end else if aKey>result.fKey then begin
   result:=result.fRight;
  end else begin
   exit;
  end;
 end;
 result:=nil;
end;

function TVulkanDeviceMemoryChunkBlockRedBlackTree.Insert(const aKey:TVulkanDeviceMemoryChunkBlockRedBlackTreeKey;
                                                          const aValue:TVulkanDeviceMemoryChunkBlockRedBlackTreeValue):TVulkanDeviceMemoryChunkBlockRedBlackTreeNode;
var x,y,xParentParent:TVulkanDeviceMemoryChunkBlockRedBlackTreeNode;
begin
 x:=fRoot;
 y:=nil;
 while assigned(x) do begin
  y:=x;
  if aKey<x.fKey then begin
   x:=x.fLeft;
  end else begin
   x:=x.fRight;
  end;
 end;
 result:=TVulkanDeviceMemoryChunkBlockRedBlackTreeNode.Create(aKey,aValue,nil,nil,y,true);
 if assigned(y) then begin
  if aKey<y.fKey then begin
   y.Left:=result;
  end else begin
   y.Right:=result;
  end;
 end else begin
  fRoot:=result;
 end;
 x:=result;
 while (x<>fRoot) and assigned(x.fParent) and assigned(x.fParent.fParent) and x.fParent.fColor do begin
  xParentParent:=x.fParent.fParent;
  if x.fParent=xParentParent.fLeft then begin
   y:=xParentParent.fRight;
   if assigned(y) and y.fColor then begin
    x.fParent.fColor:=false;
    y.fColor:=false;
    xParentParent.fColor:=true;
    x:=xParentParent;
   end else begin
    if x=x.fParent.fRight then begin
     x:=x.fParent;
     RotateLeft(x);
    end;
    x.fParent.fColor:=false;
    xParentParent.fColor:=true;
    RotateRight(xParentParent);
   end;
  end else begin
   y:=xParentParent.fLeft;
   if assigned(y) and y.fColor then begin
    x.fParent.fColor:=false;
    y.fColor:=false;
    x.fParent.fParent.fColor:=true;
    x:=x.fParent.fParent;
   end else begin
    if x=x.fParent.fLeft then begin
     x:=x.fParent;
     RotateRight(x);
    end;
    x.fParent.fColor:=false;
    xParentParent.fColor:=true;
    RotateLeft(xParentParent);
   end;
  end;
 end;
 fRoot.fColor:=false;
end;

procedure TVulkanDeviceMemoryChunkBlockRedBlackTree.Remove(const aNode:TVulkanDeviceMemoryChunkBlockRedBlackTreeNode);
var w,x,y,z,xParent:TVulkanDeviceMemoryChunkBlockRedBlackTreeNode;
    TemporaryColor:boolean;
begin
 z:=aNode;
 y:=z;
 x:=nil;
 xParent:=nil;
 if assigned(x) and assigned(xParent) then begin
  // For to suppress "Value assigned to '*' never used" hints
 end;
 if assigned(y.fLeft) then begin
  if assigned(y.fRight) then begin
   y:=y.fRight;
   while assigned(y.fLeft) do begin
    y:=y.fLeft;
   end;
   x:=y.fRight;
  end else begin
   x:=y.fLeft;
  end;
 end else begin
  x:=y.fRight;
 end;
 if y<>z then begin
  z.fLeft.fParent:=y;
  y.fLeft:=z.fLeft;
  if y<>z.fRight then begin
   xParent:=y.fParent;
   if assigned(x) then begin
    x.fParent:=y.fParent;
   end;
   y.fParent.fLeft:=x;
   y.fRight:=z.fRight;
   z.fRight.fParent:=y;
  end else begin
   xParent:=y;
  end;
  if fRoot=z then begin
   fRoot:=y;
  end else if z.fParent.fLeft=z then begin
   z.fParent.fLeft:=y;
  end else begin
   z.fParent.fRight:=y;
  end;
  y.fParent:=z.fParent;
  TemporaryColor:=y.fColor;
  y.fColor:=z.fColor;
  z.fColor:=TemporaryColor;
  y:=z;
 end else begin
  xParent:=y.fParent;
  if assigned(x) then begin
   x.fParent:=y.fParent;
  end;
  if fRoot=z then begin
   fRoot:=x;
  end else if z.fParent.fLeft=z then begin
   z.fParent.fLeft:=x;
  end else begin
   z.fParent.fRight:=x;
  end;
 end;
 if assigned(y) then begin
  if not y.fColor then begin
   while (x<>fRoot) and not (assigned(x) and x.fColor) do begin
    if x=xParent.fLeft then begin
     w:=xParent.fRight;
     if w.fColor then begin
      w.fColor:=false;
      xParent.fColor:=true;
      RotateLeft(xParent);
      w:=xParent.fRight;
     end;
     if not ((assigned(w.fLeft) and w.fLeft.fColor) or (assigned(w.fRight) and w.fRight.fColor)) then begin
      w.fColor:=true;
      x:=xParent;
      xParent:=xParent.fParent;
     end else begin
      if not (assigned(w.fRight) and w.fRight.fColor) then begin
       w.fLeft.fColor:=false;
       w.fColor:=true;
       RotateRight(w);
       w:=xParent.fRight;
      end;
      w.fColor:=xParent.fColor;
      xParent.fColor:=false;
      if assigned(w.fRight) then begin
       w.fRight.fColor:=false;
      end;
      RotateLeft(xParent);
      x:=fRoot;
     end;
    end else begin
     w:=xParent.fLeft;
     if w.fColor then begin
      w.fColor:=false;
      xParent.fColor:=true;
      RotateRight(xParent);
      w:=xParent.fLeft;
     end;
     if not ((assigned(w.fLeft) and w.fLeft.fColor) or (assigned(w.fRight) and w.fRight.fColor)) then begin
      w.fColor:=true;
      x:=xParent;
      xParent:=xParent.fParent;
     end else begin
      if not (assigned(w.fLeft) and w.fLeft.fColor) then begin
       w.fRight.fColor:=false;
       w.fColor:=true;
       RotateLeft(w);
       w:=xParent.fLeft;
      end;
      w.fColor:=xParent.fColor;
      xParent.fColor:=false;
      if assigned(w.fLeft) then begin
       w.fLeft.fColor:=false;
      end;
      RotateRight(xParent);
      x:=fRoot;
     end;
    end;
   end;
   if assigned(x) then begin
    x.fColor:=false;
   end;
  end;
  y.Clear;
  y.Free;
 end;
end;

procedure TVulkanDeviceMemoryChunkBlockRedBlackTree.Delete(const aKey:TVulkanDeviceMemoryChunkBlockRedBlackTreeKey);
var Node:TVulkanDeviceMemoryChunkBlockRedBlackTreeNode;
begin
 Node:=Find(aKey);
 if assigned(Node) then begin
  Remove(Node);
 end;
end;

function TVulkanDeviceMemoryChunkBlockRedBlackTree.LeftMost:TVulkanDeviceMemoryChunkBlockRedBlackTreeNode;
begin
 result:=fRoot;
 while assigned(result) and assigned(result.fLeft) do begin
  result:=result.fLeft;
 end;
end;

function TVulkanDeviceMemoryChunkBlockRedBlackTree.RightMost:TVulkanDeviceMemoryChunkBlockRedBlackTreeNode;
begin
 result:=fRoot;
 while assigned(result) and assigned(result.fRight) do begin
  result:=result.fRight;
 end;
end;

constructor TVulkanDeviceMemoryChunkBlock.Create(const aMemoryChunk:TVulkanDeviceMemoryChunk;
                                                 const aOffset:TVkDeviceSize;
                                                 const aSize:TVkDeviceSize;
                                                 const aAllocationType:TVulkanDeviceMemoryAllocationType);
begin
 inherited Create;
 fMemoryChunk:=aMemoryChunk;
 fOffset:=aOffset;
 fSize:=aSize;
 fAllocationType:=aAllocationType;
 fOffsetRedBlackTreeNode:=fMemoryChunk.fOffsetRedBlackTree.Insert(aOffset,self);
 if fAllocationType=vdmatFree then begin
  fSizeRedBlackTreeNode:=fMemoryChunk.fSizeRedBlackTree.Insert(aSize,self);
 end;
end;

destructor TVulkanDeviceMemoryChunkBlock.Destroy;
begin
 fMemoryChunk.fOffsetRedBlackTree.Remove(fOffsetRedBlackTreeNode);
 if fAllocationType=vdmatFree then begin
  fMemoryChunk.fSizeRedBlackTree.Remove(fSizeRedBlackTreeNode);
 end;
 inherited Destroy;
end;

procedure TVulkanDeviceMemoryChunkBlock.Update(const aOffset:TVkDeviceSize;
                                               const aSize:TVkDeviceSize;
                                               const aAllocationType:TVulkanDeviceMemoryAllocationType);
begin
 if fOffset<>aOffset then begin
  fMemoryChunk.fOffsetRedBlackTree.Remove(fOffsetRedBlackTreeNode);
  fOffsetRedBlackTreeNode:=fMemoryChunk.fOffsetRedBlackTree.Insert(aOffset,self);
 end;
 if ((fAllocationType=vdmatFree)<>(aAllocationType=vdmatFree)) or (fSize<>aSize) then begin
  if fAllocationType=vdmatFree then begin
   fMemoryChunk.fSizeRedBlackTree.Remove(fSizeRedBlackTreeNode);
  end;
  if aAllocationType=vdmatFree then begin
   fSizeRedBlackTreeNode:=fMemoryChunk.fSizeRedBlackTree.Insert(aSize,self);
  end;
 end;
 fOffset:=aOffset;
 fSize:=aSize;
 fAllocationType:=aAllocationType;
 inherited Destroy;
end;

constructor TVulkanDeviceMemoryChunk.Create(const aMemoryManager:TVulkanDeviceMemoryManager;
                                            const aMemoryChunkFlags:TVulkanDeviceMemoryChunkFlags;
                                            const aSize:TVkDeviceSize;
                                            const aMemoryTypeBits:TVkUInt32;
                                            const aMemoryRequiredPropertyFlags:TVkMemoryPropertyFlags;
                                            const aMemoryPreferredPropertyFlags:TVkMemoryPropertyFlags;
                                            const aMemoryAvoidPropertyFlags:TVkMemoryPropertyFlags;
                                            const aMemoryRequiredHeapFlags:TVkMemoryHeapFlags;
                                            const aMemoryPreferredHeapFlags:TVkMemoryHeapFlags;
                                            const aMemoryAvoidHeapFlags:TVkMemoryHeapFlags;
                                            const aMemoryChunkList:PVulkanDeviceMemoryManagerChunkList);
var Index,HeapIndex,CurrentScore,BestScore:TVkInt32;
    MemoryAllocateInfo:TVkMemoryAllocateInfo;
    PhysicalDevice:TVulkanPhysicalDevice;
    CurrentSize,BestSize:TVkDeviceSize;
    Found:boolean;
begin
 inherited Create;

 fMemoryManager:=aMemoryManager;
                    
 fMemoryChunkFlags:=aMemoryChunkFlags;

 fSize:=aSize;

 fMemoryChunkList:=aMemoryChunkList;

 fUsed:=0;

 fMappedOffset:=0;

 fMappedSize:=fSize;
                                        
 fMemoryHandle:=VK_NULL_HANDLE;

 fMemory:=nil;

 fMemoryTypeIndex:=0;
 fMemoryTypeBits:=0;
 fMemoryHeapIndex:=0;
 PhysicalDevice:=fMemoryManager.fDevice.fPhysicalDevice;
 BestSize:=0;
 BestScore:=-1;
 Found:=false;
 for Index:=0 to length(PhysicalDevice.fMemoryProperties.memoryTypes)-1 do begin
  if ((aMemoryTypeBits and (TVkUInt32(1) shl Index))<>0) and
     ((PhysicalDevice.fMemoryProperties.memoryTypes[Index].propertyFlags and aMemoryRequiredPropertyFlags)=aMemoryRequiredPropertyFlags) and
     ((aMemoryAvoidPropertyFlags=0) or ((PhysicalDevice.fMemoryProperties.memoryTypes[Index].propertyFlags and aMemoryAvoidPropertyFlags)=0)) then begin
   HeapIndex:=PhysicalDevice.fMemoryProperties.memoryTypes[Index].heapIndex;
   CurrentSize:=PhysicalDevice.fMemoryProperties.memoryHeaps[HeapIndex].size;
   if ((PhysicalDevice.fMemoryProperties.memoryHeaps[HeapIndex].flags and aMemoryRequiredHeapFlags)=aMemoryRequiredHeapFlags) and
      ((aMemoryAvoidHeapFlags=0) or ((PhysicalDevice.fMemoryProperties.memoryHeaps[HeapIndex].flags and aMemoryAvoidHeapFlags)=0)) and
      (aSize<=CurrentSize) and (BestSize<CurrentSize) then begin
    CurrentScore:=0;
    if (PhysicalDevice.fMemoryProperties.memoryTypes[Index].propertyFlags and aMemoryPreferredPropertyFlags)=aMemoryPreferredPropertyFlags then begin
     CurrentScore:=CurrentScore or 2;
    end;
    if (PhysicalDevice.fMemoryProperties.memoryHeaps[HeapIndex].flags and aMemoryPreferredHeapFlags)=aMemoryPreferredHeapFlags then begin
     CurrentScore:=CurrentScore or 1;
    end;
    if BestScore<CurrentScore then begin
     BestScore:=CurrentScore;
     BestSize:=CurrentSize;
     fMemoryTypeIndex:=Index;
     fMemoryTypeBits:=TVkUInt32(1) shl Index;
     fMemoryHeapIndex:=PhysicalDevice.fMemoryProperties.memoryTypes[Index].heapIndex;
     Found:=true;
    end;
   end;
  end;
 end;
 if not Found then begin
  raise EVulkanException.Create('No suitable device memory heap available');
 end;

 fMemoryPropertyFlags:=PhysicalDevice.fMemoryProperties.memoryTypes[fMemoryTypeIndex].propertyFlags;

 fMemoryHeapFlags:=PhysicalDevice.fMemoryProperties.memoryHeaps[fMemoryHeapIndex].flags;

 FillChar(MemoryAllocateInfo,SizeOf(TVkMemoryAllocateInfo),#0);
 MemoryAllocateInfo.sType:=VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO;
 MemoryAllocateInfo.pNext:=nil;
 MemoryAllocateInfo.allocationSize:=fSize;
 MemoryAllocateInfo.memoryTypeIndex:=fMemoryTypeIndex;

 HandleResultCode(fMemoryManager.fDevice.Commands.AllocateMemory(fMemoryManager.fDevice.fDeviceHandle,@MemoryAllocateInfo,fMemoryManager.fDevice.fAllocationCallbacks,@fMemoryHandle));

 fOffsetRedBlackTree:=TVulkanDeviceMemoryChunkBlockRedBlackTree.Create;
 fSizeRedBlackTree:=TVulkanDeviceMemoryChunkBlockRedBlackTree.Create;

 TVulkanDeviceMemoryChunkBlock.Create(self,0,aSize,vdmatFree);

 fLock:=TCriticalSection.Create;

 if assigned(fMemoryChunkList^.First) then begin
  fMemoryChunkList^.First.fPreviousMemoryChunk:=self;
  fNextMemoryChunk:=fMemoryChunkList^.First;
 end else begin
  fMemoryChunkList^.Last:=self;
  fNextMemoryChunk:=nil;
 end;
 fMemoryChunkList^.First:=self;
 fPreviousMemoryChunk:=nil;

 if vdmcfPersistentMapped in fMemoryChunkFlags then begin
  fLock.Acquire;
  try
   if (fMemoryPropertyFlags and TVkMemoryPropertyFlags(VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT))<>0 then begin
    if assigned(fMemory) then begin
     raise EVulkanException.Create('Memory is already mapped');
    end else begin
     fMappedOffset:=0;
     fMappedSize:=aSize;
     HandleResultCode(fMemoryManager.fDevice.Commands.MapMemory(fMemoryManager.fDevice.fDeviceHandle,fMemoryHandle,0,aSize,0,@fMemory));
    end;
   end else begin
    raise EVulkanException.Create('Memory can''t mapped');
   end;
  finally
   fLock.Release;
  end;
 end;

end;

destructor TVulkanDeviceMemoryChunk.Destroy;
begin

 if (vdmcfPersistentMapped in fMemoryChunkFlags) and
    assigned(fMemory) and
    ((fMemoryPropertyFlags and TVkMemoryPropertyFlags(VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT))<>0) then begin
  fLock.Acquire;
  try
   fMemoryManager.fDevice.Commands.UnmapMemory(fMemoryManager.fDevice.fDeviceHandle,fMemoryHandle);
   fMemory:=nil;
  finally
   fLock.Release;
  end;
 end;

 if assigned(fOffsetRedBlackTree) then begin
  while assigned(fOffsetRedBlackTree.fRoot) do begin
   fOffsetRedBlackTree.fRoot.fValue.Free;
  end;
 end;

 if assigned(fPreviousMemoryChunk) then begin
  fPreviousMemoryChunk.fNextMemoryChunk:=fNextMemoryChunk;
 end else if fMemoryChunkList^.First=self then begin
  fMemoryChunkList^.First:=fNextMemoryChunk;
 end;
 if assigned(fNextMemoryChunk) then begin
  fNextMemoryChunk.fPreviousMemoryChunk:=fPreviousMemoryChunk;
 end else if fMemoryChunkList^.Last=self then begin
  fMemoryChunkList^.Last:=fPreviousMemoryChunk;
 end;

 if fMemoryHandle<>VK_NULL_HANDLE then begin
  if ((fMemoryPropertyFlags and TVkMemoryPropertyFlags(VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT))<>0) and assigned(fMemory) then begin
   fMemoryManager.fDevice.Commands.UnmapMemory(fMemoryManager.fDevice.fDeviceHandle,fMemoryHandle);
   fMemory:=nil;
  end;
  fMemoryManager.fDevice.Commands.FreeMemory(fMemoryManager.fDevice.fDeviceHandle,fMemoryHandle,fMemoryManager.fDevice.fAllocationCallbacks);
 end;

 fOffsetRedBlackTree.Free;
 fSizeRedBlackTree.Free;

 FreeAndNil(fLock);

 fMemoryHandle:=VK_NULL_HANDLE;

 inherited Destroy;
end;

function TVulkanDeviceMemoryChunk.AllocateMemory(out aOffset:TVkDeviceSize;const aSize,aAlignment:TVkDeviceSize;const aAllocationType:TVulkanDeviceMemoryAllocationType):boolean;
var Node,OtherNode,LastNode:TVulkanDeviceMemoryChunkBlockRedBlackTreeNode;
    MemoryChunkBlock:TVulkanDeviceMemoryChunkBlock;
    Alignment,Offset,MemoryChunkBlockBeginOffset,MemoryChunkBlockEndOffset,PayloadBeginOffset,PayloadEndOffset,
    BufferImageGranularity,BufferImageGranularityInvertedMask:TVkDeviceSize;
    Direction:TVkInt32;
    TryAgain:boolean;
begin
 result:=false;

 if aSize>0 then begin

  Alignment:=Max(1,VulkanDeviceSizeRoundUpToPowerOfTwo(aAlignment));

  BufferImageGranularity:=Max(1,VulkanDeviceSizeRoundUpToPowerOfTwo(MemoryManager.fDevice.fPhysicalDevice.fProperties.limits.bufferImageGranularity));

  BufferImageGranularityInvertedMask:=not (BufferImageGranularity-1);

  fLock.Acquire;
  try

   // Best-fit search
   Node:=fSizeRedBlackTree.fRoot;
   while assigned(Node) do begin
    if aSize<Node.fKey then begin
     if assigned(Node.fLeft) then begin
      // If free block is too big, then go to left
      Node:=Node.fLeft;
      continue;
     end else begin
      // If free block is too big and there is no left children node, then try to find suitable smaller but not too small free blocks
      while assigned(Node) and (Node.fKey>aSize) do begin
       OtherNode:=Node.Predecessor;
       if assigned(OtherNode) and (OtherNode.fKey>=aSize) then begin
        Node:=OtherNode;
       end else begin
        break;
       end;
      end;
      break;
     end;
    end else if aSize>Node.fKey then begin
     if assigned(Node.fRight) then begin
      // If free block is too small, go to right
      Node:=Node.fRight;
      continue;
     end else begin
      // If free block is too small and there is no right children node, then try to find suitable bigger but not too small free blocks
      while assigned(Node) and (Node.fKey<aSize) do begin
       OtherNode:=Node.Successor;
       if assigned(OtherNode) then begin
        Node:=OtherNode;
       end else begin
        break;
       end;
      end;
      break;
     end;
    end else begin
     // Perfect match
     break;
    end;
   end;

   LastNode:=nil;

   repeat

    TryAgain:=false;

    // Check block for if it fits to the desired alignment, otherwise search for a better suitable block
    if Alignment>1 then begin
     while assigned(Node) and (Node.fKey>=aSize) do begin
      MemoryChunkBlock:=Node.fValue;
      if ((MemoryChunkBlock.Offset and (Alignment-1))<>0) and
         ((MemoryChunkBlock.Offset+(Alignment-(MemoryChunkBlock.Offset and (Alignment-1)))+aSize)>=(MemoryChunkBlock.Offset+MemoryChunkBlock.Size)) then begin
       // If free block is alignment-technical too small, then try to find with-alignment-technical suitable bigger blocks
       LastNode:=nil;
       Node:=Node.Successor;
      end else begin
       break;
      end;
     end;
    end;

    // Check block for BufferImageGranularity satisfaction
    if (BufferImageGranularity>1) and
      assigned(Node) and
      assigned(Node.fValue) then begin

     MemoryChunkBlock:=Node.fValue;

     MemoryChunkBlockBeginOffset:=MemoryChunkBlock.Offset;

     PayloadBeginOffset:=MemoryChunkBlockBeginOffset;
     if (Alignment>1) and ((PayloadBeginOffset and (Alignment-1))<>0) then begin
      inc(PayloadBeginOffset,Alignment-(PayloadBeginOffset and (Alignment-1)));
     end;

     PayloadEndOffset:=PayloadBeginOffset+aSize;

     OtherNode:=Node.fValue.fOffsetRedBlackTreeNode.Predecessor;
     if assigned(OtherNode) and
        assigned(OtherNode.fValue) and
        ((OtherNode.fValue.fAllocationType<>vdmatFree) and
         (((OtherNode.fValue.fAllocationType in [vdmatUnknown,vdmatBuffer])<>(aAllocationType in [vdmatUnknown,vdmatBuffer])) or
          ((OtherNode.fValue.fAllocationType in [vdmatImageLinear,vdmatImageOptimal])<>(aAllocationType in [vdmatImageLinear,vdmatImageOptimal])))) then begin
      if (PayloadBeginOffset and BufferImageGranularityInvertedMask)=((OtherNode.fValue.fOffset+(OtherNode.fValue.fSize-1)) and BufferImageGranularityInvertedMask) then begin
       if LastNode=Node then begin
        LastNode:=nil;
        Node:=Node.Successor;
       end else begin
        LastNode:=Node;
        if Alignment<BufferImageGranularity then begin
         Alignment:=BufferImageGranularity;
        end;
       end;
       TryAgain:=true;
      end;
     end;

     if not TryAgain then begin
      OtherNode:=Node.fValue.fOffsetRedBlackTreeNode.Successor;
      if assigned(OtherNode) and
         assigned(OtherNode.fValue) and
         ((OtherNode.fValue.fAllocationType<>vdmatFree) and
          (((OtherNode.fValue.fAllocationType in [vdmatUnknown,vdmatBuffer])<>(aAllocationType in [vdmatUnknown,vdmatBuffer])) or
           ((OtherNode.fValue.fAllocationType in [vdmatImageLinear,vdmatImageOptimal])<>(aAllocationType in [vdmatImageLinear,vdmatImageOptimal])))) then begin
       if ((PayloadEndOffset-1) and BufferImageGranularityInvertedMask)=(OtherNode.fValue.fOffset and BufferImageGranularityInvertedMask) then begin
        LastNode:=nil;
        Node:=Node.Successor;
        TryAgain:=true;
       end;
      end;
     end;

    end;

   until not TryAgain;

   if assigned(Node) and (Node.fKey>=aSize) then begin

    MemoryChunkBlock:=Node.fValue;

    MemoryChunkBlockBeginOffset:=MemoryChunkBlock.Offset;

    MemoryChunkBlockEndOffset:=MemoryChunkBlockBeginOffset+MemoryChunkBlock.Size;

    PayloadBeginOffset:=MemoryChunkBlockBeginOffset;
    if (Alignment>1) and ((PayloadBeginOffset and (Alignment-1))<>0) then begin
     inc(PayloadBeginOffset,Alignment-(PayloadBeginOffset and (Alignment-1)));
    end;

    PayloadEndOffset:=PayloadBeginOffset+aSize;

    if (PayloadBeginOffset<PayloadEndOffset) and
       (PayloadEndOffset<=MemoryChunkBlockEndOffset) then begin

     MemoryChunkBlock.Update(PayloadBeginOffset,PayloadEndOffset-PayloadBeginOffset,aAllocationType);

     if MemoryChunkBlockBeginOffset<PayloadBeginOffset then begin
      TVulkanDeviceMemoryChunkBlock.Create(self,MemoryChunkBlockBeginOffset,PayloadBeginOffset-MemoryChunkBlockBeginOffset,vdmatFree);
     end;

     if PayloadEndOffset<MemoryChunkBlockEndOffset then begin
      TVulkanDeviceMemoryChunkBlock.Create(self,PayloadEndOffset,MemoryChunkBlockEndOffset-PayloadEndOffset,vdmatFree);
     end;

     aOffset:=PayloadBeginOffset;

     inc(fUsed,PayloadEndOffset-PayloadBeginOffset);

     result:=true;

    end;

   end;

  finally
   fLock.Release;
  end;

 end;

end;

function TVulkanDeviceMemoryChunk.ReallocateMemory(var aOffset:TVkDeviceSize;const aSize,aAlignment:TVkDeviceSize):boolean;
var Node,OtherNode:TVulkanDeviceMemoryChunkBlockRedBlackTreeNode;
    MemoryChunkBlock,OtherMemoryChunkBlock:TVulkanDeviceMemoryChunkBlock;
    TempOffset,TempSize:TVkDeviceSize;
begin
 result:=false;

 fLock.Acquire;
 try

  Node:=fOffsetRedBlackTree.Find(aOffset);
  if assigned(Node) then begin
   MemoryChunkBlock:=Node.fValue;
   if MemoryChunkBlock.fAllocationType<>vdmatFree then begin
    dec(fUsed,MemoryChunkBlock.Size);
    if aSize=0 then begin
     result:=FreeMemory(aOffset);
    end else if MemoryChunkBlock.fSize=aSize then begin
     result:=true;
    end else begin
     if MemoryChunkBlock.fSize<aSize then begin
      OtherNode:=MemoryChunkBlock.fOffsetRedBlackTreeNode.Successor;
      if assigned(OtherNode) and
         (MemoryChunkBlock.fOffsetRedBlackTreeNode<>OtherNode) then begin
       OtherMemoryChunkBlock:=OtherNode.fValue;
       if OtherMemoryChunkBlock.fAllocationType=vdmatFree then begin
        if (MemoryChunkBlock.fOffset+aSize)<(OtherMemoryChunkBlock.fOffset+OtherMemoryChunkBlock.fSize) then begin
         MemoryChunkBlock.Update(MemoryChunkBlock.fOffset,aSize,MemoryChunkBlock.fAllocationType);
         OtherMemoryChunkBlock.Update(MemoryChunkBlock.fOffset+aSize,(OtherMemoryChunkBlock.fOffset+OtherMemoryChunkBlock.fSize)-(MemoryChunkBlock.fOffset+aSize),vdmatFree);
         result:=true;
        end else if (MemoryChunkBlock.fOffset+aSize)=(OtherMemoryChunkBlock.fOffset+OtherMemoryChunkBlock.fSize) then begin
         MemoryChunkBlock.Update(MemoryChunkBlock.fOffset,aSize,MemoryChunkBlock.fAllocationType);
         OtherMemoryChunkBlock.Free;
         result:=true;
        end;
       end;
      end;
     end else if MemoryChunkBlock.fSize>aSize then begin
      OtherNode:=MemoryChunkBlock.fOffsetRedBlackTreeNode.Successor;
      if assigned(OtherNode) and
         (MemoryChunkBlock.fOffsetRedBlackTreeNode<>OtherNode) and
         (OtherNode.fValue.fAllocationType=vdmatFree) then begin
       OtherMemoryChunkBlock:=OtherNode.fValue;
       TempOffset:=MemoryChunkBlock.fOffset+aSize;
       TempSize:=(OtherMemoryChunkBlock.fOffset+OtherMemoryChunkBlock.fSize)-TempOffset;
       MemoryChunkBlock.Update(MemoryChunkBlock.fOffset,aSize,MemoryChunkBlock.fAllocationType);
       OtherMemoryChunkBlock.Update(TempOffset,TempSize,vdmatFree);
       result:=true;
      end else begin
       TempOffset:=MemoryChunkBlock.fOffset+aSize;
       TempSize:=(MemoryChunkBlock.fOffset+MemoryChunkBlock.fSize)-TempOffset;
       MemoryChunkBlock.Update(MemoryChunkBlock.fOffset,aSize,MemoryChunkBlock.fAllocationType);
       TVulkanDeviceMemoryChunkBlock.Create(self,TempOffset,TempSize,vdmatFree);
       result:=true;
      end;
     end;
    end;
    if result then begin
     inc(fUsed,aSize);
    end;
   end;
  end;

 finally
  fLock.Release;
 end;

end;

function TVulkanDeviceMemoryChunk.FreeMemory(const aOffset:TVkDeviceSize):boolean;
var Node,OtherNode:TVulkanDeviceMemoryChunkBlockRedBlackTreeNode;
    MemoryChunkBlock,OtherMemoryChunkBlock:TVulkanDeviceMemoryChunkBlock;
    TempOffset,TempSize:TVkDeviceSize;
begin
 result:=false;

 fLock.Acquire;
 try

  Node:=fOffsetRedBlackTree.Find(aOffset);
  if assigned(Node) then begin

   MemoryChunkBlock:=Node.fValue;
   if MemoryChunkBlock.fAllocationType<>vdmatFree then begin

    dec(fUsed,MemoryChunkBlock.fSize);

    // Freeing including coalescing free blocks
    while assigned(Node) do begin

     // Coalescing previous free block with current block
     OtherNode:=MemoryChunkBlock.fOffsetRedBlackTreeNode.Predecessor;
     if assigned(OtherNode) and (OtherNode.fValue.fAllocationType=vdmatFree) then begin
      OtherMemoryChunkBlock:=OtherNode.fValue;
      TempOffset:=OtherMemoryChunkBlock.fOffset;
      TempSize:=(MemoryChunkBlock.fOffset+MemoryChunkBlock.fSize)-TempOffset;
      MemoryChunkBlock.Free;
      OtherMemoryChunkBlock.Update(TempOffset,TempSize,vdmatFree);
      MemoryChunkBlock:=OtherMemoryChunkBlock;
      Node:=OtherNode;
      continue;
     end;

     // Coalescing current block with next free block
     OtherNode:=MemoryChunkBlock.fOffsetRedBlackTreeNode.Successor;
     if assigned(OtherNode) and (OtherNode.fValue.fAllocationType=vdmatFree) then begin
      OtherMemoryChunkBlock:=OtherNode.fValue;
      TempOffset:=MemoryChunkBlock.fOffset;
      TempSize:=(OtherMemoryChunkBlock.fOffset+OtherMemoryChunkBlock.fSize)-TempOffset;
      OtherMemoryChunkBlock.Free;
      MemoryChunkBlock.Update(TempOffset,TempSize,vdmatFree);
      continue;
     end;

     if MemoryChunkBlock.fAllocationType<>vdmatFree then begin
      // Mark block as free
      MemoryChunkBlock.Update(MemoryChunkBlock.fOffset,MemoryChunkBlock.fSize,vdmatFree);
     end;
     break;

    end;

    result:=true;
    
   end;

  end;

 finally
  fLock.Release;
 end;
end;

function TVulkanDeviceMemoryChunk.MapMemory(const aOffset:TVkDeviceSize=0;const aSize:TVkDeviceSize=TVkDeviceSize(VK_WHOLE_SIZE)):PVkVoid;
begin
 result:=nil;
 if vdmcfPersistentMapped in fMemoryChunkFlags then begin
  if (fMemoryPropertyFlags and TVkMemoryPropertyFlags(VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT))<>0 then begin
   if assigned(fMemory) then begin
    result:=TVkPointer(TVkPtrUInt(TVkPtrUInt(fMemory)+TVkPtrUInt(aOffset)));
   end else begin
    raise EVulkanException.Create('Persistent mapped memory is not mapped?');
   end;
  end else begin
   raise EVulkanException.Create('Memory can''t mapped');
  end;
 end else begin
  fLock.Acquire;
  try
   if (fMemoryPropertyFlags and TVkMemoryPropertyFlags(VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT))<>0 then begin
    if assigned(fMemory) then begin
     raise EVulkanException.Create('Memory is already mapped');
    end else begin
     fMappedOffset:=aOffset;
     fMappedSize:=aSize;
     HandleResultCode(fMemoryManager.fDevice.Commands.MapMemory(fMemoryManager.fDevice.fDeviceHandle,fMemoryHandle,aOffset,aSize,0,@result));
     fMemory:=result;
    end;
   end else begin
    raise EVulkanException.Create('Memory can''t mapped');
   end;
  finally
   fLock.Release;
  end;
 end;
end;

procedure TVulkanDeviceMemoryChunk.UnmapMemory;
begin
 if vdmcfPersistentMapped in fMemoryChunkFlags then begin
  if assigned(fMemory) then begin
   // Do nothing in this case
  end else begin 
   raise EVulkanException.Create('Persistent mapped memory is not mapped?');
  end;
 end else begin
  fLock.Acquire;
  try
   if (fMemoryPropertyFlags and TVkMemoryPropertyFlags(VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT))<>0 then begin
    if assigned(fMemory) then begin
     fMemoryManager.fDevice.Commands.UnmapMemory(fMemoryManager.fDevice.fDeviceHandle,fMemoryHandle);
     fMemory:=nil;
    end else begin
     raise EVulkanException.Create('Non-mapped memory can''t unmapped');
    end;
   end;
  finally
   fLock.Release;
  end;
 end;
end;

procedure TVulkanDeviceMemoryChunk.FlushMappedMemory;
var MappedMemoryRange:TVkMappedMemoryRange;
begin
 fLock.Acquire;
 try
  if assigned(fMemory) then begin
   FillChar(MappedMemoryRange,SizeOf(TVkMappedMemoryRange),#0);
   MappedMemoryRange.sType:=VK_STRUCTURE_TYPE_MAPPED_MEMORY_RANGE;
   MappedMemoryRange.pNext:=nil;
   MappedMemoryRange.memory:=fMemoryHandle;
   MappedMemoryRange.offset:=fMappedOffset;
   MappedMemoryRange.size:=fMappedSize;
   HandleResultCode(vkFlushMappedMemoryRanges(fMemoryManager.fDevice.fDeviceHandle,1,@MappedMemoryRange));
  end else begin
   raise EVulkanException.Create('Non-mapped memory can''t be flushed');
  end;
 finally
  fLock.Release;
 end;
end;

procedure TVulkanDeviceMemoryChunk.FlushMappedMemoryRange(const aBase:TVkPointer;const aSize:TVkDeviceSize);
var MappedMemoryRange:TVkMappedMemoryRange;
    Offset,Size:TVkDeviceSize;
begin
 fLock.Acquire;
 try
  if assigned(fMemory) then begin
   Offset:=fMappedOffset+TVkDeviceSize(TVkPtrUInt(aBase)-TVkPtrUInt(fMemory));
   if aSize=TVkDeviceSize(VK_WHOLE_SIZE) then begin
    Size:=TVkInt64(Max(0,TVkInt64((fMappedOffset+fMappedSize)-Offset)));
   end else begin
    Size:=Min(TVkInt64(Max(TVkInt64(aSize),0)),TVkInt64(Max(0,TVkInt64((fMappedOffset+fMappedSize)-Offset))));
   end;
   FillChar(MappedMemoryRange,SizeOf(TVkMappedMemoryRange),#0);
   MappedMemoryRange.sType:=VK_STRUCTURE_TYPE_MAPPED_MEMORY_RANGE;
   MappedMemoryRange.pNext:=nil;
   MappedMemoryRange.memory:=fMemoryHandle;
   MappedMemoryRange.offset:=Offset;
   MappedMemoryRange.size:=Size;
   HandleResultCode(vkFlushMappedMemoryRanges(fMemoryManager.fDevice.fDeviceHandle,1,@MappedMemoryRange));
  end else begin
   raise EVulkanException.Create('Non-mapped memory can''t be flushed');
  end;
 finally
  fLock.Release;
 end;
end;

procedure TVulkanDeviceMemoryChunk.InvalidateMappedMemory;
var MappedMemoryRange:TVkMappedMemoryRange;
begin
 fLock.Acquire;
 try
  if assigned(fMemory) then begin
   FillChar(MappedMemoryRange,SizeOf(TVkMappedMemoryRange),#0);
   MappedMemoryRange.sType:=VK_STRUCTURE_TYPE_MAPPED_MEMORY_RANGE;
   MappedMemoryRange.pNext:=nil;
   MappedMemoryRange.memory:=fMemoryHandle;
   MappedMemoryRange.offset:=fMappedOffset;
   MappedMemoryRange.size:=fMappedSize;
   HandleResultCode(vkInvalidateMappedMemoryRanges(fMemoryManager.fDevice.fDeviceHandle,1,@MappedMemoryRange));
  end else begin
   raise EVulkanException.Create('Non-mapped memory can''t be invalidated');
  end;
 finally
  fLock.Release;
 end;
end;

procedure TVulkanDeviceMemoryChunk.InvalidateMappedMemoryRange(const aBase:TVkPointer;const aSize:TVkDeviceSize);
var MappedMemoryRange:TVkMappedMemoryRange;
    Offset,Size:TVkDeviceSize;
begin
 fLock.Acquire;
 try
  if assigned(fMemory) then begin
   Offset:=fMappedOffset+TVkDeviceSize(TVkPtrUInt(aBase)-TVkPtrUInt(fMemory));
   if aSize=TVkDeviceSize(VK_WHOLE_SIZE) then begin
    Size:=TVkInt64(Max(0,TVkInt64((fMappedOffset+fMappedSize)-Offset)));
   end else begin
    Size:=Min(TVkInt64(Max(TVkInt64(aSize),0)),TVkInt64(Max(0,TVkInt64((fMappedOffset+fMappedSize)-Offset))));
   end;
   FillChar(MappedMemoryRange,SizeOf(TVkMappedMemoryRange),#0);
   MappedMemoryRange.sType:=VK_STRUCTURE_TYPE_MAPPED_MEMORY_RANGE;
   MappedMemoryRange.pNext:=nil;
   MappedMemoryRange.memory:=fMemoryHandle;
   MappedMemoryRange.offset:=Offset;
   MappedMemoryRange.size:=Size;
   HandleResultCode(vkInvalidateMappedMemoryRanges(fMemoryManager.fDevice.fDeviceHandle,1,@MappedMemoryRange));
  end else begin
   raise EVulkanException.Create('Non-mapped memory can''t be invalidated');
  end;
 finally
  fLock.Release;
 end;
end;

constructor TVulkanDeviceMemoryBlock.Create(const aMemoryManager:TVulkanDeviceMemoryManager;
                                            const aMemoryChunk:TVulkanDeviceMemoryChunk;
                                            const aOffset:TVkDeviceSize;
                                            const aSize:TVkDeviceSize);
begin

 inherited Create;

 fMemoryManager:=aMemoryManager;

 fMemoryChunk:=aMemoryChunk;

 fOffset:=aOffset;

 fSize:=aSize;

 if assigned(fMemoryManager.fLastMemoryBlock) then begin
  fMemoryManager.fLastMemoryBlock.fNextMemoryBlock:=self;
  fPreviousMemoryBlock:=fMemoryManager.fLastMemoryBlock;
 end else begin
  fMemoryManager.fFirstMemoryBlock:=self;
  fPreviousMemoryBlock:=nil;
 end;
 fMemoryManager.fLastMemoryBlock:=self;
 fNextMemoryBlock:=nil;

end;

destructor TVulkanDeviceMemoryBlock.Destroy;
begin
 if assigned(fPreviousMemoryBlock) then begin
  fPreviousMemoryBlock.fNextMemoryBlock:=fNextMemoryBlock;
 end else if fMemoryManager.fFirstMemoryBlock=self then begin
  fMemoryManager.fFirstMemoryBlock:=fNextMemoryBlock;
 end;
 if assigned(fNextMemoryBlock) then begin
  fNextMemoryBlock.fPreviousMemoryBlock:=fPreviousMemoryBlock;
 end else if fMemoryManager.fLastMemoryBlock=self then begin
  fMemoryManager.fLastMemoryBlock:=fPreviousMemoryBlock;
 end;
 inherited Destroy;
end;

function TVulkanDeviceMemoryBlock.MapMemory(const aOffset:TVkDeviceSize=0;const aSize:TVkDeviceSize=TVkDeviceSize(VK_WHOLE_SIZE)):PVkVoid;
var Offset,Size:TVkDeviceSize;
begin
 Offset:=fOffset+aOffset;
 if aSize=TVkDeviceSize(VK_WHOLE_SIZE) then begin
  Size:=TVkInt64(Max(0,TVkInt64((fOffset+fSize)-Offset)));
 end else begin
  Size:=Min(TVkInt64(Max(TVkInt64(aSize),0)),TVkInt64(Max(0,TVkInt64((fOffset+fSize)-Offset))));
 end;
 result:=fMemoryChunk.MapMemory(Offset,Size);
end;

procedure TVulkanDeviceMemoryBlock.UnmapMemory;
begin
 fMemoryChunk.UnmapMemory;
end;

procedure TVulkanDeviceMemoryBlock.FlushMappedMemory;
begin
 fMemoryChunk.FlushMappedMemory;
end;

procedure TVulkanDeviceMemoryBlock.FlushMappedMemoryRange(const aBase:TVkPointer;const aSize:TVkDeviceSize);
begin
 fMemoryChunk.FlushMappedMemoryRange(aBase,aSize);
end;

procedure TVulkanDeviceMemoryBlock.InvalidateMappedMemory;
begin
 fMemoryChunk.InvalidateMappedMemory;
end;

procedure TVulkanDeviceMemoryBlock.InvalidateMappedMemoryRange(const aBase:TVkPointer;const aSize:TVkDeviceSize);
begin
 fMemoryChunk.InvalidateMappedMemoryRange(aBase,aSize);
end;

function TVulkanDeviceMemoryBlock.Fill(const aData:PVkVoid;const aSize:TVkDeviceSize):TVkDeviceSize;
var Memory:PVkVoid;
begin
 if aSize<=0 then begin
  result:=0;
 end else if aSize>fSize then begin
  result:=fSize;
 end else begin
  result:=aSize;
 end;
 Memory:=MapMemory;
 try
  Move(aData^,Memory^,result);
 finally
  UnmapMemory;
 end;
end;

constructor TVulkanDeviceMemoryManager.Create(const aDevice:TVulkanDevice);
begin
 inherited Create;

 fDevice:=aDevice;

 fLock:=TCriticalSection.Create;

 FillChar(fMemoryChunkList,SizeOf(TVulkanDeviceMemoryManagerChunkList),#0);

 fFirstMemoryBlock:=nil;
 fLastMemoryBlock:=nil;

end;

destructor TVulkanDeviceMemoryManager.Destroy;
var Index:TVkInt32;
begin
 while assigned(fFirstMemoryBlock) do begin
  fFirstMemoryBlock.Free;
 end;
 while assigned(fMemoryChunkList.First) do begin
  fMemoryChunkList.First.Free;
 end;
 fLock.Free;
 inherited Destroy;
end;

function TVulkanDeviceMemoryManager.AllocateMemoryBlock(const aMemoryBlockFlags:TVulkanDeviceMemoryBlockFlags;
                                                        const aMemoryBlockSize:TVkDeviceSize;
                                                        const aMemoryBlockAlignment:TVkDeviceSize;
                                                        const aMemoryTypeBits:TVkUInt32;
                                                        const aMemoryRequiredPropertyFlags:TVkMemoryPropertyFlags;
                                                        const aMemoryPreferredPropertyFlags:TVkMemoryPropertyFlags;
                                                        const aMemoryAvoidPropertyFlags:TVkMemoryPropertyFlags;
                                                        const aMemoryRequiredHeapFlags:TVkMemoryHeapFlags;
                                                        const aMemoryPreferredHeapFlags:TVkMemoryHeapFlags;
                                                        const aMemoryAvoidHeapFlags:TVkMemoryHeapFlags;
                                                        const aMemoryAllocationType:TVulkanDeviceMemoryAllocationType):TVulkanDeviceMemoryBlock;
var TryIteration:TVkInt32;
    MemoryChunk:TVulkanDeviceMemoryChunk;
    Offset,Alignment:TVkDeviceSize;
    MemoryChunkFlags:TVulkanDeviceMemoryChunkFlags;
    PropertyFlags:TVkMemoryPropertyFlags;
    HeapFlags:TVkMemoryHeapFlags;
begin

 result:=nil;

 if aMemoryBlockSize=0 then begin
  raise EVulkanMemoryAllocationException.Create('Can''t allocate zero-sized memory block');
 end;

 MemoryChunkFlags:=[];
 if vdmbfPersistentMapped in aMemoryBlockFlags then begin
  Include(MemoryChunkFlags,vdmcfPersistentMapped);
 end;

 if vdmbfOwnSingleMemoryChunk in aMemoryBlockFlags then begin

  // New allocated device memory blocks are always perfectly aligned already, so set Alignment here to 1 
  Alignment:=1;

  fLock.Acquire;
  try
   // Allocate a block inside a new chunk
   MemoryChunk:=TVulkanDeviceMemoryChunk.Create(self,
                                                MemoryChunkFlags,
                                                aMemoryBlockSize,
                                                aMemoryTypeBits,
                                                aMemoryRequiredPropertyFlags,
                                                aMemoryPreferredPropertyFlags,
                                                aMemoryAvoidPropertyFlags,
                                                aMemoryRequiredHeapFlags,
                                                aMemoryPreferredHeapFlags,
                                                aMemoryAvoidHeapFlags,
                                                @fMemoryChunkList);
   if MemoryChunk.AllocateMemory(Offset,aMemoryBlockSize,Alignment,aMemoryAllocationType) then begin
    result:=TVulkanDeviceMemoryBlock.Create(self,MemoryChunk,Offset,aMemoryBlockSize);
   end;
  finally
   fLock.Release;
  end;

 end else begin

  Alignment:=aMemoryBlockAlignment-1;
  Alignment:=Alignment or (Alignment shr 1);
  Alignment:=Alignment or (Alignment shr 2);
  Alignment:=Alignment or (Alignment shr 4);
  Alignment:=Alignment or (Alignment shr 8);
  Alignment:=Alignment or (Alignment shr 16);
  Alignment:=(Alignment or (Alignment shr 32))+1;

  fLock.Acquire;
  try

   // Try first to allocate a block inside already existent chunks
   for TryIteration:=0 to 3 do begin

    PropertyFlags:=aMemoryRequiredPropertyFlags;
    if TryIteration in [0,1] then begin
     if aMemoryPreferredPropertyFlags=0 then begin
      // For avoid unnecessary multiplicate fMemoryChunkList traversals
      continue;
     end else begin
      PropertyFlags:=PropertyFlags or aMemoryPreferredPropertyFlags;
     end;
    end;

    HeapFlags:=aMemoryRequiredHeapFlags;
    if TryIteration in [0,2] then begin
     if aMemoryPreferredHeapFlags=0 then begin
      // For avoid unnecessary multiplicate fMemoryChunkList traversals
      continue;
     end else begin
      HeapFlags:=HeapFlags or aMemoryPreferredHeapFlags;
     end;
    end;

    MemoryChunk:=fMemoryChunkList.First;
    while assigned(MemoryChunk) do begin
     if ((aMemoryTypeBits and MemoryChunk.fMemoryTypeBits)<>0) and
        ((MemoryChunk.fMemoryPropertyFlags and PropertyFlags)=PropertyFlags) and
        ((aMemoryAvoidPropertyFlags=0) or ((MemoryChunk.fMemoryPropertyFlags and aMemoryAvoidPropertyFlags)=0)) and
        ((MemoryChunk.fMemoryHeapFlags and HeapFlags)=HeapFlags) and
        ((aMemoryAvoidHeapFlags=0) or ((MemoryChunk.fMemoryHeapFlags and aMemoryAvoidHeapFlags)=0)) and
        ((MemoryChunk.fSize-MemoryChunk.fUsed)>=aMemoryBlockSize) and
        ((MemoryChunk.fMemoryChunkFlags*[vdmcfPersistentMapped])=(MemoryChunkFlags*[vdmcfPersistentMapped])) then begin
      if MemoryChunk.AllocateMemory(Offset,aMemoryBlockSize,Alignment,aMemoryAllocationType) then begin
       result:=TVulkanDeviceMemoryBlock.Create(self,MemoryChunk,Offset,aMemoryBlockSize);
       break;
      end;
     end;
     MemoryChunk:=MemoryChunk.fNextMemoryChunk;
    end;

    if assigned(result) then begin
     break;
    end;

   end;

   if not assigned(result) then begin
    // Otherwise allocate a block inside a new chunk
    MemoryChunk:=TVulkanDeviceMemoryChunk.Create(self,
                                                 MemoryChunkFlags,
                                                 VulkanDeviceSizeRoundUpToPowerOfTwo(Max(VulkanMinimumMemoryChunkSize,aMemoryBlockSize shl 1)),
                                                 aMemoryTypeBits,
                                                 aMemoryRequiredPropertyFlags,
                                                 aMemoryPreferredPropertyFlags,
                                                 aMemoryAvoidPropertyFlags,
                                                 aMemoryRequiredHeapFlags,
                                                 aMemoryPreferredHeapFlags,
                                                 aMemoryAvoidHeapFlags,
                                                 @fMemoryChunkList);
    if MemoryChunk.AllocateMemory(Offset,aMemoryBlockSize,Alignment,aMemoryAllocationType) then begin
     result:=TVulkanDeviceMemoryBlock.Create(self,MemoryChunk,Offset,aMemoryBlockSize);
    end;
   end;

  finally
   fLock.Release;
  end;

 end;

 if not assigned(result) then begin
  raise EVulkanMemoryAllocationException.Create('Couldn''t allocate memory block');
 end;

end;

function TVulkanDeviceMemoryManager.FreeMemoryBlock(const aMemoryBlock:TVulkanDeviceMemoryBlock):boolean;
var MemoryChunk:TVulkanDeviceMemoryChunk;
begin
 result:=assigned(aMemoryBlock);
 if result then begin
  fLock.Acquire;
  try
   MemoryChunk:=aMemoryBlock.fMemoryChunk;
   result:=MemoryChunk.FreeMemory(aMemoryBlock.fOffset);
   if result then begin
    aMemoryBlock.Free;
    if assigned(MemoryChunk.fOffsetRedBlackTree.fRoot) and
       (MemoryChunk.fOffsetRedBlackTree.fRoot.fValue.fOffset=0) and
       (MemoryChunk.fOffsetRedBlackTree.fRoot.fValue.fSize=MemoryChunk.fSize) and
       not (assigned(MemoryChunk.fOffsetRedBlackTree.fRoot.fLeft) or assigned(MemoryChunk.fOffsetRedBlackTree.fRoot.fRight)) then begin
     MemoryChunk.Free;
    end;
   end;
  finally
   fLock.Release;
  end;
 end;
end;

constructor TVulkanBuffer.Create(const aDevice:TVulkanDevice;
                                 const aSize:TVkDeviceSize;
                                 const aUsage:TVkBufferUsageFlags;
                                 const aSharingMode:TVkSharingMode=VK_SHARING_MODE_EXCLUSIVE;
                                 const aQueueFamilyIndices:TVkUInt32List=nil;
                                 const aMemoryRequiredPropertyFlags:TVkMemoryPropertyFlags=TVkMemoryPropertyFlags(VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT) or TVkMemoryPropertyFlags(VK_MEMORY_PROPERTY_HOST_COHERENT_BIT);
                                 const aMemoryPreferredPropertyFlags:TVkMemoryPropertyFlags=TVkMemoryPropertyFlags(VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT);
                                 const aMemoryAvoidPropertyFlags:TVkMemoryPropertyFlags=0;
                                 const aMemoryRequiredHeapFlags:TVkMemoryHeapFlags=0;
                                 const aMemoryPreferredHeapFlags:TVkMemoryHeapFlags=0;
                                 const aMemoryAvoidHeapFlags:TVkMemoryHeapFlags=0;
                                 const aBufferFlags:TVulkanBufferFlags=[]);
var Index:TVkInt32;
    BufferCreateInfo:TVkBufferCreateInfo;
    MemoryBlockFlags:TVulkanDeviceMemoryBlockFlags;
begin
 inherited Create;

 fDevice:=aDevice;

 fSize:=aSize;

 fBufferFlags:=aBufferFlags;

 fBufferHandle:=VK_NULL_HANDLE;

 fMemoryBlock:=nil;

 fQueueFamilyIndices:=nil;
 if assigned(aQueueFamilyIndices) then begin
  fCountQueueFamilyIndices:=aQueueFamilyIndices.Count;
  SetLength(fQueueFamilyIndices,fCountQueueFamilyIndices);
  for Index:=0 to fCountQueueFamilyIndices-1 do begin
   fQueueFamilyIndices[Index]:=aQueueFamilyIndices.Items[Index];
  end;
 end else begin
  fCountQueueFamilyIndices:=0;
 end;

 FillChar(BufferCreateInfo,SizeOf(TVkBufferCreateInfo),#0);
 BufferCreateInfo.sType:=VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO;
 BufferCreateInfo.size:=fSize;
 BufferCreateInfo.usage:=aUsage;
 BufferCreateInfo.sharingMode:=aSharingMode;
 if fCountQueueFamilyIndices>0 then begin
  BufferCreateInfo.pQueueFamilyIndices:=@fQueueFamilyIndices[0];
  BufferCreateInfo.queueFamilyIndexCount:=fCountQueueFamilyIndices;
 end;

 try

  HandleResultCode(fDevice.Commands.CreateBuffer(fDevice.fDeviceHandle,@BufferCreateInfo,fDevice.fAllocationCallbacks,@fBufferHandle));

  fDevice.Commands.GetBufferMemoryRequirements(fDevice.fDeviceHandle,fBufferHandle,@fMemoryRequirements);

  MemoryBlockFlags:=[];
  if vbfOwnSingleMemoryChunk in fBufferFlags then begin
   Include(MemoryBlockFlags,vdmbfOwnSingleMemoryChunk);
  end;
  if vbfPersistentMapped in fBufferFlags then begin
   Include(MemoryBlockFlags,vdmbfPersistentMapped);
  end;

  fMemoryBlock:=fDevice.fMemoryManager.AllocateMemoryBlock(MemoryBlockFlags,
                                                           fMemoryRequirements.Size,
                                                           fMemoryRequirements.Alignment,
                                                           fMemoryRequirements.memoryTypeBits,
                                                           aMemoryRequiredPropertyFlags,
                                                           aMemoryPreferredPropertyFlags,
                                                           aMemoryAvoidPropertyFlags,
                                                           aMemoryRequiredHeapFlags,
                                                           aMemoryPreferredHeapFlags,
                                                           aMemoryAvoidHeapFlags,
                                                           vdmatBuffer);

  Bind;

  fMemoryPropertyFlags:=fMemoryBlock.fMemoryChunk.fMemoryPropertyFlags;

  fDescriptorBufferInfo.buffer:=fBufferHandle;
  fDescriptorBufferInfo.offset:=0;
  fDescriptorBufferInfo.range:=fSize;

 except

  if fBufferHandle<>VK_NULL_HANDLE then begin
   fDevice.Commands.DestroyBuffer(fDevice.fDeviceHandle,fBufferHandle,fDevice.fAllocationCallbacks);
   fBufferHandle:=VK_NULL_HANDLE;
  end;

  if assigned(fMemoryBlock) then begin
   fDevice.fMemoryManager.FreeMemoryBlock(fMemoryBlock);
   fMemoryBlock:=nil;
  end;

  SetLength(fQueueFamilyIndices,0);

  raise;

 end;

end;

destructor TVulkanBuffer.Destroy;
begin
 if fBufferHandle<>VK_NULL_HANDLE then begin
  fDevice.Commands.DestroyBuffer(fDevice.fDeviceHandle,fBufferHandle,fDevice.fAllocationCallbacks);
  fBufferHandle:=VK_NULL_HANDLE;
 end;
 if assigned(fMemoryBlock) then begin
  fDevice.fMemoryManager.FreeMemoryBlock(fMemoryBlock);
  fMemoryBlock:=nil;
 end;
 SetLength(fQueueFamilyIndices,0);
 inherited Destroy;
end;

procedure TVulkanBuffer.Bind;
begin
 HandleResultCode(fDevice.Commands.BindBufferMemory(fDevice.fDeviceHandle,fBufferHandle,fMemoryBlock.fMemoryChunk.fMemoryHandle,fMemoryBlock.fOffset));
end;

procedure TVulkanBuffer.UploadData(const aTransferQueue:TVulkanQueue;
                                   const aTransferCommandBuffer:TVulkanCommandBuffer;
                                   const aTransferFence:TVulkanFence;
                                   const aData;
                                   const aDataOffset:TVkDeviceSize;
                                   const aDataSize:TVkDeviceSize;
                                   const aUseTemporaryStagingBufferMode:TVulkanBufferUseTemporaryStagingBufferMode=vbutsbmAutomatic);
var StagingBuffer:TVulkanBuffer;
    p:TVkPointer;
    VkBufferCopy:TVkBufferCopy;
begin

 if (aUseTemporaryStagingBufferMode=vbutsbmYes) or
    ((aUseTemporaryStagingBufferMode=vbutsbmAutomatic) and
     ((fMemoryPropertyFlags and TVkMemoryPropertyFlags(VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT))=0)) then begin

  StagingBuffer:=TVulkanBuffer.Create(fDevice,
                                      aDataSize,
                                      TVkBufferUsageFlags(VK_BUFFER_USAGE_TRANSFER_SRC_BIT),
                                      VK_SHARING_MODE_EXCLUSIVE,
                                      nil,
                                      TVkMemoryPropertyFlags(VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT),
                                      0,
                                      0,
                                      0,
                                      0,
                                      0,
                                      [vbfOwnSingleMemoryChunk]);
  try

   p:=StagingBuffer.Memory.MapMemory;
   try
    if assigned(p) then begin
     Move(aData,p^,aDataSize);
    end else begin
     raise EVulkanException.Create('Vulkan buffer memory block map failed');
    end;
   finally
    StagingBuffer.Memory.UnmapMemory;
   end;

   VkBufferCopy.srcOffset:=0;
   VkBufferCopy.dstOffset:=aDataOffset;
   VkBufferCopy.size:=aDataSize;

   aTransferCommandBuffer.Reset(TVkCommandBufferResetFlags(VK_COMMAND_BUFFER_RESET_RELEASE_RESOURCES_BIT));
   aTransferCommandBuffer.BeginRecording;
   aTransferCommandBuffer.CmdCopyBuffer(StagingBuffer.Handle,Handle,1,@VkBufferCopy);
   aTransferCommandBuffer.EndRecording;
   aTransferCommandBuffer.Execute(fDevice.TransferQueue,0,nil,nil,aTransferFence,true);

  finally
   StagingBuffer.Free;
  end;

 end else begin

  if (fMemoryPropertyFlags and TVkMemoryPropertyFlags(VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT))<>0 then begin
   p:=Memory.MapMemory(aDataOffset,aDataSize);
   try
    if assigned(p) then begin
     Move(aData,p^,aDataSize);
     if (fMemoryPropertyFlags and TVkMemoryPropertyFlags(VK_MEMORY_PROPERTY_HOST_COHERENT_BIT))=0 then begin
      Memory.FlushMappedMemoryRange(p,aDataSize);
     end;
    end else begin
     raise EVulkanException.Create('Vulkan buffer memory block map failed');
    end;
   finally
    Memory.UnmapMemory;
   end;
  end else begin
   raise EVulkanException.Create('Vulkan buffer memory block map failed');
  end;

 end;

end;

procedure TVulkanBuffer.UpdateData(const aData;
                                   const aDataOffset:TVkDeviceSize;
                                   const aDataSize:TVkDeviceSize);
var p:TVkPointer;
begin
 if (fMemoryPropertyFlags and TVkMemoryPropertyFlags(VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT))<>0 then begin
  p:=Memory.MapMemory(aDataOffset,aDataSize);
  try
   if assigned(p) then begin
    Move(aData,p^,aDataSize);
    if (fMemoryPropertyFlags and TVkMemoryPropertyFlags(VK_MEMORY_PROPERTY_HOST_COHERENT_BIT))=0 then begin
     Memory.FlushMappedMemoryRange(p,aDataSize);
    end;
   end else begin
    raise EVulkanException.Create('Vulkan buffer memory block map failed');
   end;
  finally
   Memory.UnmapMemory;
  end;
 end else begin
  raise EVulkanException.Create('Vulkan buffer memory block map failed');
 end;
end;

constructor TVulkanBufferView.Create(const aDevice:TVulkanDevice;
                                     const aBuffer:TVulkanBuffer;
                                     const aFormat:TVkFormat;
                                     const aOffset:TVkDeviceSize=0;
                                     const aRange:TVkDeviceSize=TVkDeviceSize(VK_WHOLE_SIZE));
var BufferViewCreateInfo:TVkBufferViewCreateInfo;
begin

 inherited Create;

 fDevice:=aDevice;

 fBuffer:=aBuffer;

 fBufferViewHandle:=VK_NULL_HANDLE;

 FillChar(BufferViewCreateInfo,SizeOf(TVkBufferViewCreateInfo),#0);
 BufferViewCreateInfo.sType:=VK_STRUCTURE_TYPE_BUFFER_VIEW_CREATE_INFO;
 BufferViewCreateInfo.pNext:=nil;
 BufferViewCreateInfo.flags:=0;
 BufferViewCreateInfo.buffer:=fBuffer.fBufferHandle;
 BufferViewCreateInfo.format:=aFormat;
 BufferViewCreateInfo.offset:=aOffset;
 BufferViewCreateInfo.range:=aRange;

 HandleResultCode(fDevice.fDeviceVulkan.CreateBufferView(fDevice.fDeviceHandle,@BufferViewCreateInfo,fDevice.fAllocationCallbacks,@fBufferViewHandle));

end;

constructor TVulkanBufferView.Create(const aDevice:TVulkanDevice;
                                     const aBufferView:TVkBufferView;
                                     const aBuffer:TVulkanBuffer=nil);
begin

 inherited Create;

 fDevice:=aDevice;

 fBufferViewHandle:=aBufferView;

 fBuffer:=aBuffer;

end;

destructor TVulkanBufferView.Destroy;
begin
 fBuffer:=nil;
 if fBufferViewHandle<>VK_NULL_HANDLE then begin
  fDevice.fDeviceVulkan.DestroyBufferView(fDevice.fDeviceHandle,fBufferViewHandle,fDevice.fAllocationCallbacks);
  fBufferViewHandle:=VK_NULL_HANDLE;
 end;
 inherited Destroy;
end;

constructor TVulkanEvent.Create(const aDevice:TVulkanDevice;
                                const aFlags:TVkEventCreateFlags=TVkEventCreateFlags(0));
var EventCreateInfo:TVkEventCreateInfo;
begin
 inherited Create;

 fDevice:=aDevice;

 fEventHandle:=VK_NULL_HANDLE;

 FillChar(EventCreateInfo,SizeOf(TVkEventCreateInfo),#0);
 EventCreateInfo.sType:=VK_STRUCTURE_TYPE_EVENT_CREATE_INFO;
 EventCreateInfo.pNext:=nil;
 EventCreateInfo.flags:=aFlags;

 HandleResultCode(fDevice.fDeviceVulkan.CreateEvent(fDevice.fDeviceHandle,@EventCreateInfo,fDevice.fAllocationCallbacks,@fEventHandle));

end;

destructor TVulkanEvent.Destroy;
begin
 if fEventHandle<>VK_NULL_HANDLE then begin
  fDevice.fDeviceVulkan.DestroyEvent(fDevice.fDeviceHandle,fEventHandle,fDevice.fAllocationCallbacks);
  fEventHandle:=VK_NULL_HANDLE;
 end;
 inherited Destroy;
end;

function TVulkanEvent.GetStatus:TVkResult;
begin
 result:=fDevice.fDeviceVulkan.GetEventStatus(fDevice.fDeviceHandle,fEventHandle);
end;

function TVulkanEvent.SetEvent:TVkResult;
begin
 result:=fDevice.fDeviceVulkan.SetEvent(fDevice.fDeviceHandle,fEventHandle);
 if result<VK_SUCCESS then begin
  HandleResultCode(result);
 end;
end;

function TVulkanEvent.Reset:TVkResult;
begin
 result:=fDevice.fDeviceVulkan.ResetEvent(fDevice.fDeviceHandle,fEventHandle);
 if result<VK_SUCCESS then begin
  HandleResultCode(result);
 end;
end;

constructor TVulkanFence.Create(const aDevice:TVulkanDevice;
                                const aFlags:TVkFenceCreateFlags=TVkFenceCreateFlags(0));
var FenceCreateInfo:TVkFenceCreateInfo;
begin
 inherited Create;

 fDevice:=aDevice;

 fFenceHandle:=VK_NULL_HANDLE;

 FillChar(FenceCreateInfo,SizeOf(TVkFenceCreateInfo),#0);
 FenceCreateInfo.sType:=VK_STRUCTURE_TYPE_FENCE_CREATE_INFO;
 FenceCreateInfo.pNext:=nil;
 FenceCreateInfo.flags:=aFlags;

 HandleResultCode(fDevice.fDeviceVulkan.CreateFence(fDevice.fDeviceHandle,@FenceCreateInfo,fDevice.fAllocationCallbacks,@fFenceHandle));

end;

destructor TVulkanFence.Destroy;
begin
 if fFenceHandle<>VK_NULL_HANDLE then begin
  fDevice.fDeviceVulkan.DestroyFence(fDevice.fDeviceHandle,fFenceHandle,fDevice.fAllocationCallbacks);
  fFenceHandle:=VK_NULL_HANDLE;
 end;
 inherited Destroy;
end;

function TVulkanFence.GetStatus:TVkResult;
begin
 result:=fDevice.fDeviceVulkan.GetFenceStatus(fDevice.fDeviceHandle,fFenceHandle);
end;

function TVulkanFence.Reset:TVkResult;
begin
 result:=fDevice.fDeviceVulkan.ResetFences(fDevice.fDeviceHandle,1,@fFenceHandle);
 if result<VK_SUCCESS then begin
  HandleResultCode(result);
 end;
end;

class function TVulkanFence.Reset(const aFences:array of TVulkanFence):TVkResult;
var Index:TVkInt32;
    Handles:array of TVkFence;
begin
 Handles:=nil;
 result:=VK_SUCCESS;
 if length(aFences)>0 then begin
  try
   SetLength(Handles,length(aFences));
   for Index:=0 to length(aFences)-1 do begin
    Handles[Index]:=aFences[Index].fFenceHandle;
   end;
   result:=aFences[0].fDevice.fDeviceVulkan.ResetFences(aFences[0].fDevice.fDeviceHandle,length(aFences),@Handles[0]);
  finally
   SetLength(Handles,0);
  end;
  if result<VK_SUCCESS then begin
   HandleResultCode(result);
  end;
 end;
end;

function TVulkanFence.WaitFor(const aTimeOut:TVkUInt64=TVKUInt64(TVKInt64(-1))):TVkResult;
begin
 result:=fDevice.fDeviceVulkan.WaitForFences(fDevice.fDeviceHandle,1,@fFenceHandle,VK_TRUE,aTimeOut);
 if result<VK_SUCCESS then begin
  HandleResultCode(result);
 end;
end;

class function TVulkanFence.WaitFor(const aFences:array of TVulkanFence;const aWaitAll:boolean=true;const aTimeOut:TVkUInt64=TVKUInt64(TVKInt64(-1))):TVkResult;
var Index:TVkInt32;
    Handles:array of TVkFence;
begin
 Handles:=nil;
 result:=VK_SUCCESS;
 if length(aFences)>0 then begin
  try
   SetLength(Handles,length(aFences));
   for Index:=0 to length(aFences)-1 do begin
    Handles[Index]:=aFences[Index].fFenceHandle;
   end;
   if aWaitAll then begin
    result:=aFences[0].fDevice.fDeviceVulkan.WaitForFences(aFences[0].fDevice.fDeviceHandle,length(aFences),@Handles[0],VK_TRUE,aTimeOut);
   end else begin
    result:=aFences[0].fDevice.fDeviceVulkan.WaitForFences(aFences[0].fDevice.fDeviceHandle,length(aFences),@Handles[0],VK_FALSE,aTimeOut);
   end;
  finally
   SetLength(Handles,0);
  end;
  if result<VK_SUCCESS then begin
   HandleResultCode(result);
  end;
 end;
end;

constructor TVulkanSemaphore.Create(const aDevice:TVulkanDevice;
                                    const aFlags:TVkSemaphoreCreateFlags=TVkSemaphoreCreateFlags(0));
var SemaphoreCreateInfo:TVkSemaphoreCreateInfo;
begin
 inherited Create;

 fDevice:=aDevice;

 fSemaphoreHandle:=VK_NULL_HANDLE;

 FillChar(SemaphoreCreateInfo,SizeOf(TVkSemaphoreCreateInfo),#0);
 SemaphoreCreateInfo.sType:=VK_STRUCTURE_TYPE_SEMAPHORE_CREATE_INFO;
 SemaphoreCreateInfo.pNext:=nil;
 SemaphoreCreateInfo.flags:=aFlags;

 HandleResultCode(fDevice.fDeviceVulkan.CreateSemaphore(fDevice.fDeviceHandle,@SemaphoreCreateInfo,fDevice.fAllocationCallbacks,@fSemaphoreHandle));

end;

destructor TVulkanSemaphore.Destroy;
begin
 if fSemaphoreHandle<>VK_NULL_HANDLE then begin
  fDevice.fDeviceVulkan.DestroySemaphore(fDevice.fDeviceHandle,fSemaphoreHandle,fDevice.fAllocationCallbacks);
  fSemaphoreHandle:=VK_NULL_HANDLE;
 end;
 inherited Destroy;
end;

constructor TVulkanQueue.Create(const aDevice:TVulkanDevice;
                                const aQueue:TVkQueue;
                                const aQueueFamilyIndex:TVKUInt32);
begin
 inherited Create;

 fDevice:=aDevice;

 fQueueHandle:=aQueue;

 fQueueFamilyIndex:=aQueueFamilyIndex;

 fHasSupportForSparseBindings:=fDevice.fPhysicalDevice.HasQueueSupportForSparseBindings(aQueueFamilyIndex);

end;

destructor TVulkanQueue.Destroy;
begin
 inherited Destroy;
end;

procedure TVulkanQueue.Submit(const aSubmitCount:TVkUInt32;const aSubmits:PVkSubmitInfo;const aFence:TVulkanFence=nil);
begin
 if assigned(aFence) then begin
  HandleResultCode(fDevice.fDeviceVulkan.QueueSubmit(fQueueHandle,aSubmitCount,aSubmits,aFence.fFenceHandle));
 end else begin
  HandleResultCode(fDevice.fDeviceVulkan.QueueSubmit(fQueueHandle,aSubmitCount,aSubmits,VK_NULL_HANDLE));
 end;
end;

procedure TVulkanQueue.BindSparse(const aBindInfoCount:TVkUInt32;const aBindInfo:PVkBindSparseInfo;const aFence:TVulkanFence=nil);
begin
 if assigned(aFence) then begin
  HandleResultCode(fDevice.fDeviceVulkan.QueueBindSparse(fQueueHandle,aBindInfoCount,aBindInfo,aFence.fFenceHandle));
 end else begin
  HandleResultCode(fDevice.fDeviceVulkan.QueueBindSparse(fQueueHandle,aBindInfoCount,aBindInfo,VK_NULL_HANDLE));
 end;
end;

procedure TVulkanQueue.WaitIdle;
begin
 HandleResultCode(fDevice.fDeviceVulkan.QueueWaitIdle(fQueueHandle));
end;

constructor TVulkanCommandPool.Create(const aDevice:TVulkanDevice;
                                      const aQueueFamilyIndex:TVkUInt32;
                                      const aFlags:TVkCommandPoolCreateFlags=TVkCommandPoolCreateFlags(VK_COMMAND_POOL_CREATE_RESET_COMMAND_BUFFER_BIT));
var CommandPoolCreateInfo:TVkCommandPoolCreateInfo;
begin
 inherited Create;

 fDevice:=aDevice;

 fQueueFamilyIndex:=aQueueFamilyIndex;

 fFlags:=aFlags;

 fCommandPoolHandle:=VK_NULL_HANDLE;

 FillChar(CommandPoolCreateInfo,SizeOf(TVkCommandPoolCreateInfo),#0);
 CommandPoolCreateInfo.sType:=VK_STRUCTURE_TYPE_COMMAND_POOL_CREATE_INFO;
 CommandPoolCreateInfo.queueFamilyIndex:=fQueueFamilyIndex;
 CommandPoolCreateInfo.flags:=fFlags;
 HandleResultCode(fDevice.fDeviceVulkan.CreateCommandPool(fDevice.fDeviceHandle,@CommandPoolCreateInfo,fDevice.fAllocationCallbacks,@fCommandPoolHandle));

end;

destructor TVulkanCommandPool.Destroy;
begin
 if fCommandPoolHandle<>VK_NULL_HANDLE then begin
  fDevice.fDeviceVulkan.DestroyCommandPool(fDevice.fDeviceHandle,fCommandPoolHandle,fDevice.fAllocationCallbacks);
  fCommandPoolHandle:=VK_NULL_HANDLE;
 end;
 inherited Destroy;
end;

constructor TVulkanCommandBuffer.Create(const aCommandPool:TVulkanCommandPool;
                                        const aLevel:TVkCommandBufferLevel;
                                        const aCommandBufferHandle:TVkCommandBuffer);
begin

 fDevice:=aCommandPool.fDevice;

 fCommandPool:=aCommandPool;

 fLevel:=aLevel;

 fCommandBufferHandle:=aCommandBufferHandle;

{if fLevel=VK_COMMAND_BUFFER_LEVEL_PRIMARY then begin
  fFence:=TVulkanFence.Create(fDevice);
 end else begin
  fFence:=nil;
 end;{}

end;

constructor TVulkanCommandBuffer.Create(const aCommandPool:TVulkanCommandPool;
                                        const aLevel:TVkCommandBufferLevel=VK_COMMAND_BUFFER_LEVEL_PRIMARY);
var CommandBufferAllocateInfo:TVkCommandBufferAllocateInfo;
begin
 inherited Create;

 fDevice:=aCommandPool.fDevice;

 fCommandPool:=aCommandPool;

 fLevel:=aLevel;

 fCommandBufferHandle:=VK_NULL_HANDLE;

{if fLevel=VK_COMMAND_BUFFER_LEVEL_PRIMARY then begin
  fFence:=TVulkanFence.Create(fDevice);
 end else begin
  fFence:=nil;
 end;{}

 FillChar(CommandBufferAllocateInfo,SizeOf(TVkCommandBufferAllocateInfo),#0);
 CommandBufferAllocateInfo.sType:=VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO;
 CommandBufferAllocateInfo.commandPool:=fCommandPool.fCommandPoolHandle;
 CommandBufferAllocateInfo.level:=aLevel;
 CommandBufferAllocateInfo.commandBufferCount:=1;

 HandleResultCode(fDevice.fDeviceVulkan.AllocateCommandBuffers(fDevice.fDeviceHandle,@CommandBufferAllocateInfo,@fCommandBufferHandle));

end;

destructor TVulkanCommandBuffer.Destroy;
begin
 if fCommandBufferHandle<>VK_NULL_HANDLE then begin
  fDevice.fDeviceVulkan.FreeCommandBuffers(fDevice.fDeviceHandle,fCommandPool.fCommandPoolHandle,1,@fCommandBufferHandle);
  fCommandBufferHandle:=VK_NULL_HANDLE;
 end;
//FreeAndNil(fFence);
 inherited Destroy;
end;

class function TVulkanCommandBuffer.Allocate(const aCommandPool:TVulkanCommandPool;
                                             const aLevel:TVkCommandBufferLevel=VK_COMMAND_BUFFER_LEVEL_PRIMARY;
                                             const aCommandBufferCount:TVkUInt32=1):TVulkanObjectList;
var Index:TVkInt32;
    CommandBufferHandles:array of TVkCommandBuffer;
    CommandBufferAllocateInfo:TVkCommandBufferAllocateInfo;
begin
 result:=nil;
 CommandBufferHandles:=nil;
 try
  SetLength(CommandBufferHandles,aCommandBufferCount);

  FillChar(CommandBufferAllocateInfo,SizeOf(TVkCommandBufferAllocateInfo),#0);
  CommandBufferAllocateInfo.sType:=VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO;
  CommandBufferAllocateInfo.commandPool:=aCommandPool.fCommandPoolHandle;
  CommandBufferAllocateInfo.level:=aLevel;
  CommandBufferAllocateInfo.commandBufferCount:=aCommandBufferCount;

  HandleResultCode(aCommandPool.fDevice.fDeviceVulkan.AllocateCommandBuffers(aCommandPool.fDevice.fDeviceHandle,@CommandBufferAllocateInfo,@CommandBufferHandles[0]));

  result:=TVulkanObjectList.Create;
  for Index:=0 to aCommandBufferCount-1 do begin
   result.Add(TVulkanCommandBuffer.Create(aCommandPool,aLevel,CommandBufferHandles[Index]));
  end;

 finally
  SetLength(CommandBufferHandles,0);
 end;
end;

procedure TVulkanCommandBuffer.BeginRecording(const aFlags:TVkCommandBufferUsageFlags=0;const aInheritanceInfo:PVkCommandBufferInheritanceInfo=nil);
var CommandBufferBeginInfo:TVkCommandBufferBeginInfo;
begin
 FillChar(CommandBufferBeginInfo,SizeOf(TVkCommandBufferBeginInfo),#0);
 CommandBufferBeginInfo.sType:=VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO;
 CommandBufferBeginInfo.pNext:=nil;
 CommandBufferBeginInfo.flags:=aFlags;
 CommandBufferBeginInfo.pInheritanceInfo:=aInheritanceInfo;
 HandleResultCode(fDevice.fDeviceVulkan.BeginCommandBuffer(fCommandBufferHandle,@CommandBufferBeginInfo));
end;

procedure TVulkanCommandBuffer.BeginRecordingPrimary;
var CommandBufferBeginInfo:TVkCommandBufferBeginInfo;
begin
 if fLevel=VK_COMMAND_BUFFER_LEVEL_PRIMARY then begin
  FillChar(CommandBufferBeginInfo,SizeOf(TVkCommandBufferBeginInfo),#0);
  CommandBufferBeginInfo.sType:=VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO;
  CommandBufferBeginInfo.pNext:=nil;
  CommandBufferBeginInfo.flags:=0;
  CommandBufferBeginInfo.pInheritanceInfo:=nil;
  HandleResultCode(fDevice.fDeviceVulkan.BeginCommandBuffer(fCommandBufferHandle,@CommandBufferBeginInfo));
 end else begin
  raise EVulkanException.Create('BeginRecordingPrimary called from a non-primary command buffer!');
 end;
end;

procedure TVulkanCommandBuffer.BeginRecordingSecondary(const aRenderPass:TVkRenderPass;const aSubPass:TVkUInt32;const aFrameBuffer:TVkFramebuffer;const aOcclusionQueryEnable:boolean;const aQueryFlags:TVkQueryControlFlags;const aPipelineStatistics:TVkQueryPipelineStatisticFlags;const aFlags:TVkCommandBufferUsageFlags=TVkCommandBufferUsageFlags(VK_COMMAND_BUFFER_USAGE_RENDER_PASS_CONTINUE_BIT));
var CommandBufferBeginInfo:TVkCommandBufferBeginInfo;
    InheritanceInfo:TVkCommandBufferInheritanceInfo;
begin
 if fLevel=VK_COMMAND_BUFFER_LEVEL_SECONDARY then begin
  FillChar(InheritanceInfo,SizeOf(TVkCommandBufferInheritanceInfo),#0);
  InheritanceInfo.sType:=VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_INFO;
  InheritanceInfo.pNext:=nil;
  InheritanceInfo.renderPass:=aRenderPass;
  InheritanceInfo.subpass:=aSubPass;
  InheritanceInfo.framebuffer:=aFrameBuffer;
  if aOcclusionQueryEnable then begin
   InheritanceInfo.occlusionQueryEnable:=VK_TRUE;
  end else begin
   InheritanceInfo.occlusionQueryEnable:=VK_FALSE;
  end;
  InheritanceInfo.queryFlags:=aQueryFlags;
  InheritanceInfo.pipelineStatistics:=aPipelineStatistics;
  FillChar(CommandBufferBeginInfo,SizeOf(TVkCommandBufferBeginInfo),#0);
  CommandBufferBeginInfo.sType:=VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO;
  CommandBufferBeginInfo.pNext:=nil;
  CommandBufferBeginInfo.flags:=aFlags;
  CommandBufferBeginInfo.pInheritanceInfo:=@InheritanceInfo;
  HandleResultCode(fDevice.fDeviceVulkan.BeginCommandBuffer(fCommandBufferHandle,@CommandBufferBeginInfo));
 end else begin
  raise EVulkanException.Create('BeginRecordingSecondary called from a non-secondary command buffer!');
 end;
end;

procedure TVulkanCommandBuffer.EndRecording;
begin
 HandleResultCode(fDevice.fDeviceVulkan.EndCommandBuffer(fCommandBufferHandle));
end;

procedure TVulkanCommandBuffer.Reset(const aFlags:TVkCommandBufferResetFlags=TVkCommandBufferResetFlags(VK_COMMAND_BUFFER_RESET_RELEASE_RESOURCES_BIT));
begin
 HandleResultCode(fDevice.fDeviceVulkan.ResetCommandBuffer(fCommandBufferHandle,aFlags));
end;

procedure TVulkanCommandBuffer.CmdBindPipeline(pipelineBindPoint:TVkPipelineBindPoint;pipeline:TVkPipeline);
begin
 fDevice.fDeviceVulkan.CmdBindPipeline(fCommandBufferHandle,pipelineBindPoint,pipeline);
end;

procedure TVulkanCommandBuffer.CmdSetViewport(firstViewport:TVkUInt32;viewportCount:TVkUInt32;const aViewports:PVkViewport);
begin
 fDevice.fDeviceVulkan.CmdSetViewport(fCommandBufferHandle,firstViewport,viewportCount,aViewports);
end;

procedure TVulkanCommandBuffer.CmdSetScissor(firstScissor:TVkUInt32;scissorCount:TVkUInt32;const aScissors:PVkRect2D);
begin
 fDevice.fDeviceVulkan.CmdSetScissor(fCommandBufferHandle,firstScissor,scissorCount,aScissors);
end;

procedure TVulkanCommandBuffer.CmdSetLineWidth(lineWidth:TVkFloat);
begin
 fDevice.fDeviceVulkan.CmdSetLineWidth(fCommandBufferHandle,lineWidth);
end;

procedure TVulkanCommandBuffer.CmdSetDepthBias(depthBiasConstantFactor:TVkFloat;depthBiasClamp:TVkFloat;depthBiasSlopeFactor:TVkFloat);
begin
 fDevice.fDeviceVulkan.CmdSetDepthBias(fCommandBufferHandle,depthBiasConstantFactor,depthBiasClamp,depthBiasSlopeFactor);
end;

procedure TVulkanCommandBuffer.CmdSetBlendConstants(const blendConstants:TVkFloat);
begin
 fDevice.fDeviceVulkan.CmdSetBlendConstants(fCommandBufferHandle,blendConstants);
end;

procedure TVulkanCommandBuffer.CmdSetDepthBounds(minDepthBounds:TVkFloat;maxDepthBounds:TVkFloat);
begin
 fDevice.fDeviceVulkan.CmdSetDepthBounds(fCommandBufferHandle,minDepthBounds,maxDepthBounds);
end;

procedure TVulkanCommandBuffer.CmdSetStencilCompareMask(faceMask:TVkStencilFaceFlags;compareMask:TVkUInt32);
begin
 fDevice.fDeviceVulkan.CmdSetStencilCompareMask(fCommandBufferHandle,faceMask,compareMask);
end;

procedure TVulkanCommandBuffer.CmdSetStencilWriteMask(faceMask:TVkStencilFaceFlags;writeMask:TVkUInt32);
begin
 fDevice.fDeviceVulkan.CmdSetStencilWriteMask(fCommandBufferHandle,faceMask,writeMask);
end;

procedure TVulkanCommandBuffer.CmdSetStencilReference(faceMask:TVkStencilFaceFlags;reference:TVkUInt32);
begin
 fDevice.fDeviceVulkan.CmdSetStencilReference(fCommandBufferHandle,faceMask,reference);
end;

procedure TVulkanCommandBuffer.CmdBindDescriptorSets(pipelineBindPoint:TVkPipelineBindPoint;layout:TVkPipelineLayout;firstSet:TVkUInt32;descriptorSetCount:TVkUInt32;const aDescriptorSets:PVkDescriptorSet;dynamicOffsetCount:TVkUInt32;const aDynamicOffsets:PVkUInt32);
begin
 fDevice.fDeviceVulkan.CmdBindDescriptorSets(fCommandBufferHandle,pipelineBindPoint,layout,firstSet,descriptorSetCount,aDescriptorSets,dynamicOffsetCount,aDynamicOffsets);
end;

procedure TVulkanCommandBuffer.CmdBindIndexBuffer(buffer:TVkBuffer;offset:TVkDeviceSize;indexType:TVkIndexType);
begin
 fDevice.fDeviceVulkan.CmdBindIndexBuffer(fCommandBufferHandle,buffer,offset,indexType);
end;

procedure TVulkanCommandBuffer.CmdBindVertexBuffers(firstBinding:TVkUInt32;bindingCount:TVkUInt32;const aBuffers:PVkBuffer;const aOffsets:PVkDeviceSize);
begin
 fDevice.fDeviceVulkan.CmdBindVertexBuffers(fCommandBufferHandle,firstBinding,bindingCount,aBuffers,aOffsets);
end;

procedure TVulkanCommandBuffer.CmdDraw(vertexCount:TVkUInt32;instanceCount:TVkUInt32;firstVertex:TVkUInt32;firstInstance:TVkUInt32);
begin
 fDevice.fDeviceVulkan.CmdDraw(fCommandBufferHandle,vertexCount,instanceCount,firstVertex,firstInstance);
end;

procedure TVulkanCommandBuffer.CmdDrawIndexed(indexCount:TVkUInt32;instanceCount:TVkUInt32;firstIndex:TVkUInt32;vertexOffset:TVkInt32;firstInstance:TVkUInt32);
begin
 fDevice.fDeviceVulkan.CmdDrawIndexed(fCommandBufferHandle,indexCount,instanceCount,firstIndex,vertexOffset,firstInstance);
end;

procedure TVulkanCommandBuffer.CmdDrawIndirect(buffer:TVkBuffer;offset:TVkDeviceSize;drawCount:TVkUInt32;stride:TVkUInt32);
begin
 fDevice.fDeviceVulkan.CmdDrawIndirect(fCommandBufferHandle,buffer,offset,drawCount,stride);
end;

procedure TVulkanCommandBuffer.CmdDrawIndexedIndirect(buffer:TVkBuffer;offset:TVkDeviceSize;drawCount:TVkUInt32;stride:TVkUInt32);
begin
 fDevice.fDeviceVulkan.CmdDrawIndexedIndirect(fCommandBufferHandle,buffer,offset,drawCount,stride);
end;

procedure TVulkanCommandBuffer.CmdDispatch(x:TVkUInt32;y:TVkUInt32;z:TVkUInt32);
begin
 fDevice.fDeviceVulkan.CmdDispatch(fCommandBufferHandle,x,y,z);
end;

procedure TVulkanCommandBuffer.CmdDispatchIndirect(buffer:TVkBuffer;offset:TVkDeviceSize);
begin
 fDevice.fDeviceVulkan.CmdDispatchIndirect(fCommandBufferHandle,buffer,offset);
end;

procedure TVulkanCommandBuffer.CmdCopyBuffer(srcBuffer:TVkBuffer;dstBuffer:TVkBuffer;regionCount:TVkUInt32;const aRegions:PVkBufferCopy);
begin
 fDevice.fDeviceVulkan.CmdCopyBuffer(fCommandBufferHandle,srcBuffer,dstBuffer,regionCount,aRegions);
end;

procedure TVulkanCommandBuffer.CmdCopyImage(srcImage:TVkImage;srcImageLayout:TVkImageLayout;dstImage:TVkImage;dstImageLayout:TVkImageLayout;regionCount:TVkUInt32;const aRegions:PVkImageCopy);
begin
 fDevice.fDeviceVulkan.CmdCopyImage(fCommandBufferHandle,srcImage,srcImageLayout,dstImage,dstImageLayout,regionCount,aRegions);
end;

procedure TVulkanCommandBuffer.CmdBlitImage(srcImage:TVkImage;srcImageLayout:TVkImageLayout;dstImage:TVkImage;dstImageLayout:TVkImageLayout;regionCount:TVkUInt32;const aRegions:PVkImageBlit;filter:TVkFilter);
begin
 fDevice.fDeviceVulkan.CmdBlitImage(fCommandBufferHandle,srcImage,srcImageLayout,dstImage,dstImageLayout,regionCount,aRegions,filter);
end;

procedure TVulkanCommandBuffer.CmdCopyBufferToImage(srcBuffer:TVkBuffer;dstImage:TVkImage;dstImageLayout:TVkImageLayout;regionCount:TVkUInt32;const aRegions:PVkBufferImageCopy);
begin
 fDevice.fDeviceVulkan.CmdCopyBufferToImage(fCommandBufferHandle,srcBuffer,dstImage,dstImageLayout,regionCount,aRegions);
end;

procedure TVulkanCommandBuffer.CmdCopyImageToBuffer(srcImage:TVkImage;srcImageLayout:TVkImageLayout;dstBuffer:TVkBuffer;regionCount:TVkUInt32;const aRegions:PVkBufferImageCopy);
begin
 fDevice.fDeviceVulkan.CmdCopyImageToBuffer(fCommandBufferHandle,srcImage,srcImageLayout,dstBuffer,regionCount,aRegions);
end;                                                                                             

procedure TVulkanCommandBuffer.CmdUpdateBuffer(dstBuffer:TVkBuffer;dstOffset:TVkDeviceSize;dataSize:TVkDeviceSize;const aData:PVkVoid);
begin
 fDevice.fDeviceVulkan.CmdUpdateBuffer(fCommandBufferHandle,dstBuffer,dstOffset,dataSize,aData);
end;

procedure TVulkanCommandBuffer.CmdFillBuffer(dstBuffer:TVkBuffer;dstOffset:TVkDeviceSize;size:TVkDeviceSize;data:TVkUInt32);
begin
 fDevice.fDeviceVulkan.CmdFillBuffer(fCommandBufferHandle,dstBuffer,dstOffset,size,data);
end;

procedure TVulkanCommandBuffer.CmdClearColorImage(image:TVkImage;imageLayout:TVkImageLayout;const aColor:PVkClearColorValue;rangeCount:TVkUInt32;const aRanges:PVkImageSubresourceRange);
begin
 fDevice.fDeviceVulkan.CmdClearColorImage(fCommandBufferHandle,image,imageLayout,aColor,rangeCount,aRanges);
end;

procedure TVulkanCommandBuffer.CmdClearDepthStencilImage(image:TVkImage;imageLayout:TVkImageLayout;const aDepthStencil:PVkClearDepthStencilValue;rangeCount:TVkUInt32;const aRanges:PVkImageSubresourceRange);
begin
 fDevice.fDeviceVulkan.CmdClearDepthStencilImage(fCommandBufferHandle,image,imageLayout,aDepthStencil,rangeCount,aRanges);
end;

procedure TVulkanCommandBuffer.CmdClearAttachments(attachmentCount:TVkUInt32;const aAttachments:PVkClearAttachment;rectCount:TVkUInt32;const aRects:PVkClearRect);
begin
 fDevice.fDeviceVulkan.CmdClearAttachments(fCommandBufferHandle,attachmentCount,aAttachments,rectCount,aRects);
end;

procedure TVulkanCommandBuffer.CmdResolveImage(srcImage:TVkImage;srcImageLayout:TVkImageLayout;dstImage:TVkImage;dstImageLayout:TVkImageLayout;regionCount:TVkUInt32;const aRegions:PVkImageResolve);
begin
 fDevice.fDeviceVulkan.CmdResolveImage(fCommandBufferHandle,srcImage,srcImageLayout,dstImage,dstImageLayout,regionCount,aRegions);
end;

procedure TVulkanCommandBuffer.CmdSetEvent(event:TVkEvent;stageMask:TVkPipelineStageFlags);
begin
 fDevice.fDeviceVulkan.CmdSetEvent(fCommandBufferHandle,event,stageMask);
end;

procedure TVulkanCommandBuffer.CmdResetEvent(event:TVkEvent;stageMask:TVkPipelineStageFlags);
begin
 fDevice.fDeviceVulkan.CmdResetEvent(fCommandBufferHandle,event,stageMask);
end;

procedure TVulkanCommandBuffer.CmdWaitEvents(eventCount:TVkUInt32;const aEvents:PVkEvent;srcStageMask:TVkPipelineStageFlags;dstStageMask:TVkPipelineStageFlags;memoryBarrierCount:TVkUInt32;const aMemoryBarriers:PVkMemoryBarrier;bufferMemoryBarrierCount:TVkUInt32;const aBufferMemoryBarriers:PVkBufferMemoryBarrier;imageMemoryBarrierCount:TVkUInt32;const aImageMemoryBarriers:PVkImageMemoryBarrier);
begin
 fDevice.fDeviceVulkan.CmdWaitEvents(fCommandBufferHandle,eventCount,aEvents,srcStageMask,dstStageMask,memoryBarrierCount,aMemoryBarriers,bufferMemoryBarrierCount,aBufferMemoryBarriers,imageMemoryBarrierCount,aImageMemoryBarriers);
end;

procedure TVulkanCommandBuffer.CmdPipelineBarrier(srcStageMask:TVkPipelineStageFlags;dstStageMask:TVkPipelineStageFlags;dependencyFlags:TVkDependencyFlags;memoryBarrierCount:TVkUInt32;const aMemoryBarriers:PVkMemoryBarrier;bufferMemoryBarrierCount:TVkUInt32;const aBufferMemoryBarriers:PVkBufferMemoryBarrier;imageMemoryBarrierCount:TVkUInt32;const aImageMemoryBarriers:PVkImageMemoryBarrier);
begin
 fDevice.fDeviceVulkan.CmdPipelineBarrier(fCommandBufferHandle,srcStageMask,dstStageMask,dependencyFlags,memoryBarrierCount,aMemoryBarriers,bufferMemoryBarrierCount,aBufferMemoryBarriers,imageMemoryBarrierCount,aImageMemoryBarriers);
end;

procedure TVulkanCommandBuffer.CmdBeginQuery(queryPool:TVkQueryPool;query:TVkUInt32;flags:TVkQueryControlFlags);
begin
 fDevice.fDeviceVulkan.CmdBeginQuery(fCommandBufferHandle,queryPool,query,flags);
end;

procedure TVulkanCommandBuffer.CmdEndQuery(queryPool:TVkQueryPool;query:TVkUInt32);
begin
 fDevice.fDeviceVulkan.CmdEndQuery(fCommandBufferHandle,queryPool,query);
end;

procedure TVulkanCommandBuffer.CmdResetQueryPool(queryPool:TVkQueryPool;firstQuery:TVkUInt32;queryCount:TVkUInt32);
begin
 fDevice.fDeviceVulkan.CmdResetQueryPool(fCommandBufferHandle,queryPool,firstQuery,queryCount);
end;

procedure TVulkanCommandBuffer.CmdWriteTimestamp(pipelineStage:TVkPipelineStageFlagBits;queryPool:TVkQueryPool;query:TVkUInt32);
begin
 fDevice.fDeviceVulkan.CmdWriteTimestamp(fCommandBufferHandle,pipelineStage,queryPool,query);
end;

procedure TVulkanCommandBuffer.CmdCopyQueryPoolResults(queryPool:TVkQueryPool;firstQuery:TVkUInt32;queryCount:TVkUInt32;dstBuffer:TVkBuffer;dstOffset:TVkDeviceSize;stride:TVkDeviceSize;flags:TVkQueryResultFlags);
begin
 fDevice.fDeviceVulkan.CmdCopyQueryPoolResults(fCommandBufferHandle,queryPool,firstQuery,queryCount,dstBuffer,dstOffset,stride,flags);
end;

procedure TVulkanCommandBuffer.CmdPushConstants(layout:TVkPipelineLayout;stageFlags:TVkShaderStageFlags;offset:TVkUInt32;size:TVkUInt32;const aValues:PVkVoid);
begin
 fDevice.fDeviceVulkan.CmdPushConstants(fCommandBufferHandle,layout,stageFlags,offset,size,aValues);
end;

procedure TVulkanCommandBuffer.CmdBeginRenderPass(const aRenderPassBegin:PVkRenderPassBeginInfo;contents:TVkSubpassContents);
begin
 fDevice.fDeviceVulkan.CmdBeginRenderPass(fCommandBufferHandle,aRenderPassBegin,contents);
end;

procedure TVulkanCommandBuffer.CmdNextSubpass(contents:TVkSubpassContents);
begin
 fDevice.fDeviceVulkan.CmdNextSubpass(fCommandBufferHandle,contents);
end;

procedure TVulkanCommandBuffer.CmdEndRenderPass;
begin
 fDevice.fDeviceVulkan.CmdEndRenderPass(fCommandBufferHandle);
end;

procedure TVulkanCommandBuffer.CmdExecuteCommands(commandBufferCount:TVkUInt32;const aCommandBuffers:PVkCommandBuffer);
begin
 fDevice.fDeviceVulkan.CmdExecuteCommands(fCommandBufferHandle,commandBufferCount,aCommandBuffers);
end;

procedure TVulkanCommandBuffer.CmdExecute(const aCommandBuffer:TVulkanCommandBuffer);
begin
 CmdExecuteCommands(1,@aCommandBuffer.fCommandBufferHandle);
end;

procedure TVulkanCommandBuffer.MetaCmdPresentToDrawImageBarrier(const aImage:TVulkanImage;const aDoTransitionToColorAttachmentOptimalLayout:boolean=true);
var ImageMemoryBarrier:TVkImageMemoryBarrier;
begin
 FillChar(ImageMemoryBarrier,SizeOf(TVkImageMemoryBarrier),#0);
 ImageMemoryBarrier.sType:=VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER;
 ImageMemoryBarrier.pNext:=nil;
 ImageMemoryBarrier.srcAccessMask:=TVkAccessFlags(VK_ACCESS_MEMORY_READ_BIT);
 ImageMemoryBarrier.dstAccessMask:=TVkAccessFlags(VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT);
 if aDoTransitionToColorAttachmentOptimalLayout then begin
  ImageMemoryBarrier.oldLayout:=VK_IMAGE_LAYOUT_PRESENT_SRC_KHR;
  ImageMemoryBarrier.newLayout:=VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL;
 end else begin
  ImageMemoryBarrier.oldLayout:=VK_IMAGE_LAYOUT_PRESENT_SRC_KHR;
  ImageMemoryBarrier.newLayout:=VK_IMAGE_LAYOUT_PRESENT_SRC_KHR;
 end;
 if (fDevice.fPresentQueueFamilyIndex<>fDevice.fGraphicsQueueFamilyIndex) or
    ((assigned(fDevice.fPresentQueue) and assigned(fDevice.fGraphicsQueue)) and
     (fDevice.fPresentQueue<>fDevice.fGraphicsQueue)) then begin
  ImageMemoryBarrier.srcQueueFamilyIndex:=fDevice.fPresentQueueFamilyIndex;
  ImageMemoryBarrier.dstQueueFamilyIndex:=fDevice.fGraphicsQueueFamilyIndex;
 end else begin
  ImageMemoryBarrier.srcQueueFamilyIndex:=VK_QUEUE_FAMILY_IGNORED;
  ImageMemoryBarrier.dstQueueFamilyIndex:=VK_QUEUE_FAMILY_IGNORED;
 end;
 ImageMemoryBarrier.image:=aImage.fImageHandle;
 ImageMemoryBarrier.subresourceRange.aspectMask:=TVkImageAspectFlags(VK_IMAGE_ASPECT_COLOR_BIT);
 ImageMemoryBarrier.subresourceRange.baseMipLevel:=0;
 ImageMemoryBarrier.subresourceRange.levelCount:=1;
 ImageMemoryBarrier.subresourceRange.baseArrayLayer:=0;
 ImageMemoryBarrier.subresourceRange.layerCount:=1;
 CmdPipelineBarrier(TVkPipelineStageFlags(VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT),
                    TVkPipelineStageFlags(VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT),
                    0,
                    0,nil,
                    0,nil,
                    1,@ImageMemoryBarrier);
end;

procedure TVulkanCommandBuffer.MetaCmdDrawToPresentImageBarrier(const aImage:TVulkanImage;const aDoTransitionToPresentSrcLayout:boolean=true);
var ImageMemoryBarrier:TVkImageMemoryBarrier;
begin
 FillChar(ImageMemoryBarrier,SizeOf(TVkImageMemoryBarrier),#0);
 ImageMemoryBarrier.sType:=VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER;
 ImageMemoryBarrier.pNext:=nil;
 ImageMemoryBarrier.srcAccessMask:=TVkAccessFlags(VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT);
 ImageMemoryBarrier.dstAccessMask:=TVkAccessFlags(VK_ACCESS_MEMORY_READ_BIT);
 if aDoTransitionToPresentSrcLayout then begin
  ImageMemoryBarrier.oldLayout:=VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL;
  ImageMemoryBarrier.newLayout:=VK_IMAGE_LAYOUT_PRESENT_SRC_KHR;
 end else begin
  ImageMemoryBarrier.oldLayout:=VK_IMAGE_LAYOUT_PRESENT_SRC_KHR;
  ImageMemoryBarrier.newLayout:=VK_IMAGE_LAYOUT_PRESENT_SRC_KHR;
 end;
 if (fDevice.fPresentQueueFamilyIndex<>fDevice.fGraphicsQueueFamilyIndex) or
    ((assigned(fDevice.fPresentQueue) and assigned(fDevice.fGraphicsQueue)) and
     (fDevice.fPresentQueue<>fDevice.fGraphicsQueue)) then begin
  ImageMemoryBarrier.srcQueueFamilyIndex:=fDevice.fGraphicsQueueFamilyIndex;
  ImageMemoryBarrier.dstQueueFamilyIndex:=fDevice.fPresentQueueFamilyIndex;
 end else begin
  ImageMemoryBarrier.srcQueueFamilyIndex:=VK_QUEUE_FAMILY_IGNORED;
  ImageMemoryBarrier.dstQueueFamilyIndex:=VK_QUEUE_FAMILY_IGNORED;
 end;
 ImageMemoryBarrier.image:=aImage.fImageHandle;
 ImageMemoryBarrier.subresourceRange.aspectMask:=TVkImageAspectFlags(VK_IMAGE_ASPECT_COLOR_BIT);
 ImageMemoryBarrier.subresourceRange.baseMipLevel:=0;
 ImageMemoryBarrier.subresourceRange.levelCount:=1;
 ImageMemoryBarrier.subresourceRange.baseArrayLayer:=0;
 ImageMemoryBarrier.subresourceRange.layerCount:=1;
 CmdPipelineBarrier(TVkPipelineStageFlags(VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT),
                    TVkPipelineStageFlags(VK_PIPELINE_STAGE_BOTTOM_OF_PIPE_BIT),
                    0,
                    0,nil,
                    0,nil,
                    1,@ImageMemoryBarrier);
end;

procedure TVulkanCommandBuffer.MetaCmdMemoryBarrier(const aSrcStageMask,aDstStageMask:TVkPipelineStageFlags;const aSrcAccessMask,aDstAccessMask:TVkAccessFlags);
var MemoryBarrier:TVkMemoryBarrier;
begin
 MemoryBarrier.sType:=VK_STRUCTURE_TYPE_MEMORY_BARRIER;;
 MemoryBarrier.pNext:=nil;
 MemoryBarrier.srcAccessMask:=aSrcAccessMask;
 MemoryBarrier.dstAccessMask:=aDstAccessMask;
 CmdPipelineBarrier(aSrcStageMask,
                    aDstStageMask,
                    0,
                    1,@MemoryBarrier,
                    0,nil,
                    0,nil);
end;

procedure TVulkanCommandBuffer.Execute(const aQueue:TVulkanQueue;const aWaitDstStageFlags:TVkPipelineStageFlags;const aWaitSemaphore:TVulkanSemaphore=nil;const aSignalSemaphore:TVulkanSemaphore=nil;const aFence:TVulkanFence=nil;const aDoWaitAndResetFence:boolean=true);
var SubmitInfo:TVkSubmitInfo;
begin
 if fLevel=VK_COMMAND_BUFFER_LEVEL_PRIMARY then begin

  FillChar(SubmitInfo,SizeOf(TVkSubmitInfo),#0);
  SubmitInfo.sType:=VK_STRUCTURE_TYPE_SUBMIT_INFO;
  SubmitInfo.pNext:=nil;
  if assigned(aWaitSemaphore) then begin
   SubmitInfo.waitSemaphoreCount:=1;
   SubmitInfo.pWaitSemaphores:=@aWaitSemaphore.fSemaphoreHandle;
   SubmitInfo.pWaitDstStageMask:=@aWaitDstStageFlags;
  end else begin
   SubmitInfo.waitSemaphoreCount:=0;
   SubmitInfo.pWaitSemaphores:=nil;
   SubmitInfo.pWaitDstStageMask:=nil;
  end;
  SubmitInfo.commandBufferCount:=1;
  SubmitInfo.pCommandBuffers:=@fCommandBufferHandle;
  if assigned(aSignalSemaphore) then begin
   SubmitInfo.signalSemaphoreCount:=1;
   SubmitInfo.pSignalSemaphores:=@aSignalSemaphore.fSemaphoreHandle;
  end else begin
   SubmitInfo.signalSemaphoreCount:=0;
   SubmitInfo.pSignalSemaphores:=nil;
  end;

  if assigned(aFence) then begin

   aQueue.Submit(1,@SubmitInfo,aFence);

   if aDoWaitAndResetFence then begin
    aFence.WaitFor;
    aFence.Reset;
   end;

  end else begin

   aQueue.Submit(1,@SubmitInfo,nil);

  end;

 end else begin
  raise EVulkanException.Create('Execute called from a non-primary command buffer!');
 end;
end;

constructor TVulkanCommandBufferSubmitQueue.Create(const aQueue:TVulkanQueue);
begin
 inherited Create;
 fDevice:=aQueue.fDevice;
 fQueue:=aQueue;
 fSubmitInfos:=nil;
 fSubmitInfoWaitSemaphores:=nil;
 fSubmitInfoWaitDstStageFlags:=nil;
 fSubmitInfoSignalSemaphores:=nil;
 fCountSubmitInfos:=0;
end;

destructor TVulkanCommandBufferSubmitQueue.Destroy;
begin
 fSubmitInfos:=nil;
 fSubmitInfoWaitSemaphores:=nil;
 fSubmitInfoWaitDstStageFlags:=nil;
 fSubmitInfoSignalSemaphores:=nil;
 fCountSubmitInfos:=0;
 inherited Destroy;
end;

procedure TVulkanCommandBufferSubmitQueue.Reset;
begin
 fCountSubmitInfos:=0;
end;
                                                 
procedure TVulkanCommandBufferSubmitQueue.QueueSubmit(const aCommandBuffer:TVulkanCommandBuffer;const aWaitDstStageFlags:TVkPipelineStageFlags;const aWaitSemaphore:TVulkanSemaphore=nil;const aSignalSemaphore:TVulkanSemaphore=nil);
var Index:TVkInt32;
    SubmitInfo:PVkSubmitInfo;
begin
 if aCommandBuffer.fLevel=VK_COMMAND_BUFFER_LEVEL_PRIMARY then begin

  Index:=fCountSubmitInfos;
  inc(fCountSubmitInfos);
  if length(fSubmitInfos)<fCountSubmitInfos then begin
   SetLength(fSubmitInfos,fCountSubmitInfos*2);
   SetLength(fSubmitInfoWaitSemaphores,fCountSubmitInfos*2);
   SetLength(fSubmitInfoWaitDstStageFlags,fCountSubmitInfos*2);
   SetLength(fSubmitInfoSignalSemaphores,fCountSubmitInfos*2);
  end;
  SubmitInfo:=@fSubmitInfos[Index];

  FillChar(SubmitInfo^,SizeOf(TVkSubmitInfo),#0);
  SubmitInfo^.sType:=VK_STRUCTURE_TYPE_SUBMIT_INFO;
  SubmitInfo^.pNext:=nil;
  if assigned(aWaitSemaphore) then begin
   SubmitInfo^.waitSemaphoreCount:=1;
   fSubmitInfoWaitSemaphores[Index]:=aWaitSemaphore.fSemaphoreHandle;
   fSubmitInfoWaitDstStageFlags[Index]:=aWaitDstStageFlags;
  end else begin
   SubmitInfo^.waitSemaphoreCount:=0;
   fSubmitInfoWaitSemaphores[Index]:=VK_NULL_HANDLE;
   fSubmitInfoWaitDstStageFlags[Index]:=0;
  end;
  SubmitInfo^.pWaitSemaphores:=nil;
  SubmitInfo^.pWaitDstStageMask:=nil;
  SubmitInfo^.commandBufferCount:=1;
  SubmitInfo^.pCommandBuffers:=@aCommandBuffer.fCommandBufferHandle;
  if assigned(aSignalSemaphore) then begin
   SubmitInfo^.signalSemaphoreCount:=1;
   fSubmitInfoSignalSemaphores[Index]:=aSignalSemaphore.fSemaphoreHandle;
  end else begin
   SubmitInfo^.signalSemaphoreCount:=0;
   fSubmitInfoSignalSemaphores[Index]:=VK_NULL_HANDLE;
  end;
  SubmitInfo^.pSignalSemaphores:=nil;

 end else begin
  raise EVulkanException.Create('Execute called from a non-primary command buffer!');
 end;
end;

procedure TVulkanCommandBufferSubmitQueue.SubmitQueued(const aFence:TVulkanFence=nil;const aDoWaitAndResetFence:boolean=true);
var Index:TVkInt32;
    SubmitInfo:PVkSubmitInfo;
begin

 if fCountSubmitInfos>0 then begin

  for Index:=0 to fCountSubmitInfos-1 do begin
   SubmitInfo:=@fSubmitInfos[Index];
   if SubmitInfo^.waitSemaphoreCount>0 then begin
    SubmitInfo^.pWaitSemaphores:=@fSubmitInfoWaitSemaphores[Index];
    SubmitInfo^.pWaitDstStageMask:=@fSubmitInfoWaitDstStageFlags[Index];
   end else begin
    SubmitInfo^.pWaitSemaphores:=nil;
    SubmitInfo^.pWaitDstStageMask:=nil;
   end;
   if SubmitInfo^.signalSemaphoreCount>0 then begin
    SubmitInfo^.pSignalSemaphores:=@fSubmitInfoSignalSemaphores[Index];
   end else begin
    SubmitInfo^.pSignalSemaphores:=nil;
   end;
  end;

  if assigned(aFence) then begin

   fQueue.Submit(fCountSubmitInfos,@fSubmitInfos[0],aFence);

   if aDoWaitAndResetFence then begin
    aFence.WaitFor;
    aFence.Reset;
   end;

  end else begin

   fQueue.Submit(fCountSubmitInfos,@fSubmitInfos[0],nil);

  end;

 end else begin

  if aDoWaitAndResetFence then begin
   aFence.Reset;
  end;

 end;

end;

constructor TVulkanRenderPass.Create(const aDevice:TVulkanDevice);
begin
 inherited Create;

 fDevice:=aDevice;

 fRenderPassHandle:=VK_NULL_HANDLE;

 fAttachmentDescriptions:=nil;
 fCountAttachmentDescriptions:=0;

 fAttachmentReferences:=nil;
 fCountAttachmentReferences:=0;

 fRenderPassSubpassDescriptions:=nil;
 fSubpassDescriptions:=nil;
 fCountSubpassDescriptions:=0;

 fSubpassDependencies:=nil;
 fCountSubpassDependencies:=0;

 fClearValues:=nil;

end;

destructor TVulkanRenderPass.Destroy;
begin
 if fRenderPassHandle<>VK_NULL_HANDLE then begin
  fDevice.fDeviceVulkan.DestroyRenderPass(fDevice.fDeviceHandle,fRenderPassHandle,fDevice.fAllocationCallbacks);
  fRenderPassHandle:=VK_NULL_HANDLE;
 end;
 SetLength(fAttachmentDescriptions,0);
 SetLength(fAttachmentReferences,0);
 SetLength(fRenderPassSubpassDescriptions,0);
 SetLength(fSubpassDescriptions,0);
 SetLength(fSubpassDependencies,0);
 SetLength(fClearValues,0);
 inherited Destroy;
end;

function TVulkanRenderPass.GetClearValue(const Index:TVkUInt32):PVkClearValue;
begin
 result:=@fClearValues[Index];
end;

function TVulkanRenderPass.AddAttachmentDescription(const aFlags:TVkAttachmentDescriptionFlags;
                                                    const aFormat:TVkFormat;
                                                    const aSamples:TVkSampleCountFlagBits;
                                                    const aLoadOp:TVkAttachmentLoadOp;
                                                    const aStoreOp:TVkAttachmentStoreOp;
                                                    const aStencilLoadOp:TVkAttachmentLoadOp;
                                                    const aStencilStoreOp:TVkAttachmentStoreOp;
                                                    const aInitialLayout:TVkImageLayout;
                                                    const aFinalLayout:TVkImageLayout):TVkUInt32;
var AttachmentDescription:PVkAttachmentDescription;
begin
 result:=fCountAttachmentDescriptions;
 inc(fCountAttachmentDescriptions);
 if fCountAttachmentDescriptions>length(fAttachmentDescriptions) then begin
  SetLength(fAttachmentDescriptions,fCountAttachmentDescriptions*2);
 end;
 AttachmentDescription:=@fAttachmentDescriptions[result];
 AttachmentDescription^.flags:=aFlags;
 AttachmentDescription^.format:=aFormat;
 AttachmentDescription^.samples:=aSamples;
 AttachmentDescription^.loadOp:=aLoadOp;
 AttachmentDescription^.storeOp:=aStoreOp;
 AttachmentDescription^.stencilLoadOp:=aStencilLoadOp;
 AttachmentDescription^.stencilStoreOp:=aStencilStoreOp;
 AttachmentDescription^.initialLayout:=aInitialLayout;
 AttachmentDescription^.finalLayout:=aFinalLayout;
end;

function TVulkanRenderPass.AddAttachmentReference(const aAttachment:TVkUInt32;
                                                  const aLayout:TVkImageLayout):TVkUInt32;
var AttachmentReference:PVkAttachmentReference;
begin
 result:=fCountAttachmentReferences;
 inc(fCountAttachmentReferences);
 if fCountAttachmentReferences>length(fAttachmentReferences) then begin
  SetLength(fAttachmentReferences,fCountAttachmentReferences*2);
 end;
 AttachmentReference:=@fAttachmentReferences[result];
 AttachmentReference^.attachment:=aAttachment;
 AttachmentReference^.layout:=aLayout;
end;

function TVulkanRenderPass.AddSubpassDescription(const aFlags:TVkSubpassDescriptionFlags;
                                                 const aPipelineBindPoint:TVkPipelineBindPoint;
                                                 const aInputAttachments:array of TVkInt32;
                                                 const aColorAttachments:array of TVkInt32;
                                                 const aResolveAttachments:array of TVkInt32;
                                                 const aDepthStencilAttachment:TVkInt32;
                                                 const aPreserveAttachments:array of TVkUInt32):TVkUInt32;
var RenderPassSubpassDescription:PVulkanRenderPassSubpassDescription;
begin
 result:=fCountSubpassDescriptions;
 inc(fCountSubpassDescriptions);
 if fCountSubpassDescriptions>length(fRenderPassSubpassDescriptions) then begin
  SetLength(fRenderPassSubpassDescriptions,fCountSubpassDescriptions*2);
 end;
 RenderPassSubpassDescription:=@fRenderPassSubpassDescriptions[result];
 RenderPassSubpassDescription^.Flags:=aFlags;
 RenderPassSubpassDescription^.PipelineBindPoint:=aPipelineBindPoint;
 begin
  SetLength(RenderPassSubpassDescription^.InputAttachments,length(aInputAttachments));
  if length(aInputAttachments)>0 then begin
   Move(aInputAttachments[0],RenderPassSubpassDescription^.InputAttachments[0],length(aInputAttachments)*SizeOf(TVkInt32));
  end;
 end;
 begin
  SetLength(RenderPassSubpassDescription^.ColorAttachments,length(aColorAttachments));
  if length(aColorAttachments)>0 then begin
   Move(aColorAttachments[0],RenderPassSubpassDescription^.ColorAttachments[0],length(aColorAttachments)*SizeOf(TVkInt32));
  end;
 end;
 begin
  SetLength(RenderPassSubpassDescription^.ResolveAttachments,length(aResolveAttachments));
  if length(aResolveAttachments)>0 then begin
   Move(aResolveAttachments[0],RenderPassSubpassDescription^.ResolveAttachments[0],length(aResolveAttachments)*SizeOf(TVkInt32));
  end;
 end;
 RenderPassSubpassDescription^.DepthStencilAttachment:=aDepthStencilAttachment;
 begin
  SetLength(RenderPassSubpassDescription^.PreserveAttachments,length(aPreserveAttachments));
  if length(aPreserveAttachments)>0 then begin
   Move(aPreserveAttachments[0],RenderPassSubpassDescription^.PreserveAttachments[0],length(aPreserveAttachments)*SizeOf(TVkUInt32));
  end;
 end;
end;

function TVulkanRenderPass.AddSubpassDependency(const aSrcSubpass:TVkUInt32;
                                                const aDstSubpass:TVkUInt32;
                                                const aSrcStageMask:TVkPipelineStageFlags;
                                                const aDstStageMask:TVkPipelineStageFlags;
                                                const aSrcAccessMask:TVkAccessFlags;
                                                const aDstAccessMask:TVkAccessFlags;
                                                const aDependencyFlags:TVkDependencyFlags):TVkUInt32;
var SubpassDependency:PVkSubpassDependency;
begin
 result:=fCountSubpassDependencies;
 inc(fCountSubpassDependencies);
 if fCountSubpassDependencies>length(fSubpassDependencies) then begin
  SetLength(fSubpassDependencies,fCountSubpassDependencies*2);
 end;
 SubpassDependency:=@fSubpassDependencies[result];
 SubpassDependency^.srcSubpass:=aSrcSubpass;
 SubpassDependency^.dstSubpass:=aDstSubpass;
 SubpassDependency^.srcStageMask:=aSrcStageMask;
 SubpassDependency^.dstStageMask:=aDstStageMask;
 SubpassDependency^.srcAccessMask:=aSrcAccessMask;
 SubpassDependency^.dstAccessMask:=aDstAccessMask;
 SubpassDependency^.DependencyFlags:=aDependencyFlags;
end;

procedure TVulkanRenderPass.Initialize;
var Index,SubIndex,fCountClearValues:TVkInt32;
    AttachmentDescription:PVkAttachmentDescription;
    SubpassDescription:PVkSubpassDescription;
    RenderPassSubpassDescription:PVulkanRenderPassSubpassDescription;
    ClearValue:PVkClearValue;
    RenderPassCreateInfo:TVkRenderPassCreateInfo;
begin

 FillChar(RenderPassCreateInfo,Sizeof(TVkRenderPassCreateInfo),#0);
 RenderPassCreateInfo.sType:=VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO;

 SetLength(fAttachmentDescriptions,fCountAttachmentDescriptions);
 SetLength(fAttachmentReferences,fCountAttachmentReferences);
 SetLength(fRenderPassSubpassDescriptions,fCountSubpassDescriptions);
 SetLength(fSubpassDescriptions,fCountSubpassDescriptions);
 SetLength(fSubpassDependencies,fCountSubpassDependencies);

 fCountClearValues:=0;
 for Index:=0 to fCountAttachmentDescriptions-1 do begin
  AttachmentDescription:=@fAttachmentDescriptions[Index];
  if AttachmentDescription^.loadOp in [VK_ATTACHMENT_LOAD_OP_CLEAR] then begin
   fCountClearValues:=Max(fCountClearValues,Index+1);
  end;
 end;
 SetLength(fClearValues,fCountClearValues);
 for Index:=0 to fCountClearValues-1 do begin
  AttachmentDescription:=@fAttachmentDescriptions[Index];
  ClearValue:=@fClearValues[Index];
  case AttachmentDescription^.format of
   VK_FORMAT_D32_SFLOAT_S8_UINT,
   VK_FORMAT_D32_SFLOAT,
   VK_FORMAT_D24_UNORM_S8_UINT,
   VK_FORMAT_D16_UNORM_S8_UINT,
   VK_FORMAT_D16_UNORM:begin
    ClearValue^.depthStencil.depth:=1.0;
    ClearValue^.depthStencil.stencil:=0;
   end;
   else begin
    ClearValue^.color.uint32[0]:=0;
    ClearValue^.color.uint32[1]:=0;
    ClearValue^.color.uint32[2]:=0;
    ClearValue^.color.uint32[3]:=0;
   end;
  end;
 end;

 if fCountAttachmentDescriptions>0 then begin
  RenderPassCreateInfo.attachmentCount:=fCountAttachmentDescriptions;
  RenderPassCreateInfo.pAttachments:=@fAttachmentDescriptions[0];
 end;

 if fCountSubpassDescriptions>0 then begin
  for Index:=0 to fCountSubpassDescriptions-1 do begin
   SubpassDescription:=@fSubpassDescriptions[Index];
   RenderPassSubpassDescription:=@fRenderPassSubpassDescriptions[Index];
   FillChar(SubpassDescription^,SizeOf(TVkSubpassDescription),#0);
   SubpassDescription^.flags:=RenderPassSubpassDescription^.Flags;
   SubpassDescription^.pipelineBindPoint:=RenderPassSubpassDescription^.PipelineBindPoint;
   begin
    SubpassDescription^.inputAttachmentCount:=length(RenderPassSubpassDescription^.InputAttachments);
    if SubpassDescription^.inputAttachmentCount>0 then begin
     SetLength(RenderPassSubpassDescription^.aInputAttachments,SubpassDescription^.inputAttachmentCount);
     for SubIndex:=0 to length(RenderPassSubpassDescription^.InputAttachments)-1 do begin
      RenderPassSubpassDescription^.aInputAttachments[SubIndex]:=fAttachmentReferences[RenderPassSubpassDescription^.InputAttachments[SubIndex]];
     end;
     SubpassDescription^.pInputAttachments:=@RenderPassSubpassDescription^.aInputAttachments[0];
    end;
   end;
   begin
    SubpassDescription^.ColorAttachmentCount:=length(RenderPassSubpassDescription^.ColorAttachments);
    if SubpassDescription^.ColorAttachmentCount>0 then begin
     SetLength(RenderPassSubpassDescription^.aColorAttachments,SubpassDescription^.ColorAttachmentCount);
     for SubIndex:=0 to length(RenderPassSubpassDescription^.ColorAttachments)-1 do begin
      RenderPassSubpassDescription^.aColorAttachments[SubIndex]:=fAttachmentReferences[RenderPassSubpassDescription^.ColorAttachments[SubIndex]];
     end;
     SubpassDescription^.pColorAttachments:=@RenderPassSubpassDescription^.aColorAttachments[0];
    end;
   end;
   begin
    if (SubpassDescription^.ColorAttachmentCount>0) and
       (SubpassDescription^.ColorAttachmentCount=TVkUInt32(length(RenderPassSubpassDescription^.ResolveAttachments))) then begin
     SetLength(RenderPassSubpassDescription^.aResolveAttachments,SubpassDescription^.ColorAttachmentCount);
     for SubIndex:=0 to length(RenderPassSubpassDescription^.ResolveAttachments)-1 do begin
      RenderPassSubpassDescription^.aResolveAttachments[SubIndex]:=fAttachmentReferences[RenderPassSubpassDescription^.ResolveAttachments[SubIndex]];
     end;
     SubpassDescription^.pResolveAttachments:=@RenderPassSubpassDescription^.aResolveAttachments[0];
    end;
   end;
   if RenderPassSubpassDescription^.DepthStencilAttachment>=0 then begin
    SubpassDescription^.pDepthStencilAttachment:=@fAttachmentReferences[RenderPassSubpassDescription^.DepthStencilAttachment];
   end;
   begin
    SubpassDescription^.PreserveAttachmentCount:=length(RenderPassSubpassDescription^.PreserveAttachments);
    if SubpassDescription^.PreserveAttachmentCount>0 then begin
     SubpassDescription^.pPreserveAttachments:=@RenderPassSubpassDescription^.PreserveAttachments[0];
    end;
   end;
  end;
  RenderPassCreateInfo.subpassCount:=fCountSubpassDescriptions;
  RenderPassCreateInfo.pSubpasses:=@fSubpassDescriptions[0];
 end;

 if fCountSubpassDependencies>0 then begin
  RenderPassCreateInfo.dependencyCount:=fCountSubpassDependencies;
  RenderPassCreateInfo.pDependencies:=@fSubpassDependencies[0];
 end;
 
 HandleResultCode(fDevice.fDeviceVulkan.CreateRenderPass(fDevice.fDeviceHandle,@RenderPassCreateInfo,fDevice.fAllocationCallbacks,@fRenderPassHandle));

end;

procedure TVulkanRenderPass.BeginRenderPass(const aCommandBuffer:TVulkanCommandBuffer;
                                            const aFrameBuffer:TVulkanFrameBuffer;
                                            const aSubpassContents:TVkSubpassContents;
                                            const aOffsetX,aOffsetY,aWidth,aHeight:TVkUInt32);
var RenderPassBeginInfo:TVkRenderPassBeginInfo;
begin
 FillChar(RenderPassBeginInfo,SizeOf(TVkRenderPassBeginInfo),#0);
 RenderPassBeginInfo.sType:=VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO;
 RenderPassBeginInfo.renderPass:=fRenderPassHandle;
 RenderPassBeginInfo.framebuffer:=aFrameBuffer.fFrameBufferHandle;
 RenderPassBeginInfo.renderArea.offset.x:=aOffsetX;
 RenderPassBeginInfo.renderArea.offset.y:=aOffsetY;
 RenderPassBeginInfo.renderArea.extent.width:=aWidth;
 RenderPassBeginInfo.renderArea.extent.height:=aHeight;
 RenderPassBeginInfo.clearValueCount:=length(fClearValues);
 if RenderPassBeginInfo.clearValueCount>0 then begin
  RenderPassBeginInfo.pClearValues:=@fClearValues[0];
 end;
 aCommandBuffer.CmdBeginRenderPass(@RenderPassBeginInfo,aSubpassContents);
end;

procedure TVulkanRenderPass.EndRenderPass(const aCommandBuffer:TVulkanCommandBuffer);
begin
 aCommandBuffer.CmdEndRenderPass;
end;

constructor TVulkanSampler.Create(const aDevice:TVulkanDevice;
                                  const aSampler:TVkSampler;
                                  const aDoDestroy:boolean=true);
begin

 inherited Create;

 fDevice:=aDevice;

 fSamplerHandle:=aSampler;

 fDoDestroy:=aDoDestroy;

end;

constructor TVulkanSampler.Create(const aDevice:TVulkanDevice;
                                  const aMagFilter:TVkFilter;
                                  const aMinFilter:TVkFilter;
                                  const aMipmapMode:TVkSamplerMipmapMode;
                                  const aAddressModeU:TVkSamplerAddressMode;
                                  const aAddressModeV:TVkSamplerAddressMode;
                                  const aAddressModeW:TVkSamplerAddressMode;
                                  const aMipLodBias:TVkFloat;
                                  const aAnisotropyEnable:boolean;
                                  const aMaxAnisotropy:TVkFloat;
                                  const aCompareEnable:boolean;
                                  const aCompareOp:TVkCompareOp;
                                  const aMinLod:TVkFloat;
                                  const aMaxLod:TVkFloat;
                                  const aBorderColor:TVkBorderColor;
                                  const aUnnormalizedCoordinates:boolean);
var SamplerCreateInfo:TVkSamplerCreateInfo;
begin

 inherited Create;

 fDevice:=aDevice;

 fSamplerHandle:=VK_NULL_HANDLE;

 fDoDestroy:=true;

 FillChar(SamplerCreateInfo,SizeOf(TVkSamplerCreateInfo),#0);
 SamplerCreateInfo.sType:=VK_STRUCTURE_TYPE_SAMPLER_CREATE_INFO;
 SamplerCreateInfo.pNext:=nil;
 SamplerCreateInfo.flags:=0;
 SamplerCreateInfo.magFilter:=aMagFilter;
 SamplerCreateInfo.minFilter:=aMinFilter;
 SamplerCreateInfo.mipmapMode:=aMipmapMode;
 SamplerCreateInfo.addressModeU:=aAddressModeU;
 SamplerCreateInfo.addressModeV:=aAddressModeV;
 SamplerCreateInfo.addressModeW:=aAddressModeW;
 SamplerCreateInfo.mipLodBias:=aMipLodBias;
 if aAnisotropyEnable then begin
  SamplerCreateInfo.anisotropyEnable:=VK_TRUE;
 end else begin
  SamplerCreateInfo.anisotropyEnable:=VK_FALSE;
 end;
 SamplerCreateInfo.maxAnisotropy:=aMaxAnisotropy;
 if aCompareEnable then begin
  SamplerCreateInfo.compareEnable:=VK_TRUE;
 end else begin
  SamplerCreateInfo.compareEnable:=VK_FALSE;
 end;
 SamplerCreateInfo.compareOp:=aCompareOp;
 SamplerCreateInfo.minLod:=aMinLod;
 SamplerCreateInfo.maxLod:=aMaxLod;
 SamplerCreateInfo.borderColor:=aBorderColor;
 if aUnnormalizedCoordinates then begin
  SamplerCreateInfo.unnormalizedCoordinates:=VK_TRUE;
 end else begin
  SamplerCreateInfo.unnormalizedCoordinates:=VK_FALSE;
 end;

 HandleResultCode(fDevice.fDeviceVulkan.CreateSampler(fDevice.fDeviceHandle,@SamplerCreateInfo,fDevice.fAllocationCallbacks,@fSamplerHandle));

end;

destructor TVulkanSampler.Destroy;
begin
 if fSamplerHandle<>VK_NULL_HANDLE then begin
  if fDoDestroy then begin
   fDevice.fDeviceVulkan.DestroySampler(fDevice.fDeviceHandle,fSamplerHandle,fDevice.fAllocationCallbacks);
  end;
  fSamplerHandle:=VK_NULL_HANDLE;
 end;
 inherited Destroy;
end;

constructor TVulkanImage.Create(const aDevice:TVulkanDevice;
                                const aImage:TVkImage;
                                const aImageView:TVulkanImageView=nil;
                                const aDoDestroy:boolean=true);
begin

 inherited Create;

 fDevice:=aDevice;

 fImageHandle:=aImage;

 fImageView:=aImageView;

 fDoDestroy:=aDoDestroy;

end;

constructor TVulkanImage.Create(const aDevice:TVulkanDevice;
                                const aFlags:TVkImageCreateFlags;
                                const aImageType:TVkImageType;
                                const aFormat:TVkFormat;
                                const aExtentWidth:TVkUInt32;
                                const aExtentHeight:TVkUInt32;
                                const aExtentDepth:TVkUInt32;
                                const aMipLevels:TVkUInt32;
                                const aArrayLayers:TVkUInt32;
                                const aSamples:TVkSampleCountFlagBits;
                                const aTiling:TVkImageTiling;
                                const aUsage:TVkImageUsageFlags;
                                const aSharingMode:TVkSharingMode;
                                const aQueueFamilyIndexCount:TVkUInt32;
                                const aQueueFamilyIndices:PVkUInt32;
                                const aInitialLayout:TVkImageLayout);
var ImageCreateInfo:TVkImageCreateInfo;
begin

 inherited Create;

 fDevice:=aDevice;

 fImageHandle:=VK_NULL_HANDLE;

 fImageView:=nil;

 fDoDestroy:=true;

 FillChar(ImageCreateInfo,SizeOf(TVkImageCreateInfo),#0);
 ImageCreateInfo.sType:=VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO;
 ImageCreateInfo.pNext:=nil;
 ImageCreateInfo.flags:=aFlags;
 ImageCreateInfo.imageType:=aImageType;
 ImageCreateInfo.format:=aFormat;
 ImageCreateInfo.extent.width:=aExtentWidth;
 ImageCreateInfo.extent.height:=aExtentHeight;
 ImageCreateInfo.extent.depth:=aExtentDepth;
 ImageCreateInfo.mipLevels:=aMipLevels;
 ImageCreateInfo.arrayLayers:=aArrayLayers;
 ImageCreateInfo.samples:=aSamples;
 ImageCreateInfo.tiling:=aTiling;
 ImageCreateInfo.usage:=aUsage;
 ImageCreateInfo.sharingMode:=aSharingMode;
 ImageCreateInfo.queueFamilyIndexCount:=aQueueFamilyIndexCount;
 ImageCreateInfo.pQueueFamilyIndices:=aQueueFamilyIndices;
 ImageCreateInfo.initialLayout:=aInitialLayout;

 HandleResultCode(fDevice.fDeviceVulkan.CreateImage(fDevice.fDeviceHandle,@ImageCreateInfo,fDevice.fAllocationCallbacks,@fImageHandle));

end;

constructor TVulkanImage.Create(const aDevice:TVulkanDevice;
                                const aFlags:TVkImageCreateFlags;
                                const aImageType:TVkImageType;
                                const aFormat:TVkFormat;
                                const aExtentWidth:TVkUInt32;
                                const aExtentHeight:TVkUInt32;
                                const aExtentDepth:TVkUInt32;
                                const aMipLevels:TVkUInt32;
                                const aArrayLayers:TVkUInt32;
                                const aSamples:TVkSampleCountFlagBits;
                                const aTiling:TVkImageTiling;
                                const aUsage:TVkImageUsageFlags;
                                const aSharingMode:TVkSharingMode;
                                const aQueueFamilyIndices:array of TVkUInt32;
                                const aInitialLayout:TVkImageLayout);
var ImageCreateInfo:TVkImageCreateInfo;
begin

 inherited Create;

 fDevice:=aDevice;

 fImageHandle:=VK_NULL_HANDLE;

 fImageView:=nil;

 fDoDestroy:=true;

 FillChar(ImageCreateInfo,SizeOf(TVkImageCreateInfo),#0);
 ImageCreateInfo.sType:=VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO;
 ImageCreateInfo.pNext:=nil;
 ImageCreateInfo.flags:=aFlags;
 ImageCreateInfo.imageType:=aImageType;
 ImageCreateInfo.format:=aFormat;
 ImageCreateInfo.extent.width:=aExtentWidth;
 ImageCreateInfo.extent.height:=aExtentHeight;
 ImageCreateInfo.extent.depth:=aExtentDepth;
 ImageCreateInfo.mipLevels:=aMipLevels;
 ImageCreateInfo.arrayLayers:=aArrayLayers;
 ImageCreateInfo.samples:=aSamples;
 ImageCreateInfo.tiling:=aTiling;
 ImageCreateInfo.usage:=aUsage;
 ImageCreateInfo.sharingMode:=aSharingMode;
 ImageCreateInfo.queueFamilyIndexCount:=length(aQueueFamilyIndices);
 if ImageCreateInfo.queueFamilyIndexCount>0 then begin
  ImageCreateInfo.pQueueFamilyIndices:=@aQueueFamilyIndices[0];
 end else begin
  ImageCreateInfo.pQueueFamilyIndices:=nil;
 end;
 ImageCreateInfo.initialLayout:=aInitialLayout;

 HandleResultCode(fDevice.fDeviceVulkan.CreateImage(fDevice.fDeviceHandle,@ImageCreateInfo,fDevice.fAllocationCallbacks,@fImageHandle));

end;

destructor TVulkanImage.Destroy;
begin
 if assigned(fImageView) then begin
  if fImageView.fImage=self then begin
   fImageView.fImage:=nil;
  end;
  fImageView:=nil;
 end;
 if fImageHandle<>VK_NULL_HANDLE then begin
  if fDoDestroy then begin
   fDevice.fDeviceVulkan.DestroyImage(fDevice.fDeviceHandle,fImageHandle,fDevice.fAllocationCallbacks);
  end;
  fImageHandle:=VK_NULL_HANDLE;
 end;
 inherited Destroy;
end;

procedure TVulkanImage.SetLayout(const aAspectMask:TVkImageAspectFlags;
                                 const aOldImageLayout:TVkImageLayout;
                                 const aNewImageLayout:TVkImageLayout;
                                 const aRange:PVkImageSubresourceRange;
                                 const aCommandBuffer:TVulkanCommandBuffer;
                                 const aQueue:TVulkanQueue=nil;
                                 const aFence:TVulkanFence=nil;
                                 const aBeginAndExecuteCommandBuffer:boolean=false;
                                 const aSrcQueueFamilyIndex:TVkQueue=TVkQueue(VK_QUEUE_FAMILY_IGNORED);
                                 const aDstQueueFamilyIndex:TVkQueue=TVkQueue(VK_QUEUE_FAMILY_IGNORED));
begin
 VulkanSetImageLayout(fImageHandle,
                      aAspectMask,
                      aOldImageLayout,
                      aNewImageLayout,
                      aRange,
                      aCommandBuffer,
                      aQueue,
                      aFence,
                      aBeginAndExecuteCommandBuffer,
                      aSrcQueueFamilyIndex,
                      aDstQueueFamilyIndex);
end;

constructor TVulkanImageView.Create(const aDevice:TVulkanDevice;
                                    const aImageView:TVkImageView;
                                    const aImage:TVulkanImage=nil);
begin

 inherited Create;

 fDevice:=aDevice;

 fImageViewHandle:=aImageView;

 fImage:=aImage;

end;

constructor TVulkanImageView.Create(const aDevice:TVulkanDevice;
                                    const aImage:TVulkanImage;
                                    const aImageViewType:TVkImageViewType;
                                    const aFormat:TvkFormat;
                                    const aComponentRed:TVkComponentSwizzle=VK_COMPONENT_SWIZZLE_IDENTITY;
                                    const aComponentGreen:TVkComponentSwizzle=VK_COMPONENT_SWIZZLE_IDENTITY;
                                    const aComponentBlue:TVkComponentSwizzle=VK_COMPONENT_SWIZZLE_IDENTITY;
                                    const aComponentAlpha:TVkComponentSwizzle=VK_COMPONENT_SWIZZLE_IDENTITY;
                                    const aImageAspectFlags:TVkImageAspectFlags=TVkImageAspectFlags(VK_IMAGE_ASPECT_COLOR_BIT);
                                    const aBaseMipLevel:TVkUInt32=0;
                                    const aCountMipMapLevels:TVkUInt32=1;
                                    const aBaseArrayLayer:TVkUInt32=1;
                                    const aCountArrayLayers:TVkUInt32=0);
var ImageViewCreateInfo:TVkImageViewCreateInfo;
begin

 inherited Create;

 fDevice:=aDevice;

 fImage:=aImage;

 fImageViewHandle:=VK_NULL_HANDLE;

 FillChar(ImageViewCreateInfo,SizeOf(TVkImageViewCreateInfo),#0);
 ImageViewCreateInfo.sType:=VK_STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO;
 ImageViewCreateInfo.pNext:=nil;
 ImageViewCreateInfo.flags:=0;
 ImageViewCreateInfo.image:=aImage.fImageHandle;
 ImageViewCreateInfo.viewType:=aImageViewType;
 ImageViewCreateInfo.format:=aFormat;
 ImageViewCreateInfo.components.r:=aComponentRed;
 ImageViewCreateInfo.components.g:=aComponentGreen;
 ImageViewCreateInfo.components.b:=aComponentBlue;
 ImageViewCreateInfo.components.a:=aComponentAlpha;
 ImageViewCreateInfo.subresourceRange.aspectMask:=aImageAspectFlags;
 ImageViewCreateInfo.subresourceRange.baseMipLevel:=aBaseMipLevel;
 ImageViewCreateInfo.subresourceRange.levelCount:=aCountMipMapLevels;
 ImageViewCreateInfo.subresourceRange.baseArrayLayer:=aBaseArrayLayer;
 ImageViewCreateInfo.subresourceRange.layerCount:=aCountArrayLayers;

 HandleResultCode(fDevice.fDeviceVulkan.CreateImageView(fDevice.fDeviceHandle,@ImageViewCreateInfo,fDevice.fAllocationCallbacks,@fImageViewHandle));

end;

destructor TVulkanImageView.Destroy;
begin
 if assigned(fImage) then begin
  if fImage.fImageView=self then begin
   fImage.fImageView:=nil;
  end;
  fImage:=nil;
 end;
 if fImageViewHandle<>VK_NULL_HANDLE then begin
  fDevice.fDeviceVulkan.DestroyImageView(fDevice.fDeviceHandle,fImageViewHandle,fDevice.fAllocationCallbacks);
  fImageViewHandle:=VK_NULL_HANDLE;
 end;
 inherited Destroy;
end;

constructor TVulkanFrameBufferAttachment.Create(const aDevice:TVulkanDevice;
                                                const aGraphicsQueue:TVulkanQueue;
                                                const aGraphicsCommandBuffer:TVulkanCommandBuffer;
                                                const aGraphicsCommandBufferFence:TVulkanFence;
                                                const aWidth:TVkUInt32;
                                                const aHeight:TVkUInt32;
                                                const aFormat:TVkFormat;
                                                const aUsage:TVkBufferUsageFlags);
var MemoryRequirements:TVkMemoryRequirements;
    AspectMask:TVkImageAspectFlags;
    ImageLayout:TVkImageLayout;
begin
 inherited Create;

 fDevice:=aDevice;

 fWidth:=aWidth;

 fHeight:=aHeight;

 fFormat:=aFormat;

 fImage:=nil;

 fImageView:=nil;

 fMemoryBlock:=nil;

 fDoDestroy:=true;

 if (aUsage and TVkBufferUsageFlags(VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT))<>0 then begin
  AspectMask:=TVkImageAspectFlags(VK_IMAGE_ASPECT_COLOR_BIT);
  ImageLayout:=VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL;
 end else if (aUsage and TVkBufferUsageFlags(VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT))<>0 then begin
  if fFormat in [VK_FORMAT_D32_SFLOAT_S8_UINT,VK_FORMAT_D24_UNORM_S8_UINT,VK_FORMAT_D16_UNORM_S8_UINT] then begin
   AspectMask:=TVkImageAspectFlags(VK_IMAGE_ASPECT_DEPTH_BIT) or TVkImageAspectFlags(VK_IMAGE_ASPECT_STENCIL_BIT);
  end else begin
   AspectMask:=TVkImageAspectFlags(VK_IMAGE_ASPECT_DEPTH_BIT);
  end;
  ImageLayout:=VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL;
 end else begin
  raise EVulkanException.Create('Invalid frame buffer attachment');
 end;

 try

  fImage:=TVulkanImage.Create(fDevice,
                              0,
                              VK_IMAGE_TYPE_2D,
                              fFormat,
                              aWidth,
                              aHeight,
                              1,
                              1,
                              1,
                              VK_SAMPLE_COUNT_1_BIT,
                              VK_IMAGE_TILING_OPTIMAL,
                              aUsage {or TVkImageUsageFlags(VK_IMAGE_USAGE_SAMPLED_BIT)},
                              VK_SHARING_MODE_EXCLUSIVE,
                              [],
                              VK_IMAGE_LAYOUT_UNDEFINED);

  fDevice.fDeviceVulkan.GetImageMemoryRequirements(fDevice.fDeviceHandle,fImage.fImageHandle,@MemoryRequirements);

  fMemoryBlock:=fDevice.fMemoryManager.AllocateMemoryBlock([],
                                                           MemoryRequirements.size,
                                                           MemoryRequirements.alignment,
                                                           MemoryRequirements.memoryTypeBits,
                                                           TVkMemoryPropertyFlags(VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT),
                                                           0,
                                                           0,
                                                           0,
                                                           0,
                                                           0,
                                                           vdmatImageOptimal);
  if not assigned(fMemoryBlock) then begin
   raise EVulkanMemoryAllocationException.Create('Memory for frame buffer attachment couldn''t be allocated!');
  end;

  HandleResultCode(fDevice.fDeviceVulkan.BindImageMemory(fDevice.fDeviceHandle,fImage.fImageHandle,fMemoryBlock.fMemoryChunk.fMemoryHandle,fMemoryBlock.fOffset));

  if (aUsage and TVkBufferUsageFlags(VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT))<>0 then begin
   fImage.SetLayout(AspectMask,
                    VK_IMAGE_LAYOUT_UNDEFINED,
                    VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL,
                    nil,
                    aGraphicsCommandBuffer,
                    aGraphicsQueue,
                    aGraphicsCommandBufferFence,
                    true);
  end else begin
   fImage.SetLayout(AspectMask,
                    VK_IMAGE_LAYOUT_UNDEFINED,
                    ImageLayout,
                    nil,
                    aGraphicsCommandBuffer,
                    aGraphicsQueue,
                    aGraphicsCommandBufferFence,
                    true);
  end;
          
  fImageView:=TVulkanImageView.Create(fDevice,
                                      fImage,
                                      VK_IMAGE_VIEW_TYPE_2D,
                                      fFormat,
                                      VK_COMPONENT_SWIZZLE_IDENTITY,
                                      VK_COMPONENT_SWIZZLE_IDENTITY,
                                      VK_COMPONENT_SWIZZLE_IDENTITY,
                                      VK_COMPONENT_SWIZZLE_IDENTITY,
                                      AspectMask,
                                      0,
                                      1,
                                      0,
                                      1);

  fImage.fImageView:=fImageView;

 except

  FreeAndNil(fImageView);

  FreeAndNil(fImage);

  if assigned(fMemoryBlock) then begin
   fDevice.fMemoryManager.FreeMemoryBlock(fMemoryBlock);
   fMemoryBlock:=nil;
  end;

  raise;

 end;
end;

constructor TVulkanFrameBufferAttachment.Create(const aDevice:TVulkanDevice;
                                                const aImage:TVulkanImage;
                                                const aImageView:TVulkanImageView;
                                                const aWidth:TVkUInt32;
                                                const aHeight:TVkUInt32;
                                                const aFormat:TVkFormat;
                                                const aDoDestroy:boolean=true);
begin

 inherited Create;

 fDevice:=aDevice;

 fWidth:=aWidth;

 fHeight:=aHeight;

 fFormat:=aFormat;

 fImage:=aImage;

 fImageView:=aImageView;

 fMemoryBlock:=nil;

 fDoDestroy:=aDoDestroy;

end;

destructor TVulkanFrameBufferAttachment.Destroy;
begin

 if fDoDestroy then begin

  FreeAndNil(fImageView);

  FreeAndNil(fImage);

  if assigned(fMemoryBlock) then begin
   fDevice.fMemoryManager.FreeMemoryBlock(fMemoryBlock);
   fMemoryBlock:=nil;
  end;

 end else begin

  fImageView:=nil;

  fImage:=nil;

  fMemoryBlock:=nil;

 end;

 inherited Destroy;

end;

constructor TVulkanFrameBuffer.Create(const aDevice:TVulkanDevice;
                                      const aRenderPass:TVulkanRenderPass;
                                      const aWidth:TVkUInt32;
                                      const aHeight:TVkUInt32;
                                      const aLayers:TVkUInt32);
begin

 inherited Create;

 fDevice:=aDevice;

 fFrameBufferHandle:=VK_NULL_HANDLE;

 fFrameBufferAttachments:=nil;

 fFrameBufferAttachmentImageViews:=nil;

 fCountFrameBufferAttachments:=0;

 fRenderPass:=aRenderPass;

 fWidth:=aWidth;

 fHeight:=aHeight;

 fLayers:=aLayers;

 fDoDestroy:=true;

end;

constructor TVulkanFrameBuffer.Create(const aDevice:TVulkanDevice;
                                      const aRenderPass:TVulkanRenderPass;
                                      const aWidth:TVkUInt32;
                                      const aHeight:TVkUInt32;
                                      const aLayers:TVkUInt32;
                                      const aFrameBufferAttachments:array of TVulkanFrameBufferAttachment;
                                      const aDoDestroyAttachments:boolean=true);
begin

 inherited Create;

 fDevice:=aDevice;

 fFrameBufferHandle:=VK_NULL_HANDLE;

 fFrameBufferAttachments:=nil;

 fFrameBufferAttachmentImageViews:=nil;

 fCountFrameBufferAttachments:=length(aFrameBufferAttachments);

 SetLength(fFrameBufferAttachments,fCountFrameBufferAttachments);

 if fCountFrameBufferAttachments>0 then begin
  Move(aFrameBufferAttachments[0],fFrameBufferAttachments[0],fCountFrameBufferAttachments*SizeOf(TVulkanFrameBufferAttachment));
 end;

 fRenderPass:=aRenderPass;

 fWidth:=aWidth;

 fHeight:=aHeight;

 fLayers:=aLayers;

 fDoDestroy:=true;

 fDoDestroyAttachments:=aDoDestroyAttachments;

 Initialize;

end;                                      

constructor TVulkanFrameBuffer.Create(const aDevice:TVulkanDevice;
                                      const aRenderPass:TVulkanRenderPass;
                                      const aWidth:TVkUInt32;
                                      const aHeight:TVkUInt32;
                                      const aLayers:TVkUInt32;
                                      const aFrameBufferHandle:TVkFrameBuffer;
                                      const aFrameBufferAttachments:array of TVulkanFrameBufferAttachment;
                                      const aDoDestroy:boolean=true;
                                      const aDoDestroyAttachments:boolean=true);
begin

 inherited Create;

 fDevice:=aDevice;

 fFrameBufferHandle:=aFrameBufferHandle;

 fFrameBufferAttachments:=nil;

 fFrameBufferAttachmentImageViews:=nil;

 fCountFrameBufferAttachments:=length(aFrameBufferAttachments);

 SetLength(fFrameBufferAttachments,fCountFrameBufferAttachments);

 if fCountFrameBufferAttachments>0 then begin
  Move(aFrameBufferAttachments[0],fFrameBufferAttachments[0],fCountFrameBufferAttachments*SizeOf(TVulkanFrameBufferAttachment));
 end;

 fRenderPass:=aRenderPass;

 fWidth:=aWidth;

 fHeight:=aHeight;

 fLayers:=aLayers;

 fDoDestroy:=aDoDestroy;

 fDoDestroyAttachments:=aDoDestroyAttachments;

end;

destructor TVulkanFrameBuffer.Destroy;
var Index:TVkInt32;
begin

 if fFrameBufferHandle<>VK_NULL_HANDLE then begin
  if fDoDestroy then begin
   fDevice.fDeviceVulkan.DestroyFramebuffer(fDevice.fDeviceHandle,fFrameBufferHandle,fDevice.fAllocationCallbacks);
  end;
  fFrameBufferHandle:=VK_NULL_HANDLE;
 end;

 for Index:=0 to fCountFrameBufferAttachments-1 do begin
  if fDoDestroyAttachments then begin
   FreeAndNil(fFrameBufferAttachments[Index]);
  end else begin
   fFrameBufferAttachments[Index]:=nil;
  end;
 end;

 SetLength(fFrameBufferAttachments,0);

 SetLength(fFrameBufferAttachmentImageViews,0);

 inherited Destroy;
end;

function TVulkanFrameBuffer.GetFrameBufferAttachment(const aIndex:TVkInt32):TVulkanFrameBufferAttachment;
begin
 result:=fFrameBufferAttachments[aIndex];
end;

function TVulkanFrameBuffer.AddAttachment(const aFrameBufferAttachment:TVulkanFrameBufferAttachment):TVkInt32;
begin
 result:=fCountFrameBufferAttachments;
 inc(fCountFrameBufferAttachments);
 if fCountFrameBufferAttachments>length(fFrameBufferAttachments) then begin
  SetLength(fFrameBufferAttachments,fCountFrameBufferAttachments*2);
 end;
 fFrameBufferAttachments[result]:=aFrameBufferAttachment;
end;

procedure TVulkanFrameBuffer.Initialize;
var Index:TVkInt32;
    FrameBufferCreateInfo:TVkFramebufferCreateInfo;
begin
 if fFrameBufferHandle=VK_NULL_HANDLE then begin

  SetLength(fFrameBufferAttachments,fCountFrameBufferAttachments);

  SetLength(fFrameBufferAttachmentImageViews,fCountFrameBufferAttachments);

  for Index:=0 to fCountFrameBufferAttachments-1 do begin
   fFrameBufferAttachmentImageViews[Index]:=fFrameBufferAttachments[Index].fImageView.fImageViewHandle;
  end;

  FillChar(FrameBufferCreateInfo,SizeOf(TVkFramebufferCreateInfo),#0);
  FrameBufferCreateInfo.sType:=VK_STRUCTURE_TYPE_FRAMEBUFFER_CREATE_INFO;
  FrameBufferCreateInfo.pNext:=nil;
  FrameBufferCreateInfo.flags:=0;
  FrameBufferCreateInfo.renderPass:=fRenderPass.fRenderPassHandle;
  FrameBufferCreateInfo.attachmentCount:=fCountFrameBufferAttachments;
  FrameBufferCreateInfo.pAttachments:=@fFrameBufferAttachmentImageViews[0];
  FrameBufferCreateInfo.width:=fWidth;
  FrameBufferCreateInfo.height:=fHeight;
  FrameBufferCreateInfo.layers:=fLayers;

  HandleResultCode(fDevice.fDeviceVulkan.CreateFramebuffer(fDevice.fDeviceHandle,@FrameBufferCreateInfo,fDevice.fAllocationCallbacks,@fFrameBufferHandle));

 end;
end;

constructor TVulkanSwapChain.Create(const aDevice:TVulkanDevice;
                                    const aSurface:TVulkanSurface;
                                    const aOldSwapChain:TVulkanSwapChain=nil;
                                    const aDesiredImageWidth:TVkUInt32=0;
                                    const aDesiredImageHeight:TVkUInt32=0;
                                    const aDesiredImageCount:TVkUInt32=2;
                                    const aImageArrayLayers:TVkUInt32=1;
                                    const aImageFormat:TVkFormat=VK_FORMAT_UNDEFINED;
                                    const aImageColorSpace:TVkColorSpaceKHR=VK_COLOR_SPACE_SRGB_NONLINEAR_KHR;
                                    const aImageUsage:TVkImageUsageFlags=TVkImageUsageFlags(VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT);
                                    const aImageSharingMode:TVkSharingMode=VK_SHARING_MODE_EXCLUSIVE;
                                    const aQueueFamilyIndices:TVkUInt32List=nil;
                                    const aCompositeAlpha:TVkCompositeAlphaFlagBitsKHR=VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR;
                                    const aPresentMode:TVkPresentModeKHR=VK_PRESENT_MODE_MAILBOX_KHR;
                                    const aClipped:boolean=true;
                                    const aDesiredTransform:TVkSurfaceTransformFlagsKHR=TVkSurfaceTransformFlagsKHR($ffffffff));
type TPresentModes=VK_PRESENT_MODE_IMMEDIATE_KHR..VK_PRESENT_MODE_FIFO_RELAXED_KHR;
const PresentModeTryOrder:array[TPresentModes,0..3] of TVkPresentModeKHR=
       ((VK_PRESENT_MODE_IMMEDIATE_KHR,VK_PRESENT_MODE_MAILBOX_KHR,VK_PRESENT_MODE_FIFO_RELAXED_KHR,VK_PRESENT_MODE_FIFO_KHR),
        (VK_PRESENT_MODE_MAILBOX_KHR,VK_PRESENT_MODE_IMMEDIATE_KHR,VK_PRESENT_MODE_FIFO_RELAXED_KHR,VK_PRESENT_MODE_FIFO_KHR),
        (VK_PRESENT_MODE_FIFO_KHR,VK_PRESENT_MODE_FIFO_RELAXED_KHR,VK_PRESENT_MODE_MAILBOX_KHR,VK_PRESENT_MODE_IMMEDIATE_KHR),
        (VK_PRESENT_MODE_FIFO_RELAXED_KHR,VK_PRESENT_MODE_FIFO_KHR,VK_PRESENT_MODE_MAILBOX_KHR,VK_PRESENT_MODE_IMMEDIATE_KHR));
var Index,TryIterationIndex:TVkInt32;
    SurfaceCapabilities:TVkSurfaceCapabilitiesKHR;
    SurfacePresentModes:TVkPresentModeKHRArray;
    SurfaceFormat:TVkSurfaceFormatKHR;
    SwapChainImages:array of TVkImage;
    FormatProperties:TVkFormatProperties;
    SwapChainCreateInfo:TVkSwapchainCreateInfoKHR;
    Found:boolean;
begin
 inherited Create;

 fDevice:=aDevice;

 fSurface:=aSurface;

 fSwapChainHandle:=VK_NULL_HANDLE;

 fQueueFamilyIndices:=nil;

 fImages:=nil;

 fPresentMode:=aPresentMode;

 fCurrentImageIndex:=0;

 fCountImages:=0;

 fWidth:=0;

 fHeight:=0;

 try

  if (fDevice.fPresentQueueFamilyIndex<0) or not
     fDevice.fPhysicalDevice.GetSurfaceSupport(fDevice.fPresentQueueFamilyIndex,fSurface) then begin
   raise EVulkanSurfaceException.Create('Surface not supported by device');
  end;

  if assigned(aQueueFamilyIndices) then begin
   fCountQueueFamilyIndices:=aQueueFamilyIndices.Count;
   SetLength(fQueueFamilyIndices,fCountQueueFamilyIndices);
   for Index:=0 to fCountQueueFamilyIndices-1 do begin
    fQueueFamilyIndices[Index]:=aQueueFamilyIndices.Items[Index];
   end;
  end else begin
   fCountQueueFamilyIndices:=0;
  end;

  SurfaceCapabilities:=fDevice.fPhysicalDevice.GetSurfaceCapabilities(fSurface);

  FillChar(SwapChainCreateInfo,SizeOf(TVkSwapChainCreateInfoKHR),#0);
  SwapChainCreateInfo.sType:=VK_STRUCTURE_TYPE_SWAPCHAIN_CREATE_INFO_KHR;

  SwapChainCreateInfo.surface:=fSurface.fSurfaceHandle;

  if SurfaceCapabilities.minImageCount>aDesiredImageCount then begin
   SwapChainCreateInfo.minImageCount:=SurfaceCapabilities.minImageCount;
  end else if (SurfaceCapabilities.maxImageCount<>0) and
              (SurfaceCapabilities.maxImageCount<aDesiredImageCount) then begin
   SwapChainCreateInfo.minImageCount:=SurfaceCapabilities.maxImageCount;
  end else begin
   SwapChainCreateInfo.minImageCount:=aDesiredImageCount;
  end;

  if aImageFormat=VK_FORMAT_UNDEFINED then begin
   SurfaceFormat:=fDevice.fPhysicalDevice.GetSurfaceFormat(fSurface);
   SwapChainCreateInfo.imageFormat:=SurfaceFormat.format;
   SwapChainCreateInfo.imageColorSpace:=SurfaceFormat.colorSpace;
  end else begin
   SwapChainCreateInfo.imageFormat:=aImageFormat;
   SwapChainCreateInfo.imageColorSpace:=aImageColorSpace;
  end;

  fImageFormat:=SwapChainCreateInfo.imageFormat;
  fImageColorSpace:=SwapChainCreateInfo.imageColorSpace;
   
  fDevice.fInstance.fVulkan.GetPhysicalDeviceFormatProperties(fDevice.fPhysicalDevice.fPhysicalDeviceHandle,SwapChainCreateInfo.imageFormat,@FormatProperties);
  if (FormatProperties.OptimalTilingFeatures and TVkFormatFeatureFlags(VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BIT))=0 then begin
   raise EVulkanException.Create('No suitable color image format!');
  end;

  if ((aDesiredImageWidth<>0) and (aDesiredImageHeight<>0)) or
     ((TVkInt32(SurfaceCapabilities.CurrentExtent.Width)<0) or (TVkInt32(SurfaceCapabilities.CurrentExtent.Height)<0)) then begin
   SwapChainCreateInfo.imageExtent.width:=Min(Max(aDesiredImageWidth,SurfaceCapabilities.minImageExtent.width),SurfaceCapabilities.maxImageExtent.width);
   SwapChainCreateInfo.imageExtent.height:=Min(Max(aDesiredImageHeight,SurfaceCapabilities.minImageExtent.height),SurfaceCapabilities.maxImageExtent.height);
  end else begin
   SwapChainCreateInfo.imageExtent:=SurfaceCapabilities.CurrentExtent;
  end;

  fWidth:=SwapChainCreateInfo.imageExtent.width;

  fHeight:=SwapChainCreateInfo.imageExtent.height;

  SwapChainCreateInfo.imageArrayLayers:=aImageArrayLayers;
  SwapChainCreateInfo.imageUsage:=aImageUsage;
  SwapChainCreateInfo.imageSharingMode:=aImageSharingMode;

  if fCountQueueFamilyIndices>0 then begin
   SwapChainCreateInfo.pQueueFamilyIndices:=@fQueueFamilyIndices[0];
   SwapChainCreateInfo.queueFamilyIndexCount:=fCountQueueFamilyIndices;
  end;

  if (aDesiredTransform<>TVkSurfaceTransformFlagsKHR($ffffffff)) and
     ((SurfaceCapabilities.SupportedTransforms and aDesiredTransform)<>0) then begin
   SwapChainCreateInfo.preTransform:=TVkSurfaceTransformFlagBitsKHR(aDesiredTransform);
  end else if (SurfaceCapabilities.SupportedTransforms and TVkSurfaceTransformFlagsKHR(VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR))<>0 then begin
   SwapChainCreateInfo.preTransform:=TVkSurfaceTransformFlagBitsKHR(VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR);
  end else begin
   SwapChainCreateInfo.preTransform:=TVkSurfaceTransformFlagBitsKHR(SurfaceCapabilities.currentTransform);
  end;

  SwapChainCreateInfo.compositeAlpha:=aCompositeAlpha;

  SurfacePresentModes:=nil;
  try
   SurfacePresentModes:=fDevice.fPhysicalDevice.GetSurfacePresentModes(fSurface);
   case aPresentMode of
    VK_PRESENT_MODE_IMMEDIATE_KHR..VK_PRESENT_MODE_FIFO_RELAXED_KHR:begin
     SwapChainCreateInfo.presentMode:=VK_PRESENT_MODE_FIFO_KHR;
     Found:=false;
     for Index:=0 to length(SurfacePresentModes)-1 do begin
      if SurfacePresentModes[Index]=aPresentMode then begin
       SwapChainCreateInfo.presentMode:=aPresentMode;
       Found:=true;
       break;
      end;
     end;
     if not Found then begin
      for TryIterationIndex:=0 to 3 do begin
       Found:=false;
       for Index:=0 to length(SurfacePresentModes)-1 do begin
        if SurfacePresentModes[Index]=PresentModeTryOrder[aPresentMode,TryIterationIndex] then begin
         SwapChainCreateInfo.presentMode:=PresentModeTryOrder[aPresentMode,TryIterationIndex];
         Found:=true;
         break;
        end;
       end;
       if Found then begin
        break;
       end;
      end;
     end;
    end;
    else begin
     SwapChainCreateInfo.presentMode:=VK_PRESENT_MODE_FIFO_KHR;
     Found:=false;
     for Index:=0 to length(SurfacePresentModes)-1 do begin
      if SurfacePresentModes[Index]=aPresentMode then begin
       SwapChainCreateInfo.presentMode:=aPresentMode;
       Found:=true;
       break;
      end;
     end;
     if not Found then begin
      for Index:=0 to length(SurfacePresentModes)-1 do begin
       if SurfacePresentModes[Index]=VK_PRESENT_MODE_FIFO_KHR then begin
        SwapChainCreateInfo.presentMode:=VK_PRESENT_MODE_FIFO_KHR;
        Found:=true;
        break;
       end;
      end;
      if not Found then begin
       if length(SurfacePresentModes)>0 then begin
        SwapChainCreateInfo.presentMode:=SurfacePresentModes[0];
       end else begin
        raise EVulkanException.Create('Vulkan initialization error (no suitable present mode found, buggy graphics driver?)');
       end;
      end;
     end;
    end;
   end;
  finally
   SetLength(SurfacePresentModes,0);
  end;

  if aClipped then begin
   SwapChainCreateInfo.clipped:=VK_TRUE;
  end else begin
   SwapChainCreateInfo.clipped:=VK_FALSE;
  end;

  if assigned(aOldSwapChain) then begin
   SwapChainCreateInfo.oldSwapchain:=aOldSwapChain.fSwapChainHandle;
  end else begin
   SwapChainCreateInfo.oldSwapchain:=VK_NULL_HANDLE;
  end;

  HandleResultCode(fDevice.fDeviceVulkan.CreateSwapChainKHR(fDevice.fDeviceHandle,@SwapChainCreateInfo,fDevice.fAllocationCallbacks,@fSwapChainHandle));

  HandleResultCode(fDevice.fDeviceVulkan.GetSwapchainImagesKHR(fDevice.fDeviceHandle,fSwapChainHandle,@fCountImages,nil));

  SwapChainImages:=nil;
  try
   SetLength(SwapChainImages,fCountImages);

   HandleResultCode(fDevice.fDeviceVulkan.GetSwapchainImagesKHR(fDevice.fDeviceHandle,fSwapChainHandle,@fCountImages,@SwapChainImages[0]));

   SetLength(fImages,fCountImages);
   for Index:=0 to fCountImages-1 do begin
    fImages[Index]:=nil;
   end;

   for Index:=0 to fCountImages-1 do begin
    fImages[Index]:=TVulkanImage.Create(fDevice,SwapChainImages[Index],nil,false);
   end;

  finally
   SetLength(SwapChainImages,0);
  end;

  fCurrentImageIndex:=fCountImages-1;

 except

  for Index:=0 to length(fImages)-1 do begin
   FreeAndNil(fImages[Index]);
  end;

  if fSwapChainHandle<>VK_NULL_HANDLE then begin
   fDevice.fDeviceVulkan.DestroySwapChainKHR(fDevice.fDeviceHandle,fSwapChainHandle,fDevice.fAllocationCallbacks);
   fSwapChainHandle:=VK_NULL_HANDLE;
  end;

  SetLength(fQueueFamilyIndices,0);

  SetLength(fImages,0);
  
  raise;

 end;
end;

destructor TVulkanSwapChain.Destroy;
var Index:TVkInt32;
begin

 for Index:=0 to length(fImages)-1 do begin
  FreeAndNil(fImages[Index]);
 end;

 if fSwapChainHandle<>VK_NULL_HANDLE then begin
  fDevice.fDeviceVulkan.DestroySwapChainKHR(fDevice.fDeviceHandle,fSwapChainHandle,fDevice.fAllocationCallbacks);
  fSwapChainHandle:=VK_NULL_HANDLE;
 end;

 SetLength(fQueueFamilyIndices,0);

 SetLength(fImages,0);

 inherited Destroy;
end;

function TVulkanSwapChain.QueuePresent(const aQueue:TVulkanQueue;const aSemaphore:TVulkanSemaphore=nil):TVkResult;
var PresentInfo:TVkPresentInfoKHR;
begin
 FillChar(PresentInfo,SizeOf(TVkPresentInfoKHR),#0);
 PresentInfo.sType:=VK_STRUCTURE_TYPE_PRESENT_INFO_KHR;
 PresentInfo.swapchainCount:=1;
 PresentInfo.pSwapchains:=@fSwapChainHandle;
 PresentInfo.pImageIndices:=@fCurrentImageIndex;
 if assigned(aSemaphore) then begin
  PresentInfo.waitSemaphoreCount:=1;
  PresentInfo.pWaitSemaphores:=@aSemaphore.fSemaphoreHandle;
 end;
 result:=fDevice.fInstance.fInstanceVulkan.QueuePresentKHR(aQueue.fQueueHandle,@PresentInfo);
 if result<VK_SUCCESS then begin
  HandleResultCode(result);
 end;
end;

function TVulkanSwapChain.AcquireNextImage(const aSemaphore:TVulkanSemaphore=nil;const aFence:TVulkanFence=nil;const aTimeOut:TVkUInt64=TVkUInt64(high(TVkUInt64))):TVkResult;
var SemaphoreHandle:TVkFence;
    FenceHandle:TVkFence;
begin
 if assigned(aSemaphore) then begin
  SemaphoreHandle:=aSemaphore.fSemaphoreHandle;
 end else begin
  SemaphoreHandle:=VK_NULL_HANDLE;
 end;
 if assigned(aFence) then begin
  FenceHandle:=aFence.fFenceHandle;
 end else begin
  FenceHandle:=VK_NULL_HANDLE;
 end;
 result:=fDevice.fDeviceVulkan.AcquireNextImageKHR(fDevice.fDeviceHandle,fSwapChainHandle,aTimeOut,SemaphoreHandle,FenceHandle,@fCurrentImageIndex);
 if result<VK_SUCCESS then begin
  HandleResultCode(result);
 end;
end;

function TVulkanSwapChain.GetImage(const aImageIndex:TVkInt32):TVulkanImage;
begin
 result:=fImages[aImageIndex];
end;

function TVulkanSwapChain.GetCurrentImage:TVulkanImage;
begin
 result:=fImages[fCurrentImageIndex];
end;

constructor TVulkanSwapChainSimpleDirectRenderTarget.Create(const aDevice:TVulkanDevice;
                                                            const aSwapChain:TVulkanSwapChain;
                                                            const aPresentQueue:TVulkanQueue;
                                                            const aPresentCommandBuffer:TVulkanCommandBuffer;
                                                            const aPresentCommandBufferFence:TVulkanFence;
                                                            const aGraphicsQueue:TVulkanQueue;
                                                            const aGraphicsCommandBuffer:TVulkanCommandBuffer;
                                                            const aGraphicsCommandBufferFence:TVulkanFence;
                                                            const aDepthImageFormat:TVkFormat=VK_FORMAT_UNDEFINED;
                                                            const aDepthImageFormatWithStencil:boolean=false;
                                                            const aClear:boolean=true);
var Index:TVkInt32;
    FormatProperties:TVkFormatProperties;
    ColorAttachmentImage:TVulkanImage;
    ColorAttachmentImageView:TVulkanImageView;
begin

 inherited Create;

 fDevice:=aDevice;

 fSwapChain:=aSwapChain;

 fFrameBufferColorAttachments:=nil;

 fFrameBuffers:=nil;

 fDepthFrameBufferAttachment:=nil;

 fRenderPass:=nil;

 try

  if fDepthImageFormat=VK_FORMAT_UNDEFINED then begin
   fDepthImageFormat:=fDevice.fPhysicalDevice.GetBestSupportedDepthFormat(aDepthImageFormatWithStencil);
  end else begin
   fDepthImageFormat:=aDepthImageFormat;
  end;

  fDevice.fInstance.fVulkan.GetPhysicalDeviceFormatProperties(fDevice.fPhysicalDevice.fPhysicalDeviceHandle,fDepthImageFormat,@FormatProperties);
  if (FormatProperties.OptimalTilingFeatures and TVkFormatFeatureFlags(VK_FORMAT_FEATURE_DEPTH_STENCIL_ATTACHMENT_BIT))=0 then begin
   raise EVulkanException.Create('No suitable depth image format!');
  end;

  begin

   fRenderPass:=TVulkanRenderPass.Create(fDevice);

   if aClear then begin

    fRenderPass.AddSubpassDescription(0,
                                      VK_PIPELINE_BIND_POINT_GRAPHICS,
                                      [],
                                      [fRenderPass.AddAttachmentReference(fRenderPass.AddAttachmentDescription(0,
                                                                                                               fSwapChain.ImageFormat,
                                                                                                               VK_SAMPLE_COUNT_1_BIT,
                                                                                                               VK_ATTACHMENT_LOAD_OP_CLEAR,
                                                                                                               VK_ATTACHMENT_STORE_OP_STORE,
                                                                                                               VK_ATTACHMENT_LOAD_OP_DONT_CARE,
                                                                                                               VK_ATTACHMENT_STORE_OP_DONT_CARE,
                                                                                                               VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL, //VK_IMAGE_LAYOUT_UNDEFINED, // VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL,
                                                                                                               VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL //VK_IMAGE_LAYOUT_PRESENT_SRC_KHR  // VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL
                                                                                                              ),
                                                                          VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL
                                                                         )],
                                      [],
                                      fRenderPass.AddAttachmentReference(fRenderPass.AddAttachmentDescription(0,
                                                                                                              fDepthImageFormat,
                                                                                                              VK_SAMPLE_COUNT_1_BIT,
                                                                                                              VK_ATTACHMENT_LOAD_OP_CLEAR,
                                                                                                              VK_ATTACHMENT_STORE_OP_STORE,
                                                                                                              VK_ATTACHMENT_LOAD_OP_DONT_CARE,
                                                                                                              VK_ATTACHMENT_STORE_OP_DONT_CARE,
                                                                                                              VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL, // VK_IMAGE_LAYOUT_UNDEFINED, // VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL,
                                                                                                              VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL
                                                                                                             ),
                                                                         VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL
                                                                        ),
                                      []);

   end else begin

    fRenderPass.AddSubpassDescription(0,
                                      VK_PIPELINE_BIND_POINT_GRAPHICS,
                                      [],
                                      [fRenderPass.AddAttachmentReference(fRenderPass.AddAttachmentDescription(0,
                                                                                                               fSwapChain.ImageFormat,
                                                                                                               VK_SAMPLE_COUNT_1_BIT,
                                                                                                               VK_ATTACHMENT_LOAD_OP_LOAD,
                                                                                                               VK_ATTACHMENT_STORE_OP_STORE,
                                                                                                               VK_ATTACHMENT_LOAD_OP_DONT_CARE,
                                                                                                               VK_ATTACHMENT_STORE_OP_DONT_CARE,
                                                                                                               VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL, //VK_IMAGE_LAYOUT_UNDEFINED, // VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL,
                                                                                                               VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL //VK_IMAGE_LAYOUT_PRESENT_SRC_KHR  // VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL
                                                                                                              ),
                                                                          VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL
                                                                         )],
                                      [],
                                      fRenderPass.AddAttachmentReference(fRenderPass.AddAttachmentDescription(0,
                                                                                                              fDepthImageFormat,
                                                                                                              VK_SAMPLE_COUNT_1_BIT,
                                                                                                              VK_ATTACHMENT_LOAD_OP_LOAD,
                                                                                                              VK_ATTACHMENT_STORE_OP_STORE,
                                                                                                              VK_ATTACHMENT_LOAD_OP_DONT_CARE,
                                                                                                              VK_ATTACHMENT_STORE_OP_DONT_CARE,
                                                                                                              VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL, // VK_IMAGE_LAYOUT_UNDEFINED, // VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL,
                                                                                                              VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL
                                                                                                             ),
                                                                         VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL
                                                                        ),
                                      []);

   end;

   fRenderPass.AddSubpassDependency(VK_SUBPASS_EXTERNAL,
                                    0,
                                    TVkPipelineStageFlags(VK_PIPELINE_STAGE_BOTTOM_OF_PIPE_BIT),
                                    TVkPipelineStageFlags(VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT),
                                    TVkAccessFlags(VK_ACCESS_MEMORY_READ_BIT),
                                    TVkAccessFlags(VK_ACCESS_COLOR_ATTACHMENT_READ_BIT) or TVkAccessFlags(VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT),
                                    TVkDependencyFlags(VK_DEPENDENCY_BY_REGION_BIT));

   fRenderPass.AddSubpassDependency(0,
                                    VK_SUBPASS_EXTERNAL,
                                    TVkPipelineStageFlags(VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT),
                                    TVkPipelineStageFlags(VK_PIPELINE_STAGE_BOTTOM_OF_PIPE_BIT),
                                    TVkAccessFlags(VK_ACCESS_COLOR_ATTACHMENT_READ_BIT) or TVkAccessFlags(VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT),
                                    TVkAccessFlags(VK_ACCESS_MEMORY_READ_BIT),
                                    TVkDependencyFlags(VK_DEPENDENCY_BY_REGION_BIT));

   fRenderPass.Initialize;

   if aClear then begin
    fRenderPass.ClearValues[0].color.float32[0]:=0.0;
    fRenderPass.ClearValues[0].color.float32[1]:=0.0;
    fRenderPass.ClearValues[0].color.float32[2]:=0.0;
    fRenderPass.ClearValues[0].color.float32[3]:=1.0;
   end;

  end;

  SetLength(fFrameBufferColorAttachments,fSwapChain.CountImages);

  for Index:=0 to fSwapChain.CountImages-1 do begin
   fFrameBufferColorAttachments[Index]:=nil;
  end;

  for Index:=0 to fSwapChain.CountImages-1 do begin

   ColorAttachmentImage:=nil;

   ColorAttachmentImageView:=nil;

   try
    ColorAttachmentImage:=TVulkanImage.Create(fDevice,fSwapChain.Images[Index].fImageHandle,nil,false);

    ColorAttachmentImage.SetLayout(TVkImageAspectFlags(VK_IMAGE_ASPECT_COLOR_BIT),
                                   VK_IMAGE_LAYOUT_UNDEFINED,
                                   VK_IMAGE_LAYOUT_PRESENT_SRC_KHR,
                                   nil,
                                   aPresentCommandBuffer,
                                   aPresentQueue,
                                   aPresentCommandBufferFence,
                                   true);

    ColorAttachmentImageView:=TVulkanImageView.Create(Device,
                                                      ColorAttachmentImage,
                                                      VK_IMAGE_VIEW_TYPE_2D,
                                                      fSwapChain.ImageFormat,
                                                      VK_COMPONENT_SWIZZLE_IDENTITY,
                                                      VK_COMPONENT_SWIZZLE_IDENTITY,
                                                      VK_COMPONENT_SWIZZLE_IDENTITY,
                                                      VK_COMPONENT_SWIZZLE_IDENTITY,
                                                      TVkImageAspectFlags(VK_IMAGE_ASPECT_COLOR_BIT),
                                                      0,
                                                      1,
                                                      0,
                                                      1);

    ColorAttachmentImage.fImageView:=ColorAttachmentImageView;
    ColorAttachmentImageView.fImage:=ColorAttachmentImage;

    fFrameBufferColorAttachments[Index]:=TVulkanFrameBufferAttachment.Create(fDevice,
                                                                             ColorAttachmentImage,
                                                                             ColorAttachmentImageView,
                                                                             fSwapChain.Width,
                                                                             fSwapChain.Height,
                                                                             fSwapChain.ImageFormat,
                                                                             true);

   except
    FreeAndNil(fFrameBufferColorAttachments[Index]);
    FreeAndNil(ColorAttachmentImageView);
    FreeAndNil(ColorAttachmentImage);
    raise;
   end;

  end;

  fDepthFrameBufferAttachment:=TVulkanFrameBufferAttachment.Create(fDevice,
                                                                   aGraphicsQueue,
                                                                   aGraphicsCommandBuffer,
                                                                   aGraphicsCommandBufferFence,
                                                                   fSwapChain.Width,
                                                                   fSwapChain.Height,
                                                                   fDepthImageFormat,
                                                                   TVkBufferUsageFlags(VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT));

  SetLength(fFrameBuffers,fSwapChain.CountImages);
  for Index:=0 to fSwapChain.CountImages-1 do begin
   fFrameBuffers[Index]:=nil;
  end;
  for Index:=0 to fSwapChain.CountImages-1 do begin
   fFrameBuffers[Index]:=TVulkanFrameBuffer.Create(fDevice,
                                                   fRenderPass,
                                                   fSwapChain.Width,
                                                   fSwapChain.Height,
                                                   1,
                                                   [fFrameBufferColorAttachments[Index],fDepthFrameBufferAttachment],
                                                   false);
  end;

 except

  for Index:=0 to length(fFramebuffers)-1 do begin
   FreeAndNil(fFrameBuffers[Index]);
  end;

  FreeAndNil(fRenderPass);

  FreeAndNil(fDepthFrameBufferAttachment);

  for Index:=0 to length(fFrameBufferColorAttachments)-1 do begin
   FreeAndNil(fFrameBufferColorAttachments[Index]);
  end;

  SetLength(fFrameBufferColorAttachments,0);

  SetLength(fFrameBuffers,0);

  raise;

 end;

end;

destructor TVulkanSwapChainSimpleDirectRenderTarget.Destroy;
var Index:TVkInt32;
begin

 for Index:=0 to length(fFramebuffers)-1 do begin
   FreeAndNil(fFrameBuffers[Index]);
 end;

 FreeAndNil(fRenderPass);

 FreeAndNil(fDepthFrameBufferAttachment);

 for Index:=0 to length(fFrameBufferColorAttachments)-1 do begin
  FreeAndNil(fFrameBufferColorAttachments[Index]);
 end;

 SetLength(fFrameBufferColorAttachments,0);
 SetLength(fFrameBuffers,0);

 inherited Destroy;
end;

function TVulkanSwapChainSimpleDirectRenderTarget.GetRenderPass:TVulkanRenderPass;
begin
 result:=fRenderPass;
end;

function TVulkanSwapChainSimpleDirectRenderTarget.GetFrameBuffer:TVulkanFrameBuffer;
begin
 result:=fFrameBuffers[fSwapChain.CurrentImageIndex];
end;

function TVulkanSwapChainSimpleDirectRenderTarget.GetFrameBufferAtIndex(const aIndex:TVkInt32):TVulkanFrameBuffer;
begin
 result:=fFrameBuffers[aIndex];
end;

constructor TVulkanShaderModule.Create(const aDevice:TVulkanDevice;const aData;const aDataSize:TVkSize);
begin

 inherited Create;

 fDevice:=aDevice;

 fShaderModuleHandle:=VK_NULL_HANDLE;

 fData:=nil;

 fDataAligned:=nil;

 fDataSize:=aDataSize;
 if (fDataSize and 3)<>0 then begin
  inc(fDataSize,4-(fDataSize and 3));
 end;

 GetMem(fData,fDataSize+4);
 fDataAligned:=fData;
 if (TVkPtrUInt(fDataAligned) and 3)<>0 then begin
  inc(TVkPtrUInt(fDataAligned),4-(TVkPtrUInt(fDataAligned) and 3));
 end;

 Load;

end;

constructor TVulkanShaderModule.Create(const aDevice:TVulkanDevice;const aStream:TStream);
begin

 inherited Create;

 fDevice:=aDevice;

 fShaderModuleHandle:=VK_NULL_HANDLE;

 fData:=nil;

 fDataAligned:=nil;

 fDataSize:=aStream.Size;
 if (fDataSize and 3)<>0 then begin
  inc(fDataSize,4-(fDataSize and 3));
 end;

 GetMem(fData,fDataSize+4);
 fDataAligned:=fData;
 if (TVkPtrUInt(fDataAligned) and 3)<>0 then begin
  inc(TVkPtrUInt(fDataAligned),4-(TVkPtrUInt(fDataAligned) and 3));
 end;

 if aStream.Seek(0,soBeginning)<>0 then begin
  raise EInOutError.Create('Stream seek error');
 end;

 if aStream.Read(fData^,aStream.Size)<>aStream.Size then begin
  raise EInOutError.Create('Stream read error');
 end;

 Load;

end;

constructor TVulkanShaderModule.Create(const aDevice:TVulkanDevice;const aFileName:string);
var FileStream:TFileStream;
begin
 FileStream:=TFileStream.Create(aFileName,fmOpenRead or fmShareDenyWrite);
 try
  Create(aDevice,FileStream);
 finally
  FileStream.Free;
 end;
end;

destructor TVulkanShaderModule.Destroy;
begin
 if fShaderModuleHandle<>VK_NULL_HANDLE then begin
  fDevice.fDeviceVulkan.DestroyShaderModule(fDevice.fDeviceHandle,fShaderModuleHandle,fDevice.fAllocationCallbacks);
  fShaderModuleHandle:=VK_NULL_HANDLE;
 end;
 if assigned(fData) then begin
  FreeMem(fData);
  fData:=nil;
 end;
 inherited Destroy;
end;

procedure TVulkanShaderModule.Load;
var ShaderModuleCreateInfo:TVkShaderModuleCreateInfo;
begin
 if fShaderModuleHandle=VK_NULL_HANDLE then begin
  FillChar(ShaderModuleCreateInfo,SizeOf(TVkShaderModuleCreateInfo),#0);
  ShaderModuleCreateInfo.sType:=VK_STRUCTURE_TYPE_SHADER_MODULE_CREATE_INFO;
  ShaderModuleCreateInfo.codeSize:=fDataSize;
  ShaderModuleCreateInfo.pCode:=fData;
  HandleResultCode(fDevice.fDeviceVulkan.CreateShaderModule(fDevice.fDeviceHandle,@ShaderModuleCreateInfo,fDevice.fAllocationCallbacks,@fShaderModuleHandle));
 end;
end;

function TVulkanShaderModule.GetVariables:TVulkanShaderModuleVariables;
// https://www.khronos.org/registry/spir-v/specs/1.1/SPIRV.html
type PVkUInt32Array=^TVkUInt32Array;
     TVkUInt32Array=array[0..65535] of TVkUInt32;
var Position,Size:TVkInt32;
    Opcode,Index,NameIndex,Count,CountIDs,CountNames:TVkUInt32;
    Opcodes:PVkUInt32Array;
    Endian:boolean;
    Variable:PVulkanShaderModuleVariable;
    Bindings,Locations,DescriptorSets:array of TVkUInt32;
    DebugNames:array of TVkCharString;
 function SwapEndian(const Value:TVkUInt32):TVkUInt32;
 begin
  if Endian then begin
   result:=(((Value shr 0) and $ff) shl 24) or
           (((Value shr 8) and $ff) shl 16) or
           (((Value shr 16) and $ff) shl 8) or
           (((Value shr 24) and $ff) shl 0);
  end else begin
   result:=Value;
  end;
 end;
begin
 result:=nil;
 Bindings:=nil;
 Locations:=nil;
 DescriptorSets:=nil;
 DebugNames:=nil;
 Count:=0;
 try
  Opcodes:=fData;
  if assigned(Opcodes) and (fDataSize>=(6*SizeOf(TVkUInt32))) and ((Opcodes^[0]=$07230203) or (Opcodes^[0]=$03022307)) then begin

   Endian:=Opcodes[0]=$03022307;

   Opcodes:=TVkPointer(@Opcodes[5]);

   Size:=(fDataSize shr 2)-5;

   CountIDs:=0;
   CountNames:=0;

   Position:=0;
   while Position<Size do begin
    Opcode:=SwapEndian(Opcodes^[Position]);
    case Opcode and $ffff of
     $0005{OpName}:begin
      CountNames:=Max(CountNames,SwapEndian(Opcodes^[Position+1])+1);
     end;
     $003b{OpVariable}:begin
      inc(Count);
     end;
     $0047{OpOpDecorate}:begin
      CountIDs:=Max(CountIDs,SwapEndian(Opcodes^[Position+1])+1);
     end;
    end;
    inc(Position,Opcode shr 16);
   end;

   SetLength(result,Count);

   try

    SetLength(Bindings,CountIDs);
    SetLength(Locations,CountIDs);
    SetLength(DescriptorSets,CountIDs);
    SetLength(DebugNames,CountNames);

    Position:=0;
    while Position<Size do begin
     Opcode:=SwapEndian(Opcodes^[Position]);
     case Opcode and $ffff of
      $0005{OpName}:begin
       Index:=SwapEndian(Opcodes^[Position+1]);
       if Index<CountNames then begin
        DebugNames[Index]:=PVkChar(TVkPointer(@Opcodes^[Position+2]));
       end;
      end;
      $0047{OpDecorate}:begin
       Index:=SwapEndian(Opcodes^[Position+1]);
       if Index<CountIDs then begin
        case Opcodes^[Position+2] of
         $0000001e{Location}:begin
          Locations[Index]:=SwapEndian(Opcodes^[Position+3]);
         end;
         $00000021{Binding}:begin
          Bindings[Index]:=SwapEndian(Opcodes^[Position+3]);
         end;
         $00000022{DescriptorSet}:begin
          DescriptorSets[Index]:=SwapEndian(Opcodes^[Position+3]);
         end;
        end;
       end;
      end;
     end;
     inc(Position,Opcode shr 16);
    end;

    Count:=0;
    Position:=0;
    while Position<Size do begin
     Opcode:=SwapEndian(Opcodes^[Position]);
     case Opcode and $ffff of
      $003b{OpVariable}:begin
       Variable:=@result[Count];
       inc(Count);
       Index:=SwapEndian(Opcodes^[Position+1]);
       if Index<CountIDs then begin
        Variable^.fLocation:=Locations[Index];
        Variable^.fBinding:=Bindings[Index];
        Variable^.fDescriptorSet:=DescriptorSets[Index];
       end else begin
        Variable^.fLocation:=0;
        Variable^.fBinding:=0;
        Variable^.fDescriptorSet:=0;
       end;
       NameIndex:=SwapEndian(Opcodes^[Position+2]);
       if NameIndex<CountNames then begin
        Variable^.fDebugName:=DebugNames[NameIndex];
       end else begin
        Variable^.fDebugName:='';
       end;
       Variable^.fName:=NameIndex;
       Variable^.fInstruction:=Position;
       Variable^.fStorageClass:=TVulkanShaderModuleVariableStorageClass(SwapEndian(Opcodes^[Position+3]));
      end;
     end;
     inc(Position,Opcode shr 16);
    end;

   finally
    Bindings:=nil;
    Locations:=nil;
    DescriptorSets:=nil;
    DebugNames:=nil;
   end;

  end;
 finally
  SetLength(result,Count);
 end;
end;

constructor TVulkanDescriptorPool.Create(const aDevice:TVulkanDevice;
                                         const aFlags:TVkDescriptorPoolCreateFlags;
                                         const aMaxSets:TVkUInt32);
begin
 inherited Create;

 fDevice:=aDevice;

 fDescriptorPoolHandle:=VK_NULL_HANDLE;

 fFlags:=aFlags;
 fMaxSets:=aMaxSets;

 fDescriptorPoolSizes:=nil;
 fCountDescriptorPoolSizes:=0;

end;

destructor TVulkanDescriptorPool.Destroy;
begin
 if fDescriptorPoolHandle<>VK_NULL_HANDLE then begin
  fDevice.fDeviceVulkan.DestroyDescriptorPool(fDevice.fDeviceHandle,fDescriptorPoolHandle,fDevice.fAllocationCallbacks);
  fDescriptorPoolHandle:=VK_NULL_HANDLE;
 end;
 SetLength(fDescriptorPoolSizes,0);
 inherited Destroy;
end;

function TVulkanDescriptorPool.AddDescriptorPoolSize(const aType:TVkDescriptorType;const aDescriptorCount:TVkUInt32):TVkInt32;
var DescriptorPoolSize:PVkDescriptorPoolSize;
begin
 result:=fCountDescriptorPoolSizes;
 inc(fCountDescriptorPoolSizes);
 if fCountDescriptorPoolSizes>length(fDescriptorPoolSizes) then begin
  SetLength(fDescriptorPoolSizes,fCountDescriptorPoolSizes*2);
 end;
 DescriptorPoolSize:=@fDescriptorPoolSizes[result];
 DescriptorPoolSize.type_:=aType;
 DescriptorPoolSize.descriptorCount:=aDescriptorCount;
end;

procedure TVulkanDescriptorPool.Initialize;
var DescriptorPoolCreateInfo:TVkDescriptorPoolCreateInfo;
begin
 if fDescriptorPoolHandle=VK_NULL_HANDLE then begin
  FillChar(DescriptorPoolCreateInfo,SizeOf(TVkDescriptorPoolCreateInfo),#0);
  DescriptorPoolCreateInfo.sType:=VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_CREATE_INFO;
  DescriptorPoolCreateInfo.flags:=fFlags;
  DescriptorPoolCreateInfo.maxSets:=fMaxSets;
  if fCountDescriptorPoolSizes>0 then begin
   SetLength(fDescriptorPoolSizes,fCountDescriptorPoolSizes);
   DescriptorPoolCreateInfo.poolSizeCount:=length(fDescriptorPoolSizes);
   DescriptorPoolCreateInfo.pPoolSizes:=@fDescriptorPoolSizes[0];
  end;
  HandleResultCode(fDevice.fDeviceVulkan.CreateDescriptorPool(fDevice.fDeviceHandle,@DescriptorPoolCreateInfo,fDevice.fAllocationCallbacks,@fDescriptorPoolHandle));
 end;
end;

constructor TVulkanDescriptorSetLayoutBinding.Create(const aBinding:TVkUInt32;
                                                     const aDescriptorType:TVkDescriptorType;
                                                     const aDescriptorCount:TVkUInt32;
                                                     const aStageFlags:TVkShaderStageFlags);
begin
 inherited Create;

 FillChar(fDescriptorSetLayoutBinding,SizeOf(TVkDescriptorSetLayoutBinding),#0);
 fDescriptorSetLayoutBinding.binding:=aBinding;
 fDescriptorSetLayoutBinding.descriptorType:=aDescriptorType;
 fDescriptorSetLayoutBinding.descriptorCount:=aDescriptorCount;
 fDescriptorSetLayoutBinding.stageFlags:=aStageFlags;

 fImmutableSamplers:=nil;
 fCountImmutableSamplers:=0;

end;

destructor TVulkanDescriptorSetLayoutBinding.Destroy;
begin
 SetLength(fImmutableSamplers,0);
 inherited Destroy;
end;

function TVulkanDescriptorSetLayoutBinding.GetBinding:TVkUInt32;
begin
 result:=fDescriptorSetLayoutBinding.binding;
end;

procedure TVulkanDescriptorSetLayoutBinding.SetBinding(const aBinding:TVkUInt32);
begin
 fDescriptorSetLayoutBinding.binding:=aBinding;
end;

function TVulkanDescriptorSetLayoutBinding.GetDescriptorType:TVkDescriptorType;
begin
 result:=fDescriptorSetLayoutBinding.descriptorType;
end;

procedure TVulkanDescriptorSetLayoutBinding.SetDescriptorType(const aDescriptorType:TVkDescriptorType);
begin
 fDescriptorSetLayoutBinding.descriptorType:=aDescriptorType;
end;

function TVulkanDescriptorSetLayoutBinding.GetDescriptorCount:TVkUInt32;
begin
 result:=fDescriptorSetLayoutBinding.DescriptorCount;
end;

procedure TVulkanDescriptorSetLayoutBinding.SetDescriptorCount(const aDescriptorCount:TVkUInt32);
begin
 fDescriptorSetLayoutBinding.descriptorCount:=aDescriptorCount;
end;

function TVulkanDescriptorSetLayoutBinding.GetStageFlags:TVkShaderStageFlags;
begin
 result:=fDescriptorSetLayoutBinding.stageFlags;
end;

procedure TVulkanDescriptorSetLayoutBinding.SetStageFlags(const aStageFlags:TVkShaderStageFlags);
begin
 fDescriptorSetLayoutBinding.stageFlags:=aStageFlags;
end;

procedure TVulkanDescriptorSetLayoutBinding.AddImmutableSampler(const aImmutableSampler:TVulkanSampler);
var Index:TVkInt32;
begin
 Index:=fCountImmutableSamplers;
 inc(fCountImmutableSamplers);
 if fCountImmutableSamplers>length(fImmutableSamplers) then begin
  SetLength(fImmutableSamplers,fCountImmutableSamplers*2);
 end;
 fImmutableSamplers[Index]:=aImmutableSampler.fSamplerHandle;
end;

procedure TVulkanDescriptorSetLayoutBinding.AddImmutableSamplers(const aImmutableSamplers:array of TVulkanSampler);
var Index:TVkInt32;
begin
 for Index:=0 to length(aImmutableSamplers)-1 do begin
  AddImmutableSampler(aImmutableSamplers[Index]);
 end;
end;

procedure TVulkanDescriptorSetLayoutBinding.Initialize;
begin
 SetLength(fImmutableSamplers,fCountImmutableSamplers);
 fDescriptorSetLayoutBinding.pImmutableSamplers:=@fImmutableSamplers[0];
end;

constructor TVulkanDescriptorSetLayout.Create(const aDevice:TVulkanDevice);
begin
 inherited Create;

 fDevice:=aDevice;

 fDescriptorSetLayoutHandle:=VK_NULL_HANDLE;

 fDescriptorSetLayoutBindingList:=TVulkanObjectList.Create;
 fDescriptorSetLayoutBindingList.OwnObjects:=true;

 fDescriptorSetLayoutBindingArray:=nil;

end;

destructor TVulkanDescriptorSetLayout.Destroy;
begin
 if fDescriptorSetLayoutHandle<>VK_NULL_HANDLE then begin
  fDevice.fDeviceVulkan.DestroyDescriptorSetLayout(fDevice.fDeviceHandle,fDescriptorSetLayoutHandle,fDevice.fAllocationCallbacks);
  fDescriptorSetLayoutHandle:=VK_NULL_HANDLE;
 end;
 FreeAndNil(fDescriptorSetLayoutBindingList);
 SetLength(fDescriptorSetLayoutBindingArray,0);
 inherited Destroy;
end;

procedure TVulkanDescriptorSetLayout.AddBinding(const aBinding:TVkUInt32;
                                                const aDescriptorType:TVkDescriptorType;
                                                const aDescriptorCount:TVkUInt32;
                                                const aStageFlags:TVkShaderStageFlags;
                                                const aImmutableSamplers:array of TVulkanSampler);
var DescriptorSetLayoutBinding:TVulkanDescriptorSetLayoutBinding;
begin
 DescriptorSetLayoutBinding:=TVulkanDescriptorSetLayoutBinding.Create(aBinding,aDescriptorType,aDescriptorCount,aStageFlags);
 fDescriptorSetLayoutBindingList.Add(DescriptorSetLayoutBinding);
 DescriptorSetLayoutBinding.AddImmutableSamplers(aImmutableSamplers);
 DescriptorSetLayoutBinding.Initialize;
end;

procedure TVulkanDescriptorSetLayout.Initialize;
var Index:TVkInt32;
    DescriptorSetLayoutCreateInfo:TVkDescriptorSetLayoutCreateInfo;
begin
 if fDescriptorSetLayoutHandle=VK_NULL_HANDLE then begin
  FillChar(DescriptorSetLayoutCreateInfo,SizeOf(TVkDescriptorSetLayoutCreateInfo),#0);
  DescriptorSetLayoutCreateInfo.sType:=VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO;
  SetLength(fDescriptorSetLayoutBindingArray,fDescriptorSetLayoutBindingList.Count);
  if length(fDescriptorSetLayoutBindingArray)>0 then begin
   for Index:=0 to length(fDescriptorSetLayoutBindingArray)-1 do begin
    fDescriptorSetLayoutBindingArray[Index]:=TVulkanDescriptorSetLayoutBinding(fDescriptorSetLayoutBindingList[Index]).fDescriptorSetLayoutBinding;
   end;
   DescriptorSetLayoutCreateInfo.bindingCount:=length(fDescriptorSetLayoutBindingArray);
   DescriptorSetLayoutCreateInfo.pBindings:=@fDescriptorSetLayoutBindingArray[0];
  end;
  HandleResultCode(fDevice.fDeviceVulkan.CreateDescriptorSetLayout(fDevice.fDeviceHandle,@DescriptorSetLayoutCreateInfo,fDevice.fAllocationCallbacks,@fDescriptorSetLayoutHandle));
 end;
end;

constructor TVulkanDescriptorSet.Create(const aDescriptorPool:TVulkanDescriptorPool;
                                        const aDescriptorSetLayout:TVulkanDescriptorSetLayout);
begin
 inherited Create;

 fDevice:=aDescriptorPool.fDevice;

 fDescriptorPool:=aDescriptorPool;

 fDescriptorSetLayout:=aDescriptorSetLayout;

 fDescriptorSetHandle:=VK_NULL_HANDLE;

 fCopyDescriptorSetQueue:=nil;
 fCopyDescriptorSetQueueSize:=0;

 fWriteDescriptorSetQueue:=nil;
 fWriteDescriptorSetQueueMetaData:=nil;
 fWriteDescriptorSetQueueSize:=0;

 FillChar(fDescriptorSetAllocateInfo,SizeOf(TVkDescriptorSetAllocateInfo),#0);
 fDescriptorSetAllocateInfo.sType:=VK_STRUCTURE_TYPE_DESCRIPTOR_SET_ALLOCATE_INFO;
 fDescriptorSetAllocateInfo.descriptorPool:=fDescriptorPool.fDescriptorPoolHandle;
 fDescriptorSetAllocateInfo.descriptorSetCount:=1;
 fDescriptorSetAllocateInfo.pSetLayouts:=@fDescriptorSetLayout.fDescriptorSetLayoutHandle;

 fDevice.fDeviceVulkan.AllocateDescriptorSets(fDevice.fDeviceHandle,@fDescriptorSetAllocateInfo,@fDescriptorSetHandle);

end;

destructor TVulkanDescriptorSet.Destroy;
begin
 if fDescriptorSetHandle<>VK_NULL_HANDLE then begin
  fDevice.fDeviceVulkan.FreeDescriptorSets(fDevice.fDeviceHandle,fDescriptorPool.fDescriptorPoolHandle,1,@fDescriptorSetHandle);
  fDescriptorSetHandle:=VK_NULL_HANDLE;
 end;
 SetLength(fCopyDescriptorSetQueue,0);
 SetLength(fWriteDescriptorSetQueue,0);
 SetLength(fWriteDescriptorSetQueueMetaData,0);
 inherited Destroy;
end;

class function TVulkanDescriptorSet.Allocate(const aDescriptorPool:TVulkanDescriptorPool;
                                             const aDescriptorSetLayouts:array of TVulkanDescriptorSetLayout):TVulkanObjectList;

var Index:TVkInt32;
begin
 result:=TVulkanObjectList.Create;
 try
  for Index:=0 to length(aDescriptorSetLayouts)-1 do begin
   result.Add(TVulkanDescriptorSet.Create(aDescriptorPool,aDescriptorSetLayouts[Index]));
  end;
 except
  FreeAndNil(result);
  raise;
 end;
end;

procedure TVulkanDescriptorSet.CopyFromDescriptorSet(const aSourceDescriptorSet:TVulkanDescriptorSet;
                                                     const aSourceBinding:TVkUInt32;
                                                     const aSourceArrayElement:TVkUInt32;
                                                     const aDestinationBinding:TVkUInt32;
                                                     const aDestinationArrayElement:TVkUInt32;
                                                     const aDescriptorCount:TVkUInt32;
                                                     const aDoInstant:boolean=false);
 procedure InstantCopyFromDescriptorSet;
 var CopyDescriptorSet:TVkCopyDescriptorSet;
 begin
  FillChar(CopyDescriptorSet,SizeOf(TVkCopyDescriptorSet),#0);
  CopyDescriptorSet.sType:=VK_STRUCTURE_TYPE_COPY_DESCRIPTOR_SET;
  CopyDescriptorSet.srcSet:=aSourceDescriptorSet.Handle;
  CopyDescriptorSet.srcBinding:=aSourceBinding;
  CopyDescriptorSet.srcArrayElement:=aSourceArrayElement;
  CopyDescriptorSet.dstBinding:=aDestinationBinding;
  CopyDescriptorSet.dstArrayElement:=aDestinationArrayElement;
  CopyDescriptorSet.descriptorCount:=aDescriptorCount;
  fDevice.fDeviceVulkan.UpdateDescriptorSets(fDevice.fDeviceHandle,0,nil,1,@CopyDescriptorSet);
 end;
var Index:TVkInt32;
    CopyDescriptorSet:PVkCopyDescriptorSet;
begin
 if aDoInstant then begin
  InstantCopyFromDescriptorSet; 
 end else begin
  Index:=fCopyDescriptorSetQueueSize;
  inc(fCopyDescriptorSetQueueSize);
  if length(fCopyDescriptorSetQueue)<fCopyDescriptorSetQueueSize then begin
   SetLength(fCopyDescriptorSetQueue,fCopyDescriptorSetQueueSize*2);
  end;
  CopyDescriptorSet:=@fCopyDescriptorSetQueue[Index];
  FillChar(CopyDescriptorSet^,SizeOf(TVkCopyDescriptorSet),#0);
  CopyDescriptorSet^.sType:=VK_STRUCTURE_TYPE_COPY_DESCRIPTOR_SET;
  CopyDescriptorSet^.srcSet:=aSourceDescriptorSet.Handle;
  CopyDescriptorSet^.srcBinding:=aSourceBinding;
  CopyDescriptorSet^.srcArrayElement:=aSourceArrayElement;
  CopyDescriptorSet^.dstBinding:=aDestinationBinding;
  CopyDescriptorSet^.dstArrayElement:=aDestinationArrayElement;
  CopyDescriptorSet^.descriptorCount:=aDescriptorCount;
 end;
end;

procedure TVulkanDescriptorSet.WriteToDescriptorSet(const aDestinationBinding:TVkUInt32;
                                                    const aDestinationArrayElement:TVkUInt32;
                                                    const aDescriptorCount:TVkUInt32;
                                                    const aDescriptorType:TVkDescriptorType;
                                                    const aImageInfo:array of TVkDescriptorImageInfo;
                                                    const aBufferInfo:array of TVkDescriptorBufferInfo;
                                                    const aTexelBufferView:array of TVkBufferView;
                                                    const aDoInstant:boolean=false);
 procedure InstantWriteToDescriptorSet;
 var WriteDescriptorSet:TVkWriteDescriptorSet;
 begin
  FillChar(WriteDescriptorSet,SizeOf(TVkWriteDescriptorSet),#0);
  WriteDescriptorSet.sType:=VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
  WriteDescriptorSet.dstSet:=fDescriptorSetHandle;
  WriteDescriptorSet.dstBinding:=aDestinationBinding;
  WriteDescriptorSet.dstArrayElement:=aDestinationArrayElement;
  WriteDescriptorSet.descriptorType:=aDescriptorType;
  WriteDescriptorSet.descriptorCount:=aDescriptorCount;
  if length(aImageInfo)>0 then begin
   WriteDescriptorSet.pImageInfo:=@aImageInfo[0];
  end else begin
   WriteDescriptorSet.pImageInfo:=nil;
  end;
  if length(aBufferInfo)>0 then begin
   WriteDescriptorSet.pBufferInfo:=@aBufferInfo[0];
  end else begin
   WriteDescriptorSet.pBufferInfo:=nil;
  end;
  if length(aTexelBufferView)>0 then begin
   WriteDescriptorSet.pTexelBufferView:=@aTexelBufferView[0];
  end else begin
   WriteDescriptorSet.pTexelBufferView:=nil;
  end;
  fDevice.fDeviceVulkan.UpdateDescriptorSets(fDevice.fDeviceHandle,1,@WriteDescriptorSet,0,nil);
 end;
var Index:TVkInt32;
    WriteDescriptorSet:PVkWriteDescriptorSet;
    WriteDescriptorSetMetaData:PVulkanDescriptorSetWriteDescriptorSetMetaData;
begin
 if aDoInstant then begin
  InstantWriteToDescriptorSet;
 end else begin
  Index:=fWriteDescriptorSetQueueSize;
  inc(fWriteDescriptorSetQueueSize);
  if length(fWriteDescriptorSetQueue)<fWriteDescriptorSetQueueSize then begin
   SetLength(fWriteDescriptorSetQueue,fWriteDescriptorSetQueueSize*2);
  end;
  if length(fWriteDescriptorSetQueueMetaData)<fWriteDescriptorSetQueueSize then begin
   SetLength(fWriteDescriptorSetQueueMetaData,fWriteDescriptorSetQueueSize*2);
  end;
  WriteDescriptorSet:=@fWriteDescriptorSetQueue[Index];
  WriteDescriptorSetMetaData:=@fWriteDescriptorSetQueueMetaData[Index];
  FillChar(WriteDescriptorSet^,SizeOf(TVkWriteDescriptorSet),#0);
  WriteDescriptorSet^.sType:=VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
  WriteDescriptorSet^.dstSet:=fDescriptorSetHandle;
  WriteDescriptorSet^.dstBinding:=aDestinationBinding;
  WriteDescriptorSet^.dstArrayElement:=aDestinationArrayElement;
  WriteDescriptorSet^.descriptorType:=aDescriptorType;
  WriteDescriptorSet^.descriptorCount:=aDescriptorCount;
  WriteDescriptorSet^.pImageInfo:=nil;
  WriteDescriptorSet^.pBufferInfo:=nil;
  WriteDescriptorSet^.pTexelBufferView:=nil;
  WriteDescriptorSetMetaData^.ImageInfo:=nil;
  WriteDescriptorSetMetaData^.BufferInfo:=nil;
  WriteDescriptorSetMetaData^.TexelBufferView:=nil;
  if length(aImageInfo)>0 then begin
   SetLength(WriteDescriptorSetMetaData^.ImageInfo,length(aImageInfo));
   Move(aImageInfo[0],WriteDescriptorSetMetaData^.ImageInfo[0],length(aImageInfo)*SizeOf(TVkDescriptorImageInfo));
  end;
  if length(aBufferInfo)>0 then begin
   SetLength(WriteDescriptorSetMetaData^.BufferInfo,length(aBufferInfo));
   Move(aBufferInfo[0],WriteDescriptorSetMetaData^.BufferInfo[0],length(aBufferInfo)*SizeOf(TVkDescriptorBufferInfo));
  end;
  if length(aTexelBufferView)>0 then begin
   SetLength(WriteDescriptorSetMetaData^.TexelBufferView,length(aTexelBufferView));
   Move(aTexelBufferView[0],WriteDescriptorSetMetaData^.TexelBufferView[0],length(aTexelBufferView)*SizeOf(TVkBufferView));
  end;
 end;
end;

procedure TVulkanDescriptorSet.Flush;
var Index:TVkInt32;
    WriteDescriptorSet:PVkWriteDescriptorSet;
    WriteDescriptorSetMetaData:PVulkanDescriptorSetWriteDescriptorSetMetaData;
begin
 if fWriteDescriptorSetQueueSize>0 then begin
  for Index:=0 to fWriteDescriptorSetQueueSize-1 do begin
   WriteDescriptorSet:=@fWriteDescriptorSetQueue[Index];
   WriteDescriptorSetMetaData:=@fWriteDescriptorSetQueueMetaData[Index];
   if length(WriteDescriptorSetMetaData^.ImageInfo)>0 then begin
    WriteDescriptorSet^.pImageInfo:=@WriteDescriptorSetMetaData^.ImageInfo[0];
   end else begin
    WriteDescriptorSet^.pImageInfo:=nil;
   end;
   if length(WriteDescriptorSetMetaData^.BufferInfo)>0 then begin
    WriteDescriptorSet^.pBufferInfo:=@WriteDescriptorSetMetaData^.BufferInfo[0];
   end else begin
    WriteDescriptorSet^.pBufferInfo:=nil;
   end;
   if length(WriteDescriptorSetMetaData^.TexelBufferView)>0 then begin
    WriteDescriptorSet^.pTexelBufferView:=@WriteDescriptorSetMetaData^.TexelBufferView[0];
   end else begin
    WriteDescriptorSet^.pTexelBufferView:=nil;
   end;
  end;
  if fCopyDescriptorSetQueueSize>0 then begin
   fDevice.fDeviceVulkan.UpdateDescriptorSets(fDevice.fDeviceHandle,fWriteDescriptorSetQueueSize,@fWriteDescriptorSetQueue[0],fCopyDescriptorSetQueueSize,@fCopyDescriptorSetQueue[0]);
  end else begin
   fDevice.fDeviceVulkan.UpdateDescriptorSets(fDevice.fDeviceHandle,fWriteDescriptorSetQueueSize,@fWriteDescriptorSetQueue[0],0,nil);
  end;
 end else if fCopyDescriptorSetQueueSize>0 then begin
  fDevice.fDeviceVulkan.UpdateDescriptorSets(fDevice.fDeviceHandle,0,nil,fCopyDescriptorSetQueueSize,@fCopyDescriptorSetQueue[0]);
 end;
 fCopyDescriptorSetQueueSize:=0;
 fWriteDescriptorSetQueueSize:=0;
end;

constructor TVulkanPipelineLayout.Create(const aDevice:TVulkanDevice);
begin

 inherited Create;

 fDevice:=aDevice;

 fPipelineLayoutHandle:=VK_NULL_HANDLE;

 fDescriptorSetLayouts:=nil;
 fCountDescriptorSetLayouts:=0;

 fPushConstantRanges:=nil;
 fCountPushConstantRanges:=0;

end;

destructor TVulkanPipelineLayout.Destroy;
begin
 if fPipelineLayoutHandle<>VK_NULL_HANDLE then begin
  fDevice.fDeviceVulkan.DestroyPipelineLayout(fDevice.fDeviceHandle,fPipelineLayoutHandle,fDevice.fAllocationCallbacks);
  fPipelineLayoutHandle:=VK_NULL_HANDLE;
 end;
 SetLength(fDescriptorSetLayouts,0);
 SetLength(fPushConstantRanges,0);
 inherited Destroy;
end;

function TVulkanPipelineLayout.AddDescriptorSetLayout(const aDescriptorSetLayout:TVkDescriptorSetLayout):TVkInt32;
begin
 result:=fCountDescriptorSetLayouts;
 inc(fCountDescriptorSetLayouts);
 if fCountDescriptorSetLayouts>length(fDescriptorSetLayouts) then begin
  SetLength(fDescriptorSetLayouts,fCountDescriptorSetLayouts*2);
 end;
 fDescriptorSetLayouts[result]:=aDescriptorSetLayout;
end;

function TVulkanPipelineLayout.AddDescriptorSetLayout(const aDescriptorSetLayout:TVulkanDescriptorSetLayout):TVkInt32;
begin
 result:=fCountDescriptorSetLayouts;
 inc(fCountDescriptorSetLayouts);
 if fCountDescriptorSetLayouts>length(fDescriptorSetLayouts) then begin
  SetLength(fDescriptorSetLayouts,fCountDescriptorSetLayouts*2);
 end;
 fDescriptorSetLayouts[result]:=aDescriptorSetLayout.fDescriptorSetLayoutHandle;
end;

function TVulkanPipelineLayout.AddDescriptorSetLayouts(const aDescriptorSetLayouts:array of TVkDescriptorSetLayout):TVkInt32;
begin
 if length(aDescriptorSetLayouts)>0 then begin
  result:=fCountDescriptorSetLayouts;
  inc(fCountDescriptorSetLayouts,length(aDescriptorSetLayouts));
  if fCountDescriptorSetLayouts>length(fDescriptorSetLayouts) then begin
   SetLength(fDescriptorSetLayouts,fCountDescriptorSetLayouts*2);
  end;
  Move(aDescriptorSetLayouts[0],fDescriptorSetLayouts[result],length(aDescriptorSetLayouts)*SizeOf(TVkDescriptorSetLayout));
 end else begin
  result:=-1;
 end;
end;

function TVulkanPipelineLayout.AddDescriptorSetLayouts(const aDescriptorSetLayouts:array of TVulkanDescriptorSetLayout):TVkInt32;
var Index:TVkInt32;
begin
 if length(aDescriptorSetLayouts)>0 then begin
  result:=fCountDescriptorSetLayouts;
  inc(fCountDescriptorSetLayouts,length(aDescriptorSetLayouts));
  if fCountDescriptorSetLayouts>length(fDescriptorSetLayouts) then begin
   SetLength(fDescriptorSetLayouts,fCountDescriptorSetLayouts*2);
  end;
  for Index:=0 to length(aDescriptorSetLayouts)-1 do begin
   fDescriptorSetLayouts[result+Index]:=aDescriptorSetLayouts[Index].fDescriptorSetLayoutHandle;
  end;
 end else begin
  result:=-1;
 end;
end;

function TVulkanPipelineLayout.AddPushConstantRange(const aPushConstantRange:TVkPushConstantRange):TVkInt32;
begin
 result:=fCountPushConstantRanges;
 inc(fCountPushConstantRanges);
 if fCountPushConstantRanges>length(fPushConstantRanges) then begin
  SetLength(fPushConstantRanges,fCountPushConstantRanges*2);
 end;
 fPushConstantRanges[result]:=aPushConstantRange;
end;

function TVulkanPipelineLayout.AddPushConstantRange(const aStageFlags:TVkShaderStageFlags;const aOffset,aSize:TVkUInt32):TVkInt32;
var PushConstantRange:PVkPushConstantRange;
begin
 result:=fCountPushConstantRanges;
 inc(fCountPushConstantRanges);
 if fCountPushConstantRanges>length(fPushConstantRanges) then begin
  SetLength(fPushConstantRanges,fCountPushConstantRanges*2);
 end;
 PushConstantRange:=@fPushConstantRanges[result];
 PushConstantRange^.stageFlags:=aStageFlags;
 PushConstantRange^.offset:=aOffset;
 PushConstantRange^.size:=aSize;
end;

function TVulkanPipelineLayout.AddPushConstantRanges(const aPushConstantRanges:array of TVkPushConstantRange):TVkInt32;
begin
 if length(aPushConstantRanges)>0 then begin
  result:=fCountPushConstantRanges;
  inc(fCountPushConstantRanges,length(aPushConstantRanges));
  if fCountPushConstantRanges>length(fPushConstantRanges) then begin
   SetLength(fPushConstantRanges,fCountPushConstantRanges*2);
  end;
  Move(aPushConstantRanges[0],fPushConstantRanges[result],length(aPushConstantRanges)*SizeOf(TVkPushConstantRange));
 end else begin
  result:=-1;
 end;
end;

procedure TVulkanPipelineLayout.Initialize;
var PipelineLayoutCreateInfo:TVkPipelineLayoutCreateInfo;
begin

 if fPipelineLayoutHandle=VK_NULL_HANDLE then begin

  FillChar(PipelineLayoutCreateInfo,SizeOf(TVkPipelineLayoutCreateInfo),#0);
  PipelineLayoutCreateInfo.sType:=VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO;
  PipelineLayoutCreateInfo.pNext:=nil;
  PipelineLayoutCreateInfo.flags:=0;
  PipelineLayoutCreateInfo.setLayoutCount:=0;
  PipelineLayoutCreateInfo.pSetLayouts:=nil;
  PipelineLayoutCreateInfo.pushConstantRangeCount:=0;
  PipelineLayoutCreateInfo.pPushConstantRanges:=nil;
  
  SetLength(fDescriptorSetLayouts,fCountDescriptorSetLayouts);
  PipelineLayoutCreateInfo.setLayoutCount:=fCountDescriptorSetLayouts;
  if fCountDescriptorSetLayouts>0 then begin
   PipelineLayoutCreateInfo.pSetLayouts:=@fDescriptorSetLayouts[0];
  end else begin
   PipelineLayoutCreateInfo.pSetLayouts:=nil;
  end;

  SetLength(fPushConstantRanges,fCountPushConstantRanges);
  PipelineLayoutCreateInfo.pushConstantRangeCount:=fCountPushConstantRanges;
  if fCountPushConstantRanges>0 then begin
   PipelineLayoutCreateInfo.pPushConstantRanges:=@fPushConstantRanges[0];
  end else begin
   PipelineLayoutCreateInfo.pPushConstantRanges:=nil;
  end;

  HandleResultCode(fDevice.fDeviceVulkan.CreatePipelineLayout(fDevice.fDeviceHandle,@PipelineLayoutCreateInfo,fDevice.fAllocationCallbacks,@fPipelineLayoutHandle));

 end;

end;

constructor TVulkanPipelineShaderStage.Create(const aStage:TVkShaderStageFlagBits;
                                              const aModule:TVulkanShaderModule;
                                              const aName:TVkCharString);
begin

 inherited Create;

 fName:=aName;

 FillChar(fPipelineShaderStageCreateInfo,SizeOf(TVkPipelineShaderStageCreateInfo),#0);
 fPipelineShaderStageCreateInfo.sType:=VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO;
 fPipelineShaderStageCreateInfo.pNext:=nil;
 fPipelineShaderStageCreateInfo.flags:=0;
 fPipelineShaderStageCreateInfo.stage:=aStage;
 fPipelineShaderStageCreateInfo.module:=aModule.fShaderModuleHandle;
 fPipelineShaderStageCreateInfo.pName:=PVkChar(fName);
 fPipelineShaderStageCreateInfo.pSpecializationInfo:=nil;

 fPointerToPipelineShaderStageCreateInfo:=@fPipelineShaderStageCreateInfo;

 fSpecializationInfo:=nil;

 fDoCopyAndDoFree:=false;

 fSpecializationMapEntries:=nil;
 fCountSpecializationMapEntries:=0;

 fInitialized:=false;

end;

destructor TVulkanPipelineShaderStage.Destroy;
begin
 fName:='';
 if assigned(fSpecializationInfo) then begin
  if assigned(fSpecializationInfo.pData) and fDoCopyAndDoFree then begin
   FreeMem(fSpecializationInfo.pData);
   fSpecializationInfo.pData:=nil;
   fSpecializationInfo.dataSize:=0;
  end;
  FreeMem(fSpecializationInfo);
  fSpecializationInfo:=nil;
 end;
 SetLength(fSpecializationMapEntries,0);
 inherited Destroy;
end;

procedure TVulkanPipelineShaderStage.AllocateSpecializationInfo;
begin
 if not assigned(fSpecializationInfo) then begin
  GetMem(fSpecializationInfo,SizeOf(TVkSpecializationInfo));
  FillChar(fSpecializationInfo^,SizeOf(TVkSpecializationInfo),#0);
  fPipelineShaderStageCreateInfo.pSpecializationInfo:=fSpecializationInfo;
 end;
end;

procedure TVulkanPipelineShaderStage.AddSpecializationDataFromMemory(const aData:TVkPointer;const aDataSize:TVkSize;const aDoCopyAndDoFree:boolean=true);
begin
 if assigned(fSpecializationInfo) and assigned(fSpecializationInfo.pData) and fDoCopyAndDoFree then begin
  FreeMem(fSpecializationInfo.pData);
  fSpecializationInfo.pData:=nil;
  fSpecializationInfo.dataSize:=0;
 end;
 if assigned(aData) and (aDataSize>0) then begin
  AllocateSpecializationInfo;
  fDoCopyAndDoFree:=aDoCopyAndDoFree;
  if fDoCopyAndDoFree then begin
   GetMem(fSpecializationInfo.pData,aDataSize);
   Move(aData^,fSpecializationInfo.pData^,aDataSize);
  end else begin
   fSpecializationInfo.pData:=aData;
  end;
  fSpecializationInfo.dataSize:=aDataSize;
 end;
end;

procedure TVulkanPipelineShaderStage.AddSpecializationDataFromStream(const aStream:TStream);
begin
 if assigned(fSpecializationInfo) and assigned(fSpecializationInfo.pData) and fDoCopyAndDoFree then begin
  FreeMem(fSpecializationInfo.pData);
  fSpecializationInfo.pData:=nil;
  fSpecializationInfo.dataSize:=0;
 end;
 if assigned(aStream) and (aStream.Size>0) then begin
  AllocateSpecializationInfo;
  fDoCopyAndDoFree:=true;
  GetMem(fSpecializationInfo.pData,aStream.Size);
  if aStream.Seek(0,soBeginning)<>0 then begin
   raise EInOutError.Create('Stream seek error');
  end;
  if aStream.Read(fSpecializationInfo.pData^,aStream.Size)<>aStream.Size then begin
   raise EInOutError.Create('Stream read error');
  end;
  fSpecializationInfo.dataSize:=aStream.Size;
 end;
end;

procedure TVulkanPipelineShaderStage.AddSpecializationDataFromFile(const aFileName:string);
var FileStream:TFileStream;
begin
 FileStream:=TFileStream.Create(aFileName,fmOpenRead or fmShareDenyWrite);
 try
  AddSpecializationDataFromStream(FileStream);
 finally
  FileStream.Free;
 end;
end;

function TVulkanPipelineShaderStage.AddSpecializationMapEntry(const aSpecializationMapEntry:TVkSpecializationMapEntry):TVkInt32;
begin
 result:=fCountSpecializationMapEntries;
 inc(fCountSpecializationMapEntries);
 if length(fSpecializationMapEntries)<fCountSpecializationMapEntries then begin
  SetLength(fSpecializationMapEntries,fCountSpecializationMapEntries*2);
 end;
 fSpecializationMapEntries[result]:=aSpecializationMapEntry;
end;

function TVulkanPipelineShaderStage.AddSpecializationMapEntry(const aConstantID,aOffset:TVkUInt32;const aSize:TVkSize):TVkInt32;
var SpecializationMapEntry:PVkSpecializationMapEntry;
begin
 result:=fCountSpecializationMapEntries;
 inc(fCountSpecializationMapEntries);
 if length(fSpecializationMapEntries)<fCountSpecializationMapEntries then begin
  SetLength(fSpecializationMapEntries,fCountSpecializationMapEntries*2);
 end;
 SpecializationMapEntry:=@fSpecializationMapEntries[result];
 SpecializationMapEntry^.constantID:=aConstantID;
 SpecializationMapEntry^.offset:=aOffset;
 SpecializationMapEntry^.size:=aSize;
end;

function TVulkanPipelineShaderStage.AddSpecializationMapEntries(const aSpecializationMapEntries:array of TVkSpecializationMapEntry):TVkInt32;
begin
 if length(aSpecializationMapEntries)>0 then begin
  result:=fCountSpecializationMapEntries;
  inc(fCountSpecializationMapEntries,length(aSpecializationMapEntries));
  if length(fSpecializationMapEntries)<fCountSpecializationMapEntries then begin
   SetLength(fSpecializationMapEntries,fCountSpecializationMapEntries*2);
  end;
  Move(aSpecializationMapEntries[0],fSpecializationMapEntries[result],length(aSpecializationMapEntries)*SizeOf(TVkSpecializationMapEntry));
 end else begin
  result:=-1;
 end;
end;

procedure TVulkanPipelineShaderStage.Initialize;
begin
 if not fInitialized then begin
  fInitialized:=true;
  if fCountSpecializationMapEntries>0 then begin
   AllocateSpecializationInfo;
   SetLength(fSpecializationMapEntries,fCountSpecializationMapEntries);
   fSpecializationInfo^.mapEntryCount:=fCountSpecializationMapEntries;
   fSpecializationInfo^.pMapEntries:=@fSpecializationMapEntries[0];
  end;
 end;
end;

constructor TVulkanPipelineCache.Create(const aDevice:TVulkanDevice;const aInitialData:TVkPointer=nil;const aInitialDataSize:TVkSize=0);
var PipelineCacheCreateInfo:TVkPipelineCacheCreateInfo;
begin
 inherited Create;

 fDevice:=aDevice;

 fPipelineCacheHandle:=VK_NULL_HANDLE;

 FillChar(PipelineCacheCreateInfo,SizeOf(TVkPipelineCacheCreateInfo),#0);
 PipelineCacheCreateInfo.sType:=VK_STRUCTURE_TYPE_PIPELINE_CACHE_CREATE_INFO;
 PipelineCacheCreateInfo.pNext:=nil;
 PipelineCacheCreateInfo.flags:=0;
 PipelineCacheCreateInfo.pInitialData:=aInitialData;
 PipelineCacheCreateInfo.initialDataSize:=aInitialDataSize;

 HandleResultCode(fDevice.fDeviceVulkan.CreatePipelineCache(fDevice.fDeviceHandle,@PipelineCacheCreateInfo,fDevice.fAllocationCallbacks,@fPipelineCacheHandle));

end;

constructor TVulkanPipelineCache.CreateFromMemory(const aDevice:TVulkanDevice;const aInitialData:TVkPointer;const aInitialDataSize:TVkSize);
type PByteArray=^TByteArray;
     TByteArray=array[0..65535] of TVkUInt8;
var Index:TVkInt32;
begin
 if not assigned(aInitialData) then begin
  raise EInOutError.Create('aInitialData is null');
 end else if aInitialDataSize<VK_UUID_SIZE then begin
  raise EInOutError.Create('Data too small');
 end else if not CompareMem(@PVulkanUUID(aInitialData)^[0],@aDevice.fPhysicalDevice.fProperties.pipelineCacheUUID,SizeOf(TVulkanUUID)) then begin
  raise EVulkanPipelineCacheException.Create('Pipeline cache dump is not compatible with the current physical device');
 end else begin
  Create(aDevice,@PByteArray(aInitialData)^[SizeOf(TVulkanUUID)],aInitialDataSize-SizeOf(TVulkanUUID));
 end;
end;

constructor TVulkanPipelineCache.CreateFromStream(const aDevice:TVulkanDevice;const aStream:TStream);
var Data:TVkPointer;
    DataSize:TVkSize;
begin
 fPipelineCacheHandle:=VK_NULL_HANDLE;
 if assigned(aStream) and (aStream.Size>0) then begin
  DataSize:=aStream.Size;
  GetMem(Data,DataSize);
  try
   if aStream.Seek(0,soBeginning)<>0 then begin
    raise EInOutError.Create('Stream seek error');
   end;
   if aStream.Read(Data^,aStream.Size)<>aStream.Size then begin
    raise EInOutError.Create('Stream read error');
   end;
   CreateFromMemory(aDevice,Data,DataSize);
  finally
   FreeMem(Data);
  end;
 end;
end;

constructor TVulkanPipelineCache.CreateFromFile(const aDevice:TVulkanDevice;const aFileName:string);
var FileStream:TFileStream;
begin
 fPipelineCacheHandle:=VK_NULL_HANDLE;
 FileStream:=TFileStream.Create(aFileName,fmOpenRead or fmShareDenyWrite);
 try
  CreateFromStream(aDevice,FileStream);
 finally
  FileStream.Free;
 end;
end;

destructor TVulkanPipelineCache.Destroy;
begin
 if fPipelineCacheHandle<>VK_NULL_HANDLE then begin
  fDevice.fDeviceVulkan.DestroyPipelineCache(fDevice.fDeviceHandle,fPipelineCacheHandle,fDevice.fAllocationCallbacks);
  fPipelineCacheHandle:=VK_NULL_HANDLE;
 end;
 inherited Destroy;
end;

procedure TVulkanPipelineCache.SaveToStream(const aStream:TStream);
var Data:TVkPointer;
    DataSize:TVKSize;
begin
 HandleResultCode(fDevice.fDeviceVulkan.GetPipelineCacheData(fDevice.fDeviceHandle,fPipelineCacheHandle,@DataSize,nil));
 if DataSize>0 then begin
  GetMem(Data,DataSize);
  try
   HandleResultCode(fDevice.fDeviceVulkan.GetPipelineCacheData(fDevice.fDeviceHandle,fPipelineCacheHandle,@DataSize,Data));
   if aStream.Write(fDevice.fPhysicalDevice.fProperties.pipelineCacheUUID,SizeOf(TVulkanUUID))<>SizeOf(TVulkanUUID) then begin
    raise EInOutError.Create('Stream write error');
   end;
   if aStream.Write(Data^,DataSize)<>TVkPtrInt(DataSize) then begin
    raise EInOutError.Create('Stream write error');
   end;
  finally
   FreeMem(Data);
  end;
 end;
end;

procedure TVulkanPipelineCache.SaveToFile(const aFileName:string);
var FileStream:TFileStream;
begin
 FileStream:=TFileStream.Create(aFileName,fmCreate);
 try
  SaveToStream(FileStream);
 finally
  FileStream.Free;
 end;
end;

procedure TVulkanPipelineCache.Merge(const aSourcePipelineCache:TVulkanPipelineCache);
begin
 HandleResultCode(fDevice.fDeviceVulkan.MergePipelineCaches(fDevice.fDeviceHandle,fPipelineCacheHandle,1,@aSourcePipelineCache.fPipelineCacheHandle));
end;

procedure TVulkanPipelineCache.Merge(const aSourcePipelineCaches:array of TVulkanPipelineCache);
var Index:TVkInt32;
    SourcePipelineCaches:TVkPipelineCacheArray;
begin
 if length(aSourcePipelineCaches)>0 then begin
  SourcePipelineCaches:=nil;
  try
   SetLength(SourcePipelineCaches,length(aSourcePipelineCaches));
   for Index:=0 to length(aSourcePipelineCaches)-1 do begin
    SourcePipelineCaches[Index]:=aSourcePipelineCaches[Index].fPipelineCacheHandle;
   end;
   HandleResultCode(fDevice.fDeviceVulkan.MergePipelineCaches(fDevice.fDeviceHandle,fPipelineCacheHandle,length(SourcePipelineCaches),@SourcePipelineCaches[0]));
  finally
   SetLength(SourcePipelineCaches,0);
  end;
 end;
end;

constructor TVulkanPipeline.Create(const aDevice:TVulkanDevice);
begin
 inherited Create;
 fDevice:=aDevice;
 fPipelineHandle:=VK_NULL_HANDLE;
end;

destructor TVulkanPipeline.Destroy;
begin
 if fPipelineHandle<>VK_NULL_HANDLE then begin
  fDevice.fDeviceVulkan.DestroyPipeline(fDevice.fDeviceHandle,fPipelineHandle,fDevice.fAllocationCallbacks);
  fPipelineHandle:=VK_NULL_HANDLE;
 end;
 inherited Destroy;
end;

constructor TVulkanComputePipeline.Create(const aDevice:TVulkanDevice;
                                          const aCache:TVulkanPipelineCache;
                                          const aFlags:TVkPipelineCreateFlags;
                                          const aStage:TVulkanPipelineShaderStage;
                                          const aLayout:TVulkanPipelineLayout;
                                          const aBasePipelineHandle:TVulkanPipeline;
                                          const aBasePipelineIndex:TVkInt32);
var PipelineCache:TVkPipelineCache;
    ComputePipelineCreateInfo:TVkComputePipelineCreateInfo;
begin
 inherited Create(aDevice);

 FillChar(ComputePipelineCreateInfo,SizeOf(TVkComputePipelineCreateInfo),#0);
 ComputePipelineCreateInfo.sType:=VK_STRUCTURE_TYPE_COMPUTE_PIPELINE_CREATE_INFO;
 ComputePipelineCreateInfo.pNext:=nil;
 ComputePipelineCreateInfo.flags:=aFlags;
 if assigned(aStage) then begin
  aStage.Initialize;
  ComputePipelineCreateInfo.stage:=aStage.fPipelineShaderStageCreateInfo;
 end;
 if assigned(aLayout) then begin
  ComputePipelineCreateInfo.layout:=aLayout.fPipelineLayoutHandle;
 end else begin
  ComputePipelineCreateInfo.layout:=VK_NULL_HANDLE;
 end;
 if assigned(aBasePipelineHandle) then begin
  ComputePipelineCreateInfo.basePipelineHandle:=aBasePipelineHandle.fPipelineHandle;
 end else begin
  ComputePipelineCreateInfo.basePipelineHandle:=VK_NULL_HANDLE;
 end;
 ComputePipelineCreateInfo.basePipelineIndex:=aBasePipelineIndex;

 if assigned(aCache) then begin
  PipelineCache:=aCache.fPipelineCacheHandle;
 end else begin
  PipelineCache:=VK_NULL_HANDLE;
 end;

 HandleResultCode(fDevice.fDeviceVulkan.CreateComputePipelines(fDevice.fDeviceHandle,PipelineCache,1,@ComputePipelineCreateInfo,fDevice.fAllocationCallbacks,@fPipelineHandle));

end;

constructor TVulkanPipelineState.Create;
begin
 inherited Create;
end;

destructor TVulkanPipelineState.Destroy;
begin
 inherited Destroy;
end;

constructor TVulkanPipelineVertexInputState.Create;
begin
 inherited Create;

 FillChar(fVertexInputStateCreateInfo,SizeOf(TVkPipelineVertexInputStateCreateInfo),0);
 fVertexInputStateCreateInfo.sType:=VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO;
 fVertexInputStateCreateInfo.pNext:=nil;
 fVertexInputStateCreateInfo.flags:=0;
 fVertexInputStateCreateInfo.vertexBindingDescriptionCount:=0;
 fVertexInputStateCreateInfo.pVertexBindingDescriptions:=nil;
 fVertexInputStateCreateInfo.vertexAttributeDescriptionCount:=0;
 fVertexInputStateCreateInfo.pVertexAttributeDescriptions:=nil;

 fPointerToVertexInputStateCreateInfo:=@fVertexInputStateCreateInfo;

 fVertexInputBindingDescriptions:=nil;
 fCountVertexInputBindingDescriptions:=0;

 fVertexInputAttributeDescriptions:=nil;
 fCountVertexInputAttributeDescriptions:=0;

end;

destructor TVulkanPipelineVertexInputState.Destroy;
begin
 SetLength(fVertexInputBindingDescriptions,0);
 SetLength(fVertexInputAttributeDescriptions,0);
 inherited Destroy;
end;

function TVulkanPipelineVertexInputState.GetVertexInputBindingDescription(const aIndex:TVkInt32):PVkVertexInputBindingDescription;
begin
 result:=@fVertexInputBindingDescriptions[aIndex];
end;

function TVulkanPipelineVertexInputState.GetVertexInputAttributeDescription(const aIndex:TVkInt32):PVkVertexInputAttributeDescription;
begin
 result:=@fVertexInputAttributeDescriptions[aIndex];
end;

procedure TVulkanPipelineVertexInputState.SetCountVertexInputBindingDescriptions(const aNewCount:TVkInt32);
begin
 fCountVertexInputBindingDescriptions:=aNewCount;
 if length(fVertexInputBindingDescriptions)<fCountVertexInputBindingDescriptions then begin
  SetLength(fVertexInputBindingDescriptions,fCountVertexInputBindingDescriptions*2);
 end;
end;

procedure TVulkanPipelineVertexInputState.SetCountVertexInputAttributeDescriptions(const aNewCount:TVkInt32);
begin
 fCountVertexInputAttributeDescriptions:=aNewCount;
 if length(fVertexInputAttributeDescriptions)<fCountVertexInputAttributeDescriptions then begin
  SetLength(fVertexInputAttributeDescriptions,fCountVertexInputAttributeDescriptions*2);
 end;
end;

procedure TVulkanPipelineVertexInputState.Assign(const aFrom:TVulkanPipelineVertexInputState);
begin
 fVertexInputBindingDescriptions:=copy(aFrom.fVertexInputBindingDescriptions);
 fCountVertexInputBindingDescriptions:=aFrom.fCountVertexInputBindingDescriptions;
 fVertexInputAttributeDescriptions:=copy(aFrom.fVertexInputAttributeDescriptions);
 fCountVertexInputAttributeDescriptions:=aFrom.fCountVertexInputAttributeDescriptions;
end;

function TVulkanPipelineVertexInputState.AddVertexInputBindingDescription(const aVertexInputBindingDescription:TVkVertexInputBindingDescription):TVkInt32;
begin
 result:=fCountVertexInputBindingDescriptions;
 inc(fCountVertexInputBindingDescriptions);
 if length(fVertexInputBindingDescriptions)<fCountVertexInputBindingDescriptions then begin
  SetLength(fVertexInputBindingDescriptions,fCountVertexInputBindingDescriptions*2);
 end;
 fVertexInputBindingDescriptions[result]:=aVertexInputBindingDescription;
end;

function TVulkanPipelineVertexInputState.AddVertexInputBindingDescription(const aBinding,aStride:TVkUInt32;const aInputRate:TVkVertexInputRate):TVkInt32;
var VertexInputBindingDescription:PVkVertexInputBindingDescription;
begin
 result:=fCountVertexInputBindingDescriptions;
 inc(fCountVertexInputBindingDescriptions);
 if length(fVertexInputBindingDescriptions)<fCountVertexInputBindingDescriptions then begin
  SetLength(fVertexInputBindingDescriptions,fCountVertexInputBindingDescriptions*2);
 end;
 VertexInputBindingDescription:=@fVertexInputBindingDescriptions[result];
 VertexInputBindingDescription^.binding:=aBinding;
 VertexInputBindingDescription^.stride:=aStride;
 VertexInputBindingDescription^.inputRate:=aInputRate;
end;

function TVulkanPipelineVertexInputState.AddVertexInputBindingDescriptions(const aVertexInputBindingDescriptions:array of TVkVertexInputBindingDescription):TVkInt32;
begin
 if length(aVertexInputBindingDescriptions)>0 then begin
  result:=fCountVertexInputBindingDescriptions;
  inc(fCountVertexInputBindingDescriptions,length(aVertexInputBindingDescriptions));
  if length(fVertexInputBindingDescriptions)<fCountVertexInputBindingDescriptions then begin
   SetLength(fVertexInputBindingDescriptions,fCountVertexInputBindingDescriptions*2);
  end;
  Move(aVertexInputBindingDescriptions[0],fVertexInputBindingDescriptions[result],length(aVertexInputBindingDescriptions)*SizeOf(TVkVertexInputBindingDescription));
 end else begin
  result:=-1;
 end;
end;

function TVulkanPipelineVertexInputState.AddVertexInputAttributeDescription(const aVertexInputAttributeDescription:TVkVertexInputAttributeDescription):TVkInt32;
begin
 result:=fCountVertexInputAttributeDescriptions;
 inc(fCountVertexInputAttributeDescriptions);
 if length(fVertexInputAttributeDescriptions)<fCountVertexInputAttributeDescriptions then begin
  SetLength(fVertexInputAttributeDescriptions,fCountVertexInputAttributeDescriptions*2);
 end;
 fVertexInputAttributeDescriptions[result]:=aVertexInputAttributeDescription;
end;

function TVulkanPipelineVertexInputState.AddVertexInputAttributeDescription(const aLocation,aBinding:TVkUInt32;const aFormat:TVkFormat;const aOffset:TVkUInt32):TVkInt32;
var VertexInputAttributeDescription:PVkVertexInputAttributeDescription;
begin
 result:=fCountVertexInputAttributeDescriptions;
 inc(fCountVertexInputAttributeDescriptions);
 if length(fVertexInputAttributeDescriptions)<fCountVertexInputAttributeDescriptions then begin
  SetLength(fVertexInputAttributeDescriptions,fCountVertexInputAttributeDescriptions*2);
 end;
 VertexInputAttributeDescription:=@fVertexInputAttributeDescriptions[result];
 VertexInputAttributeDescription^.location:=aLocation;
 VertexInputAttributeDescription^.binding:=aBinding;
 VertexInputAttributeDescription^.format:=aFormat;
 VertexInputAttributeDescription^.offset:=aOffset;
end;

function TVulkanPipelineVertexInputState.AddVertexInputAttributeDescriptions(const aVertexInputAttributeDescriptions:array of TVkVertexInputAttributeDescription):TVkInt32;
begin
 if length(aVertexInputAttributeDescriptions)>0 then begin
  result:=fCountVertexInputAttributeDescriptions;
  inc(fCountVertexInputAttributeDescriptions,length(aVertexInputAttributeDescriptions));
  if length(fVertexInputAttributeDescriptions)<fCountVertexInputAttributeDescriptions then begin
   SetLength(fVertexInputAttributeDescriptions,fCountVertexInputAttributeDescriptions*2);
  end;
  Move(aVertexInputAttributeDescriptions[0],fVertexInputAttributeDescriptions[result],length(aVertexInputAttributeDescriptions)*SizeOf(TVkVertexInputAttributeDescription));
 end else begin
  result:=-1;
 end;
end;

procedure TVulkanPipelineVertexInputState.Initialize;
begin
 SetLength(fVertexInputBindingDescriptions,fCountVertexInputBindingDescriptions);
 SetLength(fVertexInputAttributeDescriptions,fCountVertexInputAttributeDescriptions);
 if (fCountVertexInputBindingDescriptions>0) or (fCountVertexInputAttributeDescriptions>0) then begin
  fVertexInputStateCreateInfo.vertexBindingDescriptionCount:=fCountVertexInputBindingDescriptions;
  if fCountVertexInputBindingDescriptions>0 then begin
   fVertexInputStateCreateInfo.pVertexBindingDescriptions:=@fVertexInputBindingDescriptions[0];
  end;
  fVertexInputStateCreateInfo.vertexAttributeDescriptionCount:=fCountVertexInputAttributeDescriptions;
  if fCountVertexInputAttributeDescriptions>0 then begin
   fVertexInputStateCreateInfo.pVertexAttributeDescriptions:=@fVertexInputAttributeDescriptions[0];
  end;
 end;
end;

constructor TVulkanPipelineInputAssemblyState.Create;
begin
 inherited Create;

 FillChar(fInputAssemblyStateCreateInfo,SizeOf(TVkPipelineInputAssemblyStateCreateInfo),#0);
 fInputAssemblyStateCreateInfo.sType:=VK_STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO;
 fInputAssemblyStateCreateInfo.pNext:=nil;
 fInputAssemblyStateCreateInfo.flags:=0;
 fInputAssemblyStateCreateInfo.topology:=VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST;
 fInputAssemblyStateCreateInfo.primitiveRestartEnable:=VK_FALSE;

 fPointerToInputAssemblyStateCreateInfo:=@fInputAssemblyStateCreateInfo;

end;

destructor TVulkanPipelineInputAssemblyState.Destroy;
begin
 inherited Destroy;
end;

procedure TVulkanPipelineInputAssemblyState.Assign(const aFrom:TVulkanPipelineInputAssemblyState);
begin
 fInputAssemblyStateCreateInfo:=aFrom.fInputAssemblyStateCreateInfo;
end;

procedure TVulkanPipelineInputAssemblyState.SetInputAssemblyState(const aTopology:TVkPrimitiveTopology;const aPrimitiveRestartEnable:boolean);
begin
 fInputAssemblyStateCreateInfo.topology:=aTopology;
 fInputAssemblyStateCreateInfo.primitiveRestartEnable:=BooleanToVkBool[aPrimitiveRestartEnable];
end;

function TVulkanPipelineInputAssemblyState.GetTopology:TVkPrimitiveTopology;
begin
 result:=fInputAssemblyStateCreateInfo.topology;
end;

procedure TVulkanPipelineInputAssemblyState.SetTopology(const aNewValue:TVkPrimitiveTopology);
begin
 fInputAssemblyStateCreateInfo.topology:=aNewValue;
end;

function TVulkanPipelineInputAssemblyState.GetPrimitiveRestartEnable:boolean;
begin
 result:=fInputAssemblyStateCreateInfo.primitiveRestartEnable<>VK_FALSE;
end;

procedure TVulkanPipelineInputAssemblyState.SetPrimitiveRestartEnable(const aNewValue:boolean);
begin
 fInputAssemblyStateCreateInfo.primitiveRestartEnable:=BooleanToVkBool[aNewValue];
end;

constructor TVulkanPipelineTessellationState.Create;
begin
 inherited Create;

 FillChar(fTessellationStateCreateInfo,SizeOf(TVkPipelineTessellationStateCreateInfo),#0);
 fTessellationStateCreateInfo.sType:=VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_STATE_CREATE_INFO;
 fTessellationStateCreateInfo.pNext:=nil;
 fTessellationStateCreateInfo.flags:=0;
 fTessellationStateCreateInfo.patchControlPoints:=0;

 fPointerToTessellationStateCreateInfo:=@fTessellationStateCreateInfo;

end;

destructor TVulkanPipelineTessellationState.Destroy;
begin
 inherited Destroy;
end;

procedure TVulkanPipelineTessellationState.Assign(const aFrom:TVulkanPipelineTessellationState);
begin
 fTessellationStateCreateInfo:=aFrom.fTessellationStateCreateInfo;
end;

function TVulkanPipelineTessellationState.GetPatchControlPoints:TVkUInt32;
begin
 result:=fTessellationStateCreateInfo.patchControlPoints;
end;

procedure TVulkanPipelineTessellationState.SetPatchControlPoints(const aNewValue:TVkUInt32);
begin
 fTessellationStateCreateInfo.patchControlPoints:=aNewValue;
end;

procedure TVulkanPipelineTessellationState.SetTessellationState(const aPatchControlPoints:TVkUInt32);
begin
 fTessellationStateCreateInfo.patchControlPoints:=aPatchControlPoints;
end;

constructor TVulkanPipelineViewPortState.Create;
begin

 inherited Create;

 FillChar(fViewportStateCreateInfo,SizeOf(TVkPipelineViewportStateCreateInfo),#0);
 fViewportStateCreateInfo.sType:=VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO;
 fViewportStateCreateInfo.pNext:=nil;
 fViewportStateCreateInfo.flags:=0;
 fViewportStateCreateInfo.viewportCount:=0;
 fViewportStateCreateInfo.pViewports:=nil;
 fViewportStateCreateInfo.scissorCount:=0;
 fViewportStateCreateInfo.pScissors:=nil;

 fPointerToViewportStateCreateInfo:=@fViewportStateCreateInfo;

 fViewPorts:=nil;
 fCountViewPorts:=0;
 fDynamicViewPorts:=false;

 fScissors:=nil;
 fCountScissors:=0;
 fDynamicScissors:=false;

end;

destructor TVulkanPipelineViewPortState.Destroy;
begin
 SetLength(fViewPorts,0);
 SetLength(fScissors,0);
 inherited Destroy;
end;

procedure TVulkanPipelineViewPortState.Assign(const aFrom:TVulkanPipelineViewPortState);
begin
 fViewPorts:=copy(aFrom.fViewPorts);
 fCountViewPorts:=aFrom.fCountViewPorts;
 fScissors:=copy(aFrom.fScissors);
 fCountScissors:=aFrom.fCountScissors;
end;

function TVulkanPipelineViewPortState.GetViewPort(const aIndex:TVkInt32):PVkViewport;
begin
 result:=@fViewPorts[aIndex];
end;

function TVulkanPipelineViewPortState.GetScissor(const aIndex:TVkInt32):PVkRect2D;
begin
 result:=@fScissors[aIndex];
end;

procedure TVulkanPipelineViewPortState.SetCountViewPorts(const aNewCount:TVkInt32);
begin
 fCountViewPorts:=aNewCount;
 if length(fViewPorts)<fCountViewPorts then begin
  SetLength(fViewPorts,fCountViewPorts*2);
 end;
end;

procedure TVulkanPipelineViewPortState.SetCountScissors(const aNewCount:TVkInt32);
begin
 fCountScissors:=aNewCount;
 if length(fScissors)<fCountScissors then begin
  SetLength(fScissors,fCountScissors*2);
 end;
end;

function TVulkanPipelineViewPortState.AddViewPort(const aViewPort:TVkViewport):TVkInt32;
begin
 result:=fCountViewPorts;
 inc(fCountViewPorts);
 if length(fViewPorts)<fCountViewPorts then begin
  SetLength(fViewPorts,fCountViewPorts*2);
 end;
 fViewPorts[result]:=aViewPort;
end;

function TVulkanPipelineViewPortState.AddViewPort(const pX,pY,aWidth,aHeight,aMinDepth,aMaxDepth:TVkFloat):TVkInt32;
var Viewport:PVkViewport;
begin
 result:=fCountViewPorts;
 inc(fCountViewPorts);
 if length(fViewPorts)<fCountViewPorts then begin
  SetLength(fViewPorts,fCountViewPorts*2);
 end;
 Viewport:=@fViewPorts[result];
 Viewport^.x:=pX;
 Viewport^.y:=pY;
 Viewport^.width:=aWidth;
 Viewport^.height:=aHeight;
 Viewport^.minDepth:=aMinDepth;
 Viewport^.maxDepth:=aMaxDepth;
end;

function TVulkanPipelineViewPortState.AddViewPorts(const aViewPorts:array of TVkViewport):TVkInt32;
begin
 if length(aViewPorts)>0 then begin
  result:=fCountViewPorts;
  inc(fCountViewPorts,length(aViewPorts));
  if length(fViewPorts)<fCountViewPorts then begin
   SetLength(fViewPorts,fCountViewPorts*2);
  end;
  Move(aViewPorts[0],fViewPorts[result],length(aViewPorts)*SizeOf(TVkViewport));
 end else begin
  result:=-1;
 end;
end;

function TVulkanPipelineViewPortState.AddScissor(const aScissor:TVkRect2D):TVkInt32;
begin
 result:=fCountScissors;
 inc(fCountScissors);
 if length(fScissors)<fCountScissors then begin
  SetLength(fScissors,fCountScissors*2);
 end;
 fScissors[result]:=aScissor;
end;

function TVulkanPipelineViewPortState.AddScissor(const pX,pY:TVkInt32;const aWidth,aHeight:TVkUInt32):TVkInt32;
var Scissor:PVkRect2D;
begin
 result:=fCountScissors;
 inc(fCountScissors);
 if length(fScissors)<fCountScissors then begin
  SetLength(fScissors,fCountScissors*2);
 end;
 Scissor:=@fScissors[result];
 Scissor^.offset.x:=pX;
 Scissor^.offset.y:=pY;
 Scissor^.extent.width:=aWidth;
 Scissor^.extent.height:=aHeight;
end;

function TVulkanPipelineViewPortState.AddScissors(const aScissors:array of TVkRect2D):TVkInt32;
begin
 if length(aScissors)>0 then begin
  result:=fCountScissors;
  inc(fCountScissors,length(aScissors));
  if length(fScissors)<fCountScissors then begin
   SetLength(fScissors,fCountScissors*2);
  end;
  Move(aScissors[0],fScissors[result],length(aScissors)*SizeOf(TVkRect2D));
 end else begin
  result:=-1;
 end;
end;

procedure TVulkanPipelineViewPortState.Initialize;
begin
 SetLength(fViewPorts,fCountViewPorts);
 SetLength(fScissors,fCountScissors);
 if (fCountViewPorts>0) or (fCountScissors>0) then begin
  fViewportStateCreateInfo.viewportCount:=fCountViewPorts;
  if (fCountViewPorts>0) and not fDynamicViewPorts then begin
   fViewportStateCreateInfo.pViewports:=@fViewPorts[0];
  end else begin
   fViewportStateCreateInfo.pViewports:=nil;
  end;
  fViewportStateCreateInfo.scissorCount:=fCountScissors;
  if (fCountScissors>0) and not fDynamicScissors then begin
   fViewportStateCreateInfo.pScissors:=@fScissors[0];
  end else begin
   fViewportStateCreateInfo.pScissors:=nil;
  end;
 end;
end;

constructor TVulkanPipelineRasterizationState.Create;
begin

 inherited Create;

 FillChar(fRasterizationStateCreateInfo,SizeOf(TVkPipelineRasterizationStateCreateInfo),#0);
 fRasterizationStateCreateInfo.sType:=VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO;
 fRasterizationStateCreateInfo.pNext:=nil;
 fRasterizationStateCreateInfo.flags:=0;
 fRasterizationStateCreateInfo.depthClampEnable:=VK_TRUE;
 fRasterizationStateCreateInfo.rasterizerDiscardEnable:=VK_FALSE;
 fRasterizationStateCreateInfo.polygonMode:=VK_POLYGON_MODE_FILL;
 fRasterizationStateCreateInfo.cullMode:=TVkCullModeFlags(VK_CULL_MODE_NONE);
 fRasterizationStateCreateInfo.frontFace:=VK_FRONT_FACE_COUNTER_CLOCKWISE;
 fRasterizationStateCreateInfo.depthBiasEnable:=VK_TRUE;
 fRasterizationStateCreateInfo.depthBiasConstantFactor:=0.0;
 fRasterizationStateCreateInfo.depthBiasClamp:=0.0;
 fRasterizationStateCreateInfo.depthBiasSlopeFactor:=0.0;
 fRasterizationStateCreateInfo.lineWidth:=1.0;

 fPointerToRasterizationStateCreateInfo:=@fRasterizationStateCreateInfo;

end;

destructor TVulkanPipelineRasterizationState.Destroy;
begin
 inherited Destroy;
end;

procedure TVulkanPipelineRasterizationState.Assign(const aFrom:TVulkanPipelineRasterizationState);
begin
 fRasterizationStateCreateInfo:=aFrom.fRasterizationStateCreateInfo;
end;

function TVulkanPipelineRasterizationState.GetDepthClampEnable:boolean;
begin
 result:=fRasterizationStateCreateInfo.depthClampEnable<>VK_FALSE;
end;

procedure TVulkanPipelineRasterizationState.SetDepthClampEnable(const aNewValue:boolean);
begin
 fRasterizationStateCreateInfo.depthClampEnable:=BooleanToVkBool[aNewValue];
end;

function TVulkanPipelineRasterizationState.GetRasterizerDiscardEnable:boolean;
begin
 result:=fRasterizationStateCreateInfo.rasterizerDiscardEnable<>VK_FALSE;
end;

procedure TVulkanPipelineRasterizationState.SetRasterizerDiscardEnable(const aNewValue:boolean);
begin
 fRasterizationStateCreateInfo.rasterizerDiscardEnable:=BooleanToVkBool[aNewValue];
end;

function TVulkanPipelineRasterizationState.GetPolygonMode:TVkPolygonMode;
begin
 result:=fRasterizationStateCreateInfo.polygonMode;
end;

procedure TVulkanPipelineRasterizationState.SetPolygonMode(const aNewValue:TVkPolygonMode);
begin
 fRasterizationStateCreateInfo.polygonMode:=aNewValue;
end;

function TVulkanPipelineRasterizationState.GetCullMode:TVkCullModeFlags;
begin
 result:=fRasterizationStateCreateInfo.cullMode;
end;

procedure TVulkanPipelineRasterizationState.SetCullMode(const aNewValue:TVkCullModeFlags);
begin
 fRasterizationStateCreateInfo.cullMode:=aNewValue;
end;

function TVulkanPipelineRasterizationState.GetFrontFace:TVkFrontFace;
begin
 result:=fRasterizationStateCreateInfo.frontFace;
end;

procedure TVulkanPipelineRasterizationState.SetFrontFace(const aNewValue:TVkFrontFace);
begin
 fRasterizationStateCreateInfo.frontFace:=aNewValue;
end;

function TVulkanPipelineRasterizationState.GetDepthBiasEnable:boolean;
begin
 result:=fRasterizationStateCreateInfo.depthBiasEnable<>VK_FALSE;
end;

procedure TVulkanPipelineRasterizationState.SetDepthBiasEnable(const aNewValue:boolean);
begin
 fRasterizationStateCreateInfo.depthBiasEnable:=BooleanToVkBool[aNewValue];
end;

function TVulkanPipelineRasterizationState.GetDepthBiasConstantFactor:TVkFloat;
begin
 result:=fRasterizationStateCreateInfo.depthBiasConstantFactor;
end;

procedure TVulkanPipelineRasterizationState.SetDepthBiasConstantFactor(const aNewValue:TVkFloat);
begin
 fRasterizationStateCreateInfo.depthBiasConstantFactor:=aNewValue;
end;

function TVulkanPipelineRasterizationState.GetDepthBiasClamp:TVkFloat;
begin
 result:=fRasterizationStateCreateInfo.depthBiasClamp;
end;

procedure TVulkanPipelineRasterizationState.SetDepthBiasClamp(const aNewValue:TVkFloat);
begin
 fRasterizationStateCreateInfo.depthBiasClamp:=aNewValue;
end;

function TVulkanPipelineRasterizationState.GetDepthBiasSlopeFactor:TVkFloat;
begin
 result:=fRasterizationStateCreateInfo.depthBiasSlopeFactor;
end;

procedure TVulkanPipelineRasterizationState.SetDepthBiasSlopeFactor(const aNewValue:TVkFloat);
begin
 fRasterizationStateCreateInfo.depthBiasSlopeFactor:=aNewValue;
end;

function TVulkanPipelineRasterizationState.GetLineWidth:TVkFloat;
begin
 result:=fRasterizationStateCreateInfo.lineWidth;
end;

procedure TVulkanPipelineRasterizationState.SetLineWidth(const aNewValue:TVkFloat);
begin
 fRasterizationStateCreateInfo.lineWidth:=aNewValue;
end;

procedure TVulkanPipelineRasterizationState.SetRasterizationState(const aDepthClampEnable:boolean;
                                                                  const aRasterizerDiscardEnable:boolean;
                                                                  const aPolygonMode:TVkPolygonMode;
                                                                  const aCullMode:TVkCullModeFlags;
                                                                  const aFrontFace:TVkFrontFace;
                                                                  const aDepthBiasEnable:boolean;
                                                                  const aDepthBiasConstantFactor:TVkFloat;
                                                                  const aDepthBiasClamp:TVkFloat;
                                                                  const aDepthBiasSlopeFactor:TVkFloat;
                                                                  const aLineWidth:TVkFloat);
begin
 fRasterizationStateCreateInfo.depthClampEnable:=BooleanToVkBool[aDepthClampEnable];
 fRasterizationStateCreateInfo.rasterizerDiscardEnable:=BooleanToVkBool[aRasterizerDiscardEnable];
 fRasterizationStateCreateInfo.polygonMode:=aPolygonMode;
 fRasterizationStateCreateInfo.cullMode:=aCullMode;
 fRasterizationStateCreateInfo.frontFace:=aFrontFace;
 fRasterizationStateCreateInfo.depthBiasEnable:=BooleanToVkBool[aDepthBiasEnable];
 fRasterizationStateCreateInfo.depthBiasConstantFactor:=aDepthBiasConstantFactor;
 fRasterizationStateCreateInfo.depthBiasClamp:=aDepthBiasClamp;
 fRasterizationStateCreateInfo.depthBiasSlopeFactor:=aDepthBiasSlopeFactor;
 fRasterizationStateCreateInfo.lineWidth:=aLineWidth;
end;

constructor TVulkanPipelineMultisampleState.Create;
begin

 inherited Create;

 FillChar(fMultisampleStateCreateInfo,SizeOf(TVkPipelineMultisampleStateCreateInfo),#0);
 fMultisampleStateCreateInfo.sType:=VK_STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO;
 fMultisampleStateCreateInfo.pNext:=nil;
 fMultisampleStateCreateInfo.flags:=0;
 fMultisampleStateCreateInfo.rasterizationSamples:=VK_SAMPLE_COUNT_1_BIT;
 fMultisampleStateCreateInfo.sampleShadingEnable:=VK_FALSE;
 fMultisampleStateCreateInfo.minSampleShading:=1.0;
 fMultisampleStateCreateInfo.pSampleMask:=nil;
 fMultisampleStateCreateInfo.alphaToCoverageEnable:=VK_FALSE;
 fMultisampleStateCreateInfo.alphaToOneEnable:=VK_FALSE;

 fPointerToMultisampleStateCreateInfo:=@fMultisampleStateCreateInfo;

 fSampleMasks:=nil;
 fCountSampleMasks:=0;

end;

destructor TVulkanPipelineMultisampleState.Destroy;
begin
 SetLength(fSampleMasks,0);
 inherited Destroy;
end;

procedure TVulkanPipelineMultisampleState.Assign(const aFrom:TVulkanPipelineMultisampleState);
begin
 fMultisampleStateCreateInfo:=aFrom.fMultisampleStateCreateInfo;
 fMultisampleStateCreateInfo.pSampleMask:=nil;
 fSampleMasks:=copy(aFrom.fSampleMasks);
 fCountSampleMasks:=aFrom.fCountSampleMasks;
end;

function TVulkanPipelineMultisampleState.AddSampleMask(const aSampleMask:TVkSampleMask):TVkInt32;
begin
 result:=fCountSampleMasks;
 inc(fCountSampleMasks);
 if length(fSampleMasks)<fCountSampleMasks then begin
  SetLength(fSampleMasks,fCountSampleMasks*2);
 end;
 fSampleMasks[result]:=aSampleMask;
end;

function TVulkanPipelineMultisampleState.AddSampleMasks(const aSampleMasks:array of TVkSampleMask):TVkInt32;
begin
 if length(aSampleMasks)>0 then begin
  result:=fCountSampleMasks;
  inc(fCountSampleMasks,length(aSampleMasks));
  if length(fSampleMasks)<fCountSampleMasks then begin
   SetLength(fSampleMasks,fCountSampleMasks*2);
  end;
  Move(aSampleMasks[0],fSampleMasks[result],length(aSampleMasks)*SizeOf(TVkSampleMask));
 end else begin
  result:=-1;
 end;
end;

function TVulkanPipelineMultisampleState.GetRasterizationSamples:TVkSampleCountFlagBits;
begin
 result:=fMultisampleStateCreateInfo.rasterizationSamples;
end;

procedure TVulkanPipelineMultisampleState.SetRasterizationSamples(const aNewValue:TVkSampleCountFlagBits);
begin
 fMultisampleStateCreateInfo.rasterizationSamples:=aNewValue;
end;

function TVulkanPipelineMultisampleState.GetSampleShadingEnable:boolean;
begin
 result:=fMultisampleStateCreateInfo.sampleShadingEnable<>VK_FALSE;
end;

procedure TVulkanPipelineMultisampleState.SetSampleShadingEnable(const aNewValue:boolean);
begin
 fMultisampleStateCreateInfo.sampleShadingEnable:=BooleanToVkBool[aNewValue];
end;

function TVulkanPipelineMultisampleState.GetSampleMask(const aIndex:TVkInt32):TVkSampleMask;
begin
 result:=fSampleMasks[aIndex];
end;

procedure TVulkanPipelineMultisampleState.SetSampleMask(const aIndex:TVkInt32;const aNewValue:TVkSampleMask);
begin
 fSampleMasks[aIndex]:=aNewValue;                                                          
end;

procedure TVulkanPipelineMultisampleState.SetCountSampleMasks(const aNewCount:TVkInt32);
begin
 fCountSampleMasks:=aNewCount;
 if length(fSampleMasks)<fCountSampleMasks then begin
  SetLength(fSampleMasks,fCountSampleMasks*2);
 end;
end;

function TVulkanPipelineMultisampleState.GetMinSampleShading:TVkFloat;
begin
 result:=fMultisampleStateCreateInfo.minSampleShading;
end;

procedure TVulkanPipelineMultisampleState.SetMinSampleShading(const aNewValue:TVkFloat);
begin
 fMultisampleStateCreateInfo.minSampleShading:=aNewValue;
end;

function TVulkanPipelineMultisampleState.GetAlphaToCoverageEnable:boolean;
begin
 result:=fMultisampleStateCreateInfo.alphaToCoverageEnable<>VK_FALSE;
end;

procedure TVulkanPipelineMultisampleState.SetAlphaToCoverageEnable(const aNewValue:boolean);
begin
 fMultisampleStateCreateInfo.alphaToCoverageEnable:=BooleanToVkBool[aNewValue];
end;

function TVulkanPipelineMultisampleState.GetAlphaToOneEnable:boolean;
begin
 result:=fMultisampleStateCreateInfo.alphaToOneEnable<>VK_FALSE;
end;

procedure TVulkanPipelineMultisampleState.SetAlphaToOneEnable(const aNewValue:boolean);
begin
 fMultisampleStateCreateInfo.alphaToOneEnable:=BooleanToVkBool[aNewValue];
end;

procedure TVulkanPipelineMultisampleState.SetMultisampleState(const aRasterizationSamples:TVkSampleCountFlagBits;
                                                              const aSampleShadingEnable:boolean;
                                                              const aMinSampleShading:TVkFloat;
                                                              const aSampleMask:array of TVkSampleMask;
                                                              const aAlphaToCoverageEnable:boolean;
                                                              const aAlphaToOneEnable:boolean);
begin
 fMultisampleStateCreateInfo.rasterizationSamples:=aRasterizationSamples;
 fMultisampleStateCreateInfo.sampleShadingEnable:=BooleanToVkBool[aSampleShadingEnable];
 fMultisampleStateCreateInfo.minSampleShading:=aMinSampleShading;
 fCountSampleMasks:=length(aSampleMask);
 SetLength(fSampleMasks,fCountSampleMasks);
 if length(aSampleMask)>0 then begin
  Move(aSampleMask[0],fSampleMasks[0],length(aSampleMask)*SizeOf(TVkSampleMask));
 end;
 fMultisampleStateCreateInfo.alphaToCoverageEnable:=BooleanToVkBool[aAlphaToCoverageEnable];
 fMultisampleStateCreateInfo.alphaToOneEnable:=BooleanToVkBool[aAlphaToOneEnable];
end;

procedure TVulkanPipelineMultisampleState.Initialize;
begin
 if fCountSampleMasks>0 then begin
  SetLength(fSampleMasks,fCountSampleMasks);
  fMultisampleStateCreateInfo.pSampleMask:=@fSampleMasks[0];
 end else begin
  fMultisampleStateCreateInfo.pSampleMask:=nil;
 end;
end;

constructor TVulkanStencilOpState.Create(const aStencilOpState:PVkStencilOpState);
begin
 inherited Create;
 fStencilOpState:=aStencilOpState;
end;

destructor TVulkanStencilOpState.Destroy;
begin
 inherited Destroy;
end;

procedure TVulkanStencilOpState.Assign(const aFrom:TVulkanStencilOpState);
begin
 fStencilOpState^:=aFrom.fStencilOpState^;
end;

function TVulkanStencilOpState.GetFailOp:TVkStencilOp;
begin
 result:=fStencilOpState^.failOp;
end;

procedure TVulkanStencilOpState.SetFailOp(const aNewValue:TVkStencilOp);
begin
 fStencilOpState^.failOp:=aNewValue;
end;

function TVulkanStencilOpState.GetPassOp:TVkStencilOp;
begin
 result:=fStencilOpState^.passOp;
end;

procedure TVulkanStencilOpState.SetPassOp(const aNewValue:TVkStencilOp);
begin
 fStencilOpState^.passOp:=aNewValue;
end;

function TVulkanStencilOpState.GetDepthFailOp:TVkStencilOp;
begin
 result:=fStencilOpState^.depthFailOp;
end;

procedure TVulkanStencilOpState.SetDepthFailOp(const aNewValue:TVkStencilOp);
begin
 fStencilOpState^.depthFailOp:=aNewValue;
end;

function TVulkanStencilOpState.GetCompareOp:TVkCompareOp;
begin
 result:=fStencilOpState^.compareOp;
end;

procedure TVulkanStencilOpState.SetCompareOp(const aNewValue:TVkCompareOp);
begin
 fStencilOpState^.compareOp:=aNewValue;
end;

function TVulkanStencilOpState.GetCompareMask:TVkUInt32;
begin
 result:=fStencilOpState^.compareMask;
end;

procedure TVulkanStencilOpState.SetCompareMask(const aNewValue:TVkUInt32);
begin
 fStencilOpState^.compareMask:=aNewValue;
end;

function TVulkanStencilOpState.GetWriteMask:TVkUInt32;
begin
 result:=fStencilOpState^.writeMask;
end;

procedure TVulkanStencilOpState.SetWriteMask(const aNewValue:TVkUInt32);
begin
 fStencilOpState^.writeMask:=aNewValue;
end;

function TVulkanStencilOpState.GetReference:TVkUInt32;
begin
 result:=fStencilOpState^.reference;
end;

procedure TVulkanStencilOpState.SetReference(const aNewValue:TVkUInt32);
begin
 fStencilOpState^.reference:=aNewValue;
end;

constructor TVulkanPipelineDepthStencilState.Create;
begin

 inherited Create;

 FillChar(fDepthStencilStateCreateInfo,SizeOf(TVkPipelineDepthStencilStateCreateInfo),#0);
 fDepthStencilStateCreateInfo.sType:=VK_STRUCTURE_TYPE_PIPELINE_DEPTH_STENCIL_STATE_CREATE_INFO;
 fDepthStencilStateCreateInfo.pNext:=nil;
 fDepthStencilStateCreateInfo.flags:=0;      
 fDepthStencilStateCreateInfo.depthTestEnable:=VK_TRUE;
 fDepthStencilStateCreateInfo.depthWriteEnable:=VK_TRUE;
 fDepthStencilStateCreateInfo.depthCompareOp:=VK_COMPARE_OP_LESS_OR_EQUAL;
 fDepthStencilStateCreateInfo.depthBoundsTestEnable:=VK_FALSE;
 fDepthStencilStateCreateInfo.stencilTestEnable:=VK_FALSE;
 fDepthStencilStateCreateInfo.front.failOp:=VK_STENCIL_OP_KEEP;
 fDepthStencilStateCreateInfo.front.depthFailOp:=VK_STENCIL_OP_KEEP;
 fDepthStencilStateCreateInfo.front.compareOp:=VK_COMPARE_OP_ALWAYS;
 fDepthStencilStateCreateInfo.front.compareMask:=0;
 fDepthStencilStateCreateInfo.front.writeMask:=0;
 fDepthStencilStateCreateInfo.front.reference:=0;
 fDepthStencilStateCreateInfo.back.failOp:=VK_STENCIL_OP_KEEP;
 fDepthStencilStateCreateInfo.back.depthFailOp:=VK_STENCIL_OP_KEEP;
 fDepthStencilStateCreateInfo.back.compareOp:=VK_COMPARE_OP_ALWAYS;
 fDepthStencilStateCreateInfo.back.compareMask:=0;
 fDepthStencilStateCreateInfo.back.writeMask:=0;
 fDepthStencilStateCreateInfo.back.reference:=0;
 fDepthStencilStateCreateInfo.minDepthBounds:=0.0;
 fDepthStencilStateCreateInfo.maxDepthBounds:=1.0;

 fPointerToDepthStencilStateCreateInfo:=@fDepthStencilStateCreateInfo;

 fFrontStencilOpState:=TVulkanStencilOpState.Create(@fDepthStencilStateCreateInfo.front);

 fBackStencilOpState:=TVulkanStencilOpState.Create(@fDepthStencilStateCreateInfo.back);

end;

destructor TVulkanPipelineDepthStencilState.Destroy;
begin
 fFrontStencilOpState.Free;
 fBackStencilOpState.Free;
 inherited Destroy;
end;

procedure TVulkanPipelineDepthStencilState.Assign(const aFrom:TVulkanPipelineDepthStencilState);
begin
 fDepthStencilStateCreateInfo:=aFrom.fDepthStencilStateCreateInfo;
end;

function TVulkanPipelineDepthStencilState.GetDepthTestEnable:boolean;
begin
 result:=fDepthStencilStateCreateInfo.depthTestEnable<>VK_FALSE;
end;

procedure TVulkanPipelineDepthStencilState.SetDepthTestEnable(const aNewValue:boolean);
begin
 fDepthStencilStateCreateInfo.depthTestEnable:=BooleanToVkBool[aNewValue];
end;

function TVulkanPipelineDepthStencilState.GetDepthWriteEnable:boolean;
begin
 result:=fDepthStencilStateCreateInfo.depthWriteEnable<>VK_FALSE;
end;

procedure TVulkanPipelineDepthStencilState.SetDepthWriteEnable(const aNewValue:boolean);
begin
 fDepthStencilStateCreateInfo.depthWriteEnable:=BooleanToVkBool[aNewValue];
end;

function TVulkanPipelineDepthStencilState.GetDepthCompareOp:TVkCompareOp;
begin
 result:=fDepthStencilStateCreateInfo.depthCompareOp;
end;

procedure TVulkanPipelineDepthStencilState.SetDepthCompareOp(const aNewValue:TVkCompareOp);
begin
 fDepthStencilStateCreateInfo.depthCompareOp:=aNewValue;
end;

function TVulkanPipelineDepthStencilState.GetDepthBoundsTestEnable:boolean;
begin
 result:=fDepthStencilStateCreateInfo.depthBoundsTestEnable<>VK_FALSE;
end;

procedure TVulkanPipelineDepthStencilState.SetDepthBoundsTestEnable(const aNewValue:boolean);
begin
 fDepthStencilStateCreateInfo.depthBoundsTestEnable:=BooleanToVkBool[aNewValue];
end;

function TVulkanPipelineDepthStencilState.GetStencilTestEnable:boolean;
begin
 result:=fDepthStencilStateCreateInfo.stencilTestEnable<>VK_FALSE;
end;

procedure TVulkanPipelineDepthStencilState.SetStencilTestEnable(const aNewValue:boolean);
begin
 fDepthStencilStateCreateInfo.stencilTestEnable:=BooleanToVkBool[aNewValue];
end;

function TVulkanPipelineDepthStencilState.GetMinDepthBounds:TVkFloat;
begin
 result:=fDepthStencilStateCreateInfo.minDepthBounds;
end;

procedure TVulkanPipelineDepthStencilState.SetMinDepthBounds(const aNewValue:TVkFloat);
begin
 fDepthStencilStateCreateInfo.minDepthBounds:=aNewValue;
end;

function TVulkanPipelineDepthStencilState.GetMaxDepthBounds:TVkFloat;
begin
 result:=fDepthStencilStateCreateInfo.maxDepthBounds;
end;

procedure TVulkanPipelineDepthStencilState.SetMaxDepthBounds(const aNewValue:TVkFloat);
begin
 fDepthStencilStateCreateInfo.maxDepthBounds:=aNewValue;
end;

procedure TVulkanPipelineDepthStencilState.SetDepthStencilState(const aDepthTestEnable:boolean;
                                                                const aDepthWriteEnable:boolean;
                                                                const aDepthCompareOp:TVkCompareOp;
                                                                const aDepthBoundsTestEnable:boolean;
                                                                const aStencilTestEnable:boolean;
                                                                const aFront:TVkStencilOpState;
                                                                const aBack:TVkStencilOpState;
                                                                const aMinDepthBounds:TVkFloat;
                                                                const aMaxDepthBounds:TVkFloat);
begin
 fDepthStencilStateCreateInfo.depthTestEnable:=BooleanToVkBool[aDepthTestEnable];
 fDepthStencilStateCreateInfo.depthWriteEnable:=BooleanToVkBool[aDepthWriteEnable];
 fDepthStencilStateCreateInfo.depthCompareOp:=aDepthCompareOp;
 fDepthStencilStateCreateInfo.depthBoundsTestEnable:=BooleanToVkBool[aDepthBoundsTestEnable];
 fDepthStencilStateCreateInfo.stencilTestEnable:=BooleanToVkBool[aStencilTestEnable];
 fDepthStencilStateCreateInfo.front:=aFront;
 fDepthStencilStateCreateInfo.back:=aBack;
 fDepthStencilStateCreateInfo.minDepthBounds:=aMinDepthBounds;
 fDepthStencilStateCreateInfo.maxDepthBounds:=aMaxDepthBounds;
end;

constructor TVulkanPipelineColorBlendState.Create;
begin

 inherited Create;

 FillChar(fColorBlendStateCreateInfo,SizeOf(TVkPipelineColorBlendStateCreateInfo),#0);
 fColorBlendStateCreateInfo.sType:=VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO;
 fColorBlendStateCreateInfo.pNext:=nil;
 fColorBlendStateCreateInfo.flags:=0;
 fColorBlendStateCreateInfo.logicOpEnable:=VK_FALSE;
 fColorBlendStateCreateInfo.logicOp:=VK_LOGIC_OP_NO_OP;
 fColorBlendStateCreateInfo.blendConstants[0]:=0.0;
 fColorBlendStateCreateInfo.blendConstants[1]:=0.0;
 fColorBlendStateCreateInfo.blendConstants[2]:=0.0;
 fColorBlendStateCreateInfo.blendConstants[3]:=0.0;

 fPointerToColorBlendStateCreateInfo:=@fColorBlendStateCreateInfo;

 fColorBlendAttachmentStates:=nil;
 fCountColorBlendAttachmentStates:=0;

end;

destructor TVulkanPipelineColorBlendState.Destroy;
begin
 SetLength(fColorBlendAttachmentStates,0);
 inherited Destroy;
end;

procedure TVulkanPipelineColorBlendState.Assign(const aFrom:TVulkanPipelineColorBlendState);
begin
 fColorBlendStateCreateInfo:=aFrom.fColorBlendStateCreateInfo;
 fColorBlendStateCreateInfo.attachmentCount:=0;
 fColorBlendStateCreateInfo.pAttachments:=nil;
end;

function TVulkanPipelineColorBlendState.GetLogicOpEnable:boolean;
begin
 result:=fColorBlendStateCreateInfo.logicOpEnable<>VK_FALSE;
end;

procedure TVulkanPipelineColorBlendState.SetLogicOpEnable(const aNewValue:boolean);
begin
 fColorBlendStateCreateInfo.logicOpEnable:=BooleanToVkBool[aNewValue];
end;

function TVulkanPipelineColorBlendState.GetLogicOp:TVkLogicOp;
begin
 result:=fColorBlendStateCreateInfo.logicOp;
end;

procedure TVulkanPipelineColorBlendState.SetLogicOp(const aNewValue:TVkLogicOp);
begin
 fColorBlendStateCreateInfo.logicOp:=aNewValue;
end;

procedure TVulkanPipelineColorBlendState.SetCountColorBlendAttachmentStates(const aNewCount:TVkInt32);
begin
 fCountColorBlendAttachmentStates:=aNewCount;
 if length(fColorBlendAttachmentStates)<fCountColorBlendAttachmentStates then begin
  SetLength(fColorBlendAttachmentStates,fCountColorBlendAttachmentStates*2);
 end;
end;

function TVulkanPipelineColorBlendState.GetColorBlendAttachmentState(const aIndex:TVkInt32):PVkPipelineColorBlendAttachmentState;
begin
 result:=@fColorBlendAttachmentStates[aIndex];
end;

function TVulkanPipelineColorBlendState.GetBlendConstant(const aIndex:TVkInt32):TVkFloat;
begin
 result:=fColorBlendStateCreateInfo.blendConstants[aIndex];
end;

procedure TVulkanPipelineColorBlendState.SetBlendConstant(const aIndex:TVkInt32;const aNewValue:TVkFloat);
begin
 fColorBlendStateCreateInfo.blendConstants[aIndex]:=aNewValue;
end;

procedure TVulkanPipelineColorBlendState.SetColorBlendState(const aLogicOpEnable:boolean;
                                                            const aLogicOp:TVkLogicOp;
                                                            const aBlendConstants:array of TVkFloat);
var ArrayItemCount:TVkInt32;
begin
 fColorBlendStateCreateInfo.logicOpEnable:=BooleanToVkBool[aLogicOpEnable];
 fColorBlendStateCreateInfo.logicOp:=aLogicOp;
 ArrayItemCount:=length(aBlendConstants);
 if ArrayItemCount>length(fColorBlendStateCreateInfo.blendConstants) then begin
  ArrayItemCount:=length(fColorBlendStateCreateInfo.blendConstants);
 end;
 if ArrayItemCount>0 then begin
  Move(aBlendConstants[0],fColorBlendStateCreateInfo.blendConstants[0],ArrayItemCount*SizeOf(TVkFloat));
 end;
end;

function TVulkanPipelineColorBlendState.AddColorBlendAttachmentState(const aColorBlendAttachmentState:TVkPipelineColorBlendAttachmentState):TVkInt32;
begin
 result:=fCountColorBlendAttachmentStates;
 inc(fCountColorBlendAttachmentStates);
 if length(fColorBlendAttachmentStates)<fCountColorBlendAttachmentStates then begin
  SetLength(fColorBlendAttachmentStates,fCountColorBlendAttachmentStates*2);
 end;
 fColorBlendAttachmentStates[result]:=aColorBlendAttachmentState;
end;

function TVulkanPipelineColorBlendState.AddColorBlendAttachmentState(const aBlendEnable:boolean;
                                                                     const aSrcColorBlendFactor:TVkBlendFactor;
                                                                     const aDstColorBlendFactor:TVkBlendFactor;
                                                                     const aColorBlendOp:TVkBlendOp;
                                                                     const aSrcAlphaBlendFactor:TVkBlendFactor;
                                                                     const aDstAlphaBlendFactor:TVkBlendFactor;
                                                                     const aAlphaBlendOp:TVkBlendOp;
                                                                     const aColorWriteMask:TVkColorComponentFlags):TVkInt32;
var ColorBlendAttachmentState:PVkPipelineColorBlendAttachmentState;
begin
 result:=fCountColorBlendAttachmentStates;
 inc(fCountColorBlendAttachmentStates);
 if length(fColorBlendAttachmentStates)<fCountColorBlendAttachmentStates then begin
  SetLength(fColorBlendAttachmentStates,fCountColorBlendAttachmentStates*2);
 end;
 ColorBlendAttachmentState:=@fColorBlendAttachmentStates[result];
 if aBlendEnable then begin
  ColorBlendAttachmentState^.blendEnable:=VK_TRUE;
 end else begin
  ColorBlendAttachmentState^.blendEnable:=VK_FALSE;
 end;
 ColorBlendAttachmentState^.srcColorBlendFactor:=aSrcColorBlendFactor;
 ColorBlendAttachmentState^.dstColorBlendFactor:=aDstColorBlendFactor;
 ColorBlendAttachmentState^.colorBlendOp:=aColorBlendOp;
 ColorBlendAttachmentState^.srcAlphaBlendFactor:=aSrcAlphaBlendFactor;
 ColorBlendAttachmentState^.dstAlphaBlendFactor:=aDstAlphaBlendFactor;
 ColorBlendAttachmentState^.alphaBlendOp:=aAlphaBlendOp;
 ColorBlendAttachmentState^.colorWriteMask:=aColorWriteMask;
end;

function TVulkanPipelineColorBlendState.AddColorBlendAttachmentStates(const aColorBlendAttachmentStates:array of TVkPipelineColorBlendAttachmentState):TVkInt32;
begin
 if length(aColorBlendAttachmentStates)>0 then begin
  result:=fCountColorBlendAttachmentStates;
  inc(fCountColorBlendAttachmentStates,length(aColorBlendAttachmentStates));
  if length(fColorBlendAttachmentStates)<fCountColorBlendAttachmentStates then begin
   SetLength(fColorBlendAttachmentStates,fCountColorBlendAttachmentStates*2);
  end;
  Move(aColorBlendAttachmentStates[0],fColorBlendAttachmentStates[result],length(aColorBlendAttachmentStates)*SizeOf(TVkRect2D));
 end else begin
  result:=-1;
 end;
end;

procedure TVulkanPipelineColorBlendState.Initialize;
begin
 SetLength(fColorBlendAttachmentStates,fCountColorBlendAttachmentStates);
 if fCountColorBlendAttachmentStates>0 then begin
  fColorBlendStateCreateInfo.attachmentCount:=fCountColorBlendAttachmentStates;
  fColorBlendStateCreateInfo.pAttachments:=@fColorBlendAttachmentStates[0];
 end;
end;

constructor TVulkanPipelineDynamicState.Create;
begin

 inherited Create;

 FillChar(fDynamicStateCreateInfo,SizeOf(TVkPipelineDynamicStateCreateInfo),#0);
 fDynamicStateCreateInfo.sType:=VK_STRUCTURE_TYPE_PIPELINE_DYNAMIC_STATE_CREATE_INFO;
 fDynamicStateCreateInfo.pNext:=nil;
 fDynamicStateCreateInfo.flags:=0;
 fDynamicStateCreateInfo.dynamicStateCount:=0;
 fDynamicStateCreateInfo.pDynamicStates:=nil;

 fPointerToDynamicStateCreateInfo:=@fDynamicStateCreateInfo;

 fDynamicStates:=nil;
 fCountDynamicStates:=0;

end;

destructor TVulkanPipelineDynamicState.Destroy;
begin
 SetLength(fDynamicStates,0);
 inherited Destroy;
end;

procedure TVulkanPipelineDynamicState.Assign(const aFrom:TVulkanPipelineDynamicState);
begin
 fDynamicStates:=copy(aFrom.fDynamicStates);
 fCountDynamicStates:=aFrom.fCountDynamicStates;
end;

function TVulkanPipelineDynamicState.GetDynamicState(const aIndex:TVkInt32):PVkDynamicState;
begin
 result:=@fDynamicStates[aIndex];
end;

procedure TVulkanPipelineDynamicState.SetCountDynamicStates(const aNewCount:TVkInt32);
begin
 fCountDynamicStates:=aNewCount;
 if length(fDynamicStates)<fCountDynamicStates then begin
  SetLength(fDynamicStates,fCountDynamicStates*2);
 end;
end;

function TVulkanPipelineDynamicState.AddDynamicState(const aDynamicState:TVkDynamicState):TVkInt32;
begin
 result:=fCountDynamicStates;
 inc(fCountDynamicStates);
 if length(fDynamicStates)<fCountDynamicStates then begin
  SetLength(fDynamicStates,fCountDynamicStates*2);
 end;
 fDynamicStates[result]:=aDynamicState;
end;

function TVulkanPipelineDynamicState.AddDynamicStates(const aDynamicStates:array of TVkDynamicState):TVkInt32;
begin
 if length(aDynamicStates)>0 then begin
  result:=fCountDynamicStates;
  inc(fCountDynamicStates,length(aDynamicStates));
  if length(fDynamicStates)<fCountDynamicStates then begin
   SetLength(fDynamicStates,fCountDynamicStates*2);
  end;
  Move(aDynamicStates[0],fDynamicStates[result],length(aDynamicStates)*SizeOf(TVkDynamicState));
 end else begin
  result:=-1;
 end;
end;

procedure TVulkanPipelineDynamicState.Initialize;
begin
 SetLength(fDynamicStates,fCountDynamicStates);
 fDynamicStateCreateInfo.DynamicStateCount:=fCountDynamicStates;
 if fCountDynamicStates>0 then begin
  fDynamicStateCreateInfo.pDynamicStates:=@fDynamicStates[0];
 end;
end;

constructor TVulkanGraphicsPipelineConstructor.Create(const aDevice:TVulkanDevice;
                                                      const aCache:TVulkanPipelineCache;
                                                      const aFlags:TVkPipelineCreateFlags;
                                                      const aStages:array of TVulkanPipelineShaderStage;
                                                      const aLayout:TVulkanPipelineLayout;
                                                      const aRenderPass:TVulkanRenderPass;
                                                      const aSubPass:TVkUInt32;
                                                      const aBasePipelineHandle:TVulkanPipeline;
                                                      const aBasePipelineIndex:TVkInt32);
var Index:TVkInt32;
begin
 fStages:=nil;
 fCountStages:=0;

 inherited Create(aDevice);

 fVertexInputState:=TVulkanPipelineVertexInputState.Create;

 fInputAssemblyState:=TVulkanPipelineInputAssemblyState.Create;

 fTessellationState:=TVulkanPipelineTessellationState.Create;

 fViewPortState:=TVulkanPipelineViewPortState.Create;

 fRasterizationState:=TVulkanPipelineRasterizationState.Create;

 fMultisampleState:=TVulkanPipelineMultisampleState.Create;

 fDepthStencilState:=TVulkanPipelineDepthStencilState.Create;

 fColorBlendState:=TVulkanPipelineColorBlendState.Create;

 fDynamicState:=TVulkanPipelineDynamicState.Create;

 FillChar(fGraphicsPipelineCreateInfo,SizeOf(TVkGraphicsPipelineCreateInfo),#0);
 fGraphicsPipelineCreateInfo.sType:=VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO;
 fGraphicsPipelineCreateInfo.pNext:=nil;
 fGraphicsPipelineCreateInfo.flags:=aFlags;
 fGraphicsPipelineCreateInfo.stageCount:=length(aStages);
 fCountStages:=fGraphicsPipelineCreateInfo.stageCount;
 if fCountStages>0 then begin
  SetLength(fStages,fCountStages);
  for Index:=0 to fCountStages-1 do begin
   aStages[Index].Initialize;
   fStages[Index]:=aStages[Index].fPipelineShaderStageCreateInfo;
  end;
  fGraphicsPipelineCreateInfo.pStages:=@fStages[0];
 end else begin
  fGraphicsPipelineCreateInfo.pStages:=nil;
 end;
 fGraphicsPipelineCreateInfo.pVertexInputState:=@fVertexInputState.fVertexInputStateCreateInfo;
 fGraphicsPipelineCreateInfo.pInputAssemblyState:=@fInputAssemblyState.fInputAssemblyStateCreateInfo;
 fGraphicsPipelineCreateInfo.pTessellationState:=nil;
 fGraphicsPipelineCreateInfo.pViewportState:=@fViewPortState.fViewportStateCreateInfo;
 fGraphicsPipelineCreateInfo.pRasterizationState:=@fRasterizationState.fRasterizationStateCreateInfo;
 fGraphicsPipelineCreateInfo.pMultisampleState:=@fMultisampleState.fMultisampleStateCreateInfo;
 fGraphicsPipelineCreateInfo.pDepthStencilState:=@fDepthStencilState.fDepthStencilStateCreateInfo;
 fGraphicsPipelineCreateInfo.pColorBlendState:=@fColorBlendState.fColorBlendStateCreateInfo;
 fGraphicsPipelineCreateInfo.pDynamicState:=nil;
 if assigned(aLayout) then begin
  fGraphicsPipelineCreateInfo.layout:=aLayout.fPipelineLayoutHandle;
 end else begin
  fGraphicsPipelineCreateInfo.layout:=VK_NULL_HANDLE;
 end;
 if assigned(aRenderPass) then begin
  fGraphicsPipelineCreateInfo.renderPass:=aRenderPass.fRenderPassHandle;
 end else begin
  fGraphicsPipelineCreateInfo.renderPass:=VK_NULL_HANDLE;
 end;
 fGraphicsPipelineCreateInfo.subpass:=aSubPass;
 if assigned(aBasePipelineHandle) then begin
  fGraphicsPipelineCreateInfo.basePipelineHandle:=aBasePipelineHandle.fPipelineHandle;
 end else begin
  fGraphicsPipelineCreateInfo.basePipelineHandle:=VK_NULL_HANDLE;
 end;
 fGraphicsPipelineCreateInfo.basePipelineIndex:=aBasePipelineIndex;

 if assigned(aCache) then begin
  fPipelineCache:=aCache.fPipelineCacheHandle;
 end else begin
  fPipelineCache:=VK_NULL_HANDLE;
 end;

end;

destructor TVulkanGraphicsPipelineConstructor.Destroy;
begin
 SetLength(fStages,0);
 fVertexInputState.Free;
 fInputAssemblyState.Free;
 fTessellationState.Free;
 fViewPortState.Free;
 fRasterizationState.Free;
 fMultisampleState.Free;
 fDepthStencilState.Free;
 fColorBlendState.Free;
 fDynamicState.Free;
 inherited Destroy;
end;

procedure TVulkanGraphicsPipelineConstructor.Assign(const aFrom:TVulkanGraphicsPipelineConstructor);
begin
 fStages:=copy(aFrom.fStages);
 fCountStages:=aFrom.fCountStages;
 fVertexInputState.Assign(aFrom.fVertexInputState);
 fInputAssemblyState.Assign(aFrom.fInputAssemblyState);
 fTessellationState.Assign(aFrom.fTessellationState);
 fViewPortState.Assign(aFrom.fViewPortState);
 fRasterizationState.Assign(aFrom.fRasterizationState);
 fMultisampleState.Assign(aFrom.fMultisampleState);
 fDepthStencilState.Assign(aFrom.fDepthStencilState);
 fColorBlendState.Assign(aFrom.fColorBlendState);
 fDynamicState.Assign(aFrom.fDynamicState);
end;

function TVulkanGraphicsPipelineConstructor.AddStage(const aStage:TVulkanPipelineShaderStage):TVkInt32;
begin
 result:=fCountStages;
 inc(fCountStages);
 if length(fStages)<fCountStages then begin
  SetLength(fStages,fCountStages*2);
 end;
 aStage.Initialize;
 fStages[result]:=aStage.fPipelineShaderStageCreateInfo;
end;

function TVulkanGraphicsPipelineConstructor.AddStages(const aStages:array of TVulkanPipelineShaderStage):TVkInt32;
var Index:TVkInt32;
begin
 if length(aStages)>0 then begin
  result:=AddStage(aStages[0]);
  for Index:=1 to length(aStages)-1 do begin
   AddStage(aStages[Index]);
  end;
 end else begin
  result:=-1;
 end;
end;

function TVulkanGraphicsPipelineConstructor.AddVertexInputBindingDescription(const aVertexInputBindingDescription:TVkVertexInputBindingDescription):TVkInt32;
begin
 Assert(assigned(fVertexInputState));
 result:=fVertexInputState.AddVertexInputBindingDescription(aVertexInputBindingDescription);
end;

function TVulkanGraphicsPipelineConstructor.AddVertexInputBindingDescription(const aBinding,aStride:TVkUInt32;const aInputRate:TVkVertexInputRate):TVkInt32;
begin
 Assert(assigned(fVertexInputState));
 result:=fVertexInputState.AddVertexInputBindingDescription(aBinding,aStride,aInputRate);
end;

function TVulkanGraphicsPipelineConstructor.AddVertexInputBindingDescriptions(const aVertexInputBindingDescriptions:array of TVkVertexInputBindingDescription):TVkInt32;
begin
 Assert(assigned(fVertexInputState));
 result:=fVertexInputState.AddVertexInputBindingDescriptions(aVertexInputBindingDescriptions);
end;

function TVulkanGraphicsPipelineConstructor.AddVertexInputAttributeDescription(const aVertexInputAttributeDescription:TVkVertexInputAttributeDescription):TVkInt32;
begin
 Assert(assigned(fVertexInputState));
 result:=fVertexInputState.AddVertexInputAttributeDescription(aVertexInputAttributeDescription);
end;

function TVulkanGraphicsPipelineConstructor.AddVertexInputAttributeDescription(const aLocation,aBinding:TVkUInt32;const aFormat:TVkFormat;const aOffset:TVkUInt32):TVkInt32;
begin
 Assert(assigned(fVertexInputState));
 result:=fVertexInputState.AddVertexInputAttributeDescription(aLocation,aBinding,aFormat,aOffset);
end;

function TVulkanGraphicsPipelineConstructor.AddVertexInputAttributeDescriptions(const aVertexInputAttributeDescriptions:array of TVkVertexInputAttributeDescription):TVkInt32;
begin
 Assert(assigned(fVertexInputState));
 result:=fVertexInputState.AddVertexInputAttributeDescriptions(aVertexInputAttributeDescriptions);
end;

procedure TVulkanGraphicsPipelineConstructor.SetInputAssemblyState(const aTopology:TVkPrimitiveTopology;const aPrimitiveRestartEnable:boolean);
begin
 Assert(assigned(fInputAssemblyState));
 fInputAssemblyState.SetInputAssemblyState(aTopology,aPrimitiveRestartEnable);
end;

procedure TVulkanGraphicsPipelineConstructor.SetTessellationState(const aPatchControlPoints:TVkUInt32);
begin
 Assert(assigned(fTessellationState));
 fTessellationState.SetTessellationState(aPatchControlPoints);
end;

function TVulkanGraphicsPipelineConstructor.AddViewPort(const aViewPort:TVkViewport):TVkInt32;
begin
 Assert(assigned(fViewPortState));
 result:=fViewPortState.AddViewPort(aViewPort);
end;

function TVulkanGraphicsPipelineConstructor.AddViewPort(const pX,pY,aWidth,aHeight,aMinDepth,aMaxDepth:TVkFloat):TVkInt32;
begin
 Assert(assigned(fViewPortState));
 result:=fViewPortState.AddViewPort(pX,pY,aWidth,aHeight,aMinDepth,aMaxDepth);
end;

function TVulkanGraphicsPipelineConstructor.AddViewPorts(const aViewPorts:array of TVkViewport):TVkInt32;
begin
 Assert(assigned(fViewPortState));
 result:=fViewPortState.AddViewPorts(aViewPorts);
end;

function TVulkanGraphicsPipelineConstructor.AddScissor(const aScissor:TVkRect2D):TVkInt32;
begin
 Assert(assigned(fViewPortState));
 result:=fViewPortState.AddScissor(aScissor);
end;

function TVulkanGraphicsPipelineConstructor.AddScissor(const pX,pY:TVkInt32;const aWidth,aHeight:TVkUInt32):TVkInt32;
begin
 Assert(assigned(fViewPortState));
 result:=fViewPortState.AddScissor(pX,pY,aWidth,aHeight);
end;

function TVulkanGraphicsPipelineConstructor.AddScissors(const aScissors:array of TVkRect2D):TVkInt32;
begin
 Assert(assigned(fViewPortState));
 result:=fViewPortState.AddScissors(aScissors);
end;

procedure TVulkanGraphicsPipelineConstructor.SetRasterizationState(const aDepthClampEnable:boolean;
                                                                   const aRasterizerDiscardEnable:boolean;
                                                                   const aPolygonMode:TVkPolygonMode;
                                                                   const aCullMode:TVkCullModeFlags;
                                                                   const aFrontFace:TVkFrontFace;
                                                                   const aDepthBiasEnable:boolean;
                                                                   const aDepthBiasConstantFactor:TVkFloat;
                                                                   const aDepthBiasClamp:TVkFloat;
                                                                   const aDepthBiasSlopeFactor:TVkFloat;
                                                                   const aLineWidth:TVkFloat);
begin
 Assert(assigned(fRasterizationState));
 fRasterizationState.SetRasterizationState(aDepthClampEnable,
                                           aRasterizerDiscardEnable,
                                           aPolygonMode,
                                           aCullMode,
                                           aFrontFace,
                                           aDepthBiasEnable,
                                           aDepthBiasConstantFactor,
                                           aDepthBiasClamp,
                                           aDepthBiasSlopeFactor,
                                           aLineWidth);
end;

procedure TVulkanGraphicsPipelineConstructor.SetMultisampleState(const aRasterizationSamples:TVkSampleCountFlagBits;
                                                                 const aSampleShadingEnable:boolean;
                                                                 const aMinSampleShading:TVkFloat;
                                                                 const aSampleMask:array of TVkSampleMask;
                                                                 const aAlphaToCoverageEnable:boolean;
                                                                 const aAlphaToOneEnable:boolean);
begin
 Assert(assigned(fMultisampleState));
 fMultisampleState.SetMultisampleState(aRasterizationSamples,
                                       aSampleShadingEnable,
                                       aMinSampleShading,
                                       aSampleMask,
                                       aAlphaToCoverageEnable,
                                       aAlphaToOneEnable);
end;

procedure TVulkanGraphicsPipelineConstructor.SetDepthStencilState(const aDepthTestEnable:boolean;
                                                                  const aDepthWriteEnable:boolean;
                                                                  const aDepthCompareOp:TVkCompareOp;
                                                                  const aDepthBoundsTestEnable:boolean;
                                                                  const aStencilTestEnable:boolean;
                                                                  const aFront:TVkStencilOpState;
                                                                  const aBack:TVkStencilOpState;
                                                                  const aMinDepthBounds:TVkFloat;
                                                                  const aMaxDepthBounds:TVkFloat);
begin
 Assert(assigned(fDepthStencilState));
 fDepthStencilState.SetDepthStencilState(aDepthTestEnable,
                                         aDepthWriteEnable,
                                         aDepthCompareOp,
                                         aDepthBoundsTestEnable,
                                         aStencilTestEnable,
                                         aFront,
                                         aBack,
                                         aMinDepthBounds,
                                         aMaxDepthBounds);
end;

procedure TVulkanGraphicsPipelineConstructor.SetColorBlendState(const aLogicOpEnable:boolean;
                                                                const aLogicOp:TVkLogicOp;
                                                                const aBlendConstants:array of TVkFloat);
begin
 Assert(assigned(fColorBlendState));
 fColorBlendState.SetColorBlendState(aLogicOpEnable,
                                     aLogicOp,
                                     aBlendConstants);
end;

function TVulkanGraphicsPipelineConstructor.AddColorBlendAttachmentState(const aColorBlendAttachmentState:TVkPipelineColorBlendAttachmentState):TVkInt32;
begin
 Assert(assigned(fColorBlendState));
 result:=fColorBlendState.AddColorBlendAttachmentState(aColorBlendAttachmentState);
end;

function TVulkanGraphicsPipelineConstructor.AddColorBlendAttachmentState(const aBlendEnable:boolean;
                                                                         const aSrcColorBlendFactor:TVkBlendFactor;
                                                                         const aDstColorBlendFactor:TVkBlendFactor;
                                                                         const aColorBlendOp:TVkBlendOp;
                                                                         const aSrcAlphaBlendFactor:TVkBlendFactor;
                                                                         const aDstAlphaBlendFactor:TVkBlendFactor;
                                                                         const aAlphaBlendOp:TVkBlendOp;
                                                                         const aColorWriteMask:TVkColorComponentFlags):TVkInt32;
begin
 Assert(assigned(fColorBlendState));
 result:=fColorBlendState.AddColorBlendAttachmentState(aBlendEnable,
                                                       aSrcColorBlendFactor,
                                                       aDstColorBlendFactor,
                                                       aColorBlendOp,
                                                       aSrcAlphaBlendFactor,
                                                       aDstAlphaBlendFactor,
                                                       aAlphaBlendOp,
                                                       aColorWriteMask);
end;

function TVulkanGraphicsPipelineConstructor.AddColorBlendAttachmentStates(const aColorBlendAttachmentStates:array of TVkPipelineColorBlendAttachmentState):TVkInt32;
begin
 Assert(assigned(fColorBlendState));
 result:=fColorBlendState.AddColorBlendAttachmentStates(aColorBlendAttachmentStates);
end;

function TVulkanGraphicsPipelineConstructor.AddDynamicState(const aDynamicState:TVkDynamicState):TVkInt32;
begin
 Assert(assigned(fDynamicState));
 result:=fDynamicState.AddDynamicState(aDynamicState);
end;

function TVulkanGraphicsPipelineConstructor.AddDynamicStates(const aDynamicStates:array of TVkDynamicState):TVkInt32;
begin
 Assert(assigned(fDynamicState));
 result:=fDynamicState.AddDynamicStates(aDynamicStates);
end;

procedure TVulkanGraphicsPipelineConstructor.Initialize;
begin
 if fPipelineHandle=VK_NULL_HANDLE then begin

  fGraphicsPipelineCreateInfo.stageCount:=fCountStages;
  if fCountStages>0 then begin
   SetLength(fStages,fCountStages);
   fGraphicsPipelineCreateInfo.pStages:=@fStages[0];
  end else begin
   fGraphicsPipelineCreateInfo.pStages:=nil;
  end;

  fVertexInputState.Initialize;

  if fTessellationState.fTessellationStateCreateInfo.patchControlPoints>0 then begin
   fGraphicsPipelineCreateInfo.pTessellationState:=@fTessellationState.fTessellationStateCreateInfo;
  end;

  fViewPortState.Initialize;

  fMultisampleState.Initialize;

  fColorBlendState.Initialize;

  fDynamicState.Initialize;

  if fDynamicState.CountDynamicStates>0 then begin
   fGraphicsPipelineCreateInfo.pDynamicState:=@fDynamicState.fDynamicStateCreateInfo;
  end;

  HandleResultCode(fDevice.fDeviceVulkan.CreateGraphicsPipelines(fDevice.fDeviceHandle,fPipelineCache,1,@fGraphicsPipelineCreateInfo,fDevice.fAllocationCallbacks,@fPipelineHandle));

 end;

end;

constructor TVulkanGraphicsPipeline.Create(const aDevice:TVulkanDevice;
                                           const aCache:TVulkanPipelineCache;
                                           const aFlags:TVkPipelineCreateFlags;
                                           const aStages:array of TVulkanPipelineShaderStage;
                                           const aLayout:TVulkanPipelineLayout;
                                           const aRenderPass:TVulkanRenderPass;
                                           const aSubPass:TVkUInt32;
                                           const aBasePipelineHandle:TVulkanPipeline;
                                           const aBasePipelineIndex:TVkInt32);
begin
 inherited Create(aDevice);
 fGraphicsPipelineConstructor:=TVulkanGraphicsPipelineConstructor.Create(fDevice,
                                                                         aCache,
                                                                         aFlags,
                                                                         aStages,
                                                                         aLayout,
                                                                         aRenderPass,
                                                                         aSubPass,
                                                                         aBasePipelineHandle,
                                                                         aBasePipelineIndex);
end;

destructor TVulkanGraphicsPipeline.Destroy;
begin
 FreeAndNil(fGraphicsPipelineConstructor);
 inherited Destroy;
end;

procedure TVulkanGraphicsPipeline.Assign(const aFrom:TVulkanGraphicsPipeline);
begin
 fGraphicsPipelineConstructor.Assign(aFrom.fGraphicsPipelineConstructor);
end;

function TVulkanGraphicsPipeline.GetCountStages:TVkInt32;
begin
 Assert(assigned(fGraphicsPipelineConstructor));
 result:=fGraphicsPipelineConstructor.fCountStages;
end;

function TVulkanGraphicsPipeline.GetVertexInputState:TVulkanPipelineVertexInputState;
begin
 Assert(assigned(fGraphicsPipelineConstructor));
 result:=fGraphicsPipelineConstructor.fVertexInputState;
end;

function TVulkanGraphicsPipeline.GetInputAssemblyState:TVulkanPipelineInputAssemblyState;
begin
 Assert(assigned(fGraphicsPipelineConstructor));
 result:=fGraphicsPipelineConstructor.fInputAssemblyState;
end;

function TVulkanGraphicsPipeline.GetTessellationState:TVulkanPipelineTessellationState;
begin
 Assert(assigned(fGraphicsPipelineConstructor));
 result:=fGraphicsPipelineConstructor.fTessellationState;
end;

function TVulkanGraphicsPipeline.GetViewPortState:TVulkanPipelineViewPortState;
begin
 Assert(assigned(fGraphicsPipelineConstructor));
 result:=fGraphicsPipelineConstructor.fViewPortState;
end;

function TVulkanGraphicsPipeline.GetRasterizationState:TVulkanPipelineRasterizationState;
begin
 Assert(assigned(fGraphicsPipelineConstructor));
 result:=fGraphicsPipelineConstructor.fRasterizationState;
end;

function TVulkanGraphicsPipeline.GetMultisampleState:TVulkanPipelineMultisampleState;
begin
 Assert(assigned(fGraphicsPipelineConstructor));
 result:=fGraphicsPipelineConstructor.fMultisampleState;
end;

function TVulkanGraphicsPipeline.GetDepthStencilState:TVulkanPipelineDepthStencilState;
begin
 Assert(assigned(fGraphicsPipelineConstructor));
 result:=fGraphicsPipelineConstructor.fDepthStencilState;
end;

function TVulkanGraphicsPipeline.GetColorBlendState:TVulkanPipelineColorBlendState;
begin
 Assert(assigned(fGraphicsPipelineConstructor));
 result:=fGraphicsPipelineConstructor.fColorBlendState;
end;

function TVulkanGraphicsPipeline.GetDynamicState:TVulkanPipelineDynamicState;
begin
 Assert(assigned(fGraphicsPipelineConstructor));
 result:=fGraphicsPipelineConstructor.fDynamicState;
end;

function TVulkanGraphicsPipeline.AddStage(const aStage:TVulkanPipelineShaderStage):TVkInt32;
begin
 Assert(assigned(fGraphicsPipelineConstructor));
 result:=fGraphicsPipelineConstructor.AddStage(aStage);
end;

function TVulkanGraphicsPipeline.AddStages(const aStages:array of TVulkanPipelineShaderStage):TVkInt32;
begin
 Assert(assigned(fGraphicsPipelineConstructor));
 result:=fGraphicsPipelineConstructor.AddStages(aStages);
end;

function TVulkanGraphicsPipeline.AddVertexInputBindingDescription(const aVertexInputBindingDescription:TVkVertexInputBindingDescription):TVkInt32;
begin
 Assert(assigned(fGraphicsPipelineConstructor));
 result:=fGraphicsPipelineConstructor.AddVertexInputBindingDescription(aVertexInputBindingDescription);
end;

function TVulkanGraphicsPipeline.AddVertexInputBindingDescription(const aBinding,aStride:TVkUInt32;const aInputRate:TVkVertexInputRate):TVkInt32;
begin
 Assert(assigned(fGraphicsPipelineConstructor));
 result:=fGraphicsPipelineConstructor.AddVertexInputBindingDescription(aBinding,aStride,aInputRate);
end;

function TVulkanGraphicsPipeline.AddVertexInputBindingDescriptions(const aVertexInputBindingDescriptions:array of TVkVertexInputBindingDescription):TVkInt32;
begin
 Assert(assigned(fGraphicsPipelineConstructor));
 result:=fGraphicsPipelineConstructor.AddVertexInputBindingDescriptions(aVertexInputBindingDescriptions);
end;

function TVulkanGraphicsPipeline.AddVertexInputAttributeDescription(const aVertexInputAttributeDescription:TVkVertexInputAttributeDescription):TVkInt32;
begin
 Assert(assigned(fGraphicsPipelineConstructor));
 result:=fGraphicsPipelineConstructor.AddVertexInputAttributeDescription(aVertexInputAttributeDescription);
end;

function TVulkanGraphicsPipeline.AddVertexInputAttributeDescription(const aLocation,aBinding:TVkUInt32;const aFormat:TVkFormat;const aOffset:TVkUInt32):TVkInt32;
begin
 Assert(assigned(fGraphicsPipelineConstructor));
 result:=fGraphicsPipelineConstructor.AddVertexInputAttributeDescription(aLocation,aBinding,aFormat,aOffset);
end;

function TVulkanGraphicsPipeline.AddVertexInputAttributeDescriptions(const aVertexInputAttributeDescriptions:array of TVkVertexInputAttributeDescription):TVkInt32;
begin
 Assert(assigned(fGraphicsPipelineConstructor));
 result:=fGraphicsPipelineConstructor.AddVertexInputAttributeDescriptions(aVertexInputAttributeDescriptions);
end;

procedure TVulkanGraphicsPipeline.SetInputAssemblyState(const aTopology:TVkPrimitiveTopology;const aPrimitiveRestartEnable:boolean);
begin
 Assert(assigned(fGraphicsPipelineConstructor));
 fGraphicsPipelineConstructor.SetInputAssemblyState(aTopology,aPrimitiveRestartEnable);
end;

procedure TVulkanGraphicsPipeline.SetTessellationState(const aPatchControlPoints:TVkUInt32);
begin
 Assert(assigned(fGraphicsPipelineConstructor));
 fGraphicsPipelineConstructor.SetTessellationState(aPatchControlPoints);
end;

function TVulkanGraphicsPipeline.AddViewPort(const aViewPort:TVkViewport):TVkInt32;
begin
 Assert(assigned(fGraphicsPipelineConstructor));
 result:=fGraphicsPipelineConstructor.AddViewPort(aViewPort);
end;

function TVulkanGraphicsPipeline.AddViewPort(const pX,pY,aWidth,aHeight,aMinDepth,aMaxDepth:TVkFloat):TVkInt32;
begin
 Assert(assigned(fGraphicsPipelineConstructor));
 result:=fGraphicsPipelineConstructor.AddViewPort(pX,pY,aWidth,aHeight,aMinDepth,aMaxDepth);
end;

function TVulkanGraphicsPipeline.AddViewPorts(const aViewPorts:array of TVkViewport):TVkInt32;
begin
 Assert(assigned(fGraphicsPipelineConstructor));
 result:=fGraphicsPipelineConstructor.AddViewPorts(aViewPorts);
end;

function TVulkanGraphicsPipeline.AddScissor(const aScissor:TVkRect2D):TVkInt32;
begin
 Assert(assigned(fGraphicsPipelineConstructor));
 result:=fGraphicsPipelineConstructor.AddScissor(aScissor);
end;

function TVulkanGraphicsPipeline.AddScissor(const pX,pY:TVkInt32;const aWidth,aHeight:TVkUInt32):TVkInt32;
begin
 Assert(assigned(fGraphicsPipelineConstructor));
 result:=fGraphicsPipelineConstructor.AddScissor(pX,pY,aWidth,aHeight);
end;

function TVulkanGraphicsPipeline.AddScissors(const aScissors:array of TVkRect2D):TVkInt32;
begin
 Assert(assigned(fGraphicsPipelineConstructor));
 result:=fGraphicsPipelineConstructor.AddScissors(aScissors);
end;

procedure TVulkanGraphicsPipeline.SetRasterizationState(const aDepthClampEnable:boolean;
                                                        const aRasterizerDiscardEnable:boolean;
                                                        const aPolygonMode:TVkPolygonMode;
                                                        const aCullMode:TVkCullModeFlags;
                                                        const aFrontFace:TVkFrontFace;
                                                        const aDepthBiasEnable:boolean;
                                                        const aDepthBiasConstantFactor:TVkFloat;
                                                        const aDepthBiasClamp:TVkFloat;
                                                        const aDepthBiasSlopeFactor:TVkFloat;
                                                        const aLineWidth:TVkFloat);
begin
 Assert(assigned(fGraphicsPipelineConstructor));
 fGraphicsPipelineConstructor.SetRasterizationState(aDepthClampEnable,
                                                    aRasterizerDiscardEnable,
                                                    aPolygonMode,
                                                    aCullMode,
                                                    aFrontFace,
                                                    aDepthBiasEnable,
                                                    aDepthBiasConstantFactor,
                                                    aDepthBiasClamp,
                                                    aDepthBiasSlopeFactor,
                                                    aLineWidth);
end;

procedure TVulkanGraphicsPipeline.SetMultisampleState(const aRasterizationSamples:TVkSampleCountFlagBits;
                                                      const aSampleShadingEnable:boolean;
                                                      const aMinSampleShading:TVkFloat;
                                                      const aSampleMask:array of TVkSampleMask;
                                                      const aAlphaToCoverageEnable:boolean;
                                                      const aAlphaToOneEnable:boolean);
begin
 Assert(assigned(fGraphicsPipelineConstructor));
 fGraphicsPipelineConstructor.SetMultisampleState(aRasterizationSamples,
                                                  aSampleShadingEnable,
                                                  aMinSampleShading,
                                                  aSampleMask,
                                                  aAlphaToCoverageEnable,
                                                  aAlphaToOneEnable);
end;

procedure TVulkanGraphicsPipeline.SetDepthStencilState(const aDepthTestEnable:boolean;
                                                       const aDepthWriteEnable:boolean;
                                                       const aDepthCompareOp:TVkCompareOp;
                                                       const aDepthBoundsTestEnable:boolean;
                                                       const aStencilTestEnable:boolean;
                                                       const aFront:TVkStencilOpState;
                                                       const aBack:TVkStencilOpState;
                                                       const aMinDepthBounds:TVkFloat;
                                                       const aMaxDepthBounds:TVkFloat);
begin
 Assert(assigned(fGraphicsPipelineConstructor));
 fGraphicsPipelineConstructor.SetDepthStencilState(aDepthTestEnable,
                                                   aDepthWriteEnable,
                                                   aDepthCompareOp,
                                                   aDepthBoundsTestEnable,
                                                   aStencilTestEnable,
                                                   aFront,
                                                   aBack,
                                                   aMinDepthBounds,
                                                   aMaxDepthBounds);
end;

procedure TVulkanGraphicsPipeline.SetColorBlendState(const aLogicOpEnable:boolean;
                                                     const aLogicOp:TVkLogicOp;
                                                     const aBlendConstants:array of TVkFloat);
begin
 Assert(assigned(fGraphicsPipelineConstructor));
 fGraphicsPipelineConstructor.SetColorBlendState(aLogicOpEnable,
                                                 aLogicOp,
                                                 aBlendConstants);
end;

function TVulkanGraphicsPipeline.AddColorBlendAttachmentState(const aColorBlendAttachmentState:TVkPipelineColorBlendAttachmentState):TVkInt32;
begin
 Assert(assigned(fGraphicsPipelineConstructor));
 result:=fGraphicsPipelineConstructor.AddColorBlendAttachmentState(aColorBlendAttachmentState);
end;

function TVulkanGraphicsPipeline.AddColorBlendAttachmentState(const aBlendEnable:boolean;
                                                              const aSrcColorBlendFactor:TVkBlendFactor;
                                                              const aDstColorBlendFactor:TVkBlendFactor;
                                                              const aColorBlendOp:TVkBlendOp;
                                                              const aSrcAlphaBlendFactor:TVkBlendFactor;
                                                              const aDstAlphaBlendFactor:TVkBlendFactor;
                                                              const aAlphaBlendOp:TVkBlendOp;
                                                              const aColorWriteMask:TVkColorComponentFlags):TVkInt32;
begin
 Assert(assigned(fGraphicsPipelineConstructor));
 result:=fGraphicsPipelineConstructor.AddColorBlendAttachmentState(aBlendEnable,
                                                                   aSrcColorBlendFactor,
                                                                   aDstColorBlendFactor,
                                                                   aColorBlendOp,
                                                                   aSrcAlphaBlendFactor,
                                                                   aDstAlphaBlendFactor,
                                                                   aAlphaBlendOp,
                                                                   aColorWriteMask);
end;

function TVulkanGraphicsPipeline.AddColorBlendAttachmentStates(const aColorBlendAttachmentStates:array of TVkPipelineColorBlendAttachmentState):TVkInt32;
begin
 Assert(assigned(fGraphicsPipelineConstructor));
 result:=fGraphicsPipelineConstructor.AddColorBlendAttachmentStates(aColorBlendAttachmentStates);
end;

function TVulkanGraphicsPipeline.AddDynamicState(const aDynamicState:TVkDynamicState):TVkInt32;
begin
 Assert(assigned(fGraphicsPipelineConstructor));
 result:=fGraphicsPipelineConstructor.AddDynamicState(aDynamicState);
end;

function TVulkanGraphicsPipeline.AddDynamicStates(const aDynamicStates:array of TVkDynamicState):TVkInt32;
begin
 Assert(assigned(fGraphicsPipelineConstructor));
 result:=fGraphicsPipelineConstructor.AddDynamicStates(aDynamicStates);
end;

procedure TVulkanGraphicsPipeline.Initialize;
begin
 if fPipelineHandle=VK_NULL_HANDLE then begin
  Assert(assigned(fGraphicsPipelineConstructor));
  fGraphicsPipelineConstructor.Initialize;
  fPipelineHandle:=fGraphicsPipelineConstructor.fPipelineHandle;
  fGraphicsPipelineConstructor.fPipelineHandle:=VK_NULL_HANDLE;
 end;
end;

procedure TVulkanGraphicsPipeline.FreeMemory;
begin
 FreeAndNil(fGraphicsPipelineConstructor);
end;

constructor TVulkanTexture.Create;
begin
 raise EVulkanTextureException.Create('Invalid constructor');
end;

constructor TVulkanTexture.CreateFromMemory(const aDevice:TVulkanDevice;
                                            const aGraphicsQueue:TVulkanQueue;
                                            const aGraphicsCommandBuffer:TVulkanCommandBuffer;
                                            const aGraphicsFence:TVulkanFence;
                                            const aTransferQueue:TVulkanQueue;
                                            const aTransferCommandBuffer:TVulkanCommandBuffer;
                                            const aTransferFence:TVulkanFence;
                                            const aFormat:TVkFormat;
                                            const aSampleCount:TVkSampleCountFlagBits;
                                            const aWidth:TVkInt32;
                                            const aHeight:TVkInt32;
                                            const aDepth:TVkInt32;
                                            const aCountArrayElements:TVkInt32;
                                            const aCountFaces:TVkInt32;
                                            const aCountMipMaps:TVkInt32;
                                            const aUsageFlags:TVulkanTextureUsageFlags;
                                            const aData:TVkPointer;
                                            const aDataSize:TVkSizeInt;
                                            const aMipMapSizeStored:boolean;
                                            const aSwapEndianness:boolean;
                                            const aSwapEndiannessTexels:TVkInt32;
                                            const aFromDDS:boolean=false);
type PUInt8Array=^TUInt8Array;
     TUInt8Array=array[0..65535] of TVkUInt8;
 function Swap16(x:TVkUInt16):TVkUInt16;
 begin
  result:=((x and $ff) shl 8) or ((x and $ff00) shr 8);
 end;
 function Swap32(x:TVkUInt32):TVkUInt32;
 begin
  result:=(Swap16(x and $ffff) shl 16) or Swap16((x and $ffff0000) shr 16);
 end;
 function Swap64(x:TVkUInt64):TVkUInt64;
 begin
  result:=(TVkUInt64(Swap32(x and TVkUInt64($ffffffff))) shl 32) or Swap32((x and TVkUInt64($ffffffff00000000)) shr 32);
 end;
var MaxDimension,MaxMipMapLevels,CountStorageLevels,CountArrayLayers,CountDataLevels,
    BufferImageCopyArraySize,MipMapLevelIndex,MipMapWidth,MipMapHeight,MipMapDepth,
    LayerIndex,DepthIndex,PreviousMipMapLevelIndex:TVkInt32;
    DataOffset,TotalMipMapSize,StoredMipMapSize,MipMapSize,Index:TVkUInt32;
    v16:PVkUInt16;
    v32:PVkUInt32;
    v64:PVkUInt64;
    Compressed:boolean;
    FormatProperties:TVkFormatProperties;
    Usage:TVkImageUsageFlags;
    ImageCreateFlags:TVkImageCreateFlags;
    ImageType:TVkImageType;
    MemoryRequirements:TVkMemoryRequirements;
    ImageMemoryBarrier:TVkImageMemoryBarrier;
    StagingBuffer:TVulkanBuffer;
    BufferMemoryBarrier:TVkBufferMemoryBarrier;
    BufferImageCopyArray:TVkBufferImageCopyArray;
    BufferImageCopy:PVkBufferImageCopy;
    ImageBlit:TVkImageBlit;
    ImageViewType:TVkImageViewType;
 procedure GetMipMapSize;
 begin
  case fFormat of
   VK_FORMAT_R8_UNORM:begin
    MipMapSize:=MipMapHeight*MipMapWidth*1*SizeOf(TVkUInt8);
   end;
   VK_FORMAT_R8G8_UNORM:begin
    MipMapSize:=MipMapHeight*MipMapWidth*2*SizeOf(TVkUInt8);
   end;
   VK_FORMAT_R8G8B8A8_UNORM:begin
    MipMapSize:=MipMapHeight*MipMapWidth*4*SizeOf(TVkUInt8);
   end;
   VK_FORMAT_R8_SNORM:begin
    MipMapSize:=MipMapHeight*MipMapWidth*1*SizeOf(TVkInt8);
   end;
   VK_FORMAT_R8G8_SNORM:begin
    MipMapSize:=MipMapHeight*MipMapWidth*2*SizeOf(TVkInt8);
   end;
   VK_FORMAT_R8G8B8_SNORM:begin
    MipMapSize:=MipMapHeight*MipMapWidth*4*SizeOf(TVkInt8);
   end;
   VK_FORMAT_R8_UINT:begin
    MipMapSize:=MipMapHeight*MipMapWidth*1*SizeOf(TVkUInt8);
   end;
   VK_FORMAT_R8G8_UINT:begin
    MipMapSize:=MipMapHeight*MipMapWidth*2*SizeOf(TVkUInt8);
   end;
   VK_FORMAT_R8G8B8_UINT:begin
    MipMapSize:=MipMapHeight*MipMapWidth*4*SizeOf(TVkUInt8);
   end;
   VK_FORMAT_R8_SINT:begin
    MipMapSize:=MipMapHeight*MipMapWidth*1*SizeOf(TVkInt8);
   end;
   VK_FORMAT_R8G8_SINT:begin
    MipMapSize:=MipMapHeight*MipMapWidth*2*SizeOf(TVkInt8);
   end;
   VK_FORMAT_R8G8B8_SINT:begin
    MipMapSize:=MipMapHeight*MipMapWidth*4*SizeOf(TVkInt8);
   end;
   VK_FORMAT_R8_SRGB:begin
    MipMapSize:=MipMapHeight*MipMapWidth*1*SizeOf(TVkUInt8);
   end;
   VK_FORMAT_R8G8_SRGB:begin
    MipMapSize:=MipMapHeight*MipMapWidth*2*SizeOf(TVkUInt8);
   end;
   VK_FORMAT_R8G8B8A8_SRGB:begin
    MipMapSize:=MipMapHeight*MipMapWidth*4*SizeOf(TVkUInt8);
   end;
   VK_FORMAT_R16_UNORM:begin
    MipMapSize:=MipMapHeight*MipMapWidth*1*SizeOf(TVkUInt16);
   end;
   VK_FORMAT_R16G16_UNORM:begin
    MipMapSize:=MipMapHeight*MipMapWidth*2*SizeOf(TVkUInt16);
   end;
   VK_FORMAT_R16G16B16A16_UNORM:begin
    MipMapSize:=MipMapHeight*MipMapWidth*4*SizeOf(TVkUInt16);
   end;
   VK_FORMAT_R16_SNORM:begin
    MipMapSize:=MipMapHeight*MipMapWidth*1*SizeOf(TVkInt16);
   end;
   VK_FORMAT_R16G16_SNORM:begin
    MipMapSize:=MipMapHeight*MipMapWidth*2*SizeOf(TVkInt16);
   end;
   VK_FORMAT_R16G16B16A16_SNORM:begin
    MipMapSize:=MipMapHeight*MipMapWidth*4*SizeOf(TVkInt16);
   end;
   VK_FORMAT_R16_UINT:begin
    MipMapSize:=MipMapHeight*MipMapWidth*1*SizeOf(TVkUInt16);
   end;
   VK_FORMAT_R16G16_UINT:begin
    MipMapSize:=MipMapHeight*MipMapWidth*2*SizeOf(TVkUInt16);
   end;
   VK_FORMAT_R16G16B16A16_UINT:begin
    MipMapSize:=MipMapHeight*MipMapWidth*4*SizeOf(TVkUInt16);
   end;
   VK_FORMAT_R16_SINT:begin
    MipMapSize:=MipMapHeight*MipMapWidth*1*SizeOf(TVkInt16);
   end;
   VK_FORMAT_R16G16_SINT:begin
    MipMapSize:=MipMapHeight*MipMapWidth*2*SizeOf(TVkInt16);
   end;
   VK_FORMAT_R16G16B16A16_SINT:begin
    MipMapSize:=MipMapHeight*MipMapWidth*4*SizeOf(TVkInt16);
   end;
   VK_FORMAT_R16_SFLOAT:begin
    MipMapSize:=MipMapHeight*MipMapWidth*1*SizeOf(TVkUInt16);
   end;
   VK_FORMAT_R16G16_SFLOAT:begin
    MipMapSize:=MipMapHeight*MipMapWidth*2*SizeOf(TVkUInt16);
   end;
   VK_FORMAT_R16G16B16A16_SFLOAT:begin
    MipMapSize:=MipMapHeight*MipMapWidth*4*SizeOf(TVkUInt16);
   end;
   VK_FORMAT_R32_UINT:begin
    MipMapSize:=MipMapHeight*MipMapWidth*1*SizeOf(TVkUInt32);
   end;
   VK_FORMAT_R32G32_UINT:begin
    MipMapSize:=MipMapHeight*MipMapWidth*2*SizeOf(TVkUInt32);
   end;
   VK_FORMAT_R32G32B32A32_UINT:begin
    MipMapSize:=MipMapHeight*MipMapWidth*4*SizeOf(TVkUInt32);
   end;
   VK_FORMAT_R32_SINT:begin
    MipMapSize:=MipMapHeight*MipMapWidth*1*SizeOf(TVkInt32);
   end;
   VK_FORMAT_R32G32_SINT:begin
    MipMapSize:=MipMapHeight*MipMapWidth*2*SizeOf(TVkInt32);
   end;
   VK_FORMAT_R32G32B32A32_SINT:begin
    MipMapSize:=MipMapHeight*MipMapWidth*4*SizeOf(TVkInt32);
   end;
   VK_FORMAT_R32_SFLOAT:begin
    MipMapSize:=MipMapHeight*MipMapWidth*1*SizeOf(single);
   end;
   VK_FORMAT_R32G32_SFLOAT:begin
    MipMapSize:=MipMapHeight*MipMapWidth*2*SizeOf(single);
   end;
   VK_FORMAT_R32G32B32A32_SFLOAT:begin
    MipMapSize:=MipMapHeight*MipMapWidth*4*SizeOf(single);
   end;
   VK_FORMAT_BC1_RGB_UNORM_BLOCK:begin
    MipMapSize:=((MipMapHeight+3) div 4)*((MipMapWidth+3) div 4)*8;
    Compressed:=true;
   end;
   VK_FORMAT_BC1_RGBA_UNORM_BLOCK:begin
    MipMapSize:=((MipMapHeight+3) div 4)*((MipMapWidth+3) div 4)*8;
    Compressed:=true;
   end;
   VK_FORMAT_BC2_UNORM_BLOCK:begin
    MipMapSize:=((MipMapHeight+3) div 4)*((MipMapWidth+3) div 4)*16;
    Compressed:=true;
   end;
   VK_FORMAT_BC3_UNORM_BLOCK:begin
    MipMapSize:=((MipMapHeight+3) div 4)*((MipMapWidth+3) div 4)*16;
    Compressed:=true;
   end;
   VK_FORMAT_BC1_RGB_SRGB_BLOCK:begin
    MipMapSize:=((MipMapHeight+3) div 4)*((MipMapWidth+3) div 4)*8;
    Compressed:=true;
   end;
   VK_FORMAT_BC1_RGBA_SRGB_BLOCK:begin
    MipMapSize:=((MipMapHeight+3) div 4)*((MipMapWidth+3) div 4)*8;
    Compressed:=true;
   end;
   VK_FORMAT_BC2_SRGB_BLOCK:begin
    MipMapSize:=((MipMapHeight+3) div 4)*((MipMapWidth+3) div 4)*16;
    Compressed:=true;
   end;
   VK_FORMAT_BC3_SRGB_BLOCK:begin
    MipMapSize:=((MipMapHeight+3) div 4)*((MipMapWidth+3) div 4)*16;
    Compressed:=true;
   end;
   VK_FORMAT_BC4_UNORM_BLOCK:begin
    MipMapSize:=((MipMapHeight+3) div 4)*((MipMapWidth+3) div 4)*8;
    Compressed:=true;
   end;
   VK_FORMAT_BC5_UNORM_BLOCK:begin
    MipMapSize:=((MipMapHeight+3) div 4)*((MipMapWidth+3) div 4)*16;
    Compressed:=true;
   end;
   VK_FORMAT_BC4_SNORM_BLOCK:begin
    MipMapSize:=((MipMapHeight+3) div 4)*((MipMapWidth+3) div 4)*8;
    Compressed:=true;
   end;
   VK_FORMAT_BC5_SNORM_BLOCK:begin
    MipMapSize:=((MipMapHeight+3) div 4)*((MipMapWidth+3) div 4)*16;
    Compressed:=true;
   end;
   VK_FORMAT_ETC2_R8G8B8_UNORM_BLOCK:begin
    MipMapSize:=((MipMapHeight+3) div 4)*((MipMapWidth+3) div 4)*8;
    Compressed:=true;
   end;
   VK_FORMAT_ETC2_R8G8B8A1_UNORM_BLOCK:begin
    MipMapSize:=((MipMapHeight+3) div 4)*((MipMapWidth+3) div 4)*8;
    Compressed:=true;
   end;
   VK_FORMAT_ETC2_R8G8B8A8_UNORM_BLOCK:begin
    MipMapSize:=((MipMapHeight+3) div 4)*((MipMapWidth+3) div 4)*16;
    Compressed:=true;
   end;
   VK_FORMAT_ETC2_R8G8B8_SRGB_BLOCK:begin
    MipMapSize:=((MipMapHeight+3) div 4)*((MipMapWidth+3) div 4)*8;
    Compressed:=true;
   end;
   VK_FORMAT_ETC2_R8G8B8A1_SRGB_BLOCK:begin
    MipMapSize:=((MipMapHeight+3) div 4)*((MipMapWidth+3) div 4)*8;
    Compressed:=true;
   end;
   VK_FORMAT_ETC2_R8G8B8A8_SRGB_BLOCK:begin
    MipMapSize:=((MipMapHeight+3) div 4)*((MipMapWidth+3) div 4)*16;
    Compressed:=true;
   end;
   VK_FORMAT_EAC_R11_UNORM_BLOCK:begin
    MipMapSize:=((MipMapHeight+3) div 4)*((MipMapWidth+3) div 4)*8;
    Compressed:=true;
   end;
   VK_FORMAT_EAC_R11G11_UNORM_BLOCK:begin
    MipMapSize:=((MipMapHeight+3) div 4)*((MipMapWidth+3) div 4)*16;
    Compressed:=true;
   end;
   VK_FORMAT_EAC_R11_SNORM_BLOCK:begin
    MipMapSize:=((MipMapHeight+3) div 4)*((MipMapWidth+3) div 4)*8;
    Compressed:=true;
   end;
   VK_FORMAT_EAC_R11G11_SNORM_BLOCK:begin
    MipMapSize:=((MipMapHeight+3) div 4)*((MipMapWidth+3) div 4)*16;
    Compressed:=true;
   end;
   VK_FORMAT_ASTC_4x4_UNORM_BLOCK:begin
    MipMapSize:=((MipMapHeight+3) div 4)*((MipMapWidth+3) div 4)*16;
    Compressed:=true;
   end;
   VK_FORMAT_ASTC_5x4_UNORM_BLOCK:begin
    MipMapSize:=((MipMapHeight+3) div 4)*((MipMapWidth+4) div 5)*16;
    Compressed:=true;
   end;
   VK_FORMAT_ASTC_5x5_UNORM_BLOCK:begin
    MipMapSize:=((MipMapHeight+4) div 5)*((MipMapWidth+4) div 5)*16;
    Compressed:=true;
   end;
   VK_FORMAT_ASTC_6x5_UNORM_BLOCK:begin
    MipMapSize:=((MipMapHeight+4) div 5)*((MipMapWidth+5) div 6)*16;
    Compressed:=true;
   end;
   VK_FORMAT_ASTC_6x6_UNORM_BLOCK:begin
    MipMapSize:=((MipMapHeight+5) div 6)*((MipMapWidth+5) div 6)*16;
    Compressed:=true;
   end;
   VK_FORMAT_ASTC_8x5_UNORM_BLOCK:begin
    MipMapSize:=((MipMapHeight+4) div 5)*((MipMapWidth+7) div 8)*16;
    Compressed:=true;
   end;
   VK_FORMAT_ASTC_8x6_UNORM_BLOCK:begin
    MipMapSize:=((MipMapHeight+5) div 6)*((MipMapWidth+7) div 8)*16;
    Compressed:=true;
   end;
   VK_FORMAT_ASTC_8x8_UNORM_BLOCK:begin
    MipMapSize:=((MipMapHeight+7) div 8)*((MipMapWidth+7) div 8)*16;
    Compressed:=true;
   end;
   VK_FORMAT_ASTC_10x5_UNORM_BLOCK:begin
    MipMapSize:=((MipMapHeight+4) div 5)*((MipMapWidth+9) div 10)*16;
    Compressed:=true;
   end;
   VK_FORMAT_ASTC_10x6_UNORM_BLOCK:begin
    MipMapSize:=((MipMapHeight+5) div 6)*((MipMapWidth+9) div 10)*16;
    Compressed:=true;
   end;
   VK_FORMAT_ASTC_10x8_UNORM_BLOCK:begin
    MipMapSize:=((MipMapHeight+7) div 8)*((MipMapWidth+9) div 10)*16;
    Compressed:=true;
   end;
   VK_FORMAT_ASTC_10x10_UNORM_BLOCK:begin
    MipMapSize:=((MipMapHeight+9) div 10)*((MipMapWidth+9) div 10)*16;
    Compressed:=true;
   end;
   VK_FORMAT_ASTC_12x10_UNORM_BLOCK:begin
    MipMapSize:=((MipMapHeight+9) div 10)*((MipMapWidth+11) div 12)*16;
    Compressed:=true;
   end;
   VK_FORMAT_ASTC_12x12_UNORM_BLOCK:begin
    MipMapSize:=((MipMapHeight+11) div 12)*((MipMapWidth+11) div 12)*16;
    Compressed:=true;
   end;
   VK_FORMAT_ASTC_4x4_SRGB_BLOCK:begin
    MipMapSize:=((MipMapHeight+3) div 4)*((MipMapWidth+3) div 4)*16;
    Compressed:=true;
   end;
   VK_FORMAT_ASTC_5x4_SRGB_BLOCK:begin
    MipMapSize:=((MipMapHeight+3) div 4)*((MipMapWidth+4) div 5)*16;
    Compressed:=true;
   end;
   VK_FORMAT_ASTC_5x5_SRGB_BLOCK:begin
    MipMapSize:=((MipMapHeight+4) div 5)*((MipMapWidth+4) div 5)*16;
    Compressed:=true;
   end;
   VK_FORMAT_ASTC_6x5_SRGB_BLOCK:begin
    MipMapSize:=((MipMapHeight+4) div 5)*((MipMapWidth+5) div 6)*16;
    Compressed:=true;
   end;
   VK_FORMAT_ASTC_6x6_SRGB_BLOCK:begin
    MipMapSize:=((MipMapHeight+5) div 6)*((MipMapWidth+5) div 6)*16;
    Compressed:=true;
   end;
   VK_FORMAT_ASTC_8x5_SRGB_BLOCK:begin
    MipMapSize:=((MipMapHeight+4) div 5)*((MipMapWidth+7) div 8)*16;
    Compressed:=true;
   end;
   VK_FORMAT_ASTC_8x6_SRGB_BLOCK:begin
    MipMapSize:=((MipMapHeight+5) div 6)*((MipMapWidth+7) div 8)*16;
    Compressed:=true;
   end;
   VK_FORMAT_ASTC_8x8_SRGB_BLOCK:begin
    MipMapSize:=((MipMapHeight+7) div 8)*((MipMapWidth+7) div 8)*16;
    Compressed:=true;
   end;
   VK_FORMAT_ASTC_10x5_SRGB_BLOCK:begin
    MipMapSize:=((MipMapHeight+4) div 5)*((MipMapWidth+9) div 10)*16;
    Compressed:=true;
   end;
   VK_FORMAT_ASTC_10x6_SRGB_BLOCK:begin
    MipMapSize:=((MipMapHeight+5) div 6)*((MipMapWidth+9) div 10)*16;
    Compressed:=true;
   end;
   VK_FORMAT_ASTC_10x8_SRGB_BLOCK:begin
    MipMapSize:=((MipMapHeight+7) div 8)*((MipMapWidth+9) div 10)*16;
    Compressed:=true;
   end;
   VK_FORMAT_ASTC_10x10_SRGB_BLOCK:begin
    MipMapSize:=((MipMapHeight+9) div 10)*((MipMapWidth+9) div 10)*16;
    Compressed:=true;
   end;
   VK_FORMAT_ASTC_12x10_SRGB_BLOCK:begin
    MipMapSize:=((MipMapHeight+9) div 10)*((MipMapWidth+11) div 12)*16;
    Compressed:=true;
   end;
   VK_FORMAT_ASTC_12x12_SRGB_BLOCK:begin
    MipMapSize:=((MipMapHeight+11) div 12)*((MipMapWidth+11) div 12)*16;
    Compressed:=true;
   end;
   else begin
    raise EVulkanTextureException.Create('Non-supported texture image format ('+IntToStr(TVkInt32(fFormat))+')');
   end;
  end;
 end;
begin

 inherited Create;

 fDevice:=aDevice;

 fFormat:=VK_FORMAT_UNDEFINED;

 fImageLayout:=VK_IMAGE_LAYOUT_UNDEFINED;

 fImage:=nil;

 fImageView:=nil;

 fSampler:=nil;

 fMemoryBlock:=nil;

 fWidth:=0;
 fHeight:=0;
 fDepth:=0;

 fCountArrayLayers:=0;

 fCountMipMaps:=0;

 fSampleCount:=VK_SAMPLE_COUNT_1_BIT;

 fUsage:=vtufUndefined;

 fUsageFlags:=[];

 fWrapModeU:=vtwmRepeat;
 fWrapModeV:=vtwmRepeat;
 fWrapModeW:=vtwmRepeat;

 fFilterMode:=vtfmNearest;

 fBorderColor:=VK_BORDER_COLOR_FLOAT_OPAQUE_BLACK;

 fMaxAnisotropy:=1.0;

 if (aDepth<1) or (aCountArrayElements<1) or (aCountFaces<1) then begin
  raise EVulkanTextureException.Create('Invalid parameters');
 end;
 if (aWidth<1) or (aWidth>32768) or (aHeight<1) or (aHeight>32768) or (aDepth<1) or (aDepth>32768) then begin
  raise EVulkanTextureException.Create('Invalid texture size ('+IntToStr(aWidth)+'x'+IntToStr(aHeight)+'x'+IntToStr(aDepth)+')');
 end;
 if not (aCountFaces in [1,6]) then begin
  raise EVulkanTextureException.Create('Cube maps must have 6 faces');
 end;
 if (aCountFaces<>1) and (aWidth<>aHeight) then begin
  raise EVulkanTextureException.Create('Cube maps must be square ('+IntToStr(aWidth)+'x'+IntToStr(aHeight)+')');
 end;
{if (aDepth>1) or (aCountArrayElements>1) then begin
  raise EVulkanTextureException.Create('3D array textures not supported yet');
 end;}

 MaxDimension:=Max(Max(aWidth,aHeight),aDepth);
 MaxMipMapLevels:=VulkanIntLog2(MaxDimension)+1;
 if aCountMipMaps>MaxMipMapLevels then begin
  raise EVulkanTextureException.Create('Too many mip levels ('+IntToStr(aCountMipMaps)+' > '+IntToStr(MaxMipMapLevels)+')');
 end;

 FormatProperties:=fDevice.fPhysicalDevice.GetFormatProperties(aFormat);

 if (vtufSampled in aUsageFlags) and ((FormatProperties.optimalTilingFeatures and TVkFormatFeatureFlags(VK_FORMAT_FEATURE_SAMPLED_IMAGE_BIT))=0) then begin
  raise EVulkanTextureException.Create('Texture format '+IntToStr(TVkInt32(aFormat))+' can''t be sampled');
 end;

 if (vtufColorAttachment in aUsageFlags) and ((FormatProperties.optimalTilingFeatures and TVkFormatFeatureFlags(VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BIT))=0) then begin
  raise EVulkanTextureException.Create('Texture format '+IntToStr(TVkInt32(aFormat))+' can''t be rendered to');
 end;

 if (vtufStorage in aUsageFlags) and ((FormatProperties.optimalTilingFeatures and TVkFormatFeatureFlags(VK_FORMAT_FEATURE_STORAGE_IMAGE_BIT))=0) then begin
  raise EVulkanTextureException.Create('Texture format '+IntToStr(TVkInt32(aFormat))+' can''t be used for storage');
 end;

 if aCountMipMaps>=1 then begin
  CountStorageLevels:=aCountMipMaps;
 end else begin
  CountStorageLevels:=MaxMipMapLevels;
 end;

 CountArrayLayers:=aCountFaces*aCountArrayElements;

 fWidth:=aWidth;
 fHeight:=aHeight;
 fDepth:=aDepth;
 fCountArrayLayers:=CountArrayLayers;
 fCountMipMaps:=CountStorageLevels;
 fSampleCount:=aSampleCount;
 fUsage:=vtufUndefined;
 fUsageFlags:=aUsageFlags;
 fWrapModeU:=vtwmRepeat;
 fWrapModeV:=vtwmRepeat;
 fWrapModeW:=vtwmRepeat;
 if CountStorageLevels>1 then begin
  fFilterMode:=vtfmBilinear;
 end else begin
  fFilterMode:=vtfmLinear;
 end;
 fBorderColor:=VK_BORDER_COLOR_FLOAT_OPAQUE_BLACK;
 fMaxAnisotropy:=1.0;
 fFormat:=aFormat;

 Compressed:=false;

 Usage:=0;
 if (vtufTransferDst in fUsageFlags) or assigned(aData) then begin
  Usage:=Usage or TVkImageUsageFlags(VK_IMAGE_USAGE_TRANSFER_DST_BIT);
 end;
 if (vtufTransferSrc in fUsageFlags) or (assigned(aData) and (aCountMipMaps<0)) then begin
  Usage:=Usage or TVkImageUsageFlags(VK_IMAGE_USAGE_TRANSFER_SRC_BIT);
 end;
 if vtufSampled in fUsageFlags then begin
  Usage:=Usage or TVkImageUsageFlags(VK_IMAGE_USAGE_SAMPLED_BIT);
 end;
 if vtufColorAttachment in fUsageFlags then begin
  Usage:=Usage or TVkImageUsageFlags(VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT);
 end;
 if vtufStorage in fUsageFlags then begin
  Usage:=Usage or TVkImageUsageFlags(VK_IMAGE_USAGE_STORAGE_BIT);
 end;

 ImageCreateFlags:=0;
 if aCountFaces=6 then begin
  ImageCreateFlags:=ImageCreateFlags or TVkImageCreateFlags(VK_IMAGE_CREATE_CUBE_COMPATIBLE_BIT);
 end;

 if aDepth>1 then begin
  ImageType:=VK_IMAGE_TYPE_3D;
 end else begin
  ImageType:=VK_IMAGE_TYPE_2D;
 end;

 fImage:=TVulkanImage.Create(fDevice,
                             ImageCreateFlags,
                             ImageType,
                             fFormat,
                             fWidth,
                             fHeight,
                             fDepth,
                             fCountMipMaps,
                             fCountArrayLayers,
                             fSampleCount,
                             VK_IMAGE_TILING_OPTIMAL,
                             Usage,
                             VK_SHARING_MODE_EXCLUSIVE,
                             0,
                             nil,
                             VK_IMAGE_LAYOUT_UNDEFINED
                            );

 fDevice.Commands.GetImageMemoryRequirements(fDevice.fDeviceHandle,fImage.fImageHandle,@MemoryRequirements);

 fMemoryBlock:=fDevice.fMemoryManager.AllocateMemoryBlock([],
                                                          MemoryRequirements.size,
                                                          MemoryRequirements.alignment,
                                                          MemoryRequirements.memoryTypeBits,
                                                          TVkMemoryPropertyFlags(VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT),
                                                          0,
                                                          0,
                                                          0,
                                                          0,
                                                          0,
                                                          vdmatImageOptimal);
 if not assigned(fMemoryBlock) then begin
  raise EVulkanMemoryAllocationException.Create('Memory for texture couldn''t be allocated!');
 end;

 HandleResultCode(fDevice.fDeviceVulkan.BindImageMemory(fDevice.fDeviceHandle,
                                                        fImage.fImageHandle,
                                                        fMemoryBlock.fMemoryChunk.fMemoryHandle,
                                                        fMemoryBlock.fOffset));

 if assigned(aData) then begin

  if fSampleCount<>VK_SAMPLE_COUNT_1_BIT then begin
   raise EVulkanTextureException.Create('Sample count must be 1 bit');
  end;

  if aCountMipMaps>1 then begin
   CountDataLevels:=aCountMipMaps;
  end else begin
   CountDataLevels:=1;
  end;

  StagingBuffer:=TVulkanBuffer.Create(fDevice,
                                      aDataSize,
                                      TVkBufferUsageFlags(VK_BUFFER_USAGE_TRANSFER_SRC_BIT),
                                      VK_SHARING_MODE_EXCLUSIVE,
                                      nil,
                                      TVkMemoryPropertyFlags(VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT),
                                      0,
                                      0,
                                      0,
                                      0,
                                      0,
                                      [vbfOwnSingleMemoryChunk]);
  try

   if (not aFromDDS) and (aSwapEndianness and (aSwapEndiannessTexels in [2,4,8])) then begin
    DataOffset:=0;
    for MipMapLevelIndex:=0 to CountDataLevels-1 do begin
     MipMapWidth:=Max(1,fWidth shr MipMapLevelIndex);
     MipMapHeight:=Max(1,fHeight shr MipMapLevelIndex);
     MipMapDepth:=Max(1,fDepth shr MipMapLevelIndex);
     TotalMipMapSize:=0;
     StoredMipMapSize:=0;
     if aMipMapSizeStored then begin
      Assert(TVkSizeInt(DataOffset+SizeOf(TVkUInt32))<=TVkSizeInt(aDataSize));
      StoredMipMapSize:=TVkUInt32(TVkPointer(@TUInt8Array(TVkPointer(aData)^)[DataOffset])^);
      inc(DataOffset,SizeOf(TVkUInt32));
      if aSwapEndianness then begin
       StoredMipMapSize:=Swap32(StoredMipMapSize);
      end;
      if StoredMipMapSize<>0 then begin
      end;
     end;
     for LayerIndex:=0 to fCountArrayLayers-1 do begin
      for DepthIndex:=0 to MipMapDepth-1 do begin
       MipMapSize:=0;
       GetMipMapSize;
       Assert(TVkSizeInt(DataOffset+MipMapSize)<=TVkSizeInt(aDataSize));
       case aSwapEndiannessTexels of
        2:begin
         v16:=TVkPointer(TVkPtrUInt(TVkPtrUInt(TVkPointer(aData))+TVkPtrUInt(DataOffset)));
         for Index:=1 to MipMapSize shr 1 do begin
          v16^:=Swap16(v16^);
          inc(v16);
         end;
        end;
        4:begin
         v32:=TVkPointer(TVkPtrUInt(TVkPtrUInt(TVkPointer(aData))+TVkPtrUInt(DataOffset)));
         for Index:=1 to MipMapSize shr 2 do begin
          v32^:=Swap32(v32^);
          inc(v32);
         end;
        end;
        8:begin
         v64:=TVkPointer(TVkPtrUInt(TVkPtrUInt(TVkPointer(aData))+TVkPtrUInt(DataOffset)));
         for Index:=1 to MipMapSize shr 3 do begin
          v64^:=Swap64(v64^);
          inc(v64);
         end;
        end;
       end;
       inc(TotalMipMapSize,MipMapSize);
       inc(DataOffset,MipMapSize);
       if aMipMapSizeStored and ((fDepth<=1) and (aCountArrayElements<=1)) then begin
        Assert(TotalMipMapSize=StoredMipMapSize);
        inc(DataOffset,3-((MipMapSize+3) and 3));
       end;
      end;
     end;
     if aMipMapSizeStored and ((fDepth>1) or (aCountArrayElements>1)) then begin
      Assert(TotalMipMapSize=StoredMipMapSize);
      inc(DataOffset,3-((TotalMipMapSize+3) and 3));
     end;
    end;
   end;

   StagingBuffer.UploadData(aTransferQueue,
                            aTransferCommandBuffer,
                            aTransferFence,
                            aData^,
                            0,
                            aDataSize,
                            vbutsbmNo);

   BufferImageCopyArray:=nil;
   try

    if (aGraphicsQueue=aTransferQueue) and
       (aGraphicsCommandBuffer=aTransferCommandBuffer) and
       (aGraphicsFence=aTransferFence) then begin

     aGraphicsCommandBuffer.Reset(TVkCommandBufferResetFlags(VK_COMMAND_BUFFER_RESET_RELEASE_RESOURCES_BIT));
     aGraphicsCommandBuffer.BeginRecording;
     try

      FillChar(ImageMemoryBarrier,SizeOf(TVkImageMemoryBarrier),#0);
      ImageMemoryBarrier.srcAccessMask:=0;
      ImageMemoryBarrier.dstAccessMask:=TVkAccessFlags(VK_ACCESS_TRANSFER_WRITE_BIT);
      ImageMemoryBarrier.sType:=VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER;
      ImageMemoryBarrier.oldLayout:=VK_IMAGE_LAYOUT_UNDEFINED;
      ImageMemoryBarrier.newLayout:=VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL;
      ImageMemoryBarrier.srcQueueFamilyIndex:=VK_QUEUE_FAMILY_IGNORED;
      ImageMemoryBarrier.dstQueueFamilyIndex:=VK_QUEUE_FAMILY_IGNORED;
      ImageMemoryBarrier.image:=fImage.fImageHandle;
      ImageMemoryBarrier.subresourceRange.aspectMask:=TVkImageAspectFlags(VK_IMAGE_ASPECT_COLOR_BIT);
      ImageMemoryBarrier.subresourceRange.baseMipLevel:=0;
      ImageMemoryBarrier.subresourceRange.levelCount:=fCountMipMaps;
      ImageMemoryBarrier.subresourceRange.baseArrayLayer:=0;
      ImageMemoryBarrier.subresourceRange.layerCount:=fCountArrayLayers;
      aGraphicsCommandBuffer.CmdPipelineBarrier(TVkPipelineStageFlags(VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT),
                                                TVkPipelineStageFlags(VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT),
                                                0,
                                                0,
                                                nil,
                                                0,
                                                nil,
                                                1,
                                                @ImageMemoryBarrier);

      FillChar(BufferMemoryBarrier,SizeOf(TVkBufferMemoryBarrier),#0);
      BufferMemoryBarrier.sType:=VK_STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER;
      BufferMemoryBarrier.srcAccessMask:=TVkAccessFlags(VK_ACCESS_HOST_WRITE_BIT);
      BufferMemoryBarrier.dstAccessMask:=TVkAccessFlags(VK_ACCESS_TRANSFER_READ_BIT);
      BufferMemoryBarrier.srcQueueFamilyIndex:=VK_QUEUE_FAMILY_IGNORED;
      BufferMemoryBarrier.dstQueueFamilyIndex:=VK_QUEUE_FAMILY_IGNORED;
      BufferMemoryBarrier.buffer:=StagingBuffer.fBufferHandle;
      BufferMemoryBarrier.offset:=StagingBuffer.Memory.fOffset;
      BufferMemoryBarrier.size:=aDataSize;
      aGraphicsCommandBuffer.CmdPipelineBarrier(TVkPipelineStageFlags(VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT),
                                                TVkPipelineStageFlags(VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT),
                                                0,
                                                0,
                                                nil,
                                                1,
                                                @BufferMemoryBarrier,
                                                0,
                                                nil);

      SetLength(BufferImageCopyArray,CountDataLevels*fCountArrayLayers*fDepth);
      BufferImageCopyArraySize:=0;
      DataOffset:=0;
      if aFromDDS then begin
       for LayerIndex:=0 to fCountArrayLayers-1 do begin
        for MipMapLevelIndex:=0 to CountDataLevels-1 do begin
         MipMapWidth:=Max(1,fWidth shr MipMapLevelIndex);
         MipMapHeight:=Max(1,fHeight shr MipMapLevelIndex);
         MipMapDepth:=Max(1,fDepth shr MipMapLevelIndex);
         for DepthIndex:=0 to MipMapDepth-1 do begin
          BufferImageCopy:=@BufferImageCopyArray[BufferImageCopyArraySize];
          inc(BufferImageCopyArraySize);
          FillChar(BufferImageCopy^,SizeOf(TVkBufferImageCopy),#0);
          BufferImageCopy^.bufferOffset:=DataOffset;
          BufferImageCopy^.bufferRowLength:=0;
          BufferImageCopy^.bufferImageHeight:=0;
          BufferImageCopy^.imageSubresource.aspectMask:=TVkImageAspectFlags(VK_IMAGE_ASPECT_COLOR_BIT);
          BufferImageCopy^.imageSubresource.mipLevel:=MipMapLevelIndex;
          BufferImageCopy^.imageSubresource.baseArrayLayer:=LayerIndex;
          BufferImageCopy^.imageSubresource.layerCount:=1;
          BufferImageCopy^.imageOffset.x:=0;
          BufferImageCopy^.imageOffset.y:=0;
          BufferImageCopy^.imageOffset.z:=DepthIndex;
          BufferImageCopy^.imageExtent.width:=fWidth;
          BufferImageCopy^.imageExtent.height:=fHeight;
          BufferImageCopy^.imageExtent.depth:=1;
          MipMapSize:=0;
          GetMipMapSize;
          Assert(TVkSizeInt(DataOffset+MipMapSize)<=TVkSizeInt(aDataSize));
          inc(DataOffset,MipMapSize);
         end;
        end;
       end;
      end else begin
       for MipMapLevelIndex:=0 to CountDataLevels-1 do begin
        MipMapWidth:=Max(1,fWidth shr MipMapLevelIndex);
        MipMapHeight:=Max(1,fHeight shr MipMapLevelIndex);
        MipMapDepth:=Max(1,fDepth shr MipMapLevelIndex);
        TotalMipMapSize:=0;
        StoredMipMapSize:=0;
        if aMipMapSizeStored then begin
         Assert(TVkSizeInt(DataOffset+SizeOf(TVkUInt32))<=TVkSizeInt(aDataSize));
         StoredMipMapSize:=TVkUInt32(TVkPointer(@TUInt8Array(TVkPointer(aData)^)[DataOffset])^);
         inc(DataOffset,SizeOf(TVkUInt32));
         if aSwapEndianness then begin
          StoredMipMapSize:=Swap32(StoredMipMapSize);
         end;
         if StoredMipMapSize<>0 then begin
         end;
        end;
        for LayerIndex:=0 to fCountArrayLayers-1 do begin
         for DepthIndex:=0 to MipMapDepth-1 do begin
          BufferImageCopy:=@BufferImageCopyArray[BufferImageCopyArraySize];
          inc(BufferImageCopyArraySize);
          FillChar(BufferImageCopy^,SizeOf(TVkBufferImageCopy),#0);
          BufferImageCopy^.bufferOffset:=DataOffset;
          BufferImageCopy^.bufferRowLength:=0;
          BufferImageCopy^.bufferImageHeight:=0;
          BufferImageCopy^.imageSubresource.aspectMask:=TVkImageAspectFlags(VK_IMAGE_ASPECT_COLOR_BIT);
          BufferImageCopy^.imageSubresource.mipLevel:=MipMapLevelIndex;
          BufferImageCopy^.imageSubresource.baseArrayLayer:=LayerIndex;
          BufferImageCopy^.imageSubresource.layerCount:=1;
          BufferImageCopy^.imageOffset.x:=0;
          BufferImageCopy^.imageOffset.y:=0;
          BufferImageCopy^.imageOffset.z:=DepthIndex;
          BufferImageCopy^.imageExtent.width:=fWidth;
          BufferImageCopy^.imageExtent.height:=fHeight;
          BufferImageCopy^.imageExtent.depth:=1;
          MipMapSize:=0;
          GetMipMapSize;
          Assert(TVkSizeInt(DataOffset+MipMapSize)<=TVkSizeInt(aDataSize));
          inc(TotalMipMapSize,MipMapSize);
          inc(DataOffset,MipMapSize);
          if aMipMapSizeStored and ((fDepth<=1) and (aCountArrayElements<=1)) then begin
           Assert(TotalMipMapSize=StoredMipMapSize);
           inc(DataOffset,3-((MipMapSize+3) and 3));
          end;
         end;
        end;
        if aMipMapSizeStored and ((fDepth>1) or (aCountArrayElements>1)) then begin
         Assert(TotalMipMapSize=StoredMipMapSize);
         inc(DataOffset,3-((TotalMipMapSize+3) and 3));
        end;
       end;
      end;
      SetLength(BufferImageCopyArray,BufferImageCopyArraySize);

      Assert(TVkSizeInt(DataOffset)=TVkSizeInt(aDataSize));

      aGraphicsCommandBuffer.CmdCopyBufferToImage(StagingBuffer.fBufferHandle,fImage.fImageHandle,VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL,BufferImageCopyArraySize,@BufferImageCopyArray[0]);

      if aCountMipMaps<1 then begin

       if Compressed then begin
        raise EVulkanTextureException.Create('Mip map levels can''t generated for compressed textures automatically');
       end;

       for MipMapLevelIndex:=1 to CountStorageLevels do begin

        PreviousMipMapLevelIndex:=MipMapLevelIndex-1;

        FillChar(ImageMemoryBarrier,SizeOf(TVkImageMemoryBarrier),#0);
        ImageMemoryBarrier.sType:=VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER;
        ImageMemoryBarrier.srcAccessMask:=TVkAccessFlags(VK_ACCESS_TRANSFER_WRITE_BIT);
        ImageMemoryBarrier.dstAccessMask:=TVkAccessFlags(VK_ACCESS_TRANSFER_READ_BIT);
        ImageMemoryBarrier.oldLayout:=VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL;
        ImageMemoryBarrier.newLayout:=VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL;
        ImageMemoryBarrier.srcQueueFamilyIndex:=VK_QUEUE_FAMILY_IGNORED;
        ImageMemoryBarrier.dstQueueFamilyIndex:=VK_QUEUE_FAMILY_IGNORED;
        ImageMemoryBarrier.image:=fImage.fImageHandle;
        ImageMemoryBarrier.subresourceRange.aspectMask:=TVkImageAspectFlags(VK_IMAGE_ASPECT_COLOR_BIT);
        ImageMemoryBarrier.subresourceRange.baseMipLevel:=PreviousMipMapLevelIndex;
        ImageMemoryBarrier.subresourceRange.levelCount:=1;
        ImageMemoryBarrier.subresourceRange.baseArrayLayer:=0;
        ImageMemoryBarrier.subresourceRange.layerCount:=fCountArrayLayers;
        aGraphicsCommandBuffer.CmdPipelineBarrier(TVkPipelineStageFlags(VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT),
                                                  TVkPipelineStageFlags(VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT),
                                                  0,
                                                  0,
                                                  nil,
                                                  0,
                                                  nil,
                                                  1,
                                                  @ImageMemoryBarrier);

        if MipMapLevelIndex<CountStorageLevels then begin
         FillChar(ImageBlit,SizeOf(TVkImageBlit),#0);
         ImageBlit.srcSubresource.aspectMask:=TVkImageAspectFlags(VK_IMAGE_ASPECT_COLOR_BIT);
         ImageBlit.srcSubresource.mipLevel:=PreviousMipMapLevelIndex;
         ImageBlit.srcSubresource.baseArrayLayer:=0;
         ImageBlit.srcSubresource.layerCount:=fCountArrayLayers;
         ImageBlit.srcOffsets[0].x:=0;
         ImageBlit.srcOffsets[0].y:=0;
         ImageBlit.srcOffsets[0].z:=0;
         ImageBlit.srcOffsets[1].x:=Max(1,fWidth shr PreviousMipMapLevelIndex);
         ImageBlit.srcOffsets[1].y:=Max(1,fHeight shr PreviousMipMapLevelIndex);
         ImageBlit.srcOffsets[1].z:=Max(1,fDepth shr PreviousMipMapLevelIndex);
         ImageBlit.dstSubresource.aspectMask:=TVkImageAspectFlags(VK_IMAGE_ASPECT_COLOR_BIT);
         ImageBlit.dstSubresource.mipLevel:=MipMapLevelIndex;
         ImageBlit.dstSubresource.baseArrayLayer:=0;
         ImageBlit.dstSubresource.layerCount:=fCountArrayLayers;
         ImageBlit.dstOffsets[0].x:=0;
         ImageBlit.dstOffsets[0].y:=0;
         ImageBlit.dstOffsets[0].z:=0;
         ImageBlit.dstOffsets[1].x:=Max(1,fWidth shr MipMapLevelIndex);
         ImageBlit.dstOffsets[1].y:=Max(1,fHeight shr MipMapLevelIndex);
         ImageBlit.dstOffsets[1].z:=Max(1,fDepth shr MipMapLevelIndex);
         aGraphicsCommandBuffer.CmdBlitImage(fImage.fImageHandle,
                                             VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL,
                                             fImage.fImageHandle,
                                             VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL,
                                             1,
                                             @ImageBlit,
                                             VK_FILTER_LINEAR);
        end;

       end;

      end;

      FillChar(ImageMemoryBarrier,SizeOf(TVkImageMemoryBarrier),#0);
      ImageMemoryBarrier.sType:=VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER;
      if aCountMipMaps>=1 then begin
       ImageMemoryBarrier.srcAccessMask:=TVkAccessFlags(VK_ACCESS_TRANSFER_WRITE_BIT);
      end else begin
       ImageMemoryBarrier.srcAccessMask:=TVkAccessFlags(VK_ACCESS_TRANSFER_READ_BIT);
      end;
      ImageMemoryBarrier.dstAccessMask:=TVkAccessFlags(VK_ACCESS_SHADER_READ_BIT) or TVkAccessFlags(VK_ACCESS_INPUT_ATTACHMENT_READ_BIT);
      if aCountMipMaps>=1 then begin
       ImageMemoryBarrier.oldLayout:=VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL;
      end else begin
       ImageMemoryBarrier.oldLayout:=VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL;
      end;
      ImageMemoryBarrier.newLayout:=VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL;
      ImageMemoryBarrier.srcQueueFamilyIndex:=VK_QUEUE_FAMILY_IGNORED;
      ImageMemoryBarrier.dstQueueFamilyIndex:=VK_QUEUE_FAMILY_IGNORED;
      ImageMemoryBarrier.image:=fImage.fImageHandle;
      ImageMemoryBarrier.subresourceRange.aspectMask:=TVkImageAspectFlags(VK_IMAGE_ASPECT_COLOR_BIT);
      ImageMemoryBarrier.subresourceRange.baseMipLevel:=0;
      ImageMemoryBarrier.subresourceRange.levelCount:=fCountMipMaps;
      ImageMemoryBarrier.subresourceRange.baseArrayLayer:=0;
      ImageMemoryBarrier.subresourceRange.layerCount:=fCountArrayLayers;
      aGraphicsCommandBuffer.CmdPipelineBarrier(TVkPipelineStageFlags(VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT),
                                                TVkPipelineStageFlags(VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT),
                                                0,
                                                0,
                                                nil,
                                                0,
                                                nil,
                                                1,
                                                @ImageMemoryBarrier);

     finally
      aGraphicsCommandBuffer.EndRecording;
      aGraphicsCommandBuffer.Execute(aGraphicsQueue,0,nil,nil,aGraphicsFence,true);
     end;

    end else begin

     raise EVulkanTextureException.Create('TODO');

    end;

   finally
    SetLength(BufferImageCopyArray,0);
   end;

  finally
   StagingBuffer.Free;
  end;

 end else begin

  FillChar(ImageMemoryBarrier,SizeOf(TVkImageMemoryBarrier),#0);
  ImageMemoryBarrier.sType:=VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER;
  ImageMemoryBarrier.srcAccessMask:=0;
  ImageMemoryBarrier.dstAccessMask:=TVkAccessFlags(VK_ACCESS_SHADER_READ_BIT);
  ImageMemoryBarrier.oldLayout:=VK_IMAGE_LAYOUT_UNDEFINED;
  ImageMemoryBarrier.newLayout:=VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL;
  ImageMemoryBarrier.srcQueueFamilyIndex:=VK_QUEUE_FAMILY_IGNORED;
  ImageMemoryBarrier.dstQueueFamilyIndex:=VK_QUEUE_FAMILY_IGNORED;
  ImageMemoryBarrier.image:=fImage.fImageHandle;
  ImageMemoryBarrier.subresourceRange.aspectMask:=TVkImageAspectFlags(VK_IMAGE_ASPECT_COLOR_BIT);
  ImageMemoryBarrier.subresourceRange.baseMipLevel:=0;
  ImageMemoryBarrier.subresourceRange.levelCount:=fCountMipMaps;
  ImageMemoryBarrier.subresourceRange.baseArrayLayer:=0;
  ImageMemoryBarrier.subresourceRange.layerCount:=fCountArrayLayers;
  aGraphicsCommandBuffer.Reset(TVkCommandBufferResetFlags(VK_COMMAND_BUFFER_RESET_RELEASE_RESOURCES_BIT));
  aGraphicsCommandBuffer.BeginRecording;
  aGraphicsCommandBuffer.CmdPipelineBarrier(TVkPipelineStageFlags(VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT),
                                            TVkPipelineStageFlags(VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT),
                                            0,
                                            0,
                                            nil,
                                            0,
                                            nil,
                                            1,
                                            @ImageMemoryBarrier);
  aGraphicsCommandBuffer.EndRecording;
  aGraphicsCommandBuffer.Execute(aGraphicsQueue,0,nil,nil,aGraphicsFence,true);

 end;

 fUsage:=vtufSampled;
 fImageLayout:=VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL;

 if fDepth>1 then begin
  ImageViewType:=VK_IMAGE_VIEW_TYPE_3D;
 end else begin
  if aCountFaces>1 then begin
   if aCountArrayElements>1 then begin
    ImageViewType:=VK_IMAGE_VIEW_TYPE_CUBE_ARRAY;
   end else begin
    ImageViewType:=VK_IMAGE_VIEW_TYPE_CUBE;
   end;
  end else begin
   if aCountArrayElements>1 then begin
    ImageViewType:=VK_IMAGE_VIEW_TYPE_2D_ARRAY;
   end else begin
    ImageViewType:=VK_IMAGE_VIEW_TYPE_2D;
   end;
  end;
 end;

 fImageView:=TVulkanImageView.Create(fDevice,
                                     fImage,
                                     ImageViewType,
                                     fFormat,
                                     VK_COMPONENT_SWIZZLE_IDENTITY,
                                     VK_COMPONENT_SWIZZLE_IDENTITY,
                                     VK_COMPONENT_SWIZZLE_IDENTITY,
                                     VK_COMPONENT_SWIZZLE_IDENTITY,
                                     TVkImageAspectFlags(VK_IMAGE_ASPECT_COLOR_BIT),
                                     0,
                                     fCountMipMaps,
                                     0,
                                     fCountArrayLayers);


 if assigned(fSampler) then begin
  fDescriptorImageInfo.sampler:=fSampler.fSamplerHandle;
 end else begin
  fDescriptorImageInfo.sampler:=VK_NULL_HANDLE;
 end;
 if assigned(fImageView) then begin
  fDescriptorImageInfo.imageView:=fImageView.fImageViewHandle;
 end else begin
  fDescriptorImageInfo.imageView:=VK_NULL_HANDLE;
 end;
 fDescriptorImageInfo.imageLayout:=fImageLayout;

end;

constructor TVulkanTexture.CreateFromStream(const aDevice:TVulkanDevice;
                                            const aGraphicsQueue:TVulkanQueue;
                                            const aGraphicsCommandBuffer:TVulkanCommandBuffer;
                                            const aGraphicsFence:TVulkanFence;
                                            const aTransferQueue:TVulkanQueue;
                                            const aTransferCommandBuffer:TVulkanCommandBuffer;
                                            const aTransferFence:TVulkanFence;
                                            const aFormat:TVkFormat;
                                            const aSampleCount:TVkSampleCountFlagBits;
                                            const aWidth:TVkInt32;
                                            const aHeight:TVkInt32;
                                            const aDepth:TVkInt32;
                                            const aCountArrayElements:TVkInt32;
                                            const aCountFaces:TVkInt32;
                                            const aCountMipMaps:TVkInt32;
                                            const aUsageFlags:TVulkanTextureUsageFlags;
                                            const aStream:TStream;
                                            const aMipMapSizeStored:boolean;
                                            const aSwapEndianness:boolean;
                                            const aSwapEndiannessTexels:TVkInt32;
                                            const aFromDDS:boolean=false);
var Data:TVkPointer;
    DataSize:TVkUInt32;
begin
 DataSize:=aStream.Size;
 GetMem(Data,DataSize);
 try
  if TVkInt64(aStream.Read(Data^,DataSize))<>TVkInt64(DataSize) then begin
   raise EVulkanTextureException.Create('Stream read error');
  end;
  CreateFromMemory(aDevice,
                   aGraphicsQueue,
                   aGraphicsCommandBuffer,
                   aGraphicsFence,
                   aTransferQueue,
                   aTransferCommandBuffer,
                   aTransferFence,
                   aFormat,
                   aSampleCount,
                   aWidth,
                   aHeight,
                   aDepth,
                   aCountArrayElements,
                   aCountFaces,
                   aCountMipMaps,
                   aUsageFlags,
                   Data,
                   DataSize,
                   aMipMapSizeStored,
                   aSwapEndianness,
                   aSwapEndiannessTexels,
                   aFromDDS);
 finally
  FreeMem(Data);
 end;
end;

constructor TVulkanTexture.CreateFromKTX(const aDevice:TVulkanDevice;
                                         const aGraphicsQueue:TVulkanQueue;
                                         const aGraphicsCommandBuffer:TVulkanCommandBuffer;
                                         const aGraphicsFence:TVulkanFence;
                                         const aTransferQueue:TVulkanQueue;
                                         const aTransferCommandBuffer:TVulkanCommandBuffer;
                                         const aTransferFence:TVulkanFence;
                                         const aStream:TStream);
type PKTXIdentifier=^TKTXIdentifier;
     TKTXIdentifier=array[0..11] of TVkUInt8;
     PKTXHeader=^TKTXHeader;
     TKTXHeader=packed record
      Identifier:TKTXIdentifier;
      Endianness:TVkUInt32;
      GLType:TVkUInt32;
      GLTypeSize:TVkUInt32;
      GLFormat:TVkUInt32;
      GLInternalFormat:TVkUInt32;
      GLBaseInternalFormat:TVkUInt32;
      PixelWidth:TVkUInt32;
      PixelHeight:TVkUInt32;
      PixelDepth:TVkUInt32;
      NumberOfArrayElements:TVkUInt32;
      NumberOfFaces:TVkUInt32;
      NumberOfMipMapLevels:TVkUInt32;
      BytesOfKeyValueData:TVkUInt32;
     end;
 function Swap16(x:TVkUInt16):TVkUInt16;
 begin
  result:=((x and $ff) shl 8) or ((x and $ff00) shr 8);
 end;
 function Swap32(x:TVkUInt32):TVkUInt32;
 begin
  result:=(Swap16(x and $ffff) shl 16) or Swap16((x and $ffff0000) shr 16);
 end;
var KTXHeader:TKTXHeader;
    MustSwap:boolean;
    NumberOfArrayElements:TVkUInt32;
    NumberOfFaces:TVkUInt32;
    NumberOfMipMapLevels:TVkUInt32;
    Data:TVkPointer;
    DataSize:TVkSizeInt;
    NewPosition:TVkInt64;
begin

 if aStream.Read(KTXHeader,SizeOf(TKTXHeader))<>SizeOf(TKTXHeader) then begin
  raise EVulkanTextureException.Create('Stream read error');
 end;

 if (KTXHeader.Identifier[0]<>$ab) or
    (KTXHeader.Identifier[1]<>$4b) or
    (KTXHeader.Identifier[2]<>$54) or
    (KTXHeader.Identifier[3]<>$58) or
    (KTXHeader.Identifier[4]<>$20) or
    (KTXHeader.Identifier[5]<>$31) or
    (KTXHeader.Identifier[6]<>$31) or
    (KTXHeader.Identifier[7]<>$bb) or
    (KTXHeader.Identifier[8]<>$0d) or
    (KTXHeader.Identifier[9]<>$0a) or
    (KTXHeader.Identifier[10]<>$1a) or
    (KTXHeader.Identifier[11]<>$0a) then begin
  raise EVulkanTextureException.Create('Invalid KTX stream');
 end;

 MustSwap:=false;
 case KTXHeader.Endianness of
  $01020304:begin
   MustSwap:=true;
   KTXHeader.GLType:=Swap32(KTXHeader.GLType);
   KTXHeader.GLTypeSize:=Swap32(KTXHeader.GLTypeSize);
   KTXHeader.GLFormat:=Swap32(KTXHeader.GLFormat);
   KTXHeader.GLInternalFormat:=Swap32(KTXHeader.GLInternalFormat);
   KTXHeader.GLBaseInternalFormat:=Swap32(KTXHeader.GLBaseInternalFormat);
   KTXHeader.PixelWidth:=Swap32(KTXHeader.PixelWidth);
   KTXHeader.PixelHeight:=Swap32(KTXHeader.PixelHeight);
   KTXHeader.PixelDepth:=Swap32(KTXHeader.PixelDepth);
   KTXHeader.NumberOfArrayElements:=Swap32(KTXHeader.NumberOfArrayElements);
   KTXHeader.NumberOfFaces:=Swap32(KTXHeader.NumberOfFaces);
   KTXHeader.NumberOfMipmapLevels:=Swap32(KTXHeader.NumberOfMipmapLevels);
   KTXHeader.BytesOfKeyValueData:=Swap32(KTXHeader.BytesOfKeyValueData);
   if not (KTXHeader.GLTypeSize in [1,2,4]) then begin
    exit;
   end;
  end;
  $04030201:begin
  end;
  else begin
   exit;
  end;
 end;

 if (KTXHeader.GLType=0)<>(KTXHeader.GLFormat=0) then begin
  raise EVulkanTextureException.Create('Invalid KTX stream');
 end;
 if (KTXHeader.PixelWidth=0) or ((KTXHeader.PixelDepth>0) and (KTXHeader.PixelHeight=0)) then begin
  raise EVulkanTextureException.Create('Invalid KTX stream');
 end;
 if not ((KTXHeader.GLFormat=0) or (KTXHeader.GLTypeSize in [1,2,4,8])) then begin
  raise EVulkanTextureException.Create('Invalid KTX stream');
 end;
 if not ((KTXHeader.GLFormat=0) or (KTXHeader.GLFormat=KTXHeader.GLBaseInternalFormat)) then begin
  raise EVulkanTextureException.Create('Invalid KTX stream');
 end;
 if not ((KTXHeader.GLFormat<>0) or (KTXHeader.GLTypeSize=1)) then begin
  raise EVulkanTextureException.Create('Invalid KTX stream');
 end;

 NumberOfArrayElements:=Max(1,KTXHeader.NumberOfArrayElements);
 NumberOfFaces:=Max(1,KTXHeader.NumberOfFaces);
 NumberOfMipMapLevels:=KTXHeader.NumberOfMipMapLevels;

 if KTXHeader.BytesOfKeyValueData>0 then begin
  NewPosition:=aStream.Position+KTXHeader.BytesOfKeyValueData;
  if aStream.Seek(NewPosition,soBeginning)<>NewPosition then begin
   raise EVulkanTextureException.Create('Stream seek error');
  end;
 end;

 DataSize:=aStream.Size-aStream.Position;

 GetMem(Data,DataSize);
 try
  if aStream.Read(Data^,DataSize)<>DataSize then begin
   raise EVulkanTextureException.Create('Stream read error');
  end;
  CreateFromMemory(aDevice,
                   aGraphicsQueue,
                   aGraphicsCommandBuffer,
                   aGraphicsFence,
                   aTransferQueue,
                   aTransferCommandBuffer,
                   aTransferFence,
                   VulkanGetFormatFromOpenGLInternalFormat(KTXHeader.GLInternalFormat),
                   VK_SAMPLE_COUNT_1_BIT,
                   Max(1,KTXHeader.PixelWidth),
                   Max(1,KTXHeader.PixelHeight),
                   Max(1,KTXHeader.PixelDepth),
                   NumberOfArrayElements,
                   NumberOfFaces,
                   NumberOfMipMapLevels,
                   [vtufSampled],
                   Data,
                   DataSize,
                   true,
                   MustSwap,
                   KTXHeader.GLTypeSize,
                   false);
 finally
  FreeMem(Data);
 end;

end;

constructor TVulkanTexture.CreateFromDDS(const aDevice:TVulkanDevice;
                                         const aGraphicsQueue:TVulkanQueue;
                                         const aGraphicsCommandBuffer:TVulkanCommandBuffer;
                                         const aGraphicsFence:TVulkanFence;
                                         const aTransferQueue:TVulkanQueue;
                                         const aTransferCommandBuffer:TVulkanCommandBuffer;
                                         const aTransferFence:TVulkanFence;
                                         const aStream:TStream);
const DDS_MAGIC=$20534444;
      DDSD_CAPS=$00000001;
      DDSD_HEIGHT=$00000002;
      DDSD_WIDTH=$00000004;
      DDSD_PITCH=$00000008;
      DDSD_PIXELFORMAT=$00001000;
      DDSD_MIPMAPCOUNT=$00020000;
      DDSD_LINEARSIZE=$00080000;
      DDSD_DEPTH=$00800000;
      DDPF_ALPHAPIXELS=$00000001;
      DDPF_ALPHA=$00000002;
      DDPF_FOURCC=$00000004;
      DDPF_INDEXED=$00000020;
      DDPF_RGB=$00000040;
      DDPF_YUV=$00000200;
      DDPF_LUMINANCE=$00020000;
      DDSCAPS_COMPLEX=$00000008;
      DDSCAPS_TEXTURE=$00001000;
      DDSCAPS_MIPMAP=$00400000;
      DDSCAPS2_CUBEMAP=$00000200;
      DDSCAPS2_CUBEMAP_POSITIVEX=$00000400;
      DDSCAPS2_CUBEMAP_NEGATIVEX=$00000800;
      DDSCAPS2_CUBEMAP_POSITIVEY=$00001000;
      DDSCAPS2_CUBEMAP_NEGATIVEY=$00002000;
      DDSCAPS2_CUBEMAP_POSITIVEZ=$00004000;
      DDSCAPS2_CUBEMAP_NEGATIVEZ=$00008000;
      DDSCAPS2_VOLUME=$00200000;
      D3DFMT_DXT1=$31545844;
      D3DFMT_DXT2=$32545844;
      D3DFMT_DXT3=$33545844;
      D3DFMT_DXT4=$34545844;
      D3DFMT_DXT5=$35545844;
      D3DFMT_ATI1=$31495441;
      D3DFMT_ATI2=$32495441;
      D3DFMT_BC4U=$55344342;
      D3DFMT_BC4S=$53344342;
      D3DFMT_BC5U=$55354342;
      D3DFMT_BC5S=$53354342;
      D3DFMT_RXGB=$42475852;
      D3DFMT_DX10=$30315844;
      DXGI_FORMAT_UNKNOWN=0;
      DXGI_FORMAT_R32G32B32A32_TYPELESS=1;
      DXGI_FORMAT_R32G32B32A32_FLOAT=2;
      DXGI_FORMAT_R32G32B32A32_UINT=3;
      DXGI_FORMAT_R32G32B32A32_SINT=4;
      DXGI_FORMAT_R32G32B32_TYPELESS=5;
      DXGI_FORMAT_R32G32B32_FLOAT=6;
      DXGI_FORMAT_R32G32B32_UINT=7;
      DXGI_FORMAT_R32G32B32_SINT=8;
      DXGI_FORMAT_R16G16B16A16_TYPELESS=9;
      DXGI_FORMAT_R16G16B16A16_FLOAT=10;
      DXGI_FORMAT_R16G16B16A16_UNORM=11;
      DXGI_FORMAT_R16G16B16A16_UINT=12;
      DXGI_FORMAT_R16G16B16A16_SNORM=13;
      DXGI_FORMAT_R16G16B16A16_SINT=14;
      DXGI_FORMAT_R32G32_TYPELESS=15;
      DXGI_FORMAT_R32G32_FLOAT=16;
      DXGI_FORMAT_R32G32_UINT=17;
      DXGI_FORMAT_R32G32_SINT=18;
      DXGI_FORMAT_R32G8X24_TYPELESS=19;
      DXGI_FORMAT_D32_FLOAT_S8X24_UINT=20;
      DXGI_FORMAT_R32_FLOAT_X8X24_TYPELESS=21;
      DXGI_FORMAT_X32_TYPELESS_G8X24_UINT=22;
      DXGI_FORMAT_R10G10B10A2_TYPELESS=23;
      DXGI_FORMAT_R10G10B10A2_UNORM=24;
      DXGI_FORMAT_R10G10B10A2_UINT=25;
      DXGI_FORMAT_R11G11B10_FLOAT=26;
      DXGI_FORMAT_R8G8B8A8_TYPELESS=27;
      DXGI_FORMAT_R8G8B8A8_UNORM=28;
      DXGI_FORMAT_R8G8B8A8_UNORM_SRGB=29;
      DXGI_FORMAT_R8G8B8A8_UINT=30;
      DXGI_FORMAT_R8G8B8A8_SNORM=31;
      DXGI_FORMAT_R8G8B8A8_SINT=32;
      DXGI_FORMAT_R16G16_TYPELESS=33;
      DXGI_FORMAT_R16G16_FLOAT=34;
      DXGI_FORMAT_R16G16_UNORM=35;
      DXGI_FORMAT_R16G16_UINT=36;
      DXGI_FORMAT_R16G16_SNORM=37;
      DXGI_FORMAT_R16G16_SINT=38;
      DXGI_FORMAT_R32_TYPELESS=39;
      DXGI_FORMAT_D32_FLOAT=40;
      DXGI_FORMAT_R32_FLOAT=41;
      DXGI_FORMAT_R32_UINT=42;
      DXGI_FORMAT_R32_SINT=43;
      DXGI_FORMAT_R24G8_TYPELESS=44;
      DXGI_FORMAT_D24_UNORM_S8_UINT=45;
      DXGI_FORMAT_R24_UNORM_X8_TYPELESS=46;
      DXGI_FORMAT_X24_TYPELESS_G8_UINT=47;
      DXGI_FORMAT_R8G8_TYPELESS=48;
      DXGI_FORMAT_R8G8_UNORM=49;
      DXGI_FORMAT_R8G8_UINT=50;
      DXGI_FORMAT_R8G8_SNORM=51;
      DXGI_FORMAT_R8G8_SINT=52;
      DXGI_FORMAT_R16_TYPELESS=53;
      DXGI_FORMAT_R16_FLOAT=54;
      DXGI_FORMAT_D16_UNORM=55;
      DXGI_FORMAT_R16_UNORM=56;
      DXGI_FORMAT_R16_UINT=57;
      DXGI_FORMAT_R16_SNORM=58;
      DXGI_FORMAT_R16_SINT=59;
      DXGI_FORMAT_R8_TYPELESS=60;
      DXGI_FORMAT_R8_UNORM=61;
      DXGI_FORMAT_R8_UINT=62;
      DXGI_FORMAT_R8_SNORM=63;
      DXGI_FORMAT_R8_SINT=64;
      DXGI_FORMAT_A8_UNORM=65;
      DXGI_FORMAT_R1_UNORM=66;
      DXGI_FORMAT_R9G9B9E5_SHAREDEXP=67;
      DXGI_FORMAT_R8G8_B8G8_UNORM=68;
      DXGI_FORMAT_G8R8_G8B8_UNORM=69;
      DXGI_FORMAT_BC1_TYPELESS=70;
      DXGI_FORMAT_BC1_UNORM=71;
      DXGI_FORMAT_BC1_UNORM_SRGB=72;
      DXGI_FORMAT_BC2_TYPELESS=73;
      DXGI_FORMAT_BC2_UNORM=74;
      DXGI_FORMAT_BC2_UNORM_SRGB=75;
      DXGI_FORMAT_BC3_TYPELESS=76;
      DXGI_FORMAT_BC3_UNORM=77;
      DXGI_FORMAT_BC3_UNORM_SRGB=78;
      DXGI_FORMAT_BC4_TYPELESS=79;
      DXGI_FORMAT_BC4_UNORM=80;
      DXGI_FORMAT_BC4_SNORM=81;
      DXGI_FORMAT_BC5_TYPELESS=82;
      DXGI_FORMAT_BC5_UNORM=83;
      DXGI_FORMAT_BC5_SNORM=84;
      DXGI_FORMAT_B5G6R5_UNORM=85;
      DXGI_FORMAT_B5G5R5A1_UNORM=86;
      DXGI_FORMAT_B8G8R8A8_UNORM=87;
      DXGI_FORMAT_B8G8R8X8_UNORM=88;
      DXGI_FORMAT_R10G10B10_XR_BIAS_A2_UNORM=89;
      DXGI_FORMAT_B8G8R8A8_TYPELESS=90;
      DXGI_FORMAT_B8G8R8A8_UNORM_SRGB=91;
      DXGI_FORMAT_B8G8R8X8_TYPELESS=92;
      DXGI_FORMAT_B8G8R8X8_UNORM_SRGB=93;
      DXGI_FORMAT_BC6H_TYPELESS=94;
      DXGI_FORMAT_BC6H_UF16=95;
      DXGI_FORMAT_BC6H_SF16=96;
      DXGI_FORMAT_BC7_TYPELESS=97;
      DXGI_FORMAT_BC7_UNORM=98;
      DXGI_FORMAT_BC7_UNORM_SRGB=99;
      DXGI_FORMAT_AYUV=100;
      DXGI_FORMAT_Y410=101;
      DXGI_FORMAT_Y416=102;
      DXGI_FORMAT_NV12=103;
      DXGI_FORMAT_P010=104;
      DXGI_FORMAT_P016=105;
      DXGI_FORMAT_420_OPAQUE=106;
      DXGI_FORMAT_YUY2=107;
      DXGI_FORMAT_Y210=108;
      DXGI_FORMAT_Y216=109;
      DXGI_FORMAT_NV11=110;
      DXGI_FORMAT_AI44=111;
      DXGI_FORMAT_IA44=112;
      DXGI_FORMAT_P8=113;
      DXGI_FORMAT_A8P8=114;
      DXGI_FORMAT_B4G4R4A4_UNORM=115;
type PDDSPixelFormat=^TDDSPixelFormat;
     TDDSPixelFormat=packed record
      dwSize:TVkUInt32;
      dwFlags:TVkUInt32;
      dwFourCC:TVkUInt32;
      dwRGBBitCount:TVkUInt32;
      dwRBitMask:TVkUInt32;
      dwGBitMask:TVkUInt32;
      dwBBitMask:TVkUInt32;
      dwABitMask:TVkUInt32;
     end;
     PDDSCaps=^TDDSCaps;
     TDDSCaps=packed record
      dwCaps1:TVkUInt32;
      dwCaps2:TVkUInt32;
      dwDDSX:TVkUInt32;
      dwReserved:TVkUInt32;
     end;
     PDDSHeader=^TDDSHeader;
     TDDSHeader=packed record
      dwMagic:TVkUInt32;
      dwSize:TVkUInt32;
      dwFlags:TVkUInt32;
      dwHeight:TVkUInt32;
      dwWidth:TVkUInt32;
      dwPitchOrLinearSize:TVkUInt32;
      dwDepth:TVkUInt32;
      dwMipMapCount:TVkUInt32;
      dwReserved:array[0..10] of TVkUInt32;
      PixelFormat:TDDSPixelFormat;
      Caps:TDDSCaps;
      dwReserved2:TVkUInt32;
     end;
     PDDSHeaderDX10=^TDDSHeaderDX10;
     TDDSHeaderDX10=packed record
      dxgiFormat:TVkUInt32;
      ResourceDimension:TVkUInt32;
      MiscFlag:TVkUInt32;
      ArraySize:TVkUInt32;
      Reserved:TVkUInt32;
     end;
var Header:TDDSHeader;
    HeaderDX10:TDDSHeaderDX10;
    ImageWidth,ImageHeight,ImageDepth,ImageMipMaps,ImageFaces,ImageArrayElements:TVkUInt32;
    ImageFormat:TVkFormat;
    IsVolume:boolean;
    DataSize:TVkSizeInt;
    Data:TVkPointer;
begin
 if aStream.Read(Header,SizeOf(TDDSHeader))<>SizeOf(TDDSHeader) then begin
  raise EVulkanTextureException.Create('Invalid DDS stream');
 end;
 if ((Header.dwMagic<>DDS_MAGIC) or (Header.dwSize<>124) or ((Header.dwFlags and DDSD_PIXELFORMAT)=0) or ((Header.dwFlags and DDSD_CAPS)=0)) then begin
  raise EVulkanTextureException.Create('Invalid DDS stream');
 end;
 if (Header.dwFlags and DDSD_WIDTH)<>0 then begin
  ImageWidth:=Header.dwWidth;
 end else begin
  ImageWidth:=1;
 end;
 if (Header.dwFlags and DDSD_HEIGHT)<>0 then begin
  ImageHeight:=Header.dwHeight;
 end else begin
  ImageHeight:=1;
 end;
 if (Header.dwFlags and DDSD_DEPTH)<>0 then begin
  ImageDepth:=Header.dwDepth;
 end else begin
  ImageDepth:=1;
 end;
 if (Header.dwFlags and DDSD_MIPMAPCOUNT)<>0 then begin
  ImageMipMaps:=Max(1,Header.dwMipMapCount);
 end else begin
  ImageMipMaps:=1;
 end;
 ImageFaces:=1;
 ImageArrayElements:=1;
 IsVolume:=false;
 if (Header.Caps.dwCaps1 and DDSCAPS_COMPLEX)<>0 then begin
  if (Header.Caps.dwCaps2 and DDSCAPS2_CUBEMAP)<>0 then begin
   if (Header.Caps.dwCaps2 and (DDSCAPS2_CUBEMAP_POSITIVEX or
                                DDSCAPS2_CUBEMAP_NEGATIVEX or
                                DDSCAPS2_CUBEMAP_POSITIVEY or
                                DDSCAPS2_CUBEMAP_NEGATIVEY or
                                DDSCAPS2_CUBEMAP_POSITIVEZ or
                                DDSCAPS2_CUBEMAP_NEGATIVEZ))=(DDSCAPS2_CUBEMAP_POSITIVEX or
                                                              DDSCAPS2_CUBEMAP_NEGATIVEX or
                                                              DDSCAPS2_CUBEMAP_POSITIVEY or
                                                              DDSCAPS2_CUBEMAP_NEGATIVEY or
                                                              DDSCAPS2_CUBEMAP_POSITIVEZ or
                                                              DDSCAPS2_CUBEMAP_NEGATIVEZ) then begin
    ImageFaces:=6;
   end else begin
    raise EVulkanTextureException.Create('Invalid DDS stream');
   end;
  end else if (Header.Caps.dwCaps2 and DDSCAPS2_VOLUME)<>0 then begin
   IsVolume:=true;
  end;
 end;
 ImageFormat:=VK_FORMAT_UNDEFINED;
 if (Header.dwFlags and DDSD_PIXELFORMAT)<>0 then begin
  if (Header.PixelFormat.dwFlags and DDPF_FOURCC)<>0 then begin
   case Header.PixelFormat.dwFourCC of
    D3DFMT_DXT1:begin
     ImageFormat:=VK_FORMAT_BC1_RGBA_UNORM_BLOCK;
    end;
    D3DFMT_DXT2,D3DFMT_DXT3:begin
     ImageFormat:=VK_FORMAT_BC2_UNORM_BLOCK;
    end;
    D3DFMT_DXT4,D3DFMT_DXT5:begin
     ImageFormat:=VK_FORMAT_BC3_UNORM_BLOCK;
    end;
    D3DFMT_ATI1,D3DFMT_BC4U:begin
     ImageFormat:=VK_FORMAT_BC4_UNORM_BLOCK;
    end;
    D3DFMT_BC4S:begin
     ImageFormat:=VK_FORMAT_BC4_SNORM_BLOCK;
    end;
    D3DFMT_ATI2,D3DFMT_BC5U:begin
     ImageFormat:=VK_FORMAT_BC5_UNORM_BLOCK;
    end;
    D3DFMT_BC5S:begin
     ImageFormat:=VK_FORMAT_BC5_SNORM_BLOCK;
    end;
    D3DFMT_DX10:begin
     if aStream.Read(HeaderDX10,SizeOf(TDDSHeaderDX10))<>SizeOf(TDDSHeaderDX10) then begin
      raise EVulkanTextureException.Create('Invalid DDS stream');
     end;
     case HeaderDX10.dxgiFormat of
      DXGI_FORMAT_UNKNOWN:begin
       ImageFormat:=VK_FORMAT_UNDEFINED;
      end;
      DXGI_FORMAT_R32G32B32A32_TYPELESS:begin
       ImageFormat:=VK_FORMAT_R32G32B32A32_UINT;
      end;
      DXGI_FORMAT_R32G32B32A32_FLOAT:begin
       ImageFormat:=VK_FORMAT_R32G32B32A32_SFLOAT;
      end;
      DXGI_FORMAT_R32G32B32A32_UINT:begin
       ImageFormat:=VK_FORMAT_R32G32B32A32_UINT;
      end;
      DXGI_FORMAT_R32G32B32A32_SINT:begin
       ImageFormat:=VK_FORMAT_R32G32B32A32_SINT;
      end;
      DXGI_FORMAT_R32G32B32_TYPELESS:begin
       ImageFormat:=VK_FORMAT_R32G32B32_UINT;
      end;
      DXGI_FORMAT_R32G32B32_FLOAT:begin
       ImageFormat:=VK_FORMAT_R32G32B32_SFLOAT;
      end;
      DXGI_FORMAT_R32G32B32_UINT:begin
       ImageFormat:=VK_FORMAT_R32G32B32_UINT;
      end;
      DXGI_FORMAT_R32G32B32_SINT:begin
       ImageFormat:=VK_FORMAT_R32G32B32_SINT;
      end;
      DXGI_FORMAT_R16G16B16A16_TYPELESS:begin
       ImageFormat:=VK_FORMAT_R16G16B16A16_UINT;
      end;
      DXGI_FORMAT_R16G16B16A16_FLOAT:begin
       ImageFormat:=VK_FORMAT_R16G16B16A16_SFLOAT;
      end;
      DXGI_FORMAT_R16G16B16A16_UNORM:begin
       ImageFormat:=VK_FORMAT_R16G16B16A16_UNORM;
      end;
      DXGI_FORMAT_R16G16B16A16_UINT:begin
       ImageFormat:=VK_FORMAT_R16G16B16A16_UINT;
      end;
      DXGI_FORMAT_R16G16B16A16_SNORM:begin
       ImageFormat:=VK_FORMAT_R16G16B16A16_SNORM;
      end;
      DXGI_FORMAT_R16G16B16A16_SINT:begin
       ImageFormat:=VK_FORMAT_R16G16B16A16_SINT;
      end;
      DXGI_FORMAT_R32G32_TYPELESS:begin
       ImageFormat:=VK_FORMAT_R32G32_UINT;
      end;
      DXGI_FORMAT_R32G32_FLOAT:begin
       ImageFormat:=VK_FORMAT_R32G32_SFLOAT;
      end;
      DXGI_FORMAT_R32G32_UINT:begin
       ImageFormat:=VK_FORMAT_R32G32_UINT;
      end;
      DXGI_FORMAT_R32G32_SINT:begin
       ImageFormat:=VK_FORMAT_R32G32_SINT;
      end;
      DXGI_FORMAT_R32G8X24_TYPELESS:begin
       ImageFormat:=VK_FORMAT_UNDEFINED;
      end;
      DXGI_FORMAT_D32_FLOAT_S8X24_UINT:begin
       ImageFormat:=VK_FORMAT_D32_SFLOAT_S8_UINT;
      end;
      DXGI_FORMAT_R32_FLOAT_X8X24_TYPELESS:begin
       ImageFormat:=VK_FORMAT_D32_SFLOAT_S8_UINT;
      end;
      DXGI_FORMAT_X32_TYPELESS_G8X24_UINT:begin
       ImageFormat:=VK_FORMAT_UNDEFINED;
      end;
      DXGI_FORMAT_R10G10B10A2_TYPELESS:begin
       ImageFormat:=VK_FORMAT_A2R10G10B10_UINT_PACK32;
      end;
      DXGI_FORMAT_R10G10B10A2_UNORM:begin
       ImageFormat:=VK_FORMAT_A2R10G10B10_UNORM_PACK32;
      end;
      DXGI_FORMAT_R10G10B10A2_UINT:begin
       ImageFormat:=VK_FORMAT_A2R10G10B10_UINT_PACK32;
      end;
      DXGI_FORMAT_R11G11B10_FLOAT:begin
       ImageFormat:=VK_FORMAT_B10G11R11_UFLOAT_PACK32;
      end;
      DXGI_FORMAT_R8G8B8A8_TYPELESS:begin
       ImageFormat:=VK_FORMAT_R8G8B8A8_UINT;
      end;
      DXGI_FORMAT_R8G8B8A8_UNORM:begin
       ImageFormat:=VK_FORMAT_R8G8B8A8_UNORM;
      end;
      DXGI_FORMAT_R8G8B8A8_UNORM_SRGB:begin
       ImageFormat:=VK_FORMAT_R8G8B8A8_SRGB;
      end;
      DXGI_FORMAT_R8G8B8A8_UINT:begin
       ImageFormat:=VK_FORMAT_R8G8B8A8_UINT;
      end;
      DXGI_FORMAT_R8G8B8A8_SNORM:begin
       ImageFormat:=VK_FORMAT_R8G8B8A8_SNORM;
      end;
      DXGI_FORMAT_R8G8B8A8_SINT:begin
       ImageFormat:=VK_FORMAT_R8G8B8A8_SINT;
      end;
      DXGI_FORMAT_R16G16_TYPELESS:begin
       ImageFormat:=VK_FORMAT_R16G16_UINT;
      end;
      DXGI_FORMAT_R16G16_FLOAT:begin
       ImageFormat:=VK_FORMAT_R16G16_SFLOAT;
      end;
      DXGI_FORMAT_R16G16_UNORM:begin
       ImageFormat:=VK_FORMAT_R16G16_UNORM;
      end;
      DXGI_FORMAT_R16G16_UINT:begin
       ImageFormat:=VK_FORMAT_R16G16_UINT;
      end;
      DXGI_FORMAT_R16G16_SNORM:begin
       ImageFormat:=VK_FORMAT_R16G16_SNORM;
      end;
      DXGI_FORMAT_R16G16_SINT:begin
       ImageFormat:=VK_FORMAT_R16G16_SINT;
      end;
      DXGI_FORMAT_R32_TYPELESS:begin
       ImageFormat:=VK_FORMAT_R32_UINT;
      end;
      DXGI_FORMAT_D32_FLOAT:begin
       ImageFormat:=VK_FORMAT_D32_SFLOAT;
      end;
      DXGI_FORMAT_R32_FLOAT:begin
       ImageFormat:=VK_FORMAT_R32_SFLOAT;
      end;
      DXGI_FORMAT_R32_UINT:begin
       ImageFormat:=VK_FORMAT_R32_UINT;
      end;
      DXGI_FORMAT_R32_SINT:begin
       ImageFormat:=VK_FORMAT_R32_SINT;
      end;
      DXGI_FORMAT_R24G8_TYPELESS:begin
       ImageFormat:=VK_FORMAT_UNDEFINED;
      end;
      DXGI_FORMAT_D24_UNORM_S8_UINT:begin
       ImageFormat:=VK_FORMAT_D24_UNORM_S8_UINT;
      end;
      DXGI_FORMAT_R24_UNORM_X8_TYPELESS:begin
       ImageFormat:=VK_FORMAT_UNDEFINED;
      end;
      DXGI_FORMAT_X24_TYPELESS_G8_UINT:begin
       ImageFormat:=VK_FORMAT_UNDEFINED;
      end;
      DXGI_FORMAT_R8G8_TYPELESS:begin
       ImageFormat:=VK_FORMAT_R8G8_UINT;
      end;
      DXGI_FORMAT_R8G8_UNORM:begin
       ImageFormat:=VK_FORMAT_R8G8_UNORM;
      end;
      DXGI_FORMAT_R8G8_UINT:begin
       ImageFormat:=VK_FORMAT_R8G8_UINT;
      end;
      DXGI_FORMAT_R8G8_SNORM:begin
       ImageFormat:=VK_FORMAT_R8G8_SNORM;
      end;
      DXGI_FORMAT_R8G8_SINT:begin
       ImageFormat:=VK_FORMAT_R8G8_SINT;
      end;
      DXGI_FORMAT_R16_TYPELESS:begin
       ImageFormat:=VK_FORMAT_R16_UINT;
      end;
      DXGI_FORMAT_R16_FLOAT:begin
       ImageFormat:=VK_FORMAT_R16_SFLOAT;
      end;
      DXGI_FORMAT_D16_UNORM:begin
       ImageFormat:=VK_FORMAT_D16_UNORM;
      end;
      DXGI_FORMAT_R16_UNORM:begin
       ImageFormat:=VK_FORMAT_R16_UNORM;
      end;
      DXGI_FORMAT_R16_UINT:begin
       ImageFormat:=VK_FORMAT_R16_UINT;
      end;
      DXGI_FORMAT_R16_SNORM:begin
       ImageFormat:=VK_FORMAT_R16_SNORM;
      end;
      DXGI_FORMAT_R16_SINT:begin
       ImageFormat:=VK_FORMAT_R16_SINT;
      end;
      DXGI_FORMAT_R8_TYPELESS:begin
       ImageFormat:=VK_FORMAT_R8_UINT;
      end;
      DXGI_FORMAT_R8_UNORM:begin
       ImageFormat:=VK_FORMAT_R8_UNORM;
      end;
      DXGI_FORMAT_R8_UINT:begin
       ImageFormat:=VK_FORMAT_R8_UINT;
      end;
      DXGI_FORMAT_R8_SNORM:begin
       ImageFormat:=VK_FORMAT_R8_SNORM;
      end;
      DXGI_FORMAT_R8_SINT:begin
       ImageFormat:=VK_FORMAT_R8_SINT;
      end;
      DXGI_FORMAT_A8_UNORM:begin
       ImageFormat:=VK_FORMAT_R8_UNORM;
      end;
      DXGI_FORMAT_R1_UNORM:begin
       ImageFormat:=VK_FORMAT_UNDEFINED;
      end;
      DXGI_FORMAT_R9G9B9E5_SHAREDEXP:begin
       ImageFormat:=VK_FORMAT_E5B9G9R9_UFLOAT_PACK32;
      end;
      DXGI_FORMAT_R8G8_B8G8_UNORM:begin
       ImageFormat:=VK_FORMAT_UNDEFINED;
      end;
      DXGI_FORMAT_G8R8_G8B8_UNORM:begin
       ImageFormat:=VK_FORMAT_UNDEFINED;
      end;
      DXGI_FORMAT_BC1_TYPELESS:begin
       ImageFormat:=VK_FORMAT_BC1_RGBA_UNORM_BLOCK;
      end;
      DXGI_FORMAT_BC1_UNORM:begin
       ImageFormat:=VK_FORMAT_BC1_RGBA_UNORM_BLOCK;
      end;
      DXGI_FORMAT_BC1_UNORM_SRGB:begin
       ImageFormat:=VK_FORMAT_BC1_RGBA_SRGB_BLOCK;
      end;
      DXGI_FORMAT_BC2_TYPELESS:begin
       ImageFormat:=VK_FORMAT_BC1_RGBA_UNORM_BLOCK;
      end;
      DXGI_FORMAT_BC2_UNORM:begin
       ImageFormat:=VK_FORMAT_BC2_UNORM_BLOCK;
      end;
      DXGI_FORMAT_BC2_UNORM_SRGB:begin
       ImageFormat:=VK_FORMAT_BC2_SRGB_BLOCK;
      end;
      DXGI_FORMAT_BC3_TYPELESS:begin
       ImageFormat:=VK_FORMAT_BC2_UNORM_BLOCK;
      end;
      DXGI_FORMAT_BC3_UNORM:begin
       ImageFormat:=VK_FORMAT_BC3_UNORM_BLOCK;
      end;
      DXGI_FORMAT_BC3_UNORM_SRGB:begin
       ImageFormat:=VK_FORMAT_BC3_SRGB_BLOCK;
      end;
      DXGI_FORMAT_BC4_TYPELESS:begin
       ImageFormat:=VK_FORMAT_BC4_UNORM_BLOCK;
      end;
      DXGI_FORMAT_BC4_UNORM:begin
       ImageFormat:=VK_FORMAT_BC4_UNORM_BLOCK;
      end;
      DXGI_FORMAT_BC4_SNORM:begin
       ImageFormat:=VK_FORMAT_BC4_SNORM_BLOCK;
      end;
      DXGI_FORMAT_BC5_TYPELESS:begin
       ImageFormat:=VK_FORMAT_BC5_UNORM_BLOCK;
      end;
      DXGI_FORMAT_BC5_UNORM:begin
       ImageFormat:=VK_FORMAT_BC5_UNORM_BLOCK;
      end;
      DXGI_FORMAT_BC5_SNORM:begin
       ImageFormat:=VK_FORMAT_BC5_SNORM_BLOCK;
      end;
      DXGI_FORMAT_B5G6R5_UNORM:begin
       ImageFormat:=VK_FORMAT_B5G6R5_UNORM_PACK16;
      end;
      DXGI_FORMAT_B5G5R5A1_UNORM:begin
       ImageFormat:=VK_FORMAT_B5G5R5A1_UNORM_PACK16;
      end;
      DXGI_FORMAT_B8G8R8A8_UNORM:begin
       ImageFormat:=VK_FORMAT_B8G8R8A8_UNORM;
      end;
      DXGI_FORMAT_B8G8R8X8_UNORM:begin
       ImageFormat:=VK_FORMAT_B8G8R8_UNORM;
      end;
      DXGI_FORMAT_R10G10B10_XR_BIAS_A2_UNORM:begin
       ImageFormat:=VK_FORMAT_UNDEFINED;
      end;
      DXGI_FORMAT_B8G8R8A8_TYPELESS:begin
       ImageFormat:=VK_FORMAT_B8G8R8A8_UINT;
      end;
      DXGI_FORMAT_B8G8R8A8_UNORM_SRGB:begin
       ImageFormat:=VK_FORMAT_B8G8R8A8_SRGB;
      end;
      DXGI_FORMAT_B8G8R8X8_TYPELESS:begin
       ImageFormat:=VK_FORMAT_B8G8R8_UINT;
      end;
      DXGI_FORMAT_B8G8R8X8_UNORM_SRGB:begin
       ImageFormat:=VK_FORMAT_B8G8R8_SRGB;
      end;
      DXGI_FORMAT_BC6H_TYPELESS:begin
       ImageFormat:=VK_FORMAT_BC6H_UFLOAT_BLOCK;
      end;
      DXGI_FORMAT_BC6H_UF16:begin
       ImageFormat:=VK_FORMAT_BC6H_UFLOAT_BLOCK;
      end;
      DXGI_FORMAT_BC6H_SF16:begin
       ImageFormat:=VK_FORMAT_BC6H_SFLOAT_BLOCK;
      end;
      DXGI_FORMAT_BC7_TYPELESS:begin
       ImageFormat:=VK_FORMAT_BC7_UNORM_BLOCK;
      end;
      DXGI_FORMAT_BC7_UNORM:begin
       ImageFormat:=VK_FORMAT_BC7_UNORM_BLOCK;
      end;
      DXGI_FORMAT_BC7_UNORM_SRGB:begin
       ImageFormat:=VK_FORMAT_BC7_SRGB_BLOCK;
      end;
      DXGI_FORMAT_AYUV:begin
       ImageFormat:=VK_FORMAT_UNDEFINED;
      end;
      DXGI_FORMAT_Y410:begin
       ImageFormat:=VK_FORMAT_UNDEFINED;
      end;
      DXGI_FORMAT_Y416:begin
       ImageFormat:=VK_FORMAT_UNDEFINED;
      end;
      DXGI_FORMAT_NV12:begin
       ImageFormat:=VK_FORMAT_UNDEFINED;
      end;
      DXGI_FORMAT_P010:begin
       ImageFormat:=VK_FORMAT_UNDEFINED;
      end;
      DXGI_FORMAT_P016:begin
       ImageFormat:=VK_FORMAT_UNDEFINED;
      end;
      DXGI_FORMAT_420_OPAQUE:begin
       ImageFormat:=VK_FORMAT_UNDEFINED;
      end;
      DXGI_FORMAT_YUY2:begin
       ImageFormat:=VK_FORMAT_UNDEFINED;
      end;
      DXGI_FORMAT_Y210:begin
       ImageFormat:=VK_FORMAT_UNDEFINED;
      end;
      DXGI_FORMAT_Y216:begin
       ImageFormat:=VK_FORMAT_UNDEFINED;
      end;
      DXGI_FORMAT_NV11:begin
       ImageFormat:=VK_FORMAT_UNDEFINED;
      end;
      DXGI_FORMAT_AI44:begin
       ImageFormat:=VK_FORMAT_UNDEFINED;
      end;
      DXGI_FORMAT_IA44:begin
       ImageFormat:=VK_FORMAT_UNDEFINED;
      end;                                                
      DXGI_FORMAT_P8:begin
       ImageFormat:=VK_FORMAT_UNDEFINED;
      end;
      DXGI_FORMAT_A8P8:begin
       ImageFormat:=VK_FORMAT_UNDEFINED;
      end;
      DXGI_FORMAT_B4G4R4A4_UNORM:begin
       ImageFormat:=VK_FORMAT_B4G4R4A4_UNORM_PACK16;
      end;
      else begin
       ImageFormat:=VK_FORMAT_UNDEFINED;
      end;
     end;
     ImageArrayElements:=HeaderDX10.ArraySize;
    end;
   end;
  end else begin
   case Header.PixelFormat.dwRGBBitCount of
    8:begin
     if (Header.PixelFormat.dwFlags and DDPF_INDEXED)<>0 then begin
      ImageFormat:=VK_FORMAT_UNDEFINED;
     end else begin
      if ((Header.PixelFormat.dwFlags and DDPF_LUMINANCE)<>0) or
                  (Header.PixelFormat.dwRBitMask=$000000ff) and
                  (Header.PixelFormat.dwGBitMask=$00000000) and
                  (Header.PixelFormat.dwBBitMask=$00000000) and
                  (Header.PixelFormat.dwABitMask=$00000000) then begin
       ImageFormat:=VK_FORMAT_R8_UNORM;
      end else if ((Header.PixelFormat.dwFlags and DDPF_ALPHA)<>0) or
                  (Header.PixelFormat.dwRBitMask=$000000ff) and
                  (Header.PixelFormat.dwGBitMask=$00000000) and
                  (Header.PixelFormat.dwBBitMask=$00000000) and
                  (Header.PixelFormat.dwABitMask=$00000000) then begin
       ImageFormat:=VK_FORMAT_R8_UNORM;
      end else begin
       ImageFormat:=VK_FORMAT_UNDEFINED;
      end;
     end;
    end;
    16:begin
     if ((Header.PixelFormat.dwFlags and DDPF_RGB)<>0) and
        (Header.PixelFormat.dwRBitMask=$0000f800) and
        (Header.PixelFormat.dwGBitMask=$000007e0) and
        (Header.PixelFormat.dwBBitMask=$0000001f) and
        (Header.PixelFormat.dwABitMask=$00000000) then begin
      ImageFormat:=VK_FORMAT_B5G6R5_UNORM_PACK16;
     end else if ((Header.PixelFormat.dwFlags and DDPF_RGB)<>0) and
                 (Header.PixelFormat.dwRBitMask=$00007c00) and
                 (Header.PixelFormat.dwGBitMask=$000003e0) and
                 (Header.PixelFormat.dwBBitMask=$0000001f) and
                 (Header.PixelFormat.dwABitMask=$00008000) then begin
      ImageFormat:=VK_FORMAT_B5G5R5A1_UNORM_PACK16;
     end else if ((Header.PixelFormat.dwFlags and DDPF_RGB)<>0) and
                 (Header.PixelFormat.dwRBitMask=$00000f00) and
                 (Header.PixelFormat.dwGBitMask=$000000f0) and
                 (Header.PixelFormat.dwBBitMask=$0000000f) and
                 (Header.PixelFormat.dwABitMask=$0000f000) then begin
      ImageFormat:=VK_FORMAT_B4G4R4A4_UNORM_PACK16;
     end else if (Header.PixelFormat.dwRBitMask=$000000ff) and
                 (Header.PixelFormat.dwGBitMask=$00000000) and
                 (Header.PixelFormat.dwBBitMask=$00000000) and
                 (Header.PixelFormat.dwABitMask=$0000ff00) then begin
       ImageFormat:=VK_FORMAT_UNDEFINED;
     end else if (Header.PixelFormat.dwRBitMask=$0000ffff) or
                 (Header.PixelFormat.dwGBitMask=$0000ffff) or
                 (Header.PixelFormat.dwBBitMask=$0000ffff) or
                 (Header.PixelFormat.dwABitMask=$0000ffff) then begin
      ImageFormat:=VK_FORMAT_R16_UNORM;
      end else if ((Header.PixelFormat.dwFlags and DDPF_LUMINANCE)<>0) or
                  (Header.PixelFormat.dwRBitMask=$0000ffff) and
                  (Header.PixelFormat.dwGBitMask=$00000000) and
                  (Header.PixelFormat.dwBBitMask=$00000000) and
                  (Header.PixelFormat.dwABitMask=$00000000) then begin
       ImageFormat:=VK_FORMAT_R16_UNORM;
      end else if ((Header.PixelFormat.dwFlags and DDPF_LUMINANCE)<>0) or
                  (Header.PixelFormat.dwRBitMask=$000000ff) and
                  (Header.PixelFormat.dwGBitMask=$00000000) and
                  (Header.PixelFormat.dwBBitMask=$00000000) and
                  (Header.PixelFormat.dwABitMask=$0000ff00) then begin
       ImageFormat:=VK_FORMAT_R8G8_UNORM;
     end;
    end;
    24:begin
     if ((Header.PixelFormat.dwFlags and DDPF_RGB)<>0) and
        (Header.PixelFormat.dwRBitMask=$00ff0000) and
        (Header.PixelFormat.dwGBitMask=$0000ff00) and
        (Header.PixelFormat.dwBBitMask=$000000ff) then begin
      ImageFormat:=VK_FORMAT_B8G8R8_UNORM;
     end else if ((Header.PixelFormat.dwFlags and DDPF_RGB)<>0) and
                 (Header.PixelFormat.dwRBitMask=$000000ff) and
                 (Header.PixelFormat.dwGBitMask=$0000ff00) and
                 (Header.PixelFormat.dwBBitMask=$00ff0000) then begin
      ImageFormat:=VK_FORMAT_R8G8B8_UNORM;
     end;
    end;
    32:begin
     if ((Header.PixelFormat.dwFlags and DDPF_RGB)<>0) and
        (Header.PixelFormat.dwRBitMask=$00ff0000) and
        (Header.PixelFormat.dwGBitMask=$0000ff00) and
        (Header.PixelFormat.dwBBitMask=$000000ff) and
        (Header.PixelFormat.dwABitMask=$ff000000) then begin
      ImageFormat:=VK_FORMAT_B8G8R8A8_UNORM;
     end else if ((Header.PixelFormat.dwFlags and DDPF_RGB)<>0) and
                 (Header.PixelFormat.dwRBitMask=$000000ff) and
                 (Header.PixelFormat.dwGBitMask=$0000ff00) and
                 (Header.PixelFormat.dwBBitMask=$00ff0000) and
                 (Header.PixelFormat.dwABitMask=$ff000000) then begin
      ImageFormat:=VK_FORMAT_R8G8B8A8_UNORM;
     end else if ((Header.PixelFormat.dwFlags and DDPF_RGB)<>0) and
                 (Header.PixelFormat.dwRBitMask=$000003ff) and
                 (Header.PixelFormat.dwGBitMask=$000ffc00) and
                 (Header.PixelFormat.dwBBitMask=$3ff00000) and
                 (Header.PixelFormat.dwABitMask=$c0000000) then begin
      ImageFormat:=VK_FORMAT_A2R10G10B10_UNORM_PACK32;
     end else if ((Header.PixelFormat.dwFlags and DDPF_RGB)<>0) and
                 (Header.PixelFormat.dwRBitMask=$0000ffff) and
                 (Header.PixelFormat.dwGBitMask=$fff00000) and
                 (Header.PixelFormat.dwBBitMask=$00000000) and
                 (Header.PixelFormat.dwABitMask=$00000000) then begin
      ImageFormat:=VK_FORMAT_R16G16_UNORM;
     end else if ((Header.PixelFormat.dwFlags and DDPF_RGB)<>0) and
                 (Header.PixelFormat.dwRBitMask=$ffffffff) and
                 (Header.PixelFormat.dwGBitMask=$00000000) and
                 (Header.PixelFormat.dwBBitMask=$00000000) and
                 (Header.PixelFormat.dwABitMask=$00000000) then begin
      ImageFormat:=VK_FORMAT_R32_SFLOAT;
     end;
    end;
   end;
  end;
 end;
 if ImageFormat=VK_FORMAT_UNDEFINED then begin
  raise EVulkanTextureException.Create('Invalid DDS stream');
 end;
 if (ImageDepth>1) and not IsVolume then begin
  raise EVulkanTextureException.Create('Invalid DDS stream');
 end;
 DataSize:=aStream.Size-aStream.Position;
 GetMem(Data,DataSize);
 try
  if aStream.Read(Data^,DataSize)<>DataSize then begin
   raise EVulkanTextureException.Create('Stream read error');
  end;
  CreateFromMemory(aDevice,
                   aGraphicsQueue,
                   aGraphicsCommandBuffer,
                   aGraphicsFence,
                   aTransferQueue,
                   aTransferCommandBuffer,
                   aTransferFence,
                   ImageFormat,
                   VK_SAMPLE_COUNT_1_BIT,
                   Max(1,ImageWidth),
                   Max(1,ImageHeight),
                   Max(1,ImageDepth),
                   ImageArrayElements,
                   ImageFaces,
                   ImageMipMaps,
                   [vtufTransferDst,vtufSampled],
                   Data,
                   DataSize,
                   false,
                   false,
                   1,
                   true);
 finally
  FreeMem(Data);
 end;     
end;

constructor TVulkanTexture.CreateFromHDR(const aDevice:TVulkanDevice;
                                         const aGraphicsQueue:TVulkanQueue;
                                         const aGraphicsCommandBuffer:TVulkanCommandBuffer;
                                         const aGraphicsFence:TVulkanFence;
                                         const aTransferQueue:TVulkanQueue;
                                         const aTransferCommandBuffer:TVulkanCommandBuffer;
                                         const aTransferFence:TVulkanFence;
                                         const aStream:TStream;
                                         const aMipMaps:boolean);
const RGBE_DATA_RED=0;
      RGBE_DATA_GREEN=1;
      RGBE_DATA_BLUE=2;
      RGBE_DATA_SIZE=3;
 procedure rgbe2float(const r,g,b,e:TVkUInt8;out red,green,blue,alpha:TVkFloat);
 var f:TVkFloat;
 begin
  if e<>0 then begin
   f:=ldexp(1.0,e-(128+8));
 //f:=power(2.0,e-(128+8));
   red:=r*f;
   green:=g*f;
   blue:=b*f;
   alpha:=1.0;
  end else begin
   red:=0.0;
   green:=0.0;
   blue:=0.0;
   alpha:=0.0;
  end;
 end;
 function LoadHDRImage(var ImageData:TVkPointer;var ImageWidth,ImageHeight:TVkInt32):boolean;
 label NonRLE,DoFail;
 var i,j,k,CountPixels,y,x:TVkInt32;
     programtype,line:shortstring;
     gamma,exposure,r,g,b,a:TVkFloat;
     scanlinebuffer:array of array[0..3] of TVkUInt8;
     c:TVulkanRawByteChar;
     OK:longbool;
     buf:array[0..3] of TVulkanRawByteChar;
     rgbe:array[0..3] of TVkUInt8;
     Len,Val:TVkUInt8;
     p:PVkFloat;
 begin
  result:=false;
  scanlinebuffer:=nil;
  ImageData:=nil;
  if aStream.Size>16 then begin
   buf[0]:=#0;
   buf[1]:=#0;
   aStream.Read(buf,2*SizeOf(AnsiChar));
   if (buf[0]<>'#') or (buf[1]<>'?') then begin
    exit;
   end;
   programtype:='';
   gamma:=1.0;
   exposure:=1.0;
   begin
    i:=0;
    while aStream.Read(c,SizeOf(AnsiChar))=SizeOf(AnsiChar) do begin
     if c in [#1..#9,#11..#12,#14..#32] then begin
      break;
     end else if i<255 then begin
      inc(i);
      programtype[i]:=c;
     end;
    end;
    programtype[0]:=TVulkanRawByteChar(TVkUInt8(i));
    while aStream.Read(c,SizeOf(AnsiChar))=SizeOf(AnsiChar) do begin
     if c in [#0,#10,#13] then begin
      break;
     end;
    end;
   end;
   if length(programtype)>0 then begin
   end;
   OK:=false;
   while aStream.Position<aStream.Size do begin
    line:='';
    i:=0;
    while aStream.Read(c,SizeOf(AnsiChar))=SizeOf(AnsiChar) do begin
     if c in [#0,#10,#13] then begin
      break;
     end else if i<255 then begin
      inc(i);
      line[i]:=c;
     end;
    end;
    line[0]:=TVulkanRawByteChar(TVkUInt8(i));
    line:=ShortString(Trim(String(line)));
    if line='FORMAT=32-bit_rle_rgbe' then begin
     OK:=true;
     break;
    end else if Pos('GAMMA=',String(line))=1 then begin
     Delete(line,1,6);
     OK:=false;
     gamma:=0;
     System.Val(String(line),gamma,k);
     if k>0 then begin
      gamma:=1.0;
     end;
     OK:=false;
    end else if Pos('EXPOSURE=',String(line))=1 then begin
     Delete(line,1,9);
     System.Val(String(line),exposure,k);
     if k>0 then begin
      exposure:=1.0;
     end;
     OK:=false;
    end;
   end;
   if not OK then begin
    exit;
   end;
   OK:=false;
   while aStream.Position<aStream.Size do begin
    line:='';
    i:=0;
    while aStream.Read(c,SizeOf(AnsiChar))=SizeOf(AnsiChar) do begin
     if c in [#0,#10,#13] then begin
      break;
     end else if i<255 then begin
      inc(i);
      line[i]:=c;
     end;
    end;
    line[0]:=TVulkanRawByteChar(TVkUInt8(i));
    line:=ShortString(Trim(String(line)));
    if (pos('-Y',String(line))=1) and (pos('+X',String(line))>2) then begin
     Delete(line,1,2);
     line:=ShortString(Trim(String(line)));
     ImageWidth:=0;
     i:=0;
     while ((i+1)<=length(line)) and (line[i+1] in ['0'..'9']) do begin
      inc(i);
      ImageWidth:=(ImageWidth*10)+(TVkUInt8(TVulkanRawByteChar(line[i]))-TVkUInt8(TVulkanRawByteChar('0')));
     end;
     Delete(line,1,i);
     line:=ShortString(Trim(String(line)));
     if pos('-X',String(line))=1 then begin
      Delete(line,1,2);
      line:=ShortString(Trim(String(line)));
      ImageHeight:=0;
      i:=0;
      while ((i+1)<=length(line)) and (line[i+1] in ['0'..'9']) do begin
       inc(i);
       ImageHeight:=(ImageHeight*10)+(TVkUInt8(TVulkanRawByteChar(line[i]))-TVkUInt8(TVulkanRawByteChar('0')));
      end;
      OK:=true;
     end;
     break;
    end;
   end;
   if not OK then begin
    exit;
   end;
   begin
    CountPixels:=ImageWidth*ImageHeight;
    GetMem(ImageData,CountPixels*(SizeOf(TVkFloat)*4));
    p:=ImageData;
    if (ImageWidth<8) or (ImageWidth>$7fff) then begin
     NonRLE:
     while (CountPixels>0) and (aStream.Read(rgbe,SizeOf(TVkUInt8)*4)=(SizeOf(TVkUInt8)*4)) do begin
      dec(CountPixels);
      rgbe2float(rgbe[0],rgbe[1],rgbe[2],rgbe[3],r,g,b,a);
      p^:=r;
      inc(p);
      p^:=g;
      inc(p);
      p^:=b;
      inc(p);
      p^:=a;
      inc(p);
     end;
    end else begin
     y:=ImageHeight;
     while (CountPixels>0) and (y>0) do begin
      dec(y);
      if aStream.Read(rgbe,SizeOf(TVkUInt8)*4)=(SizeOf(TVkUInt8)*4) then begin
       if (rgbe[0]<>2) or (rgbe[1]<>2) or ((rgbe[2] and $80)<>0) then begin
        aStream.Seek(-(SizeOf(TVkUInt8)*4),soCurrent);
        goto NonRLE;
       end else begin
        if TVkInt32((TVkInt32(rgbe[2]) shl 8) or TVkInt32(rgbe[3]))<>ImageWidth then begin
         goto DoFail;
        end;
        if length(scanlinebuffer)<>ImageWidth then begin
         SetLength(scanlinebuffer,ImageWidth);
        end;
        for i:=0 to 3 do begin
         x:=0;
         while x<ImageWidth do begin
          if aStream.Read(Len,SizeOf(TVkUInt8))=SizeOf(TVkUInt8) then begin
           if Len>128 then begin
            k:=Len-128;
            if (x+k)>ImageWidth then begin
             goto DoFail;
            end;
            if aStream.Read(Val,SizeOf(TVkUInt8))=SizeOf(TVkUInt8) then begin
             for j:=1 to k do begin
              scanlinebuffer[x,i]:=Val;
              inc(x);
             end;
            end else begin
             goto DoFail;
            end;
           end else begin
            k:=Len;
            if (x+k)>ImageWidth then begin
             goto DoFail;
            end;
            for j:=1 to k do begin
             if aStream.Read(scanlinebuffer[x,i],SizeOf(TVkUInt8))<>SizeOf(TVkUInt8) then begin
              goto DoFail;
             end;
             inc(x);
            end;
           end;
          end else begin
           goto DoFail;
          end;
         end;
         for x:=0 to ImageWidth-1 do begin
          rgbe2float(scanlinebuffer[x,0],scanlinebuffer[x,1],scanlinebuffer[x,2],scanlinebuffer[x,3],r,g,b,a);
          p^:=r;
          inc(p);
          p^:=g;
          inc(p);
          p^:=b;
          inc(p);
          p^:=a;
          inc(p);
          dec(CountPixels);
         end;
        end;
       end;
      end else begin
       break;
      end;
     end;
    end;
    result:=CountPixels=0;
   end;
   DoFail:
   if result then begin
    if (abs(1.0-gamma)>1e-12) or (abs(1.0-exposure)>1e-12) then begin
     CountPixels:=ImageWidth*ImageHeight;
     p:=ImageData;
     while CountPixels>0 do begin
      dec(CountPixels);
      p^:=power(p^,gamma)*exposure;
      inc(p);
      p^:=power(p^,gamma)*exposure;
      inc(p);
      p^:=power(p^,gamma)*exposure;
      inc(p,2);
     end;
    end;
   end else begin
    FreeMem(ImageData);
    ImageData:=nil;
   end;
   SetLength(scanlinebuffer,0);
  end;
 end;
var ImageData:TVkPointer;
    ImageWidth,ImageHeight:TVkInt32;
begin
 ImageData:=nil;
 ImageWidth:=0;
 ImageHeight:=0;
 try
  if LoadHDRImage(ImageData,ImageWidth,ImageHeight) then begin
   CreateFromMemory(aDevice,
                    aGraphicsQueue,
                    aGraphicsCommandBuffer,
                    aGraphicsFence,
                    aTransferQueue,
                    aTransferCommandBuffer,
                    aTransferFence,
                    VK_FORMAT_R32G32B32A32_SFLOAT,
                    VK_SAMPLE_COUNT_1_BIT,
                    Max(1,ImageWidth),
                    Max(1,ImageHeight),
                    1,
                    1,
                    1,
                    MipMapLevels[aMipMaps],
                    [vtufTransferDst,vtufSampled],
                    ImageData,
                    ImageWidth*ImageHeight*SizeOf(TVkFloat)*4,
                    false,
                    false,
                    1,
                    true);
  end else begin
   raise EVulkanTextureException.Create('Invalid HDR stream');
  end;
 finally
  if assigned(ImageData) then begin
   FreeMem(ImageData);
  end;
 end;
end;

constructor TVulkanTexture.CreateFromTGA(const aDevice:TVulkanDevice;
                                         const aGraphicsQueue:TVulkanQueue;
                                         const aGraphicsCommandBuffer:TVulkanCommandBuffer;
                                         const aGraphicsFence:TVulkanFence;
                                         const aTransferQueue:TVulkanQueue;
                                         const aTransferCommandBuffer:TVulkanCommandBuffer;
                                         const aTransferFence:TVulkanFence;
                                         const aStream:TStream;
                                         const aMipMaps:boolean);
var Data,ImageData:TVkPointer;
    DataSize,ImageWidth,ImageHeight:TVkInt32;
begin
 DataSize:=aStream.Size;
 GetMem(Data,DataSize);
 try
  if aStream.Read(Data^,DataSize)<>DataSize then begin
   raise EVulkanTextureException.Create('Invalid TGA stream');
  end;
  ImageData:=nil;
  ImageWidth:=0;
  ImageHeight:=0;
  try
   if LoadTGAImage(Data,DataSize,ImageData,ImageWidth,ImageHeight,false) then begin
    CreateFromMemory(aDevice,
                     aGraphicsQueue,
                     aGraphicsCommandBuffer,
                     aGraphicsFence,
                     aTransferQueue,
                     aTransferCommandBuffer,
                     aTransferFence,
                     VK_FORMAT_R8G8B8A8_UNORM,
                     VK_SAMPLE_COUNT_1_BIT,
                     Max(1,ImageWidth),
                     Max(1,ImageHeight),
                     1,
                     1,
                     1,
                     MipMapLevels[aMipMaps],
                     [vtufTransferDst,vtufSampled],
                     ImageData,
                     ImageWidth*ImageHeight*SizeOf(TVkUInt8)*4,
                     false,
                     false,
                     1,
                     true);
   end else begin
    raise EVulkanTextureException.Create('Invalid TGA stream');
   end;
  finally
   if assigned(ImageData) then begin
    FreeMem(ImageData);
   end;
  end;
 finally
  FreeMem(Data);
 end;
end;

constructor TVulkanTexture.CreateFromPNG(const aDevice:TVulkanDevice;
                                         const aGraphicsQueue:TVulkanQueue;
                                         const aGraphicsCommandBuffer:TVulkanCommandBuffer;
                                         const aGraphicsFence:TVulkanFence;
                                         const aTransferQueue:TVulkanQueue;
                                         const aTransferCommandBuffer:TVulkanCommandBuffer;
                                         const aTransferFence:TVulkanFence;
                                         const aStream:TStream;
                                         const aMipMaps:boolean);
var Data,ImageData:TVkPointer;
    DataSize,ImageWidth,ImageHeight,VulkanBytesPerPixel:TVkInt32;
    PNGPixelFormat:TPNGPixelFormat;
    VulkanPixelFormat:TVkFormat;
begin
 DataSize:=aStream.Size;
 GetMem(Data,DataSize);
 try
  if aStream.Read(Data^,DataSize)<>DataSize then begin
   raise EVulkanTextureException.Create('Invalid PNG stream');
  end;
  ImageData:=nil;
  ImageWidth:=0;
  ImageHeight:=0;
  try
   PNGPixelFormat:=ppfUnknown;
   if LoadPNGImage(Data,DataSize,ImageData,ImageWidth,ImageHeight,false,PNGPixelFormat) then begin
    case PNGPixelFormat of
     ppfR8G8B8A8:begin
      VulkanPixelFormat:=VK_FORMAT_R8G8B8A8_UNORM;
      VulkanBytesPerPixel:=4;
     end;
     ppfR16G16B16A16:begin
      VulkanPixelFormat:=VK_FORMAT_R16G16B16A16_UNORM;
      VulkanBytesPerPixel:=8;
     end;
     else begin
      VulkanPixelFormat:=VK_FORMAT_R8G8B8A8_UNORM;
      VulkanBytesPerPixel:=4;
      raise EVulkanTextureException.Create('Invalid PNG stream');
     end;
    end;
    CreateFromMemory(aDevice,
                     aGraphicsQueue,
                     aGraphicsCommandBuffer,
                     aGraphicsFence,
                     aTransferQueue,
                     aTransferCommandBuffer,
                     aTransferFence,
                     VulkanPixelFormat,
                     VK_SAMPLE_COUNT_1_BIT,
                     Max(1,ImageWidth),
                     Max(1,ImageHeight),
                     1,
                     1,
                     1,
                     MipMapLevels[aMipMaps],
                     [vtufTransferDst,vtufSampled],
                     ImageData,
                     ImageWidth*ImageHeight*VulkanBytesPerPixel,
                     false,
                     false,
                     1,
                     true);
   end else begin
    raise EVulkanTextureException.Create('Invalid PNG stream');
   end;
  finally
   if assigned(ImageData) then begin
    FreeMem(ImageData);
   end;
  end;
 finally
  FreeMem(Data);
 end;
end;

constructor TVulkanTexture.CreateFromJPEG(const aDevice:TVulkanDevice;
                                          const aGraphicsQueue:TVulkanQueue;
                                          const aGraphicsCommandBuffer:TVulkanCommandBuffer;
                                          const aGraphicsFence:TVulkanFence;
                                          const aTransferQueue:TVulkanQueue;
                                          const aTransferCommandBuffer:TVulkanCommandBuffer;
                                          const aTransferFence:TVulkanFence;
                                          const aStream:TStream;
                                          const aMipMaps:boolean);
var Data,ImageData:TVkPointer;
    DataSize,ImageWidth,ImageHeight:TVkInt32;
begin
 DataSize:=aStream.Size;
 GetMem(Data,DataSize);
 try
  if aStream.Read(Data^,DataSize)<>DataSize then begin
   raise EVulkanTextureException.Create('Invalid JPEG stream');
  end;
  ImageData:=nil;
  ImageWidth:=0;
  ImageHeight:=0;
  try
   if LoadJPEGImage(Data,DataSize,ImageData,ImageWidth,ImageHeight,false) then begin
    CreateFromMemory(aDevice,
                     aGraphicsQueue,
                     aGraphicsCommandBuffer,
                     aGraphicsFence,
                     aTransferQueue,
                     aTransferCommandBuffer,
                     aTransferFence,
                     VK_FORMAT_R8G8B8A8_UNORM,
                     VK_SAMPLE_COUNT_1_BIT,
                     Max(1,ImageWidth),
                     Max(1,ImageHeight),
                     1,
                     1,
                     1,
                     MipMapLevels[aMipMaps],
                     [vtufTransferDst,vtufSampled],
                     ImageData,
                     ImageWidth*ImageHeight*SizeOf(TVkUInt8)*4,
                     false,
                     false,
                     1,
                     true);
   end else begin
    raise EVulkanTextureException.Create('Invalid JPEG stream');
   end;
  finally
   if assigned(ImageData) then begin
    FreeMem(ImageData);
   end;
  end;
 finally
  FreeMem(Data);
 end;
end;

constructor TVulkanTexture.CreateFromBMP(const aDevice:TVulkanDevice;
                                         const aGraphicsQueue:TVulkanQueue;
                                         const aGraphicsCommandBuffer:TVulkanCommandBuffer;
                                         const aGraphicsFence:TVulkanFence;
                                         const aTransferQueue:TVulkanQueue;
                                         const aTransferCommandBuffer:TVulkanCommandBuffer;
                                         const aTransferFence:TVulkanFence;
                                         const aStream:TStream;
                                         const aMipMaps:boolean);
var Data,ImageData:TVkPointer;
    DataSize,ImageWidth,ImageHeight:TVkInt32;
begin
 DataSize:=aStream.Size;
 GetMem(Data,DataSize);
 try
  if aStream.Read(Data^,DataSize)<>DataSize then begin
   raise EVulkanTextureException.Create('Invalid JPEG stream');
  end;
  ImageData:=nil;
  ImageWidth:=0;
  ImageHeight:=0;
  try
   if LoadBMPImage(Data,DataSize,ImageData,ImageWidth,ImageHeight,false) then begin
    CreateFromMemory(aDevice,
                     aGraphicsQueue,
                     aGraphicsCommandBuffer,
                     aGraphicsFence,
                     aTransferQueue,
                     aTransferCommandBuffer,
                     aTransferFence,
                     VK_FORMAT_R8G8B8A8_UNORM,
                     VK_SAMPLE_COUNT_1_BIT,
                     Max(1,ImageWidth),
                     Max(1,ImageHeight),
                     1,
                     1,
                     1,
                     MipMapLevels[aMipMaps],
                     [vtufTransferDst,vtufSampled],
                     ImageData,
                     ImageWidth*ImageHeight*SizeOf(TVkUInt8)*4,
                     false,
                     false,
                     1,
                     true);
   end else begin
    raise EVulkanTextureException.Create('Invalid BMP stream');
   end;
  finally
   if assigned(ImageData) then begin
    FreeMem(ImageData);
   end;
  end;
 finally
  FreeMem(Data);
 end;
end;

constructor TVulkanTexture.CreateFromImage(const aDevice:TVulkanDevice;
                                           const aGraphicsQueue:TVulkanQueue;
                                           const aGraphicsCommandBuffer:TVulkanCommandBuffer;
                                           const aGraphicsFence:TVulkanFence;
                                           const aTransferQueue:TVulkanQueue;
                                           const aTransferCommandBuffer:TVulkanCommandBuffer;
                                           const aTransferFence:TVulkanFence;
                                           const aStream:TStream;
                                           const aMipMaps:boolean);
const DDS_MAGIC=$20534444;
      DDSD_CAPS=$00000001;
      DDSD_PIXELFORMAT=$00001000;
type PFirstBytes=^TFirstBytes;
     TFirstBytes=array[0..63] of TVkUInt8;
     PDDSHeader=^TDDSHeader;
     TDDSHeader=packed record
      dwMagic:TVkUInt32;
      dwSize:TVkUInt32;
      dwFlags:TVkUInt32;
      dwHeight:TVkUInt32;
      dwWidth:TVkUInt32;
      dwPitchOrLinearSize:TVkUInt32;
      dwDepth:TVkUInt32;
      dwMipMapCount:TVkUInt32;
     end;
var FirstBytes:TFirstBytes;
begin
 aStream.Seek(0,soBeginning);
 FillChar(FirstBytes,SizeOf(FirstBytes),#0);
 aStream.ReadBuffer(FirstBytes,Min(SizeOf(FirstBytes),aStream.Size));
 aStream.Seek(0,soBeginning);
 if (FirstBytes[0]=$ab) and (FirstBytes[1]=$4b) and (FirstBytes[2]=$54) and (FirstBytes[3]=$58) and (FirstBytes[4]=$20) and (FirstBytes[5]=$31) and (FirstBytes[6]=$31) and (FirstBytes[7]=$bb) and (FirstBytes[8]=$0d) and (FirstBytes[9]=$0a) and (FirstBytes[10]=$1a) and (FirstBytes[11]=$0a) then begin
  CreateFromKTX(aDevice,
                aGraphicsQueue,
                aGraphicsCommandBuffer,
                aGraphicsFence,
                aTransferQueue,
                aTransferCommandBuffer,
                aTransferFence,
                aStream);
 end else if (FirstBytes[0]=$89) and (FirstBytes[1]=$50) and (FirstBytes[2]=$4e) and (FirstBytes[3]=$47) and (FirstBytes[4]=$0d) and (FirstBytes[5]=$0a) and (FirstBytes[6]=$1a) and (FirstBytes[7]=$0a) then begin
  CreateFromPNG(aDevice,
                aGraphicsQueue,
                aGraphicsCommandBuffer,
                aGraphicsFence,
                aTransferQueue,
                aTransferCommandBuffer,
                aTransferFence,
                aStream,
                aMipMaps);
 end else if ((PDDSHeader(TVkPointer(@FirstBytes))^.dwMagic=DDS_MAGIC) and (PDDSHeader(TVkPointer(@FirstBytes))^.dwSize=124) and not (((PDDSHeader(TVkPointer(@FirstBytes))^.dwFlags and DDSD_PIXELFORMAT)=0) or ((PDDSHeader(TVkPointer(@FirstBytes))^.dwFlags and DDSD_CAPS)=0))) then begin
  CreateFromDDS(aDevice,
                aGraphicsQueue,
                aGraphicsCommandBuffer,
                aGraphicsFence,
                aTransferQueue,
                aTransferCommandBuffer,
                aTransferFence,
                aStream);
 end else if (FirstBytes[0]=TVkUInt8(AnsiChar('B'))) and (FirstBytes[1]=TVkUInt8(AnsiChar('M'))) then begin
  CreateFromBMP(aDevice,
                aGraphicsQueue,
                aGraphicsCommandBuffer,
                aGraphicsFence,
                aTransferQueue,
                aTransferCommandBuffer,
                aTransferFence,
                aStream,
                aMipMaps);
 end else if (FirstBytes[0]=TVkUInt8(AnsiChar('#'))) and (FirstBytes[1]=TVkUInt8(AnsiChar('?'))) then begin
  CreateFromHDR(aDevice,
                aGraphicsQueue,
                aGraphicsCommandBuffer,
                aGraphicsFence,
                aTransferQueue,
                aTransferCommandBuffer,
                aTransferFence,
                aStream,
                aMipMaps);
 end else if ((FirstBytes[0] xor $ff) or (FirstBytes[1] xor $d8))=0 then begin
  CreateFromJPEG(aDevice,
                 aGraphicsQueue,
                 aGraphicsCommandBuffer,
                 aGraphicsFence,
                 aTransferQueue,
                 aTransferCommandBuffer,
                 aTransferFence,
                 aStream,
                 aMipMaps);
 end else begin
  CreateFromTGA(aDevice,
                aGraphicsQueue,
                aGraphicsCommandBuffer,
                aGraphicsFence,
                aTransferQueue,
                aTransferCommandBuffer,
                aTransferFence,
                aStream,
                aMipMaps);
 end;
end;

constructor TVulkanTexture.CreateDefault(const aDevice:TVulkanDevice;
                                         const aGraphicsQueue:TVulkanQueue;
                                         const aGraphicsCommandBuffer:TVulkanCommandBuffer;
                                         const aGraphicsFence:TVulkanFence;
                                         const aTransferQueue:TVulkanQueue;
                                         const aTransferCommandBuffer:TVulkanCommandBuffer;
                                         const aTransferFence:TVulkanFence;
                                         const aDefaultType:TVulkanTextureDefaultType;
                                         const aWidth:TVkInt32;
                                         const aHeight:TVkInt32;
                                         const aDepth:TVkInt32;
                                         const aCountArrayElements:TVkInt32;
                                         const aCountFaces:TVkInt32;
                                         const aMipmaps:boolean;
                                         const aBorder:boolean);
const TexelSize=4;
      BlockShift=5;
      BlockSize=1 shl BlockShift;
      BlockMask=BlockSize-1;
      Radius=10;
      Colors:array[0..3,0..3] of TVkUInt8=
       (($ff,$00,$00,$ff),
        ($00,$ff,$00,$ff),
        ($00,$00,$ff,$ff),
        ($ff,$ff,$00,$ff));
var LayerSize,DataSize,LayerIndex,x,y,Offset,lx,ly,rx,ry,cx,cy,m,Index,dx,dy,ds,Scale,CountMipMaps:TVkInt32;
    Data:TVkUInt8Array;
begin

 LayerSize:=aWidth*aHeight*TexelSize;
 DataSize:=LayerSize*aDepth*aCountArrayElements*aCountFaces;

 Data:=nil;
 try

  SetLength(Data,DataSize);

  case aDefaultType of
   vtdtCheckerboard:begin
    for LayerIndex:=0 to (aDepth*aCountArrayElements*aCountFaces)-1 do begin
     for y:=0 to aHeight-1 do begin
      for x:=0 to aWidth-1 do begin
       Offset:=(LayerIndex*LayerSize)+(((y*aWidth)+x)*TexelSize);
       if (((x shr BlockShift) xor (y shr BlockShift)) and 1)<>0 then begin
        if (LayerIndex and 1)<>0 then begin
         Data[Offset+0]:=160;
        end else begin
         Data[Offset+0]:=96;
        end;
        Data[Offset+1]:=64;
        if (LayerIndex and 1)<>0 then begin
         Data[Offset+2]:=96;
        end else begin
         Data[Offset+2]:=255;
        end;
       end else begin
        if (LayerIndex and 1)<>0 then begin
         Data[Offset+0]:=160;
        end else begin
         Data[Offset+0]:=64;
        end;
        Data[Offset+1]:=32;
        if (LayerIndex and 1)<>0 then begin
         Data[Offset+2]:=64;
        end else begin
         Data[Offset+2]:=255;
        end;
       end;
       Data[Offset+3]:=255;
      end;
     end;
    end;
   end;
   vtdtPyramids:begin
    for LayerIndex:=0 to (aDepth*aCountArrayElements*aCountFaces)-1 do begin
     for y:=0 to aHeight-1 do begin
      for x:=0 to aWidth-1 do begin
       Offset:=(LayerIndex*LayerSize)+(((y*aWidth)+x)*TexelSize);
       lx:=x and BlockSize;
       ly:=y and BlockSize;
       rx:=BlockSize-lx;
       ry:=BlockSize-ly;
       cx:=0;
       cy:=0;
       if (lx<>ly) and (lx<>ry) then begin
        m:=BlockSize;
        if lx<m then begin
         m:=lx;
         cx:=-96;
         cy:=0;
        end;
        if ly<m then begin
         m:=ly;
         cx:=0;
         cy:=-96;
        end;
        if rx<m then begin
         m:=rx;
         cx:=96;
         cy:=0;
        end;
        if ry<m then begin
         m:=ry;
         cx:=0;
         cy:=96;
        end;
        if m>0 then begin
        end;
       end;
       Data[Offset+0]:=128+cx;
       Data[Offset+1]:=128+cy;
       Data[Offset+2]:=128+85;
       Data[Offset+3]:=255;
      end;
     end;
    end;
   end;
   else {vtdtCircles:}begin
    for LayerIndex:=0 to (aDepth*aCountArrayElements*aCountFaces)-1 do begin
     for y:=0 to aHeight-1 do begin
      for x:=0 to aWidth-1 do begin
       Offset:=(LayerIndex*LayerSize)+(((y*aWidth)+x)*TexelSize);
       Index:=((((y shr (BlockShift-1)) and 2) xor ((y shr BlockShift) and 2))) or
              (((((y shr BlockShift) and 1) xor ((y shr (BlockShift+1)) and 1))));
       dx:=((x and not BlockMask)+(BlockSize shr 1))-x;
       dy:=((y and not BlockMask)+(BlockSize shr 1))-y;
       ds:=abs(((dx*dx)+(dy*dy))-(Radius*Radius));
       Scale:=Min(ds,BlockSize);
       Data[Offset+0]:=Min(Max((Colors[Index,0]*Scale) shr BlockShift,0),255);
       Data[Offset+1]:=Min(Max((Colors[Index,1]*Scale) shr BlockShift,0),255);
       Data[Offset+2]:=Min(Max((Colors[Index,2]*Scale) shr BlockShift,0),255);
       Data[Offset+3]:=255;
      end;
     end;
    end;
   end;
  end;

  if aBorder then begin
   for LayerIndex:=0 to (aDepth*aCountArrayElements*aCountFaces)-1 do begin
    for y:=0 to aHeight-1 do begin
     Offset:=(LayerIndex*LayerSize)+(((y*aWidth)+0)*TexelSize);
     Data[Offset+0]:=0;
     Data[Offset+1]:=0;
     Data[Offset+2]:=0;
     Data[Offset+3]:=255;
     Offset:=(LayerIndex*LayerSize)+(((y*aWidth)+(aWidth-1))*TexelSize);
     Data[Offset+0]:=0;
     Data[Offset+1]:=0;
     Data[Offset+2]:=0;
     Data[Offset+3]:=255;
    end;
    for x:=0 to aWidth-1 do begin
     Offset:=(LayerIndex*LayerSize)+(((0*aWidth)+x)*TexelSize);
     Data[Offset+0]:=0;
     Data[Offset+1]:=0;
     Data[Offset+2]:=0;
     Data[Offset+3]:=255;
     Offset:=(LayerIndex*LayerSize)+((((aHeight-1)*aWidth)+x)*TexelSize);
     Data[Offset+0]:=0;
     Data[Offset+1]:=0;
     Data[Offset+2]:=0;
     Data[Offset+3]:=255;
    end;
   end;
  end;

  if aMipMaps then begin
   CountMipMaps:=-1;
  end else begin
   CountMipMaps:=1;
  end;

  CreateFromMemory(aDevice,
                   aGraphicsQueue,
                   aGraphicsCommandBuffer,
                   aGraphicsFence,
                   aTransferQueue,
                   aTransferCommandBuffer,
                   aTransferFence,
                   VK_FORMAT_R8G8B8A8_UNORM,
                   VK_SAMPLE_COUNT_1_BIT,
                   aWidth,
                   aHeight,
                   aDepth,
                   aCountArrayElements,
                   aCountFaces,
                   CountMipMaps,
                   [vtufTransferDst,vtufSampled],
                   @Data[0],
                   DataSize,
                   false,
                   false,
                   1,
                   false);

 finally
  SetLength(Data,0);
 end;

end;

destructor TVulkanTexture.Destroy;
begin
 FreeAndNil(fSampler);
 FreeAndNil(fImageView);
 if assigned(fMemoryBlock) then begin
  fDevice.fMemoryManager.FreeMemoryBlock(fMemoryBlock);
  fMemoryBlock:=nil;
 end;
 FreeAndNil(fImage);
 inherited Destroy;
end;

procedure TVulkanTexture.UpdateSampler;
var MagFilter:TVkFilter;
    MinFilter:TVkFilter;
    MipmapMode:TVkSamplerMipmapMode;
    AddressModeU:TVkSamplerAddressMode;
    AddressModeV:TVkSamplerAddressMode;
    AddressModeW:TVkSamplerAddressMode;
    AnisotropyEnable:boolean;
begin
 FreeAndNil(fSampler);
 case fFilterMode of
  vtfmNearest:begin
   MagFilter:=VK_FILTER_NEAREST;
   MinFilter:=VK_FILTER_NEAREST;
   MipmapMode:=VK_SAMPLER_MIPMAP_MODE_NEAREST;
  end;
  vtfmLinear:begin
   MagFilter:=VK_FILTER_LINEAR;
   MinFilter:=VK_FILTER_LINEAR;
   MipmapMode:=VK_SAMPLER_MIPMAP_MODE_NEAREST;
  end;
  else {vtfmBilinear:}begin
   MagFilter:=VK_FILTER_LINEAR;
   MinFilter:=VK_FILTER_LINEAR;
   MipmapMode:=VK_SAMPLER_MIPMAP_MODE_LINEAR;
  end;
 end;
 case fWrapModeU of
  vtwmRepeat:begin
   AddressModeU:=VK_SAMPLER_ADDRESS_MODE_REPEAT;
  end;
  vtwmClampToEdge:begin
   AddressModeU:=VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE;
  end;
  else {vtwmClampToBorder:}begin
   AddressModeU:=VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_BORDER;
  end;
 end;
 case fWrapModeV of
  vtwmRepeat:begin
   AddressModeV:=VK_SAMPLER_ADDRESS_MODE_REPEAT;
  end;
  vtwmClampToEdge:begin
   AddressModeV:=VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE;
  end;
  else {vtwmClampToBorder:}begin
   AddressModeV:=VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_BORDER;
  end;
 end;
 case fWrapModeW of
  vtwmRepeat:begin
   AddressModeW:=VK_SAMPLER_ADDRESS_MODE_REPEAT;
  end;
  vtwmClampToEdge:begin
   AddressModeW:=VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE;
  end;
  else {vtwmClampToBorder:}begin
   AddressModeW:=VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_BORDER;
  end;
 end;
 AnisotropyEnable:=fMaxAnisotropy>1.0;
 fSampler:=TVulkanSampler.Create(fDevice,
                                 MagFilter,
                                 MinFilter,
                                 MipmapMode,
                                 AddressModeU,
                                 AddressModeV,
                                 AddressModeW,
                                 0.0,
                                 AnisotropyEnable,
                                 fMaxAnisotropy,
                                 false,
                                 VK_COMPARE_OP_NEVER,
                                 0.0,
                                 CountMipMaps,
                                 fBorderColor,
                                 false);
 if assigned(fSampler) then begin
  fDescriptorImageInfo.sampler:=fSampler.fSamplerHandle;
 end else begin
  fDescriptorImageInfo.sampler:=VK_NULL_HANDLE;
 end;
end;

//////////////////////////////////////////// Sprites ///////////////////////////////////////////////////

constructor TVulkanSpriteTexture.Create(const aPixels:PVulkanSpriteTexturePixels;const aWidth,aHeight:TVkInt32);
begin
 inherited Create;

 fTexture:=nil;

 fPixels:=aPixels;

 fWidth:=aWidth;
 fHeight:=aHeight;

 fUploaded:=false;
 fDirty:=true;

end;

destructor TVulkanSpriteTexture.Destroy;
begin

 Unload;

 FreeAndNil(fTexture);

 fPixels:=nil;

 inherited Destroy;
end;

procedure TVulkanSpriteTexture.Upload(const aDevice:TVulkanDevice;
                                      const aGraphicsQueue:TVulkanQueue;
                                      const aGraphicsCommandBuffer:TVulkanCommandBuffer;
                                      const aGraphicsFence:TVulkanFence;
                                      const aTransferQueue:TVulkanQueue;
                                      const aTransferCommandBuffer:TVulkanCommandBuffer;
                                      const aTransferFence:TVulkanFence;
                                      const aMipMaps:boolean);
begin

 if not fUploaded then begin

  FreeAndNil(fTexture);

{$if true}
  fTexture:=TVulkanTexture.CreateFromMemory(aDevice,
                                            aGraphicsQueue,
                                            aGraphicsCommandBuffer,
                                            aGraphicsFence,
                                            aTransferQueue,
                                            aTransferCommandBuffer,
                                            aTransferFence,
                                            VK_FORMAT_R8G8B8A8_UNORM,
                                            VK_SAMPLE_COUNT_1_BIT,
                                            Max(1,fWidth),
                                            Max(1,fHeight),
                                            1,
                                            1,
                                            1,
                                            MipMapLevels[aMipMaps],  
                                            [vtufTransferDst,vtufSampled],
                                            fPixels,
                                            fWidth*fHeight*SizeOf(TVkUInt8)*4,
                                            false,
                                            false,
                                            1,
                                            true);
{$else}
 fTexture:=TVulkanTexture.CreateDefault(aDevice,
                                         aGraphicsQueue,
                                         aGraphicsCommandBuffer,
                                         aGraphicsFence,
                                         aTransferQueue,
                                         aTransferCommandBuffer,
                                         aTransferFence,
                                         vtdtCheckerboard,
                                         Max(1,fWidth),
                                         Max(1,fHeight),
                                         1,
                                         1,
                                         1,
                                         aMipMaps,
                                         false);
{$ifend}
  fTexture.WrapModeU:=vtwmClampToBorder;
  fTexture.WrapModeV:=vtwmClampToBorder;
  fTexture.WrapModeW:=vtwmClampToBorder;
  fTexture.BorderColor:=VK_BORDER_COLOR_FLOAT_TRANSPARENT_BLACK;
  fTexture.UpdateSampler;

  fUploaded:=true;

 end;

end;

procedure TVulkanSpriteTexture.Unload;
begin

 if fUploaded then begin

  FreeAndNil(fTexture);

  fUploaded:=false;

 end;

end;

constructor TVulkanSpriteFont.Create;
begin
 inherited Create;
end;

destructor TVulkanSpriteFont.Destroy;
begin
 inherited Destroy;
end;

constructor TVulkanSprite.Create;
begin
 inherited Create;
 Name:='';
end;

destructor TVulkanSprite.Destroy;
begin
 Name:='';
 inherited Destroy;
end;

constructor TVulkanSpriteBatch.Create(const aDevice:TVulkanDevice;
                                      const aGraphicsQueue:TVulkanQueue;
                                      const aGraphicsCommandBuffer:TVulkanCommandBuffer;
                                      const aGraphicsFence:TVulkanFence;
                                      const aTransferQueue:TVulkanQueue;
                                      const aTransferCommandBuffer:TVulkanCommandBuffer;
                                      const aTransferFence:TVulkanFence;
                                      const aPipelineCache:TVulkanPipelineCache;
                                      const aRenderPass:TVulkanRenderPass;
                                      const aCountBuffers:TVkInt32);
var Index:TVkInt32;
    RenderingModeIndex:TVulkanSpriteBatchRenderingMode;
    BlendingModeIndex:TVulkanSpriteBatchBlendingMode;
    Indices:array of TVkUInt32;
    VulkanGraphicsPipeline:TVulkanGraphicsPipeline;
    VulkanSpriteBatchBuffer:PVulkanSpriteBatchBuffer;
    Stream:TStream;
begin
 inherited Create;

 fDevice:=aDevice;

 fGraphicsQueue:=aGraphicsQueue;
 fGraphicsCommandBuffer:=aGraphicsCommandBuffer;
 fGraphicsFence:=aGraphicsFence;

 fTransferQueue:=aTransferQueue;
 fTransferCommandBuffer:=aTransferCommandBuffer;
 fTransferFence:=aTransferFence;

 fPipelineCache:=aPipelineCache;

 fCountBuffers:=aCountBuffers;

 fVulkanSpriteBatchBuffers:=nil;

 SetLength(fVulkanSpriteBatchBuffers,aCountBuffers);

 fLastTexture:=nil;

 fVertexBufferUsed:=0;
 fIndexBufferUsed:=0;

 fRenderingMode:=vsbrmNormal;

 fBlendingMode:=vsbbmAlphaBlending;

 fWidth:=1280;
 fHeight:=720;

 fViewPort.x:=0.0;
 fViewPort.y:=0.0;
 fViewPort.Width:=1280.0;
 fViewPort.Height:=720.0;
 fViewPort.minDepth:=0.0;
 fViewPort.maxDepth:=1.0;

 fPointerToViewport:=@fViewport;

 fCurrentDestinationVertexDataBuffer:=nil;

 fVertexBufferCount:=32768;
 fVertexBufferSize:=SizeOf(TVulkanSpriteBatchVertex)*(4*fVertexBufferCount);

 fIndexBufferCount:=(fVertexBufferCount*6) div 4;
 fIndexBufferSize:=SizeOf(TVkUInt32)*fIndexBufferCount;

 Indices:=nil;
 try
  SetLength(Indices,fIndexBufferCount);
  Index:=0;
  while Index<fVertexBufferCount do begin
   Indices[fIndexBufferUsed+0]:=Index+0;
   Indices[fIndexBufferUsed+1]:=Index+1;
   Indices[fIndexBufferUsed+2]:=Index+2;
   Indices[fIndexBufferUsed+3]:=Index+0;
   Indices[fIndexBufferUsed+4]:=Index+2;
   Indices[fIndexBufferUsed+5]:=Index+3;
   inc(fIndexBufferUsed,6);
   inc(Index,4);
  end;

  fVulkanIndexBuffer:=TVulkanBuffer.Create(fDevice,
                                           fIndexBufferUsed*SizeOf(TVkUInt32),
                                           TVkBufferUsageFlags(VK_BUFFER_USAGE_TRANSFER_DST_BIT) or TVkBufferUsageFlags(VK_BUFFER_USAGE_INDEX_BUFFER_BIT),
                                           TVkSharingMode(VK_SHARING_MODE_EXCLUSIVE),
                                           nil,
                                           TVkMemoryPropertyFlags(VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT)
                                          );
  fVulkanIndexBuffer.UploadData(fTransferQueue,
                                fTransferCommandBuffer,
                                fTransferFence,
                                Indices[0],
                                0,
                                fIndexBufferUsed*SizeOf(TVkUInt32),
                                vbutsbmYes);

 finally
  Indices:=nil;
 end;

 for Index:=0 to length(fVulkanSpriteBatchBuffers)-1 do begin
  VulkanSpriteBatchBuffer:=@fVulkanSpriteBatchBuffers[Index];
  VulkanSpriteBatchBuffer^.fSpinLock:=0;
  VulkanSpriteBatchBuffer^.fVulkanVertexBuffers:=nil;
  VulkanSpriteBatchBuffer^.fVulkanVertexDataBuffers:=nil;
  VulkanSpriteBatchBuffer^.fVulkanVertexDataBufferSizes:=nil;
  VulkanSpriteBatchBuffer^.fCountVulkanVertexBuffers:=0;
  VulkanSpriteBatchBuffer^.fCountUsedVertexBuffers:=0;
  VulkanSpriteBatchBuffer^.fQueueItems:=nil;
  VulkanSpriteBatchBuffer^.fCountQueueItems:=0;
 end;

 fCurrentVulkanVertexBufferIndex:=0;

 fVulkanDescriptorPool:=TVulkanDescriptorPool.Create(fDevice,
                                                     TVkDescriptorPoolCreateFlags(VK_DESCRIPTOR_POOL_CREATE_FREE_DESCRIPTOR_SET_BIT),
                                                     2);

 fVulkanDescriptorPool.AddDescriptorPoolSize(VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER,1);
 fVulkanDescriptorPool.AddDescriptorPoolSize(VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER,1);
 fVulkanDescriptorPool.Initialize;

 fVulkanDescriptorSetLayout:=TVulkanDescriptorSetLayout.Create(fDevice);
 fVulkanDescriptorSetLayout.AddBinding(0,
                                       VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER,
                                       1,
                                       TVkShaderStageFlags(VK_SHADER_STAGE_FRAGMENT_BIT),
                                       []);
 fVulkanDescriptorSetLayout.Initialize;

 fVulkanDescriptorSets:=nil;
 fCountVulkanDescriptorSets:=0;

 fVulkanTextureDescriptorSetHashMap:=TVulkanPointerHashMap.Create;

 fVulkanPipelineLayout:=TVulkanPipelineLayout.Create(fDevice);
 fVulkanPipelineLayout.AddDescriptorSetLayout(fVulkanDescriptorSetLayout);
 fVulkanPipelineLayout.Initialize;

 fVulkanRenderPass:=aRenderPass;

 Stream:=TVulkanDataStream.Create(@FontVertexSPIRVData,FontVertexSPIRVDataSize);
 try
  fFontVertexShaderModule:=TVulkanShaderModule.Create(fDevice,Stream);
 finally
  Stream.Free;
 end;

 Stream:=TVulkanDataStream.Create(@FontFragmentSPIRVData,FontFragmentSPIRVDataSize);
 try
  fFontFragmentShaderModule:=TVulkanShaderModule.Create(fDevice,Stream);
 finally
  Stream.Free;
 end;

 Stream:=TVulkanDataStream.Create(@SpriteBatchVertexSPIRVData,SpriteBatchVertexSPIRVDataSize);
 try
  fSpriteBatchVertexShaderModule:=TVulkanShaderModule.Create(fDevice,Stream);
 finally
  Stream.Free;
 end;

 Stream:=TVulkanDataStream.Create(@SpriteBatchFragmentSPIRVData,SpriteBatchFragmentSPIRVDataSize);
 try
  fSpriteBatchFragmentShaderModule:=TVulkanShaderModule.Create(fDevice,Stream);
 finally
  Stream.Free;
 end;

 fVulkanPipelineFontShaderStageTriangleVertex:=TVulkanPipelineShaderStage.Create(VK_SHADER_STAGE_VERTEX_BIT,fFontVertexShaderModule,'main');

 fVulkanPipelineFontShaderStageTriangleFragment:=TVulkanPipelineShaderStage.Create(VK_SHADER_STAGE_FRAGMENT_BIT,fFontFragmentShaderModule,'main');

 fVulkanPipelineSpriteBatchShaderStageTriangleVertex:=TVulkanPipelineShaderStage.Create(VK_SHADER_STAGE_VERTEX_BIT,fSpriteBatchVertexShaderModule,'main');

 fVulkanPipelineSpriteBatchShaderStageTriangleFragment:=TVulkanPipelineShaderStage.Create(VK_SHADER_STAGE_FRAGMENT_BIT,fSpriteBatchFragmentShaderModule,'main');

 for RenderingModeIndex:=Low(TVulkanSpriteBatchRenderingMode) to High(TVulkanSpriteBatchRenderingMode) do begin

  for BlendingModeIndex:=Low(TVulkanSpriteBatchBlendingMode) to High(TVulkanSpriteBatchBlendingMode) do begin

   VulkanGraphicsPipeline:=TVulkanGraphicsPipeline.Create(fDevice,
                                                          fPipelineCache,
                                                          0,
                                                          [],
                                                          fVulkanPipelineLayout,
                                                          fVulkanRenderPass,
                                                          0,
                                                          nil,
                                                          0);
   fVulkanGraphicsPipelines[RenderingModeIndex,BlendingModeIndex]:=VulkanGraphicsPipeline;

   case RenderingModeIndex of
    vsbrmFont:begin
     VulkanGraphicsPipeline.AddStage(fVulkanPipelineFontShaderStageTriangleVertex);
     VulkanGraphicsPipeline.AddStage(fVulkanPipelineFontShaderStageTriangleFragment);
    end;
    vsbrmNormal:begin
     VulkanGraphicsPipeline.AddStage(fVulkanPipelineSpriteBatchShaderStageTriangleVertex);
     VulkanGraphicsPipeline.AddStage(fVulkanPipelineSpriteBatchShaderStageTriangleFragment);
    end;
    else begin
     Assert(false);
    end;
   end;

   VulkanGraphicsPipeline.InputAssemblyState.Topology:=VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST;
   VulkanGraphicsPipeline.InputAssemblyState.PrimitiveRestartEnable:=false;

   VulkanGraphicsPipeline.VertexInputState.AddVertexInputBindingDescription(0,SizeOf(TVulkanSpriteBatchVertex),VK_VERTEX_INPUT_RATE_VERTEX);
   VulkanGraphicsPipeline.VertexInputState.AddVertexInputAttributeDescription(0,0,VK_FORMAT_R32G32_SFLOAT,TVkPtrUInt(Pointer(@PVulkanSpriteBatchVertex(nil)^.Position)));
   VulkanGraphicsPipeline.VertexInputState.AddVertexInputAttributeDescription(1,0,VK_FORMAT_R32G32_SFLOAT,TVkPtrUInt(Pointer(@PVulkanSpriteBatchVertex(nil)^.TextureCoord)));
   VulkanGraphicsPipeline.VertexInputState.AddVertexInputAttributeDescription(2,0,VK_FORMAT_R32G32B32A32_SFLOAT,TVkPtrUInt(Pointer(@PVulkanSpriteBatchVertex(nil)^.Color)));

   VulkanGraphicsPipeline.ViewPortState.AddViewPort(0.0,0.0,fWidth,fHeight,0.0,1.0);
   VulkanGraphicsPipeline.ViewPortState.DynamicViewPorts:=true;

   VulkanGraphicsPipeline.ViewPortState.AddScissor(0,0,fWidth,fHeight);
   VulkanGraphicsPipeline.ViewPortState.DynamicScissors:=true;

   VulkanGraphicsPipeline.RasterizationState.DepthClampEnable:=false;
   VulkanGraphicsPipeline.RasterizationState.RasterizerDiscardEnable:=false;
   VulkanGraphicsPipeline.RasterizationState.PolygonMode:=VK_POLYGON_MODE_FILL;  
   VulkanGraphicsPipeline.RasterizationState.CullMode:=TVkCullModeFlags(VK_CULL_MODE_NONE);
   VulkanGraphicsPipeline.RasterizationState.FrontFace:=VK_FRONT_FACE_COUNTER_CLOCKWISE;
   VulkanGraphicsPipeline.RasterizationState.DepthBiasEnable:=false;
   VulkanGraphicsPipeline.RasterizationState.DepthBiasConstantFactor:=0.0;
   VulkanGraphicsPipeline.RasterizationState.DepthBiasClamp:=0.0;
   VulkanGraphicsPipeline.RasterizationState.DepthBiasSlopeFactor:=0.0;
   VulkanGraphicsPipeline.RasterizationState.LineWidth:=1.0;

   VulkanGraphicsPipeline.MultisampleState.RasterizationSamples:=VK_SAMPLE_COUNT_1_BIT;
   VulkanGraphicsPipeline.MultisampleState.SampleShadingEnable:=false;
   VulkanGraphicsPipeline.MultisampleState.MinSampleShading:=0.0;
   VulkanGraphicsPipeline.MultisampleState.CountSampleMasks:=0;
   VulkanGraphicsPipeline.MultisampleState.AlphaToCoverageEnable:=false;
   VulkanGraphicsPipeline.MultisampleState.AlphaToOneEnable:=false;

   VulkanGraphicsPipeline.ColorBlendState.LogicOpEnable:=false;
   VulkanGraphicsPipeline.ColorBlendState.LogicOp:=VK_LOGIC_OP_COPY;
   VulkanGraphicsPipeline.ColorBlendState.BlendConstants[0]:=0.0;
   VulkanGraphicsPipeline.ColorBlendState.BlendConstants[1]:=0.0;
   VulkanGraphicsPipeline.ColorBlendState.BlendConstants[2]:=0.0;
   VulkanGraphicsPipeline.ColorBlendState.BlendConstants[3]:=0.0;
   case BlendingModeIndex of
    vsbbmAlphaBlending:begin
     // Normal alpha-blending
     VulkanGraphicsPipeline.ColorBlendState.AddColorBlendAttachmentState(true,
                                                                         VK_BLEND_FACTOR_SRC_ALPHA,
                                                                         VK_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA,
                                                                         VK_BLEND_OP_ADD,
                                                                         VK_BLEND_FACTOR_SRC_ALPHA,
                                                                         VK_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA,
                                                                         VK_BLEND_OP_ADD,
                                                                         TVkColorComponentFlags(VK_COLOR_COMPONENT_R_BIT) or
                                                                         TVkColorComponentFlags(VK_COLOR_COMPONENT_G_BIT) or
                                                                         TVkColorComponentFlags(VK_COLOR_COMPONENT_B_BIT) or
                                                                         TVkColorComponentFlags(VK_COLOR_COMPONENT_A_BIT));
    end;
    vsbbmAdditiveBlending:begin
     // Source-Alpha-channel-controlled additive blending
     VulkanGraphicsPipeline.ColorBlendState.AddColorBlendAttachmentState(true,
                                                                         VK_BLEND_FACTOR_SRC_ALPHA,
                                                                         VK_BLEND_FACTOR_ONE,
                                                                         VK_BLEND_OP_ADD,
                                                                         VK_BLEND_FACTOR_SRC_ALPHA,
                                                                         VK_BLEND_FACTOR_ONE,
                                                                         VK_BLEND_OP_ADD,
                                                                         TVkColorComponentFlags(VK_COLOR_COMPONENT_R_BIT) or
                                                                         TVkColorComponentFlags(VK_COLOR_COMPONENT_G_BIT) or
                                                                         TVkColorComponentFlags(VK_COLOR_COMPONENT_B_BIT) or
                                                                         TVkColorComponentFlags(VK_COLOR_COMPONENT_A_BIT));
    end;
    else begin
     VulkanGraphicsPipeline.ColorBlendState.AddColorBlendAttachmentState(false,
                                                                          VK_BLEND_FACTOR_SRC_ALPHA,
                                                                          VK_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA,
                                                                          VK_BLEND_OP_ADD,
                                                                          VK_BLEND_FACTOR_SRC_ALPHA,
                                                                          VK_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA,
                                                                          VK_BLEND_OP_ADD,
                                                                          TVkColorComponentFlags(VK_COLOR_COMPONENT_R_BIT) or
                                                                          TVkColorComponentFlags(VK_COLOR_COMPONENT_G_BIT) or
                                                                          TVkColorComponentFlags(VK_COLOR_COMPONENT_B_BIT) or
                                                                          TVkColorComponentFlags(VK_COLOR_COMPONENT_A_BIT));
    end;
   end;
   VulkanGraphicsPipeline.DepthStencilState.DepthTestEnable:=false;
   VulkanGraphicsPipeline.DepthStencilState.DepthWriteEnable:=false;
   VulkanGraphicsPipeline.DepthStencilState.DepthCompareOp:=VK_COMPARE_OP_ALWAYS;
   VulkanGraphicsPipeline.DepthStencilState.DepthBoundsTestEnable:=false;
   VulkanGraphicsPipeline.DepthStencilState.StencilTestEnable:=false;

   VulkanGraphicsPipeline.DynamicState.AddDynamicStates([VK_DYNAMIC_STATE_VIEWPORT,
                                                         VK_DYNAMIC_STATE_SCISSOR]);

   VulkanGraphicsPipeline.Initialize;

   VulkanGraphicsPipeline.FreeMemory;

  end;

 end;

 fCurrentFillSpriteBatchBuffer:=nil;

end;

destructor TVulkanSpriteBatch.Destroy;
var Index,SubIndex:TVkInt32;
    RenderingModeIndex:TVulkanSpriteBatchRenderingMode;
    BlendingModeIndex:TVulkanSpriteBatchBlendingMode;
    VulkanSpriteBatchBuffer:PVulkanSpriteBatchBuffer;
begin

 for RenderingModeIndex:=Low(TVulkanSpriteBatchRenderingMode) to High(TVulkanSpriteBatchRenderingMode) do begin
  for BlendingModeIndex:=Low(TVulkanSpriteBatchBlendingMode) to High(TVulkanSpriteBatchBlendingMode) do begin
   FreeAndNil(fVulkanGraphicsPipelines[RenderingModeIndex,BlendingModeIndex]);
  end;
 end;

 FreeAndNil(fVulkanPipelineLayout);

//FreeAndNil(fVulkanRenderPass);

 for Index:=0 to fCountVulkanDescriptorSets-1 do begin
  FreeAndNil(fVulkanDescriptorSets[Index]);
 end;

 fVulkanDescriptorSets:=nil;

 FreeAndNil(fVulkanDescriptorSetLayout);

 FreeAndNil(fVulkanDescriptorPool);

 FreeAndNil(fVulkanTextureDescriptorSetHashMap);

 FreeAndNil(fVulkanPipelineFontShaderStageTriangleVertex);

 FreeAndNil(fVulkanPipelineFontShaderStageTriangleFragment);

 FreeAndNil(fVulkanPipelineSpriteBatchShaderStageTriangleVertex);

 FreeAndNil(fVulkanPipelineSpriteBatchShaderStageTriangleFragment);

 FreeAndNil(fSpriteBatchVertexShaderModule);

 FreeAndNil(fSpriteBatchFragmentShaderModule);

 FreeAndNil(fFontVertexShaderModule);

 FreeAndNil(fFontFragmentShaderModule);

 for Index:=0 to length(fVulkanSpriteBatchBuffers)-1 do begin
  VulkanSpriteBatchBuffer:=@fVulkanSpriteBatchBuffers[Index];
  for SubIndex:=0 to VulkanSpriteBatchBuffer^.fCountVulkanVertexBuffers-1 do begin
   FreeAndNil(VulkanSpriteBatchBuffer^.fVulkanVertexBuffers[SubIndex]);
  end;
  VulkanSpriteBatchBuffer^.fVulkanVertexBuffers:=nil;
  VulkanSpriteBatchBuffer^.fVulkanVertexDataBuffers:=nil;
  VulkanSpriteBatchBuffer^.fVulkanVertexDataBufferSizes:=nil;
  VulkanSpriteBatchBuffer^.fQueueItems:=nil;
 end;

 FreeAndNil(fVulkanIndexBuffer);

 fCurrentDestinationVertexDataBuffer:=nil;

 inherited Destroy;
end;

function TVulkanSpriteBatch.RotatePoint(const PointToRotate,AroundPoint:TVulkanSpritePoint;Cosinus,Sinus:single):TVulkanSpritePoint;
var x,y:single;
begin
 x:=PointToRotate.x-AroundPoint.x;
 y:=PointToRotate.y-AroundPoint.y;
 result.x:=(((((x*Cosinus)-(y*Sinus))+AroundPoint.x)*fInverseWidth)-0.5)*2;
 result.y:=(((((x*Sinus)+(y*Cosinus))+AroundPoint.y)*fInverseHeight)-0.5)*2;
end;

procedure TVulkanSpriteBatch.SetRenderingMode(aRenderingMode:TVulkanSpriteBatchRenderingMode);
begin
 if fRenderingMode<>aRenderingMode then begin
  Flush;
  fRenderingMode:=aRenderingMode;
 end;
end;

procedure TVulkanSpriteBatch.SetBlendingMode(aBlendingMode:TVulkanSpriteBatchBlendingMode);
begin
 if fBlendingMode<>aBlendingMode then begin
  Flush;
  fBlendingMode:=aBlendingMode;
 end;
end;

procedure TVulkanSpriteBatch.Start(const aBufferIndex:TVkInt32);
begin

 fInverseWidth:=1.0/fWidth;
 fInverseHeight:=1.0/fHeight;

 fLastTexture:=nil;

 fVertexBufferUsed:=0;
 fIndexBufferUsed:=0;

 fCurrentVulkanVertexBufferIndex:=0;

 fRenderingMode:=vsbrmNormal;

 fBlendingMode:=vsbbmAlphaBlending;

 fCurrentFillSpriteBatchBuffer:=@fVulkanSpriteBatchBuffers[aBufferIndex];
 fCurrentFillSpriteBatchBuffer^.fCountQueueItems:=0;
 fCurrentFillSpriteBatchBuffer^.fCountUsedVertexBuffers:=0;

 fScissor.offset.x:=trunc(floor(fViewport.x));
 fScissor.offset.y:=trunc(floor(fViewport.y));
 fScissor.extent.Width:=trunc(ceil(fViewport.Width));
 fScissor.extent.Height:=trunc(ceil(fViewport.Height));

 GetNextDestinationVertexBuffer;

end;

procedure TVulkanSpriteBatch.Stop;
begin

 Flush;

 fCurrentFillSpriteBatchBuffer:=nil;

end;

procedure TVulkanSpriteBatch.GetNextDestinationVertexBuffer;
var CurrentVulkanVertexBufferIndex,OldCount,NewCount:TVkInt32;
begin

 CurrentVulkanVertexBufferIndex:=fCurrentVulkanVertexBufferIndex;

 OldCount:=fCurrentFillSpriteBatchBuffer^.fCountVulkanVertexBuffers;
 if OldCount<=CurrentVulkanVertexBufferIndex then begin
  NewCount:=(CurrentVulkanVertexBufferIndex+1)*2;
  SetLength(fCurrentFillSpriteBatchBuffer^.fVulkanVertexBuffers,NewCount);
  SetLength(fCurrentFillSpriteBatchBuffer^.fVulkanVertexDataBuffers,NewCount);
  SetLength(fCurrentFillSpriteBatchBuffer^.fVulkanVertexDataBufferSizes,NewCount);
  FillChar(fCurrentFillSpriteBatchBuffer^.fVulkanVertexBuffers[OldCount],(NewCount-OldCount)*SizeOf(TVulkanBuffer),#0);
  FillChar(fCurrentFillSpriteBatchBuffer^.fVulkanVertexDataBufferSizes[OldCount],(NewCount-OldCount)*SizeOf(TVkSizeInt),#0);
  fCurrentFillSpriteBatchBuffer^.fCountVulkanVertexBuffers:=NewCount;
 end;

 fCurrentDestinationVertexDataBuffer:=@fCurrentFillSpriteBatchBuffer^.fVulkanVertexDataBuffers[CurrentVulkanVertexBufferIndex][0];

end;

procedure TVulkanSpriteBatch.Flush;
var CurrentVulkanVertexBufferIndex,OldCount,NewCount,QueueItemIndex,DescriptorSetIndex:TVkInt32;
    QueueItem:PVulkanSpriteBatchQueueItem;
    PointerHashMapEntity:PVulkanPointerHashMapEntity;
    VulkanDescriptorSet:TVulkanDescriptorSet;
begin
 if assigned(fCurrentFillSpriteBatchBuffer) and (fVertexBufferUsed>0) then begin

  while InterlockedCompareExchange(fCurrentFillSpriteBatchBuffer^.fSpinLock,-1,0)<>0 do begin
  end;
  try

   CurrentVulkanVertexBufferIndex:=fCurrentVulkanVertexBufferIndex;
   inc(fCurrentVulkanVertexBufferIndex);

   fCurrentFillSpriteBatchBuffer^.fCountUsedVertexBuffers:=Max(fCurrentFillSpriteBatchBuffer^.fCountUsedVertexBuffers,CurrentVulkanVertexBufferIndex+1);

   OldCount:=fCurrentFillSpriteBatchBuffer^.fCountVulkanVertexBuffers;
   if OldCount<=CurrentVulkanVertexBufferIndex then begin
    NewCount:=(CurrentVulkanVertexBufferIndex+1)*2;
    SetLength(fCurrentFillSpriteBatchBuffer^.fVulkanVertexBuffers,NewCount);
    SetLength(fCurrentFillSpriteBatchBuffer^.fVulkanVertexDataBuffers,NewCount);
    SetLength(fCurrentFillSpriteBatchBuffer^.fVulkanVertexDataBufferSizes,NewCount);
    FillChar(fCurrentFillSpriteBatchBuffer^.fVulkanVertexBuffers[OldCount],(NewCount-OldCount)*SizeOf(TVulkanBuffer),#0);
    FillChar(fCurrentFillSpriteBatchBuffer^.fVulkanVertexDataBufferSizes[OldCount],(NewCount-OldCount)*SizeOf(TVkSizeInt),#0);
    fCurrentFillSpriteBatchBuffer^.fCountVulkanVertexBuffers:=NewCount;
   end;

   fCurrentFillSpriteBatchBuffer^.fVulkanVertexDataBufferSizes[CurrentVulkanVertexBufferIndex]:=fVertexBufferUsed*SizeOf(TVulkanSpriteBatchVertex);

   PointerHashMapEntity:=fVulkanTextureDescriptorSetHashMap.Get(fLastTexture,false);
   if assigned(PointerHashMapEntity) then begin
    DescriptorSetIndex:=TVkPtrUInt(PointerHashMapEntity^.Value);
   end else begin
    DescriptorSetIndex:=fCountVulkanDescriptorSets;
    inc(fCountVulkanDescriptorSets);
    if length(fVulkanDescriptorSets)<fCountVulkanDescriptorSets then begin
     SetLength(fVulkanDescriptorSets,fCountVulkanDescriptorSets*2);
    end;
    VulkanDescriptorSet:=TVulkanDescriptorSet.Create(fVulkanDescriptorPool,
                                                     fVulkanDescriptorSetLayout);
    VulkanDescriptorSet.WriteToDescriptorSet(0,
                                             0,
                                             1,
                                             TVkDescriptorType(VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER),
                                             [fLastTexture.fTexture.DescriptorImageInfo],
                                             [],
                                             [],
                                             false
                                            );
    VulkanDescriptorSet.Flush;
    fVulkanDescriptorSets[DescriptorSetIndex]:=VulkanDescriptorSet;
    fVulkanTextureDescriptorSetHashMap.Add(fLastTexture,TVkPointer(TVkPtrUInt(DescriptorSetIndex)));
   end;


   QueueItemIndex:=fCurrentFillSpriteBatchBuffer^.fCountQueueItems;
   inc(fCurrentFillSpriteBatchBuffer^.fCountQueueItems);
   if length(fCurrentFillSpriteBatchBuffer^.fQueueItems)<fCurrentFillSpriteBatchBuffer^.fCountQueueItems then begin
    SetLength(fCurrentFillSpriteBatchBuffer^.fQueueItems,fCurrentFillSpriteBatchBuffer^.fCountQueueItems*2);
   end;
   QueueItem:=@fCurrentFillSpriteBatchBuffer^.fQueueItems[QueueItemIndex];
   QueueItem^.BufferIndex:=CurrentVulkanVertexBufferIndex;
   QueueItem^.DescriptorSetIndex:=DescriptorSetIndex;
   QueueItem^.CountVertices:=fVertexBufferUsed;
   QueueItem^.CountIndices:=fIndexBufferUsed;
   QueueItem^.RenderingMode:=fRenderingMode;
   QueueItem^.BlendingMode:=fBlendingMode;
   QueueItem^.Scissor:=fScissor;

  finally
   InterlockedExchange(fCurrentFillSpriteBatchBuffer^.fSpinLock,0);
  end;

  fVertexBufferUsed:=0;
  fIndexBufferUsed:=0;

  GetNextDestinationVertexBuffer;

 end;
end;

procedure TVulkanSpriteBatch.SetTexture(const Texture:TVulkanSpriteTexture);
begin
 if fLastTexture<>Texture then begin
  Flush;
  fLastTexture:=Texture;
  fInverseTextureWidth:=1.0/Texture.Width;
  fInverseTextureHeight:=1.0/Texture.Height;
 end;
end;

procedure TVulkanSpriteBatch.SetScissor(const aScissor:TVkRect2D);
begin
 if (fScissor.offset.x<>aScissor.offset.x) or
    (fScissor.offset.y<>aScissor.offset.y) or
    (fScissor.extent.Width<>aScissor.extent.Width) or
    (fScissor.extent.Height<>aScissor.extent.Height) then begin
  Flush;
  fScissor:=aScissor;
 end;
end;

procedure TVulkanSpriteBatch.SetScissor(const aLeft,aTop,aWidth,aHeight:TVkInt32);
var NewScissor:TVkRect2D;
begin
 NewScissor.offset.x:=aLeft;
 NewScissor.offset.y:=aTop;
 NewScissor.extent.Width:=aWidth;
 NewScissor.extent.Height:=aHeight;
 SetScissor(NewScissor);
end;

procedure TVulkanSpriteBatch.Hook(const aHook:TVulkanSpriteBatchHook;const aData:TVkPointer);
var QueueItemIndex:TVkInt32;
    QueueItem:PVulkanSpriteBatchQueueItem;
begin
 if assigned(aHook) then begin

  Flush;
                            
  QueueItemIndex:=fCurrentFillSpriteBatchBuffer^.fCountQueueItems;
  inc(fCurrentFillSpriteBatchBuffer^.fCountQueueItems);
  if length(fCurrentFillSpriteBatchBuffer^.fQueueItems)<fCurrentFillSpriteBatchBuffer^.fCountQueueItems then begin
   SetLength(fCurrentFillSpriteBatchBuffer^.fQueueItems,fCurrentFillSpriteBatchBuffer^.fCountQueueItems*2);
  end;
  QueueItem:=@fCurrentFillSpriteBatchBuffer^.fQueueItems[QueueItemIndex];
  QueueItem^.BufferIndex:=-1;
  QueueItem^.Hook:=aHook;
  QueueItem^.HookData:=aData;

 end;
end;

procedure TVulkanSpriteBatch.Draw(const Texture:TVulkanSpriteTexture;const Src,Dest:TVulkanSpriteRect;const Color:TVulkanSpriteColor);
var sX0,sY0,sX1,sY1:single;
begin
 SetTexture(Texture);
 sX0:=Src.Left*fInverseTextureWidth;
 sY0:=Src.Top*fInverseTextureHeight;
 sX1:=Src.Right*fInverseTextureWidth;
 sY1:=Src.Bottom*fInverseTextureHeight;
 fCurrentDestinationVertexDataBuffer^[fVertexBufferUsed].Position.x:=((Dest.Left*fInverseWidth)-0.5)*2;
 fCurrentDestinationVertexDataBuffer^[fVertexBufferUsed].Position.y:=((Dest.Top*fInverseHeight)-0.5)*2;
 fCurrentDestinationVertexDataBuffer^[fVertexBufferUsed].TextureCoord.x:=sX0;
 fCurrentDestinationVertexDataBuffer^[fVertexBufferUsed].TextureCoord.y:=sY0;
 fCurrentDestinationVertexDataBuffer^[fVertexBufferUsed].Color:=Color;
 inc(fVertexBufferUsed);
 fCurrentDestinationVertexDataBuffer^[fVertexBufferUsed].Position.x:=((Dest.Right*fInverseWidth)-0.5)*2;
 fCurrentDestinationVertexDataBuffer^[fVertexBufferUsed].Position.y:=((Dest.Top*fInverseHeight)-0.5)*2;
 fCurrentDestinationVertexDataBuffer^[fVertexBufferUsed].TextureCoord.x:=sX1;
 fCurrentDestinationVertexDataBuffer^[fVertexBufferUsed].TextureCoord.y:=sY0;
 fCurrentDestinationVertexDataBuffer^[fVertexBufferUsed].Color:=Color;
 inc(fVertexBufferUsed);
 fCurrentDestinationVertexDataBuffer^[fVertexBufferUsed].Position.x:=((Dest.Right*fInverseWidth)-0.5)*2;
 fCurrentDestinationVertexDataBuffer^[fVertexBufferUsed].Position.y:=((Dest.Bottom*fInverseHeight)-0.5)*2;
 fCurrentDestinationVertexDataBuffer^[fVertexBufferUsed].TextureCoord.x:=sX1;
 fCurrentDestinationVertexDataBuffer^[fVertexBufferUsed].TextureCoord.y:=sY1;
 fCurrentDestinationVertexDataBuffer^[fVertexBufferUsed].Color:=Color;
 inc(fVertexBufferUsed);
 fCurrentDestinationVertexDataBuffer^[fVertexBufferUsed].Position.x:=((Dest.Left*fInverseWidth)-0.5)*2;
 fCurrentDestinationVertexDataBuffer^[fVertexBufferUsed].Position.y:=((Dest.Bottom*fInverseHeight)-0.5)*2;
 fCurrentDestinationVertexDataBuffer^[fVertexBufferUsed].TextureCoord.x:=sX0;
 fCurrentDestinationVertexDataBuffer^[fVertexBufferUsed].TextureCoord.y:=sY1;
 fCurrentDestinationVertexDataBuffer^[fVertexBufferUsed].Color:=Color;
 inc(fVertexBufferUsed);
 inc(fIndexBufferUsed,6);
 if fVertexBufferUsed>=fVertexBufferCount then begin
  Flush;
 end;
end;

procedure TVulkanSpriteBatch.Draw(const Texture:TVulkanSpriteTexture;Dest:TVulkanSpriteRect;const Color:TVulkanSpriteColor);
var Src:TVulkanSpriteRect;
begin
 Src.Left:=0;
 Src.Top:=0;
 Src.Right:=Texture.Width;
 Src.Bottom:=Texture.Height;
 Dest.Right:=Texture.Width;
 Dest.Bottom:=Texture.Height;
 Draw(Texture,Src,Dest,Color);
end;

procedure TVulkanSpriteBatch.Draw(const Texture:TVulkanSpriteTexture;const x,y:single;const Color:TVulkanSpriteColor);
var Src,Dest:TVulkanSpriteRect;
begin
 Src.Left:=0;
 Src.Top:=0;
 Src.Right:=Texture.Width;
 Src.Bottom:=Texture.Height;
 Dest.Left:=x;
 Dest.Top:=y;
 Dest.Right:=x+Texture.Width;
 Dest.Bottom:=y+Texture.Height;
 Draw(Texture,Src,Dest,Color);
end;

procedure TVulkanSpriteBatch.Draw(const Texture:TVulkanSpriteTexture;const x,y:single);
var Src,Dest:TVulkanSpriteRect;
    Color:TVulkanSpriteColor;
begin
 Src.Left:=0;
 Src.Top:=0;
 Src.Right:=Texture.Width;
 Src.Bottom:=Texture.Height;
 Dest.Left:=x;
 Dest.Top:=y;
 Dest.Right:=x+Texture.Width;
 Dest.Bottom:=y+Texture.Height;
 Color.r:=1.0;
 Color.g:=1.0;
 Color.b:=1.0;
 Color.a:=1.0;
 Draw(Texture,Src,Dest,Color);
end;

procedure TVulkanSpriteBatch.Draw(const Texture:TVulkanSpriteTexture;const sx1,sy1,sx2,sy2,dx1,dy1,dx2,dy2,Alpha:single);
var Src,Dest:TVulkanSpriteRect;
    Color:TVulkanSpriteColor;
begin
 Dest.Left:=dx1;
 Dest.Top:=dy1;
 Dest.Right:=dx2;
 Dest.Bottom:=dy2;
 Src.Left:=sx1;
 Src.Top:=sy1;
 Src.Right:=sx2;
 Src.Bottom:=sy2;
 Color.r:=1;
 Color.g:=1;
 Color.b:=1;
 Color.a:=Alpha;
 Draw(Texture,Src,Dest,Color);
end;

procedure TVulkanSpriteBatch.Draw(const Texture:TVulkanSpriteTexture;const Src:TVulkanSpriteRect;Dest:TVulkanSpriteRect;const Origin:TVulkanSpritePoint;const Color:TVulkanSpriteColor);
begin
 Dest.Left:=Dest.Left-Origin.x;
 Dest.Top:=Dest.Top-Origin.y;
 Dest.Right:=Dest.Right-Origin.x;
 Dest.Bottom:=Dest.Bottom-Origin.y;
 Draw(Texture,Src,Dest,Color);
end;

procedure TVulkanSpriteBatch.Draw(const Texture:TVulkanSpriteTexture;const Src,Dest:TVulkanSpriteRect;const Origin:TVulkanSpritePoint;Rotation:single;const Color:TVulkanSpriteColor);
var Cosinus,Sinus,sX0,sY0,sX1,sY1:single;
    AroundPoint:TVulkanSpritePoint;
    Points:array[0..3] of TVulkanSpritePoint;
begin
 Cosinus:=cos(Rotation);
 Sinus:=sin(Rotation);
 AroundPoint.x:=Dest.Left+Origin.x;
 AroundPoint.y:=Dest.Top+Origin.y;
 Points[0].x:=Dest.Left;
 Points[0].y:=Dest.Top;
 Points[1].x:=Dest.Right;
 Points[1].y:=Dest.Top;
 Points[2].x:=Dest.Right;
 Points[2].y:=Dest.Bottom;
 Points[3].x:=Dest.Left;
 Points[3].y:=Dest.Bottom;
 sX0:=Src.Left*fInverseTextureWidth;
 sY0:=Src.Top*fInverseTextureHeight;
 sX1:=Src.Right*fInverseTextureWidth;
 sY1:=Src.Bottom*fInverseTextureHeight;
 fCurrentDestinationVertexDataBuffer^[fVertexBufferUsed].Position:=RotatePoint(Points[0],AroundPoint,Cosinus,Sinus);
 fCurrentDestinationVertexDataBuffer^[fVertexBufferUsed].TextureCoord.x:=sX0;
 fCurrentDestinationVertexDataBuffer^[fVertexBufferUsed].TextureCoord.y:=sY0;
 fCurrentDestinationVertexDataBuffer^[fVertexBufferUsed].Color:=Color;
 inc(fVertexBufferUsed);
 fCurrentDestinationVertexDataBuffer^[fVertexBufferUsed].Position:=RotatePoint(Points[1],AroundPoint,Cosinus,Sinus);
 fCurrentDestinationVertexDataBuffer^[fVertexBufferUsed].TextureCoord.x:=sX1;
 fCurrentDestinationVertexDataBuffer^[fVertexBufferUsed].TextureCoord.y:=sY0;
 fCurrentDestinationVertexDataBuffer^[fVertexBufferUsed].Color:=Color;
 inc(fVertexBufferUsed);
 fCurrentDestinationVertexDataBuffer^[fVertexBufferUsed].Position:=RotatePoint(Points[2],AroundPoint,Cosinus,Sinus);
 fCurrentDestinationVertexDataBuffer^[fVertexBufferUsed].TextureCoord.x:=sX1;
 fCurrentDestinationVertexDataBuffer^[fVertexBufferUsed].TextureCoord.y:=sY1;
 fCurrentDestinationVertexDataBuffer^[fVertexBufferUsed].Color:=Color;
 inc(fVertexBufferUsed);
 fCurrentDestinationVertexDataBuffer^[fVertexBufferUsed].Position:=RotatePoint(Points[3],AroundPoint,Cosinus,Sinus);
 fCurrentDestinationVertexDataBuffer^[fVertexBufferUsed].TextureCoord.x:=sX0;
 fCurrentDestinationVertexDataBuffer^[fVertexBufferUsed].TextureCoord.y:=sY1;
 fCurrentDestinationVertexDataBuffer^[fVertexBufferUsed].Color:=Color;
 inc(fVertexBufferUsed);
 inc(fIndexBufferUsed,6);
 if fVertexBufferUsed>=fVertexBufferCount then begin
  Flush;
 end;
end;

procedure TVulkanSpriteBatch.Draw(const Sprite:TVulkanSprite;const Src,Dest:TVulkanSpriteRect;const Color:TVulkanSpriteColor);
const MinA=1.0/1024.0;
var tx1,ty1,tx2,ty2,xf,yf,sX0,sY0,sX1,sY1:single;
    TempDest,TempSrc:TVulkanSpriteRect;
begin
 if (abs(Color.a)>MinA) and
    (((Src.Right>=Sprite.TrimmedX) and (Src.Bottom>=Sprite.TrimmedY)) and
    (((not Sprite.Rotated) and (((Sprite.TrimmedX+Sprite.TrimmedWidth)>=Src.Left) and ((Sprite.TrimmedY+Sprite.TrimmedHeight)>=Src.Top))) or
     (Sprite.Rotated and (((Sprite.TrimmedX+Sprite.TrimmedHeight)>=Src.Left) and ((Sprite.TrimmedY+Sprite.TrimmedWidth)>=Src.Top))))) then begin
  SetTexture(Sprite.Texture);
  if Sprite.Rotated then begin
   tx1:=Max(Sprite.TrimmedX,Src.Left);
   ty1:=Max(Sprite.TrimmedY,Src.Top);
   tx2:=Min((Sprite.TrimmedX+Sprite.TrimmedHeight),Src.Right);
   ty2:=Min((Sprite.TrimmedY+Sprite.TrimmedWidth),Src.Bottom);
   xf:=abs(Dest.Right-Dest.Left)/(Src.Right-Src.Left);
   yf:=abs(Dest.Bottom-Dest.Top)/(Src.Bottom-Src.Top);
   TempDest.Left:=Dest.Left+((tx1-Src.Left)*xf);
   TempDest.Right:=Dest.Right+((tx2-Src.Right)*xf);
   TempDest.Top:=Dest.Top+((ty1-Src.Top)*yf);
   TempDest.Bottom:=Dest.Bottom+((ty2-Src.Bottom)*yf);
{  if Dest.Left<=Dest.Right then begin
    TempDest.Left:=Dest.Left+((tx1-Src.Left)*xf);
    TempDest.Right:=Dest.Right+((tx2-Src.Right)*xf);
   end else begin
    TempDest.Left:=Dest.Left+((tx2-Src.Right)*xf);
    TempDest.Right:=Dest.Right+((tx1-Src.Left)*xf);
   end;
   if Dest.Top<=Dest.Bottom then begin
    TempDest.Top:=Dest.Top+((ty1-Src.Top)*yf);
    TempDest.Bottom:=Dest.Bottom+((ty2-Src.Bottom)*yf);
   end else begin
    TempDest.Top:=Dest.Top+((ty2-Src.Bottom)*yf);
    TempDest.Bottom:=Dest.Bottom+((ty1-Src.Top)*yf);
   end;}
   TempSrc.Left:=(tx1-Sprite.TrimmedX)+Sprite.x;
   TempSrc.Top:=(ty1-Sprite.TrimmedY)+Sprite.y;
   TempSrc.Right:=TempSrc.Left+(ty2-ty1);
   TempSrc.Bottom:=TempSrc.Top+(tx2-tx1);
   sX0:=TempSrc.Left*fInverseTextureWidth;
   sY0:=TempSrc.Top*fInverseTextureHeight;
   sX1:=TempSrc.Right*fInverseTextureWidth;
   sY1:=TempSrc.Bottom*fInverseTextureHeight;
   fCurrentDestinationVertexDataBuffer^[fVertexBufferUsed].Position.x:=((TempDest.Left*fInverseWidth)-0.5)*2;
   fCurrentDestinationVertexDataBuffer^[fVertexBufferUsed].Position.y:=((TempDest.Top*fInverseHeight)-0.5)*2;
   fCurrentDestinationVertexDataBuffer^[fVertexBufferUsed].TextureCoord.x:=sX1;
   fCurrentDestinationVertexDataBuffer^[fVertexBufferUsed].TextureCoord.y:=sY0;
   fCurrentDestinationVertexDataBuffer^[fVertexBufferUsed].Color:=Color;
   inc(fVertexBufferUsed);
   fCurrentDestinationVertexDataBuffer^[fVertexBufferUsed].Position.x:=((TempDest.Right*fInverseWidth)-0.5)*2;
   fCurrentDestinationVertexDataBuffer^[fVertexBufferUsed].Position.y:=((TempDest.Top*fInverseHeight)-0.5)*2;
   fCurrentDestinationVertexDataBuffer^[fVertexBufferUsed].TextureCoord.x:=sX1;
   fCurrentDestinationVertexDataBuffer^[fVertexBufferUsed].TextureCoord.y:=sY1;
   fCurrentDestinationVertexDataBuffer^[fVertexBufferUsed].Color:=Color;
   inc(fVertexBufferUsed);
   fCurrentDestinationVertexDataBuffer^[fVertexBufferUsed].Position.x:=((TempDest.Right*fInverseWidth)-0.5)*2;
   fCurrentDestinationVertexDataBuffer^[fVertexBufferUsed].Position.y:=((TempDest.Bottom*fInverseHeight)-0.5)*2;
   fCurrentDestinationVertexDataBuffer^[fVertexBufferUsed].TextureCoord.x:=sX0;
   fCurrentDestinationVertexDataBuffer^[fVertexBufferUsed].TextureCoord.y:=sY0;
   fCurrentDestinationVertexDataBuffer^[fVertexBufferUsed].Color:=Color;
   inc(fVertexBufferUsed);
   fCurrentDestinationVertexDataBuffer^[fVertexBufferUsed].Position.x:=((TempDest.Left*fInverseWidth)-0.5)*2;
   fCurrentDestinationVertexDataBuffer^[fVertexBufferUsed].Position.y:=((TempDest.Bottom*fInverseHeight)-0.5)*2;
   fCurrentDestinationVertexDataBuffer^[fVertexBufferUsed].TextureCoord.x:=sX0;
   fCurrentDestinationVertexDataBuffer^[fVertexBufferUsed].TextureCoord.y:=sY1;
   fCurrentDestinationVertexDataBuffer^[fVertexBufferUsed].Color:=Color;
   inc(fVertexBufferUsed);
   inc(fIndexBufferUsed,6);
   if fVertexBufferUsed>=fVertexBufferCount then begin
    Flush;
   end;
  end else begin
   tx1:=Max(Sprite.TrimmedX,Src.Left);
   ty1:=Max(Sprite.TrimmedY,Src.Top);
   tx2:=Min((Sprite.TrimmedX+Sprite.TrimmedWidth),Src.Right);
   ty2:=Min((Sprite.TrimmedY+Sprite.TrimmedHeight),Src.Bottom);
   xf:=abs(Dest.Right-Dest.Left)/(Src.Right-Src.Left);
   yf:=abs(Dest.Bottom-Dest.Top)/(Src.Bottom-Src.Top);
   TempDest.Left:=Dest.Left+((tx1-Src.Left)*xf);
   TempDest.Right:=Dest.Right+((tx2-Src.Right)*xf);
   TempDest.Top:=Dest.Top+((ty1-Src.Top)*yf);
   TempDest.Bottom:=Dest.Bottom+((ty2-Src.Bottom)*yf);
{  if Dest.Left<=Dest.Right then begin
    TempDest.Left:=Dest.Left+((tx1-Src.Left)*xf);
    TempDest.Right:=Dest.Right+((tx2-Src.Right)*xf);
   end else begin
    TempDest.Left:=Dest.Left+((tx2-Src.Right)*xf);
    TempDest.Right:=Dest.Right+((tx1-Src.Left)*xf);
   end;
   if Dest.Top<=Dest.Bottom then begin
    TempDest.Top:=Dest.Top+((ty1-Src.Top)*yf);
    TempDest.Bottom:=Dest.Bottom+((ty2-Src.Bottom)*yf);
   end else begin
    TempDest.Top:=Dest.Bottom+((ty2-Src.Bottom)*yf);
    TempDest.Bottom:=Dest.Top+((ty1-Src.Top)*yf);
   end;}
   TempSrc.Left:=(tx1-Sprite.TrimmedX)+Sprite.x;
   TempSrc.Top:=(ty1-Sprite.TrimmedY)+Sprite.y;
   TempSrc.Right:=TempSrc.Left+(tx2-tx1);
   TempSrc.Bottom:=TempSrc.Top+(ty2-ty1);
   sX0:=TempSrc.Left*fInverseTextureWidth;
   sY0:=TempSrc.Top*fInverseTextureHeight;
   sX1:=TempSrc.Right*fInverseTextureWidth;
   sY1:=TempSrc.Bottom*fInverseTextureHeight;
   fCurrentDestinationVertexDataBuffer^[fVertexBufferUsed].Position.x:=((TempDest.Left*fInverseWidth)-0.5)*2;
   fCurrentDestinationVertexDataBuffer^[fVertexBufferUsed].Position.y:=((TempDest.Top*fInverseHeight)-0.5)*2;
   fCurrentDestinationVertexDataBuffer^[fVertexBufferUsed].TextureCoord.x:=sX0;
   fCurrentDestinationVertexDataBuffer^[fVertexBufferUsed].TextureCoord.y:=sY0;
   fCurrentDestinationVertexDataBuffer^[fVertexBufferUsed].Color:=Color;
   inc(fVertexBufferUsed);
   fCurrentDestinationVertexDataBuffer^[fVertexBufferUsed].Position.x:=((TempDest.Right*fInverseWidth)-0.5)*2;
   fCurrentDestinationVertexDataBuffer^[fVertexBufferUsed].Position.y:=((TempDest.Top*fInverseHeight)-0.5)*2;
   fCurrentDestinationVertexDataBuffer^[fVertexBufferUsed].TextureCoord.x:=sX1;
   fCurrentDestinationVertexDataBuffer^[fVertexBufferUsed].TextureCoord.y:=sY0;
   fCurrentDestinationVertexDataBuffer^[fVertexBufferUsed].Color:=Color;
   inc(fVertexBufferUsed);
   fCurrentDestinationVertexDataBuffer^[fVertexBufferUsed].Position.x:=((TempDest.Right*fInverseWidth)-0.5)*2;
   fCurrentDestinationVertexDataBuffer^[fVertexBufferUsed].Position.y:=((TempDest.Bottom*fInverseHeight)-0.5)*2;
   fCurrentDestinationVertexDataBuffer^[fVertexBufferUsed].TextureCoord.x:=sX1;
   fCurrentDestinationVertexDataBuffer^[fVertexBufferUsed].TextureCoord.y:=sY1;
   fCurrentDestinationVertexDataBuffer^[fVertexBufferUsed].Color:=Color;
   inc(fVertexBufferUsed);
   fCurrentDestinationVertexDataBuffer^[fVertexBufferUsed].Position.x:=((TempDest.Left*fInverseWidth)-0.5)*2;
   fCurrentDestinationVertexDataBuffer^[fVertexBufferUsed].Position.y:=((TempDest.Bottom*fInverseHeight)-0.5)*2;
   fCurrentDestinationVertexDataBuffer^[fVertexBufferUsed].TextureCoord.x:=sX0;
   fCurrentDestinationVertexDataBuffer^[fVertexBufferUsed].TextureCoord.y:=sY1;
   fCurrentDestinationVertexDataBuffer^[fVertexBufferUsed].Color:=Color;
   inc(fVertexBufferUsed);
   inc(fIndexBufferUsed,6);
   if fVertexBufferUsed>=fVertexBufferCount then begin
    Flush;
   end;
  end;
 end;
end;

procedure TVulkanSpriteBatch.Draw(const Sprite:TVulkanSprite;const Src,Dest:TVulkanSpriteRect;const Origin:TVulkanSpritePoint;Rotation:single;const Color:TVulkanSpriteColor);
const MinA=1.0/1024.0;
var Cosinus,Sinus,tx1,ty1,tx2,ty2,xf,yf,sX0,sY0,sX1,sY1:single;
    AroundPoint:TVulkanSpritePoint;
    Points:array[0..3] of TVulkanSpritePoint;
    TempDest,TempSrc:TVulkanSpriteRect;
begin
 if (abs(Color.a)>MinA) and
    (((Src.Right>=Sprite.TrimmedX) and (Src.Bottom>=Sprite.TrimmedY)) and
    (((not Sprite.Rotated) and (((Sprite.TrimmedX+Sprite.TrimmedWidth)>=Src.Left) and ((Sprite.TrimmedY+Sprite.TrimmedHeight)>=Src.Top))) or
     (Sprite.Rotated and (((Sprite.TrimmedX+Sprite.TrimmedHeight)>=Src.Left) and ((Sprite.TrimmedY+Sprite.TrimmedWidth)>=Src.Top))))) then begin
  Cosinus:=cos(Rotation);
  Sinus:=sin(Rotation);
  SetTexture(Sprite.Texture);
  if Sprite.Rotated then begin
   tx1:=Max(Sprite.TrimmedX,Src.Left);
   ty1:=Max(Sprite.TrimmedY,Src.Top);
   tx2:=Min((Sprite.TrimmedX+Sprite.TrimmedHeight),Src.Right);
   ty2:=Min((Sprite.TrimmedY+Sprite.TrimmedWidth),Src.Bottom);
   xf:=(Dest.Right-Dest.Left)/(Src.Right-Src.Left);
   yf:=(Dest.Bottom-Dest.Top)/(Src.Bottom-Src.Top);
   TempDest.Left:=Dest.Left+((tx1-Src.Left)*xf);
   TempDest.Top:=Dest.Top+((ty1-Src.Top)*yf);
   TempDest.Right:=Dest.Right+((tx2-Src.Right)*xf);
   TempDest.Bottom:=Dest.Bottom+((ty2-Src.Bottom)*yf);
   TempSrc.Left:=(tx1-Sprite.TrimmedX)+Sprite.x;
   TempSrc.Top:=(ty1-Sprite.TrimmedY)+Sprite.y;
   TempSrc.Right:=TempSrc.Left+(ty2-ty1);
   TempSrc.Bottom:=TempSrc.Top+(tx2-tx1);
   AroundPoint.x:=TempDest.Left+Origin.x;
   AroundPoint.y:=TempDest.Top+Origin.y;
   Points[0].x:=TempDest.Left;
   Points[0].y:=TempDest.Top;
   Points[1].x:=TempDest.Right;
   Points[1].y:=TempDest.Top;
   Points[2].x:=TempDest.Right;
   Points[2].y:=TempDest.Bottom;
   Points[3].x:=TempDest.Left;
   Points[3].y:=TempDest.Bottom;
   sX0:=TempSrc.Left*fInverseTextureWidth;
   sY0:=TempSrc.Top*fInverseTextureHeight;
   sX1:=TempSrc.Right*fInverseTextureWidth;
   sY1:=TempSrc.Bottom*fInverseTextureHeight;
   fCurrentDestinationVertexDataBuffer^[fVertexBufferUsed].Position:=RotatePoint(Points[0],AroundPoint,Cosinus,Sinus);
   fCurrentDestinationVertexDataBuffer^[fVertexBufferUsed].TextureCoord.x:=sX1;
   fCurrentDestinationVertexDataBuffer^[fVertexBufferUsed].TextureCoord.y:=sY0;
   fCurrentDestinationVertexDataBuffer^[fVertexBufferUsed].Color:=Color;
   inc(fVertexBufferUsed);
   fCurrentDestinationVertexDataBuffer^[fVertexBufferUsed].Position:=RotatePoint(Points[1],AroundPoint,Cosinus,Sinus);
   fCurrentDestinationVertexDataBuffer^[fVertexBufferUsed].TextureCoord.x:=sX1;
   fCurrentDestinationVertexDataBuffer^[fVertexBufferUsed].TextureCoord.y:=sY1;
   fCurrentDestinationVertexDataBuffer^[fVertexBufferUsed].Color:=Color;
   inc(fVertexBufferUsed);
   fCurrentDestinationVertexDataBuffer^[fVertexBufferUsed].Position:=RotatePoint(Points[2],AroundPoint,Cosinus,Sinus);
   fCurrentDestinationVertexDataBuffer^[fVertexBufferUsed].TextureCoord.x:=sX0;
   fCurrentDestinationVertexDataBuffer^[fVertexBufferUsed].TextureCoord.y:=sY1;
   fCurrentDestinationVertexDataBuffer^[fVertexBufferUsed].Color:=Color;
   inc(fVertexBufferUsed);
   fCurrentDestinationVertexDataBuffer^[fVertexBufferUsed].Position:=RotatePoint(Points[3],AroundPoint,Cosinus,Sinus);
   fCurrentDestinationVertexDataBuffer^[fVertexBufferUsed].TextureCoord.x:=sX0;
   fCurrentDestinationVertexDataBuffer^[fVertexBufferUsed].TextureCoord.y:=sY0;
   fCurrentDestinationVertexDataBuffer^[fVertexBufferUsed].Color:=Color;
   inc(fVertexBufferUsed);
   inc(fIndexBufferUsed,6);
   if fVertexBufferUsed>=fVertexBufferCount then begin
    Flush;
   end;
  end else begin
   tx1:=Max(Sprite.TrimmedX,Src.Left);
   ty1:=Max(Sprite.TrimmedY,Src.Top);
   tx2:=Min((Sprite.TrimmedX+Sprite.TrimmedWidth),Src.Right);
   ty2:=Min((Sprite.TrimmedY+Sprite.TrimmedHeight),Src.Bottom);
   xf:=(Dest.Right-Dest.Left)/(Src.Right-Src.Left);
   yf:=(Dest.Bottom-Dest.Top)/(Src.Bottom-Src.Top);
   TempDest.Left:=Dest.Left+((tx1-Src.Left)*xf);
   TempDest.Top:=Dest.Top+((ty1-Src.Top)*yf);
   TempDest.Right:=Dest.Right+((tx2-Src.Right)*xf);
   TempDest.Bottom:=Dest.Bottom+((ty2-Src.Bottom)*yf);
   TempSrc.Left:=(tx1-Sprite.TrimmedX)+Sprite.x;
   TempSrc.Top:=(ty1-Sprite.TrimmedY)+Sprite.y;
   TempSrc.Right:=TempSrc.Left+(tx2-tx1);
   TempSrc.Bottom:=TempSrc.Top+(ty2-ty1);
   AroundPoint.x:=TempDest.Left+Origin.x;
   AroundPoint.y:=TempDest.Top+Origin.y;
   Points[0].x:=TempDest.Left;
   Points[0].y:=TempDest.Top;
   Points[1].x:=TempDest.Right;
   Points[1].y:=TempDest.Top;
   Points[2].x:=TempDest.Right;
   Points[2].y:=TempDest.Bottom;
   Points[3].x:=TempDest.Left;
   Points[3].y:=TempDest.Bottom;
   sX0:=TempSrc.Left*fInverseTextureWidth;
   sY0:=TempSrc.Top*fInverseTextureHeight;
   sX1:=TempSrc.Right*fInverseTextureWidth;
   sY1:=TempSrc.Bottom*fInverseTextureHeight;
   fCurrentDestinationVertexDataBuffer^[fVertexBufferUsed].Position:=RotatePoint(Points[0],AroundPoint,Cosinus,Sinus);
   fCurrentDestinationVertexDataBuffer^[fVertexBufferUsed].TextureCoord.x:=sX0;
   fCurrentDestinationVertexDataBuffer^[fVertexBufferUsed].TextureCoord.y:=sY0;
   fCurrentDestinationVertexDataBuffer^[fVertexBufferUsed].Color:=Color;
   inc(fVertexBufferUsed);
   fCurrentDestinationVertexDataBuffer^[fVertexBufferUsed].Position:=RotatePoint(Points[1],AroundPoint,Cosinus,Sinus);
   fCurrentDestinationVertexDataBuffer^[fVertexBufferUsed].TextureCoord.x:=sX1;
   fCurrentDestinationVertexDataBuffer^[fVertexBufferUsed].TextureCoord.y:=sY0;
   fCurrentDestinationVertexDataBuffer^[fVertexBufferUsed].Color:=Color;
   inc(fVertexBufferUsed);
   fCurrentDestinationVertexDataBuffer^[fVertexBufferUsed].Position:=RotatePoint(Points[2],AroundPoint,Cosinus,Sinus);
   fCurrentDestinationVertexDataBuffer^[fVertexBufferUsed].TextureCoord.x:=sX1;
   fCurrentDestinationVertexDataBuffer^[fVertexBufferUsed].TextureCoord.y:=sY1;
   fCurrentDestinationVertexDataBuffer^[fVertexBufferUsed].Color:=Color;
   inc(fVertexBufferUsed);
   fCurrentDestinationVertexDataBuffer^[fVertexBufferUsed].Position:=RotatePoint(Points[3],AroundPoint,Cosinus,Sinus);
   fCurrentDestinationVertexDataBuffer^[fVertexBufferUsed].TextureCoord.x:=sX0;
   fCurrentDestinationVertexDataBuffer^[fVertexBufferUsed].TextureCoord.y:=sY1;
   fCurrentDestinationVertexDataBuffer^[fVertexBufferUsed].Color:=Color;
   inc(fVertexBufferUsed);
   inc(fIndexBufferUsed,6);
   if fVertexBufferUsed>=fVertexBufferCount then begin
    Flush;
   end;
  end;
 end;
end;

procedure TVulkanSpriteBatch.Draw(const Sprite:TVulkanSprite;const x,y:single;const Color:TVulkanSpriteColor);
var Src,Dest:TVulkanSpriteRect;
begin
 Src.Left:=0;
 Src.Top:=0;
 Src.Right:=Sprite.Width;
 Src.Bottom:=Sprite.Height;
 Dest.Left:=x;
 Dest.Top:=y;
 Dest.Right:=x+Sprite.Width;
 Dest.Bottom:=y+Sprite.Height;
 Draw(Sprite,Src,Dest,Color);
end;

procedure TVulkanSpriteBatch.Draw(const Sprite:TVulkanSprite;const x,y:single);
var Color:TVulkanSpriteColor;
begin
 Color.r:=1;
 Color.g:=1;
 Color.b:=1;
 Color.a:=1;
 Draw(Sprite,x,y,Color);
end;

procedure TVulkanSpriteBatch.Draw(const Sprite:TVulkanSprite;const sx1,sy1,sx2,sy2,dx1,dy1,dx2,dy2,Alpha:single);
var Src,Dest:TVulkanSpriteRect;
    Color:TVulkanSpriteColor;
begin
 Dest.Left:=dx1;
 Dest.Top:=dy1;
 Dest.Right:=dx2;
 Dest.Bottom:=dy2;
 Src.Left:=sx1;
 Src.Top:=sy1;
 Src.Right:=sx2;
 Src.Bottom:=sy2;
 Color.r:=1;
 Color.g:=1;
 Color.b:=1;
 Color.a:=Alpha;
 Draw(Sprite,Src,Dest,Color);
end;

procedure TVulkanSpriteBatch.DrawText(const Font:TVulkanSpriteFont;const Text:TVulkanRawByteString;x,y:single;const Color:TVulkanSpriteColor);
var Index:TVkInt32;
    Item:PVulkanSpriteFontChar;
    Dest:TVulkanSpriteRect;
begin
 Dest.Left:=x;
 Dest.Top:=y;
 for Index:=1 to length(Text) do begin
  Item:=@Font.Chars[Text[Index]];
  Dest.Right:=Dest.Left+(Item^.TextureRect.Right-Item^.TextureRect.Left);
  Dest.Bottom:=Dest.Bottom+(Item^.TextureRect.Bottom-Item^.TextureRect.Top);
  Draw(Font.Texture,Item^.TextureRect,Dest,Color);
  Dest.Left:=Dest.Left+Item^.Advance.x;
  Dest.Top:=Dest.Top+Item^.Advance.y;
 end;
end;

function NewTextureRectNode:PVulkanSpriteAtlasTextureRectNode;
begin
 GetMem(result,SizeOf(TVulkanSpriteAtlasTextureRectNode));
 FillChar(result^,SizeOf(TVulkanSpriteAtlasTextureRectNode),AnsiChar(#0));
end;

procedure FreeTextureRectNode(const Node:PVulkanSpriteAtlasTextureRectNode);
begin
 if assigned(Node) then begin
  FreeTextureRectNode(Node^.Left);
  FreeTextureRectNode(Node^.Right);
  Node^.Left:=nil;
  Node^.Right:=nil;
  FreeMem(Node);
 end;
end;

function InsertTextureRectNode(const Node:PVulkanSpriteAtlasTextureRectNode;const Width,Height,Area:TVkInt32):PVulkanSpriteAtlasTextureRectNode;
var RemainWidth,RemainHeight:TVkInt32;
begin
 result:=nil;
 if (Width<=Node^.Width) and (Height<=Node^.Height) and (Area<=Node^.FreeArea) then begin
  if assigned(Node^.Left) or assigned(Node^.Right) then begin
   // This node has children nodes, so this node has content already, so the subnodes will be processing
   if assigned(Node^.Left) then begin
    result:=InsertTextureRectNode(Node^.Left,Width,Height,Area);
    if assigned(result) then begin
     dec(Node^.FreeArea,Area);
     exit;
    end;
   end;
   if assigned(Node^.Right) then begin
    result:=InsertTextureRectNode(Node^.Right,Width,Height,Area);
    if assigned(result) then begin
     dec(Node^.FreeArea,Area);
     exit;
    end;
   end;
  end else begin
   // No children nodes, so allocate a rect here and subdivide the remained space into two subnodes
   RemainWidth:=Node^.Width-Width;
   RemainHeight:=Node^.Height-Height;
   Node^.Left:=NewTextureRectNode;
   Node^.Right:=NewTextureRectNode;
   if RemainWidth<=RemainHeight then begin
    Node^.Left^.x:=Node^.x+Width;
    Node^.Left^.y:=Node^.y;
    Node^.Left^.Width:=RemainWidth;
    Node^.Left^.Height:=Height;
    Node^.Left^.FreeArea:=Node^.Left^.Width*Node^.Left^.Height;
    Node^.Right^.x:=Node^.x;
    Node^.Right^.y:=Node^.y+Height;
    Node^.Right^.Width:=Node^.Width;
    Node^.Right^.Height:=RemainHeight;
    Node^.Right^.FreeArea:=Node^.Right^.Width*Node^.Right^.Height;
   end else begin
    Node^.Left^.x:=Node^.x;
    Node^.Left^.y:=Node^.y+Height;
    Node^.Left^.Width:=Width;
    Node^.Left^.Height:=RemainHeight;
    Node^.Left^.FreeArea:=Node^.Left^.Width*Node^.Left^.Height;
    Node^.Right^.x:=Node^.x+Width;
    Node^.Right^.y:=Node^.y;
    Node^.Right^.Width:=RemainWidth;
    Node^.Right^.Height:=Node^.Height;
    Node^.Right^.FreeArea:=Node^.Right^.Width*Node^.Right^.Height;
   end;
   Node^.Left^.ContentWidth:=0;
   Node^.Left^.ContentHeight:=0;
   Node^.Right^.ContentWidth:=0;
   Node^.Right^.ContentHeight:=0;
   Node^.ContentWidth:=Width;
   Node^.ContentHeight:=Height;
   dec(Node^.FreeArea,Area);
   result:=Node;
  end;
 end;
end;

procedure TVulkanSpriteBatch.ExecuteUpload(const aVulkanCommandBuffer:TVulkanCommandBuffer;const aBufferIndex:TVkInt32);
var Index:TVkInt32;
    CurrentDrawSpriteBatchBuffer:PVulkanSpriteBatchBuffer;
    VulkanVertexBuffer:TVulkanBuffer;
begin
 CurrentDrawSpriteBatchBuffer:=@fVulkanSpriteBatchBuffers[aBufferIndex];
 if assigned(CurrentDrawSpriteBatchBuffer) and (CurrentDrawSpriteBatchBuffer^.fCountUsedVertexBuffers>0) then begin
  while InterlockedCompareExchange(CurrentDrawSpriteBatchBuffer^.fSpinLock,-1,0)<>0 do begin
  end;
  try
   for Index:=0 to CurrentDrawSpriteBatchBuffer^.fCountUsedVertexBuffers-1 do begin
    if CurrentDrawSpriteBatchBuffer^.fVulkanVertexDataBufferSizes[Index]>0 then begin
     VulkanVertexBuffer:=CurrentDrawSpriteBatchBuffer^.fVulkanVertexBuffers[Index];
     if not assigned(VulkanVertexBuffer) then begin
      VulkanVertexBuffer:=TVulkanBuffer.Create(fDevice,
                                               fVertexBufferSize,
                                               TVkBufferUsageFlags(VK_BUFFER_USAGE_TRANSFER_DST_BIT) or TVkBufferUsageFlags(VK_BUFFER_USAGE_VERTEX_BUFFER_BIT),
                                               TVkSharingMode(VK_SHARING_MODE_EXCLUSIVE),
                                               nil,
                                               TVkMemoryPropertyFlags(VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT) {or TVkMemoryPropertyFlags(VK_MEMORY_PROPERTY_HOST_COHERENT_BIT)},
                                               0,
                                               0,
                                               0,
                                               0,
                                               0,
                                               [vbfPersistentMapped]
                                              );
      CurrentDrawSpriteBatchBuffer^.fVulkanVertexBuffers[Index]:=VulkanVertexBuffer;
     end;
     if assigned(VulkanVertexBuffer) then begin
      VulkanVertexBuffer.UploadData(fTransferQueue,
                                    fTransferCommandBuffer,
                                    fTransferFence,
                                    CurrentDrawSpriteBatchBuffer^.fVulkanVertexDataBuffers[Index,0],
                                    0,
                                    CurrentDrawSpriteBatchBuffer^.fVulkanVertexDataBufferSizes[Index],
                                    vbutsbmNo);
     end;
    end;
   end;
  finally
   InterlockedExchange(CurrentDrawSpriteBatchBuffer^.fSpinLock,0);
  end;
{ aVulkanCommandBuffer.MetaCmdMemoryBarrier(TVkPipelineStageFlags(VK_PIPELINE_STAGE_HOST_BIT),
                                            TVkPipelineStageFlags(VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT),
                                            TVkAccessFlags(VK_ACCESS_HOST_WRITE_BIT),
                                            TVkAccessFlags(VK_ACCESS_UNIFORM_READ_BIT) or TVkAccessFlags(VK_ACCESS_SHADER_READ_BIT) or TVkAccessFlags(VK_ACCESS_SHADER_READ_BIT));}
 end;
end;

procedure TVulkanSpriteBatch.ExecuteDraw(const aVulkanCommandBuffer:TVulkanCommandBuffer;const aBufferIndex:TVkInt32);
const Offsets:array[0..0] of TVkDeviceSize=(0);
var Index,DescriptorSetIndex:TVkInt32;
    QueueItem:PVulkanSpriteBatchQueueItem;
    CurrentDrawSpriteBatchBuffer:PVulkanSpriteBatchBuffer;
    VulkanVertexBuffer:TVulkanBuffer;
    OldScissor:TVkRect2D;
    OldRenderingMode:TVulkanSpriteBatchRenderingMode;
    OldBlendingMode:TVulkanSpriteBatchBlendingMode;
    ForceUpdate:boolean;
begin
 CurrentDrawSpriteBatchBuffer:=@fVulkanSpriteBatchBuffers[aBufferIndex];
 if assigned(CurrentDrawSpriteBatchBuffer) and (CurrentDrawSpriteBatchBuffer^.fCountQueueItems>0) then begin

  OldScissor.offset.x:=-$7fffffff;
  OldScissor.offset.y:=-$7fffffff;
  OldScissor.extent.Width:=$7fffffff;
  OldScissor.extent.Height:=$7fffffff;

  OldRenderingMode:=vsbrmNormal;

  OldBlendingMode:=vsbbmAlphaBlending;

  DescriptorSetIndex:=-1;

  ForceUpdate:=true;

  for Index:=0 to CurrentDrawSpriteBatchBuffer^.fCountQueueItems-1 do begin

   QueueItem:=@CurrentDrawSpriteBatchBuffer^.fQueueItems[Index];

   if QueueItem^.BufferIndex<0 then begin

    if assigned(QueueItem^.Hook) then begin
     QueueItem^.Hook(QueueItem^.HookData);
    end;

    ForceUpdate:=true;

   end else begin

    VulkanVertexBuffer:=CurrentDrawSpriteBatchBuffer^.fVulkanVertexBuffers[QueueItem^.BufferIndex];

    if ForceUpdate then begin

     aVulkanCommandBuffer.CmdBindIndexBuffer(fVulkanIndexBuffer.Handle,0,VK_INDEX_TYPE_UINT32);

     aVulkanCommandBuffer.CmdSetViewport(0,1,fPointerToViewport);

    end;

    if ForceUpdate or
       (DescriptorSetIndex<>QueueItem^.DescriptorSetIndex) then begin

     DescriptorSetIndex:=QueueItem^.DescriptorSetIndex;

     aVulkanCommandBuffer.CmdBindDescriptorSets(VK_PIPELINE_BIND_POINT_GRAPHICS,fVulkanPipelineLayout.Handle,0,1,@fVulkanDescriptorSets[DescriptorSetIndex].Handle,0,nil);

    end;

    if ForceUpdate or
       (OldRenderingMode<>QueueItem^.RenderingMode) or
       (OldBlendingMode<>QueueItem^.BlendingMode) then begin

     OldRenderingMode:=QueueItem^.RenderingMode;

     OldBlendingMode:=QueueItem^.BlendingMode;

     aVulkanCommandBuffer.CmdBindPipeline(VK_PIPELINE_BIND_POINT_GRAPHICS,fVulkanGraphicsPipelines[QueueItem^.RenderingMode,QueueItem^.BlendingMode].Handle);

     OldScissor.offset.x:=-$7fffffff;
     OldScissor.offset.y:=-$7fffffff;
     OldScissor.extent.Width:=$7fffffff;
     OldScissor.extent.Height:=$7fffffff;

    end;

    if ForceUpdate or
       (OldScissor.offset.x<>QueueItem^.Scissor.offset.x) or
       (OldScissor.offset.y<>QueueItem^.Scissor.offset.y) or
       (OldScissor.extent.Width<>QueueItem^.Scissor.extent.Width) or
       (OldScissor.extent.Height<>QueueItem^.Scissor.extent.Height) then begin

     OldScissor:=QueueItem^.Scissor;

     aVulkanCommandBuffer.CmdSetScissor(0,1,@QueueItem^.Scissor);

    end;

    aVulkanCommandBuffer.CmdBindVertexBuffers(0,1,@VulkanVertexBuffer.Handle,@Offsets);
    aVulkanCommandBuffer.CmdDrawIndexed(QueueItem^.CountIndices,1,0,0,0);

    ForceUpdate:=false;

   end;

  end;

  CurrentDrawSpriteBatchBuffer^.fCountQueueItems:=0;
  CurrentDrawSpriteBatchBuffer^.fCountUsedVertexBuffers:=0;

 end;
end;

constructor TVulkanSpriteAtlas.Create(const aDevice:TVulkanDevice);
begin
 fDevice:=aDevice;
 fTextureList:=nil;
 fList:=TList.Create;
 fHashMap:=TVulkanStringHashMap.Create;
 fIsUploaded:=false;
 fMipMaps:=true;
 fAutomaticTrim:=true;
 inherited Create;
end;

destructor TVulkanSpriteAtlas.Destroy;
var Texture,NextTexture:PVulkanSpriteAtlasTexture;
begin
 Unload;
 Texture:=fTextureList;
 while assigned(Texture) do begin
  NextTexture:=Texture^.Next;
  FreeTextureRectNode(Texture^.RootNode);
  FreeAndNil(Texture^.Texture);
  FreeMem(Texture^.Data);
  FreeMem(Texture);
  Texture:=NextTexture;
 end;
 ClearAll;
 fHashMap.Free;
 fList.Free;
 inherited Destroy;
end;

procedure TVulkanSpriteAtlas.ClearAll;
var Index:TVkInt32;
begin
 for Index:=0 to fList.Count-1 do begin
  TVulkanSprite(Items[Index]).Free;
  Items[Index]:=nil;
 end;
 fList.Clear;
 fHashMap.Clear;
end;

procedure TVulkanSpriteAtlas.Upload(const aGraphicsQueue:TVulkanQueue;
                                    const aGraphicsCommandBuffer:TVulkanCommandBuffer;
                                    const aGraphicsFence:TVulkanFence;
                                    const aTransferQueue:TVulkanQueue;
                                    const aTransferCommandBuffer:TVulkanCommandBuffer;
                                    const aTransferFence:TVulkanFence);
var Texture:PVulkanSpriteAtlasTexture;
begin
 if not fIsUploaded then begin
  Texture:=fTextureList;
  while assigned(Texture) do begin
   if not Texture^.Texture.Uploaded then begin
    Texture^.Texture.Upload(fDevice,
                            aGraphicsQueue,
                            aGraphicsCommandBuffer,
                            aGraphicsFence,
                            aTransferQueue,
                            aTransferCommandBuffer,
                            aTransferFence,
                            fMipMaps);
    Texture^.Dirty:=false;
   end;
   Texture:=Texture^.Next;
  end;
  fIsUploaded:=true;
 end;
end;

procedure TVulkanSpriteAtlas.Unload;
var Texture:PVulkanSpriteAtlasTexture;
begin
 if fIsUploaded then begin
  Texture:=fTextureList;
  while assigned(Texture) do begin
   if Texture^.Texture.Uploaded then begin
    Texture^.Texture.Unload;
   end;
   Texture:=Texture^.Next;
  end;
  fIsUploaded:=false;
 end;
end;

function TVulkanSpriteAtlas.Uploaded:boolean;
begin
 result:=fIsUploaded;
end;

function TVulkanSpriteAtlas.GetCount:TVkInt32;
begin
 result:=fList.Count;
end;

function TVulkanSpriteAtlas.GetItem(Index:TVkInt32):TVulkanSprite;
begin
 result:=TVulkanSprite(fList.Items[Index]);
end;

procedure TVulkanSpriteAtlas.SetItem(Index:TVkInt32;Item:TVulkanSprite);
begin
 fList.Items[Index]:=TVkPointer(Item);
end;

function TVulkanSpriteAtlas.GetSprite(const Name:TVulkanRawByteString):TVulkanSprite;
begin
 result:=fHashMap[Name];
end;

procedure TVulkanSpriteAtlas.AddSprite(Sprite:TVulkanSprite);
begin
 fHashMap.Add(Sprite.Name,Sprite);
 fList.Add(Sprite);
end;

function TVulkanSpriteAtlas.LoadImage(const aDataPointer:TVkPointer;
                                      const aDataSize:TVkSizeInt;
                                      var aImageData:TVkPointer;
                                      var aImageWidth,aImageHeight:TVkInt32):boolean;
type PFirstBytes=^TFirstBytes;
     TFirstBytes=array[0..63] of TVkUInt8;
     PDDSHeader=^TDDSHeader;
     TDDSHeader=packed record
      dwMagic:TVkUInt32;
      dwSize:TVkUInt32;
      dwFlags:TVkUInt32;
      dwHeight:TVkUInt32;
      dwWidth:TVkUInt32;
      dwPitchOrLinearSize:TVkUInt32;
      dwDepth:TVkUInt32;
      dwMipMapCount:TVkUInt32;
     end;
var Index:TVkInt32;
    p8:PVkUInt8;
    p16:PVkUInt16;
    PNGPixelFormat:TPNGPixelFormat;
begin
 result:=false;
 if (aDataSize>7) and (PFirstBytes(aDataPointer)^[0]=$89) and (PFirstBytes(aDataPointer)^[1]=$50) and (PFirstBytes(aDataPointer)^[2]=$4e) and (PFirstBytes(aDataPointer)^[3]=$47) and (PFirstBytes(aDataPointer)^[4]=$0d) and (PFirstBytes(aDataPointer)^[5]=$0a) and (PFirstBytes(aDataPointer)^[6]=$1a) and (PFirstBytes(aDataPointer)^[7]=$0a) then begin
  PNGPixelFormat:=ppfUnknown;
  if LoadPNGImage(aDataPointer,aDataSize,aImageData,aImageWidth,aImageHeight,false,PNGPixelFormat) then begin
   result:=true;
   if PNGPixelFormat=ppfR16G16B16A16 then begin
    // Convert to R8G8B8A8 in-placve
    p8:=aImageData;
    p16:=aImageData;
    for Index:=1 to aImageWidth*aImageHeight*4 do begin
     p8^:=p16^ shr 8;
     inc(p8);
     inc(p16);
    end;
   end;
  end;
 end else if (aDataSize>2) and (PFirstBytes(aDataPointer)^[0]=TVkUInt8(AnsiChar('B'))) and (PFirstBytes(aDataPointer)^[1]=TVkUInt8(AnsiChar('M'))) then begin
  result:=LoadBMPImage(aDataPointer,aDataSize,aImageData,aImageWidth,aImageHeight,false);
 end else if (aDataSize>2) and (((PFirstBytes(aDataPointer)^[0] xor $ff) or (PFirstBytes(aDataPointer)^[1] xor $d8))=0) then begin
  result:=LoadJPEGImage(aDataPointer,aDataSize,aImageData,aImageWidth,aImageHeight,false);
 end else begin
  result:=LoadTGAImage(aDataPointer,aDataSize,aImageData,aImageWidth,aImageHeight,false);
 end;
end;

function TVulkanSpriteAtlas.LoadXML(const aTextureStream:TStream;const aStream:TStream):boolean;
var XML:TVulkanXML;
    MemoryStream:TMemoryStream;
    i,j:TVkInt32;
    XMLItem,XMLChildrenItem:TVulkanXMLItem;
    XMLTag,XMLChildrenTag:TVulkanXMLTag;
    SpriteName:TVulkanRawByteString;
    Sprite:TVulkanSprite;
    SpriteAtlasTexture:PVulkanSpriteAtlasTexture;
    Texture:TVulkanSpriteTexture;
    ImageData:TVkPointer;
    ImageWidth,ImageHeight:TVkInt32;
begin
 result:=false;
 if assigned(aTextureStream) and assigned(aStream) then begin
  Texture:=nil;
  MemoryStream:=TMemoryStream.Create;
  try
   aStream.Seek(0,soBeginning);
   MemoryStream.CopyFrom(aTextureStream,aTextureStream.Size);
   MemoryStream.Seek(0,soBeginning);
   ImageData:=nil;
   try
    if LoadImage(MemoryStream.Memory,MemoryStream.Size,ImageData,ImageWidth,ImageHeight) then begin
     GetMem(SpriteAtlasTexture,SizeOf(TVulkanSpriteAtlasTexture));
     FillChar(SpriteAtlasTexture^,SizeOf(TVulkanSpriteAtlasTexture),AnsiChar(#0));
     SpriteAtlasTexture^.Width:=ImageWidth;
     SpriteAtlasTexture^.Height:=ImageHeight;
     SpriteAtlasTexture^.Data:=ImageData;
     SpriteAtlasTexture^.Next:=fTextureList;
     fTextureList:=SpriteAtlasTexture;
     SpriteAtlasTexture^.Dirty:=true;
     SpriteAtlasTexture^.RootNode:=NewTextureRectNode;
     SpriteAtlasTexture^.RootNode^.x:=0;
     SpriteAtlasTexture^.RootNode^.y:=0;
     SpriteAtlasTexture^.RootNode^.Width:=SpriteAtlasTexture^.Width;
     SpriteAtlasTexture^.RootNode^.Height:=SpriteAtlasTexture^.Height;
     SpriteAtlasTexture^.RootNode^.FreeArea:=0;
     SpriteAtlasTexture^.Texture:=TVulkanSpriteTexture.Create(SpriteAtlasTexture^.Data,SpriteAtlasTexture^.Width,SpriteAtlasTexture^.Height);
     Texture:=SpriteAtlasTexture^.Texture;
     ImageData:=nil;
    end;
   finally
    if assigned(ImageData) then begin
     FreeMem(ImageData);
    end;
   end;
  finally
   MemoryStream.Free;
  end;
  if assigned(Texture) then begin
   MemoryStream:=TMemoryStream.Create;
   try
    aStream.Seek(0,soBeginning);
    MemoryStream.CopyFrom(aStream,aStream.Size);
    MemoryStream.Seek(0,soBeginning);
    XML:=TVulkanXML.Create;
    try
     if XML.Parse(MemoryStream) then begin
      for i:=0 to XML.Root.Items.Count-1 do begin
       XMLItem:=XML.Root.Items[i];
       if assigned(XMLItem) and (XMLItem is TVulkanXMLTag) then begin
        XMLTag:=TVulkanXMLTag(XMLItem);
        if XMLTag.Name='TextureAtlas' then begin
         for j:=0 to XMLTag.Items.Count-1 do begin
          XMLChildrenItem:=XMLTag.Items[j];
          if assigned(XMLChildrenItem) and (XMLChildrenItem is TVulkanXMLTag) then begin
           XMLChildrenTag:=TVulkanXMLTag(XMLChildrenItem);
           if XMLChildrenTag.Name='sprite' then begin
            SpriteName:=XMLChildrenTag.GetParameter('n','');
            if length(SpriteName)>0 then begin
             Sprite:=TVulkanSprite.Create;
             Sprite.Texture:=Texture;
             Sprite.Name:=SpriteName;
             Sprite.x:=StrToIntDef(String(XMLChildrenTag.GetParameter('x','0')),0);
             Sprite.y:=StrToIntDef(String(XMLChildrenTag.GetParameter('y','0')),0);
             Sprite.Width:=StrToIntDef(String(XMLChildrenTag.GetParameter('oW',XMLChildrenTag.GetParameter('w','0'))),0);
             Sprite.Height:=StrToIntDef(String(XMLChildrenTag.GetParameter('oH',XMLChildrenTag.GetParameter('h','0'))),0);
             Sprite.TrimmedX:=StrToIntDef(String(XMLChildrenTag.GetParameter('oX','0')),0);
             Sprite.TrimmedY:=StrToIntDef(String(XMLChildrenTag.GetParameter('oY','0')),0);
             Sprite.TrimmedWidth:=StrToIntDef(String(XMLChildrenTag.GetParameter('w','0')),0);
             Sprite.TrimmedHeight:=StrToIntDef(String(XMLChildrenTag.GetParameter('h','0')),0);
             Sprite.Rotated:=XMLChildrenTag.GetParameter('r','n')='y';
             AddSprite(Sprite);
            end;
           end;
          end;
         end;
        end;
       end;
      end;
     end;
    finally
     XML.Free;
    end;
   finally
    MemoryStream.Free;
   end;
   result:=true;
  end;
 end;
end;

function TVulkanSpriteAtlas.LoadRawSprite(const Name:TVulkanRawByteString;ImageData:TVkPointer;ImageWidth,ImageHeight:TVkInt32):TVulkanSprite;
type PVkUInt32=^TVkUInt32;
var x,y,x0,y0,x1,y1:TVkInt32;
    Texture:PVulkanSpriteAtlasTexture;
    Node:PVulkanSpriteAtlasTextureRectNode;
    Sprite:TVulkanSprite;
    sp,dp:PVkUInt32;
    OK:boolean;
    TrimmedImageData:TVkPointer;
    TrimmedImageWidth:TVkInt32;
    TrimmedImageHeight:TVkInt32;
begin

 result:=nil;

 try

  Node:=nil;

  if assigned(ImageData) and (ImageWidth>0) and (ImageHeight>0) then begin

   x0:=0;
   y0:=0;
   x1:=ImageWidth;
   y1:=ImageHeight;

   if fAutomaticTrim then begin

    // Trim input

    for x:=0 to ImageWidth-1 do begin
     OK:=true;
     for y:=0 to ImageHeight-1 do begin
      sp:=ImageData;
      inc(sp,(y*ImageWidth)+x);
      if (sp^ and $ff000000)<>0 then begin
       OK:=false;
       break;
      end;
     end;
     if OK then begin
      x0:=x;
     end else begin
      break;
     end;
    end;

    sp:=ImageData;
    for y:=0 to ImageHeight-1 do begin
     OK:=true;
     for x:=0 to ImageWidth-1 do begin
      if (sp^ and $ff000000)<>0 then begin
       OK:=false;
       break;
      end;
      inc(sp);
     end;
     if OK then begin
      y0:=y;
     end else begin
      break;
     end;
    end;

    for x:=ImageWidth-1 downto 0 do begin
     OK:=true;
     for y:=0 to ImageHeight-1 do begin
      sp:=ImageData;
      inc(sp,(y*ImageWidth)+x);
      if (sp^ and $ff000000)<>0 then begin
       OK:=false;
       break;
      end;
     end;
     if OK then begin
      x1:=x+1;
     end else begin
      break;
     end;
    end;

    for y:=ImageHeight-1 downto 0 do begin
     OK:=true;
     sp:=ImageData;
     inc(sp,y*ImageWidth);
     for x:=0 to ImageWidth-1 do begin
      if (sp^ and $ff000000)<>0 then begin
       OK:=false;
       break;
      end;
      inc(sp);
     end;
     if OK then begin
      y1:=y+1;
     end else begin
      break;
     end;
    end;

   end;

   TrimmedImageData:=nil;
   
   try

    if (x0<x1) and (y0<y1) and not ((x0=0) and (y0=0) and (x1=ImageWidth) and (y1=ImageHeight)) then begin
     TrimmedImageWidth:=x1-x0;
     TrimmedImageHeight:=y1-y0;
     GetMem(TrimmedImageData,TrimmedImageWidth*TrimmedImageHeight*SizeOf(TVkUInt32));
     dp:=TrimmedImageData;
     for y:=y0 to y1-1 do begin
      sp:=ImageData;
      inc(sp,(y*ImageWidth)+x0);
      for x:=x0 to x1-1 do begin
       dp^:=sp^;
       inc(sp);
       inc(dp);
      end;
     end;
    end else begin
     TrimmedImageWidth:=ImageWidth;
     TrimmedImageHeight:=ImageHeight;
     GetMem(TrimmedImageData,TrimmedImageWidth*TrimmedImageHeight*SizeOf(TVkUInt32));
     Move(ImageData^,TrimmedImageData^,TrimmedImageWidth*TrimmedImageHeight*SizeOf(TVkUInt32));
     x0:=0;
     y0:=0;
    end;

    // Get free texture area
    Texture:=fTextureList;
    while assigned(Texture) do begin
     if assigned(Texture^.RootNode) then begin
      // Including 2px texel bilinear interpolation protection border pixels
      Node:=InsertTextureRectNode(Texture^.RootNode,TrimmedImageWidth+4,TrimmedImageHeight+4,(TrimmedImageWidth+4)*(TrimmedImageHeight+4));
      if assigned(Node) then begin
       break;
      end;
     end;
     Texture:=Texture^.Next;
    end;

    if not (assigned(Texture) and assigned(Node)) then begin
     GetMem(Texture,SizeOf(TVulkanSpriteAtlasTexture));
     FillChar(Texture^,SizeOf(TVulkanSpriteAtlasTexture),AnsiChar(#0));
     Texture^.Width:=VULKAN_SPRITEATLASTEXTURE_WIDTH;
     Texture^.Height:=VULKAN_SPRITEATLASTEXTURE_HEIGHT;
     GetMem(Texture^.Data,Texture^.Width*Texture^.Height*4);
     FillChar(Texture^.Data^,Texture^.Width*Texture^.Height*4,AnsiChar(#$00));
     Texture^.Texture:=TVulkanSpriteTexture.Create(Texture^.Data,Texture^.Width,Texture^.Height);
     Texture^.Next:=fTextureList;
     fTextureList:=Texture;
     Texture^.Dirty:=true;
     Texture^.RootNode:=NewTextureRectNode;
     Texture^.RootNode^.x:=0;
     Texture^.RootNode^.y:=0;
     Texture^.RootNode^.Width:=Texture^.Width;
     Texture^.RootNode^.Height:=Texture^.Height;
     Texture^.RootNode^.FreeArea:=Texture^.Width*Texture^.Height;
     Node:=InsertTextureRectNode(Texture^.RootNode,TrimmedImageWidth+4,TrimmedImageHeight+4,(TrimmedImageWidth+4)*(TrimmedImageHeight+4));
    end;

    if assigned(Texture) and assigned(Node) then begin
     Sprite:=TVulkanSprite.Create;
     Sprite.Texture:=Texture^.Texture;
     Sprite.Name:=Name;
     Sprite.x:=Node^.x+2;
     Sprite.y:=Node^.y+2;
     Sprite.Width:=ImageWidth;
     Sprite.Height:=ImageHeight;
     Sprite.TrimmedX:=x0;
     Sprite.TrimmedY:=y0;
     Sprite.TrimmedWidth:=TrimmedImageWidth;
     Sprite.TrimmedHeight:=TrimmedImageHeight;
     Sprite.Rotated:=false;
     AddSprite(Sprite);
     for y:=0 to TrimmedImageHeight-1 do begin
      sp:=TrimmedImageData;
      inc(sp,y*TrimmedImageWidth);
      dp:=Texture^.Data;
      inc(dp,((Sprite.y+y)*Texture^.Width)+Sprite.x);
      Move(sp^,dp^,TrimmedImageWidth*SizeOf(TVkUInt32));
     end;
     begin
      begin
       sp:=TrimmedImageData;
       dp:=Texture^.Data;
       inc(dp,((Sprite.y-1)*Texture^.Width)+Sprite.x);
       Move(sp^,dp^,TrimmedImageWidth*SizeOf(TVkUInt32));
       dp:=Texture^.Data;
       inc(dp,((Sprite.y-2)*Texture^.Width)+Sprite.x);
       Move(sp^,dp^,TrimmedImageWidth*SizeOf(TVkUInt32));
      end;
      begin
       sp:=TrimmedImageData;
       inc(sp,(TrimmedImageHeight-1)*TrimmedImageWidth);
       dp:=Texture^.Data;
       inc(dp,((Sprite.y+TrimmedImageHeight)*Texture^.Width)+Sprite.x);
       Move(sp^,dp^,TrimmedImageWidth*SizeOf(TVkUInt32));
       dp:=Texture^.Data;
       inc(dp,((Sprite.y+TrimmedImageHeight+1)*Texture^.Width)+Sprite.x);
       Move(sp^,dp^,TrimmedImageWidth*SizeOf(TVkUInt32));
      end;
     end;
     for y:=-1 to TrimmedImageHeight do begin
      sp:=Texture^.Data;
      inc(sp,((Sprite.y+y)*Texture^.Width)+Sprite.x);
      dp:=Texture^.Data;
      inc(dp,(((Sprite.y+y)*Texture^.Width)+Sprite.x)-1);
      dp^:=sp^;
      dp:=Texture^.Data;
      inc(dp,(((Sprite.y+y)*Texture^.Width)+Sprite.x)-2);
      dp^:=sp^;
      sp:=Texture^.Data;
      inc(sp,(((Sprite.y+y)*Texture^.Width)+Sprite.x)+(TrimmedImageWidth-1));
      dp:=Texture^.Data;
      inc(dp,(((Sprite.y+y)*Texture^.Width)+Sprite.x)+TrimmedImageWidth);
      dp^:=sp^;
      dp:=Texture^.Data;
      inc(dp,(((Sprite.y+y)*Texture^.Width)+Sprite.x)+TrimmedImageWidth+1);
      dp^:=sp^;
     end;
     Texture^.Dirty:=true;
    end else begin
     GetMem(Texture,SizeOf(TVulkanSpriteAtlasTexture));
     FillChar(Texture^,SizeOf(TVulkanSpriteAtlasTexture),AnsiChar(#0));
     Texture^.Width:=TrimmedImageWidth;
     Texture^.Height:=TrimmedImageHeight;
     Texture^.Data:=TrimmedImageData;
     TrimmedImageData:=nil;
     Texture^.Texture:=TVulkanSpriteTexture.Create(Texture^.Data,Texture^.Width,Texture^.Height);
     Texture^.Next:=fTextureList;
     fTextureList:=Texture;
     Texture^.Dirty:=true;
     Texture^.RootNode:=nil;
     Sprite:=TVulkanSprite.Create;
     Sprite.Texture:=Texture^.Texture;
     Sprite.Name:=Name;
     Sprite.x:=0;
     Sprite.y:=0;
     Sprite.Width:=ImageWidth;
     Sprite.Height:=ImageHeight;
     Sprite.TrimmedX:=x0;
     Sprite.TrimmedY:=y0;
     Sprite.TrimmedWidth:=TrimmedImageWidth;
     Sprite.TrimmedHeight:=TrimmedImageHeight;
     Sprite.Rotated:=false;
     AddSprite(Sprite);
    end;

   finally

    if assigned(TrimmedImageData) then begin
     FreeMem(TrimmedImageData);
    end;

   end;

   result:=Sprite;

  end else begin

   raise Exception.Create('Can''t load sprite');

  end;

 finally

 end;

end;

function TVulkanSpriteAtlas.LoadSprite(const Name:TVulkanRawByteString;Stream:TStream):TVulkanSprite;
var InputImageData,ImageData:TVkPointer;
    InputImageDataSize,ImageWidth,ImageHeight:TVkInt32;
begin

 result:=nil;

 if assigned(Stream) then begin

  try

   InputImageDataSize:=Stream.Size;
   GetMem(InputImageData,InputImageDataSize);
   try

    Stream.Seek(0,soBeginning);
    Stream.Read(InputImageData^,InputImageDataSize);
    ImageData:=nil;
    try

     if LoadImage(InputImageData,InputImageDataSize,ImageData,ImageWidth,ImageHeight) then begin

      result:=LoadRawSprite(Name,ImageData,ImageWidth,ImageHeight);

     end else begin
      raise Exception.Create('Can''t load image');
     end;

    finally

     if assigned(ImageData) then begin
      FreeMem(ImageData);
     end;
     
    end;

   finally

    if assigned(InputImageData) then begin
     FreeMem(InputImageData);
    end;

   end;

  finally

  end;

 end else begin

  raise Exception.Create('Can''t load sprite');

 end;

end;

function TVulkanSpriteAtlas.LoadSprites(const Name:TVulkanRawByteString;Stream:TStream;SpriteWidth:TVkInt32=64;SpriteHeight:TVkInt32=64):TVulkanSprites;
type PVkUInt32=^TVkUInt32;
var InputImageData,ImageData,SpriteData:TVkPointer;
    InputImageDataSize,ImageWidth,ImageHeight,Count,x,y,sy,sw,sh:TVkInt32;
    sp,dp:PVkUInt32;
begin
 result:=nil;

 if assigned(Stream) and (SpriteWidth>0) and (SpriteHeight>0) then begin

  try

   InputImageDataSize:=Stream.Size;
   GetMem(InputImageData,InputImageDataSize);
   try

    Stream.Seek(0,soBeginning);
    Stream.Read(InputImageData^,InputImageDataSize);
    ImageData:=nil;
    try

     if LoadImage(InputImageData,InputImageDataSize,ImageData,ImageWidth,ImageHeight) then begin

      GetMem(SpriteData,(SpriteWidth*SpriteHeight)*SizeOf(TVkUInt32));
      try

       Count:=((ImageWidth+(SpriteWidth-1)) div SpriteWidth)*((ImageHeight+(SpriteHeight-1)) div SpriteHeight);
       SetLength(result,Count);

       Count:=0;

       y:=0;
       while y<ImageHeight do begin

        sh:=ImageHeight-y;
        if sh<0 then begin
         sh:=0;
        end else if sh>SpriteHeight then begin
         sh:=SpriteHeight;
        end;

        if sh>0 then begin

         x:=0;
         while x<ImageWidth do begin

          FillChar(SpriteData^,(SpriteWidth*SpriteHeight)*SizeOf(TVkUInt32),AnsiChar(#0));

          sw:=ImageWidth-x;
          if sw<0 then begin
           sw:=0;
          end else if sw>SpriteWidth then begin
           sw:=SpriteWidth;
          end;

          if sw>0 then begin

           sp:=ImageData;
           inc(sp,(ImageWidth*y)+x);

           dp:=SpriteData;

           for sy:=0 to sh-1 do begin
            Move(sp^,dp^,sw*SizeOf(TVkUInt32));
            inc(sp,ImageWidth);
            inc(dp,SpriteWidth);
           end;

           result[Count]:=LoadRawSprite(Name+TVulkanRawByteString(IntToStr(Count)),SpriteData,SpriteWidth,SpriteHeight);

           inc(Count);

          end else begin

           break;

          end;

          inc(x,SpriteWidth);
         end;

        end else begin

         break;

        end;

        inc(y,SpriteHeight);
       end;

       SetLength(result,Count);

      finally

       FreeMem(SpriteData);

      end;

     end else begin

      raise Exception.Create('Can''t load image');
      
     end;

    finally

     if assigned(ImageData) then begin
      FreeMem(ImageData);
     end;

    end;

   finally

    if assigned(InputImageData) then begin
     FreeMem(InputImageData);
    end;

   end;

  finally

  end;

 end else begin

  raise Exception.Create('Can''t load sprites');

 end;

end;

/////////////////////////////////////////// TrueTypeFont ///////////////////////////////////////////////

const PixelBits=8;
      PixelFactor=1 shl PixelBits;
      HalfPixel=PixelFactor shr 1;
      OnePixel=PixelFactor;
      PixelMask=PixelFactor-1;

      deg2rad=pi/180;
      rad2deg=180/pi;

      ARGS_ARE_WORDS=$0001;
      ARGS_ARE_XY_VALUES=$0002;
      ROUND_XY_TO_GRID=$0004;
      WE_HAVE_A_SCALE=$0008;
      MORE_COMPONENTS=$0020;
      WE_HAVE_AN_XY_SCALE=$0040;
      WE_HAVE_A_2X2=$0080;
      WE_HAVE_INSTR=$0100;
      USE_MY_METRICS=$0200;
      OVERLAP_COMPOUND=$0400;
      SCALED_COMPONENT_OFFSET=$0800;
      UNSCALED_COMPONENT_OFFSET=$1000;

      // https://developer.apple.com/fonts/TTRefMan/RM07/appendixA.html

      opSVTCA0=$00;    // Set freedom and projection Vectors To Coordinate Axis
      opSVTCA1=$01;    // .
      opSPVTCA0=$02;   // Set Projection Vector To Coordinate Axis
      opSPVTCA1=$03;   // .
      opSFVTCA0=$04;   // Set Freedom Vector to Coordinate Axis
      opSFVTCA1=$05;   // .
      opSPVTL0=$06;    // Set Projection Vector To Line
      opSPVTL1=$07;    // .
      opSFVTL0=$08;    // Set Freedom Vector To Line
      opSFVTL1=$09;    // .
      opSPVFS=$0a;     // Set Projection Vector From Stack
      opSFVFS=$0b;     // Set Freedom Vector From Stack
      opGPV=$0c;       // Get Projection Vector
      opGFV=$0d;       // Get Freedom Vector
      opSFVTPV=$0e;    // Set Freedom Vector To Projection Vector
      opISECT=$0f;     // move point to InterSECTion of two lines
      opSRP0=$10;      // Set Reference Point 0
      opSRP1=$11;      // Set Reference Point 1
      opSRP2=$12;      // Set Reference Point 2
      opSZP0=$13;      // Set Zone TVkPointer 0
      opSZP1=$14;      // Set Zone TVkPointer 1
      opSZP2=$15;      // Set Zone TVkPointer 2
      opSZPS=$16;      // Set Zone PointerS
      opSLOOP=$17;     // Set LOOP variable
      opRTG=$18;       // Round To Grid
      opRTHG=$19;      // Round To Half Grid
      opSMD=$1a;       // Set Minimum Distance
      opELSE=$1b;      // ELSE clause
      opJMPR=$1c;      // JuMP Relative
      opSCVTCI=$1d;    // Set Control Value Table Cut-In
      opSSWCI=$1e;     // Set Single Width Cut-In
      opSSW=$1f;       // Set Single Width
      opDUP=$20;       // DUPlicate top stack element
      opPOP=$21;       // POP top stack element
      opCLEAR=$22;     // CLEAR the stack
      opSWAP=$23;      // SWAP the top two elements on the stack
      opDEPTH=$24;     // DEPTH of the stack
      opCINDEX=$25;    // Copy the INDEXed element to the top of the stack
      opMINDEX=$26;    // Move the INDEXed element to the top of the stack
      opALIGNPTS=$27;  // ALIGN PoinTS
      op_0x28=$28;
      opUTP=$29;       // UnTouch Point
      opLOOPCALL=$2a;  // LOOP and CALL function
      opCALL=$2b;      // CALL function
      opFDEF=$2c;      // Function DEFinition
      opENDF=$2d;      // END Function definition
      opMDAP0=$2e;     // Move Direct Absolute Point
      opMDAP1=$2f;     // .
      opIUP0=$30;      // Interpolate Untouched Points through the Stroke
      opIUP1=$31;      // .
      opSHP0=$32;      // SHift Point by the last point
      opSHP1=$33;      // .
      opSHC0=$34;      // SHift Contour by the last point
      opSHC1=$35;      // .
      opSHZ0=$36;      // SHift Zone by the last point
      opSHZ1=$37;      // .
      opSHPIX=$38;     // SHift Point by a piXel amount
      opIP=$39;        // Interpolate Point
      opMSIRP0=$3a;    // Move Stack Indirect Relative Point
      opMSIRP1=$3b;    // .
      opALIGNRP=$3c;   // ALIGN to Reference Point
      opRTDG=$3d;      // Round To TVkDouble Grid
      opMIAP0=$3e;     // Move Indirect Absolute Point
      opMIAP1=$3f;     // .
      opNPUSHB=$40;    // PUSH N Bytes
      opNPUSHW=$41;    // PUSH N Words
      opWS=$42;        // Write Store
      opRS=$43;        // Read Store
      opWCVTP=$44;     // Write Control Value Table in Pixels
      opRCVT=$45;      // Read Control Value Table
      opGC0=$46;       // Get Coordinate projected onto the projection vector with current coordinates
      opGC1=$47;       // Get Coordinate projected onto the projection vector with original coordinates
      opSCFS=$48;      // Set Coordinate From Stack using projection and freedom vector
      opMD0=$49;       // Measure Distance with current coordinates
      opMD1=$4a;       // Measure Distance with original coordinates
      opMPPEM=$4b;     // Measure Pixels Per EM
      opMPS=$4c;       // Measure Point Size
      opFLIPON=$4d;    // set the auto FLIP Boolean to ON
      opFLIPOFF=$4e;   // set the auto FLIP Boolean to OFF
      opDEBUG=$4f;     // DEBUG call
      opLT=$50;        // Less Than
      opLTEQ=$51;      // Less Than or EQual
      opGT=$52;        // Greater Than
      opGTEQ=$53;      // Greater Than or EQual
      opEQ=$54;        // EQual
      opNEQ=$55;       // Not EQual
      opODD=$56;       // ODD
      opEVEN=$57;      // EVEN
      opIF=$58;        // IF test
      opEIF=$59;       // End IF
      opAND=$5a;       // logical AND
      opOR=$5b;        // logical OR
      opNOT=$5c;       // logical NOT
      opDELTAP1=$5d;   // DELTA exception P1
      opSDB=$5e;       // Set Delta Base in the graphics state
      opSDS=$5f;       // Set Delta Shift in the graphics state
      opADD=$60;       // ADD
      opSUB=$61;       // SUBtract
      opDIV=$62;       // DIVide
      opMUL=$63;       // MULtiply
      opABS=$64;       // ABSolute value
      opNEG=$65;       // NEGate
      opFLOOR=$66;     // FLOOR
      opCEILING=$67;   // CEILING
      opROUND00=$68;   // ROUND value
      opROUND01=$69;   // .
      opROUND10=$6a;   // .
      opROUND11=$6b;   // .
      opNROUND00=$6c;  // No ROUNDing of value
      opNROUND01=$6d;  // .
      opNROUND10=$6e;  // .
      opNROUND11=$6f;  // .
      opWCVTF=$70;     // Write Control Value Table in Font units
      opDELTAP2=$71;   // DELTA exception P2
      opDELTAP3=$72;   // DELTA exception P3
      opDELTAC1=$73;   // DELTA exception C1
      opDELTAC2=$74;   // DELTA exception C2
      opDELTAC3=$75;   // DELTA exception C3
      opSROUND=$76;    // Super ROUND
      opS45ROUND=$77;  // Super ROUND 45 degrees
      opJROT=$78;      // Jump Relative On True
      opJROF=$79;      // Jump Relative On False
      opROFF=$7a;      // Round OFF
      op_0x7b=$7b;
      opRUTG=$7c;      // Round Up To Grid
      opRDTG=$7d;      // Round Down To Grid
      opSANGW=$7e;     // Set ANGle Weight
      opAA=$7f;        // Adjust Angle
      opFLIPPT=$80;    // FLIP PoinT
      opFLIPRGON=$81;  // FLIP RanGe ON
      opFLIPRGOFF=$82; // FLIP RanGe OFF
      op_0x83=$83;
      op_0x84=$84;
      opSCANCTRL=$85;  // SCAN conversion ConTRoL
      opSDPVTL0=$86;   // Set Dual Projection Vector To Line
      opSDPVTL1=$87;   // .
      opGETINFO=$88;   // GET INFOrmation
      opIDEF=$89;      // Instruction DEFinition
      opROLL=$8a;      // ROLL the top three stack elements
      opMAX=$8b;       // MAXimum of top two stack elements
      opMIN=$8c;       // MINimum of top two stack elements
      opSCANTYPE=$8d;  // SCANTYPE
      opINSTCTRL=$8e;  // INSTruction ConTRoL
      op_0x8f=$8f;
      op_0x90=$90;
      op_0x91=$91;
      op_0x92=$92;
      op_0x93=$93;
      op_0x94=$94;
      op_0x95=$95;
      op_0x96=$96;
      op_0x97=$97;
      op_0x98=$98;
      op_0x99=$99;
      op_0x9a=$9a;
      op_0x9b=$9b;
      op_0x9c=$9c;
      op_0x9d=$9d;
      op_0x9e=$9e;
      op_0x9f=$9f;
      op_0xa0=$a0;
      op_0xa1=$a1;
      op_0xa2=$a2;
      op_0xa3=$a3;
      op_0xa4=$a4;
      op_0xa5=$a5;
      op_0xa6=$a6;
      op_0xa7=$a7;
      op_0xa8=$a8;
      op_0xa9=$a9;
      op_0xaa=$aa;
      op_0xab=$ab;
      op_0xac=$ac;
      op_0xad=$ad;
      op_0xae=$ae;
      op_0xaf=$af;
      opPUSHB000=$b0;  // PUSH Bytes
      opPUSHB001=$b1;  // .
      opPUSHB010=$b2;  // .
      opPUSHB011=$b3;  // .
      opPUSHB100=$b4;  // .
      opPUSHB101=$b5;  // .
      opPUSHB110=$b6;  // .
      opPUSHB111=$b7;  // .
      opPUSHW000=$b8;  // PUSH Words
      opPUSHW001=$b9;  // .
      opPUSHW010=$ba;  // .
      opPUSHW011=$bb;  // .
      opPUSHW100=$bc;  // .
      opPUSHW101=$bd;  // .
      opPUSHW110=$be;  // .
      opPUSHW111=$bf;  // .
      opMDRP00000=$c0; // Move Direct Relative Point
      opMDRP00001=$c1; // .
      opMDRP00010=$c2; // .
      opMDRP00011=$c3; // .
      opMDRP00100=$c4; // .
      opMDRP00101=$c5; // .
      opMDRP00110=$c6; // .
      opMDRP00111=$c7; // .
      opMDRP01000=$c8; // .
      opMDRP01001=$c9; // .
      opMDRP01010=$ca; // .
      opMDRP01011=$cb; // .
      opMDRP01100=$cc; // .
      opMDRP01101=$cd; // .
      opMDRP01110=$ce; // .
      opMDRP01111=$cf; // .
      opMDRP10000=$d0; // .
      opMDRP10001=$d1; // .
      opMDRP10010=$d2; // .
      opMDRP10011=$d3; // .
      opMDRP10100=$d4; // .
      opMDRP10101=$d5; // .
      opMDRP10110=$d6; // .
      opMDRP10111=$d7; // .
      opMDRP11000=$d8; // .
      opMDRP11001=$d9; // .
      opMDRP11010=$da; // .
      opMDRP11011=$db; // .
      opMDRP11100=$dc; // .
      opMDRP11101=$dd; // .
      opMDRP11110=$de; // .
      opMDRP11111=$df; // .
      opMIRP00000=$e0; // Move Indirect Relative Point
      opMIRP00001=$e1; // .
      opMIRP00010=$e2; // .
      opMIRP00011=$e3; // .
      opMIRP00100=$e4; // .
      opMIRP00101=$e5; // .
      opMIRP00110=$e6; // .
      opMIRP00111=$e7; // .
      opMIRP01000=$e8; // .
      opMIRP01001=$e9; // .
      opMIRP01010=$ea; // .
      opMIRP01011=$eb; // .
      opMIRP01100=$ec; // .
      opMIRP01101=$ed; // .
      opMIRP01110=$ee; // .
      opMIRP01111=$ef; // .
      opMIRP10000=$f0; // .
      opMIRP10001=$f1; // .
      opMIRP10010=$f2; // .
      opMIRP10011=$f3; // .
      opMIRP10100=$f4; // .
      opMIRP10101=$f5; // .
      opMIRP10110=$f6; // .
      opMIRP10111=$f7; // .
      opMIRP11000=$f8; // .
      opMIRP11001=$f9; // .
      opMIRP11010=$fa; // .
      opMIRP11011=$fb; // .
      opMIRP11100=$fc; // .
      opMIRP11101=$fd; // .
      opMIRP11110=$fe; // .
      opMIRP11111=$ff; // .

      x=255;

      OpcodePopCount:array[0..255] of TVkUInt8=
       (
     // 0,1,2,3,4,5,6,7,8,9,a,b,c,d,e,f
        0,0,0,0,0,0,2,2,2,2,2,2,0,0,0,5, // 0
        1,1,1,1,1,1,1,1,0,0,1,0,1,1,1,1, // 1
        1,1,0,2,0,1,1,2,x,1,2,1,1,0,1,1, // 2
        0,0,0,0,1,1,1,1,0,0,2,2,0,0,2,2, // 3
        0,0,2,1,2,0,0,0,2,1,1,0,0,0,0,0, // 4
        2,2,2,2,2,2,1,1,1,0,2,2,1,0,1,1, // 5
        2,2,2,2,1,1,1,1,1,1,1,1,1,1,1,1, // 6
        2,0,0,0,0,0,1,1,2,2,0,x,0,0,1,1, // 7
        0,2,2,x,x,1,2,2,1,1,3,2,2,1,x,x, // 8
        x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x, // 9
        x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x, // a
        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, // b
        1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1, // c
        1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1, // d
        2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2, // e
        2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2  // f
       );

      DefaultGraphicsStateControlValueCutIn=(17 shl 6) div 16;

      DefaultGraphicsState:TVulkanTrueTypeFontGraphicsState=
       (
        pv:($4000,0);
        fv:($4000,0);
        dv:($4000,0);
        rp:(0,0,0);
        zp:(1,1,1);
        ControlValueCutIn:DefaultGraphicsStateControlValueCutIn;
        SingleWidthCutIn:0;
        SingleWidth:0;
        DeltaBase:9;
        DeltaShift:3;//1;
        MinDist:1 shl 6;
        Loop:1;
        RoundPeriod:1 shl 6;
        RoundPhase:0;
        RoundThreshold:1 shl 5;
        RoundSuper45:false;
        AutoFlip:true;
        InstructionControl:0;
       );

      OpcodeNames:array[0..255] of TVulkanRawByteString=
       (
        'SVTCA y','SVTCA x','SPVTCA y','SPVTCA x','SFVTCA y','SFVTCA x','SPVTL ||','SPVTL +',
        'SFVTL ||','SFVTL +','SPVFS','SFVFS','GPV','GFV','SFVTPV','ISECT',
        'SRP0','SRP1','SRP2','SZP0','SZP1','SZP2','SZPS','SLOOP',
        'RTG','RTHG','SMD','ELSE','JMPR','SCVTCI','SSWCI','SSW',
        'DUP','POP','CLEAR','SWAP','DEPTH','CINDEX','MINDEX','ALIGNPTS',
        'INS_$28','INS_$29','LOOPCALL','CALL','FDEF','ENDF','MDAP[0]','MDAP[1]',
        'IUP[0]','IUP[1]','SHP[0]','SHP[1]','SHC[0]','SHC[1]','SHZ[0]','SHZ[1]',
        'SHPIX','IP','MSIRP[0]','MSIRP[1]','ALIGNRP','RTDG','MIAP[0]','MIAP[1]',
        'NPUSHB','NPUSHW','WS','RS','WCVTP','RCVT','GC[0]','GC[1]',
        'SCFS','MD[0]','MD[1]','MPPEM','MPS','FLIPON','FLIPOFF','DEBUG',
        'LT','LTEQ','GT','GTEQ','EQ','NEQ','ODD','EVEN',
        'IF','EIF','AND','OR','NOT','DELTAP1','SDB','SDS',
        'ADD','SUB','DIV','MUL','ABS','NEG','FLOOR','CEILING',
        'ROUND[0]','ROUND[1]','ROUND[2]','ROUND[3]','NROUND[0]','NROUND[1]','NROUND[2]','NROUND[3]',
        'WCVTF','DELTAP2','DELTAP3','DELTAC1','DELTAC2','DELTAC3','SROUND','S45ROUND',
        'JROT','JROF','ROFF','INS_$7B','RUTG','RDTG','SANGW','AA',
        'FLIPPT','FLIPRGON','FLIPRGOFF','INS_$83','INS_$84','SCANCTRL','SDPVTL[0]','SDPVTL[1]',
        'GETINFO','IDEF','ROLL','MAX','MIN','SCANTYPE','INSTCTRL','INS_$8F',
        'INS_$90','INS_$91','INS_$92','INS_$93','INS_$94','INS_$95','INS_$96','INS_$97',
        'INS_$98','INS_$99','INS_$9A','INS_$9B','INS_$9C','INS_$9D','INS_$9E','INS_$9F',
        'INS_$A0','INS_$A1','INS_$A2','INS_$A3','INS_$A4','INS_$A5','INS_$A6','INS_$A7',
        'INS_$A8','INS_$A9','INS_$AA','INS_$AB','INS_$AC','INS_$AD','INS_$AE','INS_$AF',
        'PUSHB[0]','PUSHB[1]','PUSHB[2]','PUSHB[3]','PUSHB[4]','PUSHB[5]','PUSHB[6]','PUSHB[7]',
        'PUSHW[0]','PUSHW[1]','PUSHW[2]','PUSHW[3]','PUSHW[4]','PUSHW[5]','PUSHW[6]','PUSHW[7]',
        'MDRP[G]','MDRP[B]','MDRP[W]','MDRP[?]','MDRP[rG]','MDRP[rB]','MDRP[rW]','MDRP[r?]',
        'MDRP[mG]','MDRP[mB]','MDRP[mW]','MDRP[m?]','MDRP[mrG]','MDRP[mrB]','MDRP[mrW]','MDRP[mr?]',
        'MDRP[pG]','MDRP[pB]','MDRP[pW]','MDRP[p?]','MDRP[prG]','MDRP[prB]','MDRP[prW]','MDRP[pr?]',
        'MDRP[pmG]','MDRP[pmB]','MDRP[pmW]','MDRP[pm?]','MDRP[pmrG]','MDRP[pmrB]','MDRP[pmrW]','MDRP[pmr?]',
        'MIRP[G]','MIRP[B]','MIRP[W]','MIRP[?]','MIRP[rG]','MIRP[rB]','MIRP[rW]','MIRP[r?]',
        'MIRP[mG]','MIRP[mB]','MIRP[mW]','MIRP[m?]','MIRP[mrG]','MIRP[mrB]','MIRP[mrW]','MIRP[mr?]',
        'MIRP[pG]','MIRP[pB]','MIRP[pW]','MIRP[p?]','MIRP[prG]','MIRP[prB]','MIRP[prW]','MIRP[pr?]',
        'MIRP[pmG]','MIRP[pmB]','MIRP[pmW]','MIRP[pm?]','MIRP[pmrG]','MIRP[pmrB]','MIRP[pmrW]','MIRP[pmr?]'
       );

function CompareKerningPairs(const a,b:TVkPointer):TVkInt32;
begin
 result:=PVulkanTrueTypeFontKerningPair(a)^.Left-PVulkanTrueTypeFontKerningPair(b)^.Left;
 if result=0 then begin
  result:=PVulkanTrueTypeFontKerningPair(a)^.Right-PVulkanTrueTypeFontKerningPair(b)^.Right;
 end;
end;

constructor TVulkanTrueTypeFontRasterizer.Create;
begin
 inherited Create;
end;

destructor TVulkanTrueTypeFontRasterizer.Destroy;
begin
 inherited Destroy;
end;

function TVulkanTrueTypeFontRasterizer.GetCanvas:TVkPointer;
begin
 result:=nil;
end;

procedure TVulkanTrueTypeFontRasterizer.SetCanvas(NewCanvas:TVkPointer);
begin
end;

function TVulkanTrueTypeFontRasterizer.GetWidth:TVkInt32;
begin
 result:=0;
end;

procedure TVulkanTrueTypeFontRasterizer.SetWidth(NewWidth:TVkInt32);
begin
end;

function TVulkanTrueTypeFontRasterizer.GetHeight:TVkInt32;
begin
 result:=0;
end;

procedure TVulkanTrueTypeFontRasterizer.SetHeight(NewHeight:TVkInt32);
begin
end;

function TVulkanTrueTypeFontRasterizer.GetWindingRule:TVkInt32;
begin
 result:=0;
end;

procedure TVulkanTrueTypeFontRasterizer.SetWindingRule(NewWindingRule:TVkInt32);
begin
end;

procedure TVulkanTrueTypeFontRasterizer.Clear;
begin
end;

procedure TVulkanTrueTypeFontRasterizer.Reset;
begin
end;

procedure TVulkanTrueTypeFontRasterizer.Resize(NewWidth,NewHeight:TVkInt32);
begin
end;

procedure TVulkanTrueTypeFontRasterizer.MoveTo(ToX,ToY:TVkInt32);
begin
 fLastX:=ToX;
 fLastY:=ToY;
end;

procedure TVulkanTrueTypeFontRasterizer.LineTo(ToX,ToY:TVkInt32);
begin
 fLastX:=ToX;
 fLastY:=ToY;
end;

procedure TVulkanTrueTypeFontRasterizer.QuadraticCurveTo(const ControlX,ControlY,AnchorX,AnchorY:TVkInt32;const Tolerance:TVkInt32=2;const MaxLevel:TVkInt32=32);
 procedure Recursive(const x1,y1,x2,y2,x3,y3,Level:TVkInt32);
 var x12,y12,x23,y23,x123,y123,MiddleX,MiddleY,Delta:TVkInt32;
 begin
  x12:=SARLongint(x1+x2,1);
  y12:=SARLongint(y1+y2,1);
  x23:=SARLongint(x2+x3,1);
  y23:=SARLongint(y2+y3,1);
  x123:=SARLongint(x12+x23,1);
  y123:=SARLongint(y12+y23,1);
  MiddleX:=SARLongint(x1+x3,1);
  MiddleY:=SARLongint(y1+y3,1);
  Delta:=abs(MiddleX-x123)+abs(MiddleY-y123);
  if (Level>MaxLevel) or (Delta<Tolerance) then begin
   LineTo(x123,y123);
  end else begin
   Recursive(x1,y1,x12,y12,x123,y123,Level+1);
   Recursive(x123,y123,x23,y23,x3,y3,Level+1);
  end;
 end;
begin
 Recursive(fLastX,fLastY,ControlX,ControlY,AnchorX,AnchorY,0);
 LineTo(AnchorX,AnchorY);
end;

procedure TVulkanTrueTypeFontRasterizer.CubicCurveTo(const c1x,c1y,c2x,c2y,ax,ay:TVkInt32;const Tolerance:TVkInt32=2;const MaxLevel:TVkInt32=32);
 procedure Recursive(const x1,y1,x2,y2,x3,y3,x4,y4,Level:TVkInt32);
 var x12,y12,x23,y23,x34,y34,x123,y123,x234,y234,x1234,y1234,d:TVkInt32;
 begin
  x12:=SARLongint(x1+x2,1);
  y12:=SARLongint(y1+y2,1);
  x23:=SARLongint(x2+x3,1);
  y23:=SARLongint(y2+y3,1);
  x34:=SARLongint(x3+x4,1);
  y34:=SARLongint(y3+y4,1);
  x123:=SARLongint(x12+x23,1);
  y123:=SARLongint(y12+y23,1);
  x234:=SARLongint(x23+x34,1);
  y234:=SARLongint(y23+y34,1);
  x1234:=SARLongint(x123+x234,1);
  y1234:=SARLongint(y123+y234,1);
// d:=abs(SARlongint(x1+x4,1)-x1234)+abs(SARLongint(y1+y4,1)-y1234);
  d:=abs(((x1+x3)-x2)-x2)+abs(((y1+y3)-y2)-y2)+abs(((x2+x4)-x3)-x3)+abs(((y2+y4)-y3)-y3);
  if (Level>MaxLevel) or (d<Tolerance) then begin
   LineTo(x1234,y1234);
  end else begin
   Recursive(x1,y1,x12,y12,x123,y123,x1234,y1234,Level+1);
   Recursive(x1234,y1234,x234,y234,x34,y34,x4,y4,Level+1);
  end;
 end;
begin
 Recursive(fLastX,fLastY,c1x,c1y,c2x,c2y,ax,ay,0);
 LineTo(ax,ay);
end;

procedure TVulkanTrueTypeFontRasterizer.Close;
begin
end;

procedure TVulkanTrueTypeFontRasterizer.Render;
begin
end;

constructor TVulkanTrueTypeFontPolygonRasterizer.Create;
begin
 inherited Create;
 fCanvas:=nil;
 fCurrentWindingRule:=VkTTF_PolygonWindingRule_NONZERO;
 fCurrentWidth:=0;
 fCurrentHeight:=0;
 fScanlines:=nil;
 fCells:=nil;
 fAntialiasing:=true;
 fForceNonAntialiasing:=false;
 fCurrentGamma:=0.0;
 SetGamma(1.0);
 Reset;
end;

destructor TVulkanTrueTypeFontPolygonRasterizer.Destroy;
var i:TVkInt32;
begin
 for i:=0 to length(fCells)-1 do begin
  if assigned(fCells[i]) then begin
   dispose(fCells[i]);
   fCells[i]:=nil;
  end;
 end;
 SetLength(fCells,0);
 SetLength(fScanlines,0);
 inherited Destroy;
end;

function TVulkanTrueTypeFontPolygonRasterizer.GetCanvas:TVkPointer;
begin
 result:=fCanvas;
end;

procedure TVulkanTrueTypeFontPolygonRasterizer.SetCanvas(NewCanvas:TVkPointer);
begin
 fCanvas:=NewCanvas;
end;

function TVulkanTrueTypeFontPolygonRasterizer.GetWidth:TVkInt32;
begin
 result:=fCurrentWidth;
end;

procedure TVulkanTrueTypeFontPolygonRasterizer.SetWidth(NewWidth:TVkInt32);
begin
 Resize(NewWidth,fCurrentHeight);
end;

function TVulkanTrueTypeFontPolygonRasterizer.GetHeight:TVkInt32;
begin
 result:=fCurrentHeight;
end;

procedure TVulkanTrueTypeFontPolygonRasterizer.SetHeight(NewHeight:TVkInt32);
begin
 Resize(fCurrentWidth,NewHeight);
end;

function TVulkanTrueTypeFontPolygonRasterizer.GetWindingRule:TVkInt32;
begin
 result:=fCurrentWindingRule;
end;

procedure TVulkanTrueTypeFontPolygonRasterizer.SetWindingRule(NewWindingRule:TVkInt32);
begin
 fCurrentWindingRule:=NewWindingRule;
end;

procedure TVulkanTrueTypeFontPolygonRasterizer.Clear;
begin
 if assigned(Canvas) then begin
  FillChar(Canvas^,fCurrentWidth*fCurrentHeight*SizeOf(TVkUInt8),AnsiChar(#0));
 end;
end;

procedure TVulkanTrueTypeFontPolygonRasterizer.Reset;
var i:TVkInt32;
begin
 fNumCells:=0;
 fArea:=0;
 fCover:=0;
 for i:=0 to length(fScanlines)-1 do begin
  fScanlines[i].CellFirst:=nil;
  fScanlines[i].CellLast:=nil;
 end;
 fCellX:=-1;
 fCellY:=-1;
 fRenderMinY:=$7fffffff;
 fRenderMaxY:=-$7fffffff;
 fNeedToClose:=false;
 fMoveToX:=0;
 fMoveToY:=0;
 fLastX:=0;
 fLastY:=0;
end;

procedure TVulkanTrueTypeFontPolygonRasterizer.Resize(NewWidth,NewHeight:TVkInt32);
var i:TVkInt32;
begin
 fCurrentWidth:=NewWidth;
 fCurrentHeight:=NewHeight;
 if length(fScanlines)<>fCurrentHeight then begin
  SetLength(fScanlines,fCurrentHeight);
  for i:=0 to length(fScanlines)-1 do begin
   fScanlines[i].CellFirst:=nil;
   fScanlines[i].CellLast:=nil;
  end;
 end;
end;

function TVulkanTrueTypeFontPolygonRasterizer.NewCell:PVulkanTrueTypeFontPolygonRasterizerCell;
 procedure InsertBefore(CellNew,CellOld:PVulkanTrueTypeFontPolygonRasterizerCell);
 begin
  CellNew^.Next:=CellOld;
  CellNew^.Previous:=CellOld^.Previous;
  if assigned(CellOld^.Previous) then begin
   CellOld^.Previous^.Next:=CellNew;
  end;
  CellOld^.Previous:=CellNew;
  if CellOld=fScanlines[fCellY].CellFirst then begin
   fScanlines[fCellY].CellFirst:=CellNew;
  end;
 end;
 procedure InsertAfter(CellOld,CellNew:PVulkanTrueTypeFontPolygonRasterizerCell);
 begin
  CellNew^.Next:=CellOld^.Next;
  CellNew^.Previous:=CellOld;
  if assigned(CellOld^.Next) then begin
   CellOld^.Next^.Previous:=CellNew;
  end;
  CellOld^.Next:=CellNew;
  if CellOld=fScanlines[fCellY].CellLast then begin
   fScanlines[fCellY].CellLast:=CellNew;
  end;
 end;
 function GetCell:PVulkanTrueTypeFontPolygonRasterizerCell;
 var i,OldCount,NewCount:TVkInt32;
 begin
  if fNumCells>=length(fCells) then begin
   OldCount:=length(fCells);
   NewCount:=(fNumCells+1)*2;
   SetLength(fCells,NewCount);
   for i:=OldCount to NewCount-1 do begin
    New(fCells[i]);
   end;
  end;
  result:=fCells[fNumCells];
  inc(fNumCells);
  result^.x:=fCellX;
  result^.Area:=0;
  result^.Cover:=0;
  result^.Previous:=nil;
  result^.Next:=nil;
 end;
var CurrentCell:PVulkanTrueTypeFontPolygonRasterizerCell;
begin
 if (fCellY<0) or (fCellY>=length(fScanlines)) then begin
  result:=nil;
 end else begin
  if assigned(fScanlines[fCellY].CellFirst) and assigned(fScanlines[fCellY].CellLast) then begin
   if fScanlines[fCellY].CellFirst^.x=fCellX then begin
    result:=fScanlines[fCellY].CellFirst;
   end else if fScanlines[fCellY].CellLast^.x=fCellX then begin
    result:=fScanlines[fCellY].CellLast;
   end else if fScanlines[fCellY].CellFirst^.x>fCellX then begin
    result:=GetCell;
    InsertBefore(result,fScanlines[fCellY].CellFirst);
   end else if fScanlines[fCellY].CellLast^.x<fCellX then begin
    result:=GetCell;
    InsertAfter(fScanlines[fCellY].CellLast,result);
   end else begin
    CurrentCell:=fScanlines[fCellY].CellFirst;
    while assigned(CurrentCell) and (CurrentCell^.x<fCellX) do begin
     CurrentCell:=CurrentCell^.Next;
    end;
    if assigned(CurrentCell) then begin
     if CurrentCell^.x=fCellX then begin
      result:=CurrentCell;
     end else begin
      result:=GetCell;
      InsertBefore(result,CurrentCell);
     end;
    end else begin
     result:=GetCell;
     InsertAfter(fScanlines[fCellY].CellLast,result);
    end;
   end;
  end else begin
   result:=GetCell;
   fScanlines[fCellY].CellFirst:=result;
   fScanlines[fCellY].CellLast:=result;
  end;
  if fRenderMinY>fCellY then begin
   fRenderMinY:=fCellY;
  end;
  if fRenderMaxY<fCellY then begin
   fRenderMaxY:=fCellY;
  end;
 end;
end;

procedure TVulkanTrueTypeFontPolygonRasterizer.RecordCell;
var Cell:PVulkanTrueTypeFontPolygonRasterizerCell;
begin
 if (fArea<>0) or (fCover<>0) then begin
  Cell:=NewCell;
  if assigned(Cell) then begin
   inc(Cell^.Area,fArea);
   inc(Cell^.Cover,fCover);
  end;
 end;
end;

procedure TVulkanTrueTypeFontPolygonRasterizer.SetCell(NewX,NewY:TVkInt32;Force:boolean=false);
begin
 if (fCellX<>NewX) or (fCellY<>NewY) or Force then begin
  RecordCell;
  fCellX:=NewX;
  fCellY:=NewY;
  fArea:=0;
  fCover:=0;
 end;
end;

procedure TVulkanTrueTypeFontPolygonRasterizer.StartCell(NewX,NewY:TVkInt32);
begin
 fArea:=0;
 fCover:=0;
 SetCell(NewX,NewY,true);
end;

procedure TVulkanTrueTypeFontPolygonRasterizer.RenderScanLine(NewY,x1,y1,x2,y2:TVkInt32);
var ex1,ex2,fx1,fx2,Delta,Temp,First,DeltaX,Increment,Lift,Modulo,Remainder:TVkInt32;
begin
 DeltaX:=x2-x1;
 ex1:=SARLongint(x1,PixelBits);
 ex2:=SARLongint(x2,PixelBits);
 fx1:=x1 and PixelMask;
 fx2:=x2 and PixelMask;
 
 if y1=y2 then begin
  // A trivial case. Happens often
  SetCell(ex2,NewY);
  exit;
 end;
 
 if ex1=ex2 then begin
  // Everything is located in a single x-based cell. That is easy!
  Delta:=y2-y1;
  inc(fArea,(fx1+fx2)*Delta);
  inc(fCover,Delta);
  exit;
 end;

 // Ok, we'll have to render a run of adjacent fCells on the same scanline.
 if DeltaX<0 then begin
  Temp:=fx1*(y2-y1);
  First:=0;
  Increment:=-1;
  DeltaX:=-DeltaX;
 end else begin
  Temp:=(OnePixel-fx1)*(y2-y1);
  First:=OnePixel;
  Increment:=1;
 end;

 Delta:=Temp div DeltaX;
 Modulo:=Temp mod DeltaX;
 if Modulo<0 then begin
  dec(Delta);
  inc(Modulo,DeltaX);
 end;

 inc(fArea,(fx1+First)*Delta);
 inc(fCover,Delta);
 
 inc(ex1,Increment);
 SetCell(ex1,NewY);
 inc(y1,Delta);

 if ex1<>ex2 then begin
  Temp:=OnePixel*((y2-y1)+Delta);
  Lift:=Temp div DeltaX;
  Remainder:=Temp mod DeltaX;
  if Remainder<0 then begin
   dec(Lift);
   inc(Remainder,DeltaX);
  end;
  dec(Modulo,DeltaX);
  while ex1<>ex2 do begin
   Delta:=Lift;
   inc(Modulo,Remainder);
   if Modulo>=0 then begin
    dec(Modulo,DeltaX);
    inc(Delta);
   end;
   inc(fArea,OnePixel*Delta);
   inc(fCover,Delta);
   inc(y1,Delta);
   inc(ex1,Increment);
   SetCell(ex1,NewY);
  end;
 end;
 Delta:=y2-y1;
 inc(fArea,(fx2+OnePixel-First)*Delta);
 inc(fCover,Delta);
end;

procedure TVulkanTrueTypeFontPolygonRasterizer.RenderLine(ToX,ToY:TVkInt32);
var ey1,ey2,fy1,fy2,DeltaX,DeltaY,NewX,NextX,Temp,First,Delta,Remainder,Modulo,Lift,Increment,MinValue,MaxValue,NewCellX,TwoFracX,Area:TVkInt32;
begin
 ey1:=SARLongint(fY,PixelBits);
 ey2:=SARLongint(ToY,PixelBits);
 fy1:=fY and PixelMask;
 fy2:=ToY and PixelMask;

 DeltaX:=ToX-fX;
 DeltaY:=ToY-fY;
 
 // Perform vertical clipping
 if ey1<ey2 then begin
  MinValue:=ey1;
  MaxValue:=ey2;
 end else begin
  MinValue:=ey2;
  MaxValue:=ey1;
 end;

 if (MinValue>=fCurrentHeight) or (MaxValue<0) then begin
  fX:=ToX;
  fY:=ToY;
  exit;
 end;
 
 if ey1=ey2 then begin
  // Everything is on a single scanline
  RenderScanLine(ey1,fX,fy1,ToX,fy2);
  fX:=ToX;
  fY:=ToY;
  exit;
 end;
 
 // Vertical line - avoid calling RenderScanLine
 Increment:=1;
 if DeltaX=0 then begin
  NewCellX:=SARLongint(fX,PixelBits);
  TwoFracX:=(fX and PixelMask) shl 1;

  First:=OnePixel;
  if DeltaY<0 then begin
   First:=0;
   Increment:=-1;
  end;

  Delta:=First-fy1;
  inc(fArea,TwoFracX*Delta);
  inc(fCover,Delta);
  inc(ey1,Increment);

  SetCell(NewCellX,ey1);

  Delta:=(First+First)-OnePixel;
  Area:=TwoFracX*Delta;
  while ey1<>ey2 do begin
   inc(fArea,Area);
   inc(fCover,Delta);
   inc(ey1,Increment);
   SetCell(NewCellX,ey1);
  end;

  Delta:=(fy2-OnePixel)+First;
  inc(fArea,TwoFracX*Delta);
  inc(fCover,Delta);
  fX:=ToX;
  fY:=ToY;
  exit;
 end;

 // Ok, we have to render several fScanlines
 if DeltaY<0 then begin
  Temp:=fy1*DeltaX;
  First:=0;
  Increment:=-1;
  DeltaY:=-DeltaY;
 end else begin
  Temp:=(OnePixel-fy1)*DeltaX;
  First:=OnePixel;
  Increment:=1;
 end;
 
 Delta:=Temp div DeltaY;
 Modulo:=Temp mod DeltaY;
 if Modulo<0 then begin
  dec(Delta);
  inc(Modulo,DeltaY);
 end;

 NewX:=fX+Delta;
 RenderScanLine(ey1,fX,fy1,NewX,First);

 inc(ey1,Increment);
 SetCell(SARLongint(NewX,PixelBits),ey1);

 if ey1<>ey2 then begin
  Temp:=OnePixel*DeltaX;
  Lift:=Temp div DeltaY;
  Remainder:=Temp mod DeltaY;
  if Remainder<0 then begin
   dec(Lift);
   inc(Remainder,DeltaY);
  end;
  while ey1<>ey2 do begin
   Delta:=Lift;
   inc(Modulo,Remainder);
   if Modulo>=0 then begin
    dec(Modulo,DeltaY);
    inc(Delta);
   end;
   NextX:=NewX+Delta;
   RenderScanLine(ey1,NewX,OnePixel-First,NextX,First);
   NewX:=NextX;
   inc(ey1,Increment);
   SetCell(SARLongint(NewX,PixelBits),ey1);
  end;
 end;
 RenderScanLine(ey1,NewX,OnePixel-First,ToX,fy2);

 fX:=ToX;
 fY:=ToY;
end;

procedure TVulkanTrueTypeFontPolygonRasterizer.ProcessSpan(x,y,Area,Len:TVkInt32);
const Bits=((PixelBits*2)+1)-8;
      Half=1 shl (Bits-1);
var Coverage:TVkInt32;
begin
 Coverage:=abs(SARLongint(Area+Half,Bits));
 case fCurrentWindingRule of
  VkTTF_PolygonWindingRule_NONZERO:begin
   if Coverage>255 then begin
    Coverage:=255;
   end;
  end;
  VkTTF_PolygonWindingRule_EVENODD:begin
   Coverage:=Coverage and 511;
   if Coverage>256 then begin
    Coverage:=512-Coverage;
   end else if Coverage=256 then begin
    Coverage:=255;
   end;
  end;
 end;
 if Coverage<>0 then begin
  RenderSpanCoverage(y,x,Len,Coverage);
 end;
end;

procedure TVulkanTrueTypeFontPolygonRasterizer.MakeScanLineSpansAndRenderThese;
var Cover,x,Area,i:TVkInt32;
    c:PVulkanTrueTypeFontPolygonRasterizerCell;
begin
 if fNumCells<>0 then begin
  for i:=fRenderMinY to fRenderMaxY do begin
   x:=0;
   Cover:=0;
   c:=fScanlines[i].CellFirst;
   while assigned(c) do begin
    if (c^.x>x) and (Cover<>0) then begin
     ProcessSpan(x,i,Cover*(OnePixel*2),c^.x-x);
    end;
    inc(Cover,c^.Cover);
    Area:=(Cover*(OnePixel*2))-c^.Area;
    if (Area<>0) and (c^.x>=0) then begin
     ProcessSpan(c^.x,i,Area,1);
    end;
    x:=c^.x+1;
    c:=c^.Next;
   end;
  end;
 end;
end;

procedure TVulkanTrueTypeFontPolygonRasterizer.SetGamma(AGamma:TVkDouble);
const div255=1/255;
var i,j:TVkInt32;
begin
 if fCurrentGamma<>AGamma then begin
  fCurrentGamma:=AGamma;
  fForceNonAntialiasing:=AGamma<1e-8;
  for i:=low(TVulkanTrueTypeFontPolygonRasterizerGammaLookUpTable) to high(TVulkanTrueTypeFontPolygonRasterizerGammaLookUpTable) do begin
   if i=0 then begin
    j:=0;
   end else if fForceNonAntialiasing then begin
    j:=255;
   end else begin
    j:=trunc(power(i*div255,AGamma)*255);
    if j<0 then begin
     j:=0;
    end else if j>255 then begin
     j:=255;
    end;
   end;
   fCurrentGammaLookUpTable[i]:=j;
  end;
 end;
end;

procedure TVulkanTrueTypeFontPolygonRasterizer.MoveTo(ToX,ToY:TVkInt32);
begin
 Close;
 fNeedToClose:=true;
 StartCell(SARLongint(ToX,PixelBits),SARLongint(ToY,PixelBits));
 fX:=ToX;
 fY:=ToY;
 fMoveToX:=ToX;
 fMoveToY:=ToY;
 fLastX:=ToX;
 fLastY:=ToY;
end;

procedure TVulkanTrueTypeFontPolygonRasterizer.LineTo(ToX,ToY:TVkInt32);
begin
 RenderLine(ToX,ToY);
 fLastX:=ToX;
 fLastY:=ToY;
end;

procedure TVulkanTrueTypeFontPolygonRasterizer.Close;
begin
 if fNeedToClose then begin
  fNeedToClose:=false;
  if (fMoveToX<>fLastX) or (fMoveToY<>fLastY) then begin
   RenderLine(fMoveToX,fMoveToY);
   fLastX:=fMoveToX;
   fLastY:=fMoveToY;
  end;
  RecordCell;
 end;
end;

procedure TVulkanTrueTypeFontPolygonRasterizer.Render;
begin
 Close;
 MakeScanLineSpansAndRenderThese;
 Reset;
end;

procedure TVulkanTrueTypeFontPolygonRasterizer.RenderSpanCoverage(y,x,Len,Coverage:TVkInt32);
var p:PVkUInt8;
    Alpha:TVkUInt32;
    i:TVkInt32;
begin
 if (Coverage<>0) and (((x+Len)>0) and (x<fCurrentWidth)) then begin
  if x<0 then begin
   inc(Len,x);
   if Len<0 then begin
    Len:=0;
   end else begin
    x:=0;
   end;
  end;
  if Len>(fCurrentWidth-x) then begin
   Len:=fCurrentWidth-x;
  end;
  if Len>0 then begin
   p:=@PVulkanTrueTypeFontByteArray(Canvas)^[(y*fCurrentWidth)+x];
   if fAntialiasing then begin
    Alpha:=GammaLookUpTable[Coverage and $ff];
    case Alpha of
     0:begin
     end;
     1..254:begin
      for i:=1 to Len do begin
       if p^<Alpha then begin
        p^:=Alpha;
       end;
       inc(p);
      end;
     end; 
     else begin
      for i:=1 to Len shr 2 do begin
       PVkUInt32(TVkPointer(p))^:=$ffffffff;
       inc(p,SizeOf(TVkUInt32));
      end;
      for i:=1 to Len and 3 do begin
       p^:=$ff;
       inc(p);
      end;
     end;
    end;
   end else begin
    if Coverage>=128 then begin
     for i:=1 to Len shr 2 do begin
      PVkUInt32(TVkPointer(p))^:=$ffffffff;
      inc(p,SizeOf(TVkUInt32));
     end;
     for i:=1 to Len and 3 do begin
      p^:=$ff;
      inc(p);
     end;
    end;
   end;
  end;
 end;
end;

constructor TVulkanTrueTypeFontStrokeRasterizer.Create(Rasterizer:TVulkanTrueTypeFontRasterizer);
begin
 inherited Create;
 fRasterizer:=Rasterizer;
 fLinePoints:=nil;
 fNumLinePoints:=0;
 fLineWidth:=1.0;
 fLineCapMode:=VkTTF_LineCapMode_BUTT;
 fLineJoinMode:=VkTTF_LineJoinMode_BEVEL;
 fLineInnerJoinMode:=VkTTF_LineInnerJoinMode_BEVEL;
 fLineStrokePattern:='';
 fLineStrokePatternStepSize:=4.0;
 fFlushLineOnWork:=false;
end;

destructor TVulkanTrueTypeFontStrokeRasterizer.Destroy;
begin
 SetLength(fLinePoints,0);
 inherited Destroy;
end;

procedure TVulkanTrueTypeFontStrokeRasterizer.AddLinePoint(const x,y:TVkInt32);
begin
 if fNumLinePoints>=length(fLinePoints) then begin
  SetLength(fLinePoints,(fNumLinePoints+1)*2);
 end;
 fLinePoints[fNumLinePoints].x:=x;
 fLinePoints[fNumLinePoints].y:=y;
 inc(fNumLinePoints);
end;

procedure TVulkanTrueTypeFontStrokeRasterizer.ConvertLineStorkeToPolygon;
var CurrentLineWidth,i,x1,y1,x2,y2,dx,dy,d,fx,fy,lx,ly:TVkInt32;
    First,Closed:boolean;
    lhw:single;
 procedure Point(x,y:TVkInt32);
 begin
  if First then begin
   First:=false;
   if assigned(fRasterizer) then begin
    fRasterizer.MoveTo(x,y);
   end;
   fx:=x;
   fy:=y;
  end else begin
   if assigned(fRasterizer) then begin
    fRasterizer.LineTo(x,y);
   end;
  end;
  lx:=x;
  ly:=y;
 end;
 procedure CloseLine;
 begin
  if ((lx<>fx) or (ly<>fy)) and not First then begin
   Point(fx,fy);
  end;
 end;
 function CalcIntersection(ax,ay,bx,by,cx,cy,dx,dy:single;out x,y:single):boolean;
 var r,num,den:single;
 begin
  num:=((ay-cy)*(dx-cx))-((ax-cx)*(dy-cy));
  den:=((bx-ax)*(dy-cy))-((by-ay)*(dx-cx));
  if abs(den)<1.0E-14 then begin
   result:=false;
  end else begin
   r:=num/den;
   x:=ax+(r*(bx-ax));
   y:=ay+(r*(by-ay));
   result:=true;
  end;
 end;
 procedure DoArc(x,y,dx1,dy1,dx2,dy2:TVkInt32);
 var a1,a2,da:single;
     ccw:boolean;
 begin
  a1:=arctan2(dy1,dx1);
  a2:=arctan2(dy2,dx2);
  da:=a1-a2;
  ccw:=(da>0) and (da<pi);
  da:=arccos(lhw/(lhw+32))*2;
  Point(x+dx1,y+dy1);
  if ccw then begin
   if a1<a2 then begin
    a2:=a2-(2*pi);
   end;
   a2:=a2+(da*0.25);
   a1:=a1-da;
   while a1>a2 do begin
    Point(trunc(x+(cos(a1)*lhw)),trunc(y+(sin(a1)*lhw)));
    a1:=a1-da;
   end;
  end else begin
   if a1>a2 then begin
    a2:=a2+(2*pi);
   end;
   a2:=a2-(da*0.25);
   a1:=a1+da;
   while a1<a2 do begin
    Point(trunc(x+(cos(a1)*lhw)),trunc(y+(sin(a1)*lhw)));
    a1:=a1+da;
   end;
  end;
  Point(x+dx2,y+dy2);
 end;
 procedure DoMiter(p1x,p1y,p2x,p2y,p3x,p3y,dx1,dy1,dx2,dy2,CurrentLineJoinMode,miterlimit:TVkInt32);
 var xi,yi,d1,lim,x2,y2:single;
     miterlimitexceeded:boolean;
 begin
  xi:=p2x;
  yi:=p2y;
  miterlimitexceeded:=true;
  if CalcIntersection(p1x+dx1,p1y-dy1,p2x+dx1,p2y-dy1,p2x+dx2,p2y-dy2,p3x+dx2,p3y-dy2,xi,yi) then begin
   d1:=sqrt(sqr(p2x-xi)+sqr(p2y-yi));
   lim:=SARLongint(CurrentLineWidth*miterlimit,9); // div (256*2);
   if d1<=lim then begin
    Point(trunc(xi),trunc(yi));
    miterlimitexceeded:=false;
   end;
  end else begin
   x2:=p2x+dx1;
   y2:=p2y-dy1;
   if ((((x2-p1x)*dy1)-((p1y-y2)*dx1))<0)<>((((x2-p3x)*dy1)-((p3y-y2)*dx1)<0)) then begin
    Point(p2x+dx1,p2y-dy1);
    miterlimitexceeded:=false;
   end;
  end;
  if miterlimitexceeded then begin
   case CurrentLineJoinMode of
    VkTTF_LineJoinMode_MITERREVERT:begin
     Point(p2x+dx1,p2y-dy1);
     Point(p2x+dx2,p2y-dy2);
    end;
    VkTTF_LineJoinMode_MITERROUND:begin
     DoArc(p2x,p2y,dx1,-dy1,dx2,-dy2);
    end;
    else begin
     Point((p2x+dx1)+SARLongint(dy1*miterlimit,8),(p2y-dy1)+SARLongint(dx1*miterlimit,8));
     Point((p2x+dx2)-SARLongint(dy2*miterlimit,8),(p2y-dy2)-SARLongint(dx2*miterlimit,8));
    end;
   end;
  end;
 end;
 procedure Join(i1,i2,i3,di1,di2:TVkInt32);
  function calc_point_location(x1,y1,x2,y2,x3,y3:TVkInt32):TVkInt32;
  begin
   result:=((x3-x2)*(y2-y1))-((y3-y2)*(x2-x1));
  end;
 var x1,y1,x2,y2,x3,y3,dx1,dy1,dx2,dy2,d1,d2,d:TVkInt32;
 begin
  x1:=fLinePoints[i1].x;
  y1:=fLinePoints[i1].y;
  x2:=fLinePoints[i2].x;
  y2:=fLinePoints[i2].y;
  x3:=fLinePoints[i3].x;
  y3:=fLinePoints[i3].y;
  d1:=fLinePoints[di1].d;
  d2:=fLinePoints[di2].d;
  dx1:=(CurrentLineWidth*(y2-y1)) div (d1*2);
  dy1:=(CurrentLineWidth*(x2-x1)) div (d1*2);
  dx2:=(CurrentLineWidth*(y3-y2)) div (d2*2);
  dy2:=(CurrentLineWidth*(x3-x2)) div (d2*2);
  if calc_point_location(x1,y1,x2,y2,x3,y3)>0 then begin
   case fLineInnerJoinMode of
    VkTTF_LineInnerJoinMode_BEVEL:begin
     Point(x2+dx1,y2-dy1);
     Point(x2+dx2,y2-dy2);
    end;
    VkTTF_LineInnerJoinMode_MITER:begin
     DoMiter(x1,y1,x2,y2,x3,y3,dx1,dy1,dx2,dy2,VkTTF_LineJoinMode_MITERREVERT,258);
    end;
    VkTTF_LineInnerJoinMode_JAG:begin
     d:=((dx1-dx2)*(dx1-dx2))+((dy1-dy2)*(dy1-dy2));
     if (d<(d1*d1)) and (d<(d2*d2)) then begin
      DoMiter(x1,y1,x2,y2,x3,y3,dx1,dy1,dx2,dy2,VkTTF_LineJoinMode_MITERREVERT,258);
     end else begin
      Point(x2+dx1,y2-dy1);
      Point(x2,y2);
      Point(x2+dx2,y2-dy2);
     end;
    end;
    VkTTF_LineInnerJoinMode_ROUND:begin
     d:=((dx1-dx2)*(dx1-dx2))+((dy1-dy2)*(dy1-dy2));
     if (d<(d1*d1)) and (d<(d2*d2)) then begin
      DoMiter(x1,y1,x2,y2,x3,y3,dx1,dy1,dx2,dy2,VkTTF_LineJoinMode_MITERREVERT,258);
     end else begin
      Point(x2+dx1,y2-dy1);
      Point(x2,y2);
      DoArc(x2,y2,dx2,-dy2,dx1,-dy1);
      Point(x2,y2);
      Point(x2+dx2,y2-dy2);
     end;
    end;
   end;
  end else begin
   case fLineJoinMode of
    VkTTF_LineJoinMode_BEVEL:begin
     Point(x2+dx1,y2-dy1);
     Point(x2+dx2,y2-dy2);
    end;
    VkTTF_LineJoinMode_ROUND:begin
     DoArc(x2,y2,dx1,-dy1,dx2,-dy2);
    end;
    VkTTF_LineJoinMode_MITER,VkTTF_LineJoinMode_MITERREVERT,VkTTF_LineJoinMode_MITERROUND:begin
     DoMiter(x1,y1,x2,y2,x3,y3,dx1,dy1,dx2,dy2,fLineJoinMode,1024);
    end;
   end;
  end;
 end;
 procedure Cap(i1,i2,di:TVkInt32);
 var x1,y1,x2,y2,dx1,dy1,dx2,dy2,d:TVkInt32;
     a1,a2,da:single;
 begin
  x1:=fLinePoints[i1].x;
  y1:=fLinePoints[i1].y;
  x2:=fLinePoints[i2].x;
  y2:=fLinePoints[i2].y;
  d:=fLinePoints[di].d;
  dx1:=(CurrentLineWidth*(y2-y1)) div (2*d);
  dy1:=(CurrentLineWidth*(x2-x1)) div (2*d);
  case fLineCapMode of
   VkTTF_LineCapMode_ROUND:begin
    Point(x1-dx1,y1+dy1);
    if dx1=0 then begin
     dx1:=1;
    end;
    a1:=arctan2(dy1,-dx1);
    a2:=a1+pi;
    da:=arccos(lhw/(lhw+32))*2;
    a1:=a1+da;
    a2:=a2-(da*0.25);
    while a1<a2 do begin
     Point(trunc(x1+(cos(a1)*lhw)),trunc(y1+(sin(a1)*lhw)));
     a1:=a1+da;
    end;
    Point(x1+dx1,y1-dy1);
   end;
   else begin
    case fLineCapMode of
     VkTTF_LineCapMode_SQUARE:begin
      dx2:=dx1;
      dy2:=dy1;
     end;
     else begin
      dx2:=0;
      dy2:=0;
     end;
    end;
    Point(x1-dx1-dx2,y1+dy1-dy2);
    Point(x1+dx1-dx2,y1-dy1-dy2);
   end;
  end;
 end;
 function VectorLength(x,y:TVkInt32):TVkInt32;
 const Inv256=1/256;
 begin
  if (abs(x)+abs(y))<32768 then begin
   result:=isqrt((x*x)+(y*y));
  end else begin
   result:=round(sqrt(sqr(x*Inv256)+sqr(y*Inv256))*256);
  end;
 end;
begin
 if fNumLinePoints>=2 then begin
  CurrentLineWidth:=round(fLineWidth*256);
  Closed:=false;
  if (fLinePoints[0].x=fLinePoints[fNumLinePoints-1].x) and (fLinePoints[0].y=fLinePoints[fNumLinePoints-1].y) then begin
   dec(fNumLinePoints);
   Closed:=true;
  end;
  for i:=0 to fNumLinePoints-1 do begin
   x1:=fLinePoints[i].x;
   y1:=fLinePoints[i].y;
   x2:=fLinePoints[(i+1) mod fNumLinePoints].x;
   y2:=fLinePoints[(i+1) mod fNumLinePoints].y;
   dx:=x2-x1;
   dy:=y2-y1;
   d:=VectorLength(dx,dy);
   if d=0 then begin
    d:=1;
   end;
   fLinePoints[i].d:=d;
  end;
  lhw:=abs(CurrentLineWidth*0.5);
  if Closed then begin
   First:=true;
   for i:=0 to fNumLinePoints-1 do begin
    Join((i+fNumLinePoints-1) mod fNumLinePoints,i,(i+1) mod fNumLinePoints,(i+fNumLinePoints-1) mod fNumLinePoints,i);
   end;
   CloseLine;
   First:=true;
   for i:=fNumLinePoints-1 downto 0 do begin
    Join((i+1) mod fNumLinePoints,i,(i+fNumLinePoints-1) mod fNumLinePoints,i,(i+fNumLinePoints-1) mod fNumLinePoints);
   end;
   CloseLine;
  end else begin
   First:=true;
   Cap(0,1,0);
   for i:=1 to fNumLinePoints-2 do begin
    Join((i+fNumLinePoints-1) mod fNumLinePoints,i,(i+1) mod fNumLinePoints,(i+fNumLinePoints-1) mod fNumLinePoints,i);
   end;
   Cap(fNumLinePoints-1,fNumLinePoints-2,fNumLinePoints-2);
   for i:=fNumLinePoints-2 downto 1 do begin
    Join((i+1) mod fNumLinePoints,i,(i+fNumLinePoints-1) mod fNumLinePoints,i,(i+fNumLinePoints-1) mod fNumLinePoints);
   end;
  end;
  CloseLine;
 end;
end;

procedure TVulkanTrueTypeFontStrokeRasterizer.FlushLine;
var StepCounter,StepIndex,
    StepEndX,StepEndY:TVkInt32;
    NewLine,LastStepBool,StepBool,DoFlushStepLine,DoConvertLineStorkeToPolygon:boolean;
    LinePointsBuf:TVulkanTrueTypeFontStrokeRasterizerPoints;
    i:TVkInt32;
 procedure AddLinePointEx(x,y:TVkInt32);
 begin
  if (fNumLinePoints=0) or ((fNumLinePoints>0) and ((fLinePoints[fNumLinePoints-1].x<>x) or (fLinePoints[fNumLinePoints-1].y<>y))) then begin
   AddLinePoint(x,y);
   DoConvertLineStorkeToPolygon:=true;
  end;
 end;
 procedure FlushStepLine;
 begin
  if DoConvertLineStorkeToPolygon then begin
   if fNumLinePoints>1 then begin
    DoFlushStepLine:=false;
    DoConvertLineStorkeToPolygon:=false;
    ConvertLineStorkeToPolygon;
    fNumLinePoints:=0;
   end;
  end;
 end;
 procedure StepPoint(x,y:TVkInt32);
 begin
  if StepCounter=0 then begin
   if StepIndex>length(fLineStrokePattern) then begin
    StepIndex:=1;
   end;
   LastStepBool:=StepBool;
   if StepIndex<=length(fLineStrokePattern) then begin
    StepBool:=fLineStrokePattern[StepIndex]<>' ';
   end else begin
    StepBool:=false;
   end;
   if StepBool then begin
    DoFlushStepLine:=true;
    if not LastStepBool then begin
     AddLinePointEx(x,y);
    end;
   end else begin
    FlushStepLine;
    DoFlushStepLine:=false;
   end;
  end else if NewLine then begin
   if StepBool then begin
    AddLinePointEx(x,y);
   end;
  end;
  if StepBool then begin
   StepEndX:=x;
   StepEndY:=y;
  end;
  inc(StepCounter);
  if StepCounter>=fLineStrokePatternStepSize then begin
   if StepBool then begin
    AddLinePointEx(x,y);
   end;
   StepCounter:=0;
   inc(StepIndex);
  end;
  NewLine:=false;
 end;
 function Scale(ps,pc,pe,vs,ve:TVkInt32):TVkInt32;
 begin
  if ps=pe then begin
   result:=vs;
  end else begin
   if ps<pe then begin
    result:=vs+(((ve-vs)*(pc-ps)) div (pe-ps));
   end else begin
    result:=vs+(((ve-vs)*(pc-pe)) div (ps-pe));
   end;
  end;
 end;
 procedure StepLine(x0,y0,x1,y1:TVkInt32);
 var stepx,stepy{,xs,ys},dx,dy,fraction:TVkInt32;
 begin
  NewLine:=false;
  dx:=x1-x0;
  dy:=y1-y0;
  if dx<0 then begin
   dx:=-dx;
   stepx:=-1;
  end else begin
   stepx:=1;
  end;
  if dy<0 then begin
   dy:=-dy;
   stepy:=-1;
  end else begin
   stepy:=1;
  end;
{ xs:=x0;
  ys:=y0;}
  dx:=dx*2;
  dy:=dy*2;
  StepPoint(x0,y0);
  if dx>dy then begin
   fraction:=dy-SARLongint(dx,1);
   while x0<>x1 do begin
    if fraction>=0 then begin
     inc(y0,stepy);
     dec(fraction,dx);
    end;
    inc(x0,stepx);
    inc(fraction,dy);
    StepPoint(x0,y0);
   end;
  end else begin
   fraction:=dx-SARLongint(dy,1);
   while y0<>y1 do begin
    if fraction>=0 then begin
     inc(x0,stepx);
     dec(fraction,dy);
    end;
    inc(y0,stepy);
    inc(fraction,dx);
    StepPoint(x0,y0);
   end;
  end;
 end;
begin
 if not fFlushLineOnWork then begin
  fFlushLineOnWork:=true;
  if fNumLinePoints>0 then begin
   if length(fLineStrokePattern)>0 then begin
    StepCounter:=0;
    StepIndex:=1;
    DoFlushStepLine:=false;
    DoConvertLineStorkeToPolygon:=false;
    SetLength(LinePointsBuf,fNumLinePoints);
    try
     for i:=0 to fNumLinePoints-1 do begin
      LinePointsBuf[i]:=fLinePoints[i];
     end;
     LastStepBool:=false;
     StepBool:=false;
     fNumLinePoints:=0;
     if length(LinePointsBuf)=0 then begin
      StepLine(LinePointsBuf[0].x,LinePointsBuf[0].y,LinePointsBuf[0].x,LinePointsBuf[0].y);
     end else begin
      for i:=1 to length(LinePointsBuf)-1 do begin
       StepLine(LinePointsBuf[i-1].x,LinePointsBuf[i-1].y,LinePointsBuf[i].x,LinePointsBuf[i].y);
      end;
     end;
     if StepBool and DoFlushStepLine then begin
      AddLinePointEx(StepEndX,StepEndY);
     end;
     FlushStepLine;
    finally
     SetLength(LinePointsBuf,0);
     fNumLinePoints:=0;
    end;
   end else begin
    try
     ConvertLineStorkeToPolygon;
    finally
     fNumLinePoints:=0;
    end;
   end;
  end;
  fFlushLineOnWork:=false;
 end;
end;

function TVulkanTrueTypeFontStrokeRasterizer.GetCanvas:TVkPointer;
begin
 if assigned(fRasterizer) then begin
  result:=fRasterizer.GetCanvas;
 end else begin
  result:=nil;
 end;
end;

procedure TVulkanTrueTypeFontStrokeRasterizer.SetCanvas(NewCanvas:TVkPointer);
begin
 if assigned(fRasterizer) then begin
  fRasterizer.SetCanvas(NewCanvas);
 end;
end;

function TVulkanTrueTypeFontStrokeRasterizer.GetWidth:TVkInt32;
begin
 if assigned(fRasterizer) then begin
  result:=fRasterizer.GetWidth;
 end else begin
  result:=0;
 end;
end;

procedure TVulkanTrueTypeFontStrokeRasterizer.SetWidth(NewWidth:TVkInt32);
begin
 if assigned(fRasterizer) then begin
  fRasterizer.SetWidth(NewWidth);
 end;
end;

function TVulkanTrueTypeFontStrokeRasterizer.GetHeight:TVkInt32;
begin
 if assigned(fRasterizer) then begin
  result:=fRasterizer.GetHeight;
 end else begin
  result:=0;
 end;
end;

procedure TVulkanTrueTypeFontStrokeRasterizer.SetHeight(NewHeight:TVkInt32);
begin
 if assigned(fRasterizer) then begin
  fRasterizer.SetHeight(NewHeight);
 end;
end;

function TVulkanTrueTypeFontStrokeRasterizer.GetWindingRule:TVkInt32;
begin
 if assigned(fRasterizer) then begin
  result:=fRasterizer.GetWindingRule;
 end else begin
  result:=0;
 end;
end;

procedure TVulkanTrueTypeFontStrokeRasterizer.SetWindingRule(NewWindingRule:TVkInt32);
begin
 if assigned(fRasterizer) then begin
  fRasterizer.SetWindingRule(NewWindingRule);
 end;
end;

procedure TVulkanTrueTypeFontStrokeRasterizer.Clear;
begin
 if assigned(fRasterizer) then begin
  fRasterizer.Clear;
 end;
end;

procedure TVulkanTrueTypeFontStrokeRasterizer.Reset;
begin
 if assigned(fRasterizer) then begin
  fRasterizer.Reset;
 end;
end;

procedure TVulkanTrueTypeFontStrokeRasterizer.Resize(NewWidth,NewHeight:TVkInt32);
begin
 if assigned(fRasterizer) then begin
  fRasterizer.Resize(NewWidth,NewHeight);
 end;
end;

procedure TVulkanTrueTypeFontStrokeRasterizer.MoveTo(ToX,ToY:TVkInt32);
begin
 FlushLine;
 fStartLineX:=ToX;
 fStartLineY:=ToY;
 AddLinePoint(ToX,ToY);
 fLastX:=ToX;
 fLastY:=ToY;
end;

procedure TVulkanTrueTypeFontStrokeRasterizer.LineTo(ToX,ToY:TVkInt32);
begin
 AddLinePoint(ToX,ToY);
 fLastX:=ToX;
 fLastY:=ToY;
end;

procedure TVulkanTrueTypeFontStrokeRasterizer.Close;
begin
 FlushLine;
 fRasterizer.Close;
end;

procedure TVulkanTrueTypeFontStrokeRasterizer.Render;
begin
 if assigned(fRasterizer) then begin
  fRasterizer.Render;
 end;
end;

type TMatrix=array[0..5] of single;

const MatrixIdentity:TMatrix=(1,0,0,1,0,0);
      MatrixNull:TMatrix=(0,0,0,0,0,0);

function MatrixTranslate(tx,ty:single):TMatrix;
begin
 result:=MatrixIdentity;
 result[4]:=tx;
 result[5]:=ty;
end;

function MatrixScale(sx,sy:single):TMatrix;
begin
 result:=MatrixIdentity;
 result[0]:=sx;
 result[3]:=sy;
end;

function MatrixRotate(degress:single):TMatrix;
var rad,c,s:single;
begin
 rad:=degress*deg2rad;
 c:=cos(rad);
 s:=sin(rad);
 result:=MatrixIdentity;
 result[0]:=c;
 result[1]:=s;
 result[2]:=-s;
 result[3]:=c;
end;

function MatrixSkewX(x:single):TMatrix;
begin
 result:=MatrixIdentity;
 result[1]:=tan(x*deg2rad);
end;

function MatrixSkewY(y:single):TMatrix;
begin
 result:=MatrixIdentity;
 result[2]:=tan(y*deg2rad);
end;

function MatrixMul(const a,b:TMatrix):TMatrix;
begin
 result[0]:=(a[0]*b[0])+(a[1]*b[2]);
 result[1]:=(a[0]*b[1])+(a[1]*b[3]);
 result[2]:=(a[2]*b[0])+(a[3]*b[2]);
 result[3]:=(a[2]*b[1])+(a[3]*b[3]);
 result[4]:=(a[4]*b[0])+(a[5]*b[2])+b[4];
 result[5]:=(a[4]*b[1])+(a[5]*b[3])+b[5];
end;

function MatrixInverse(const a:TMatrix):TMatrix;
var det,idet:single;
begin
 det:=(a[0]*a[3])-(a[1]*a[2]);
 if abs(det)<1E-14 then begin
  result:=a;
 end else begin
  idet:=1/det;
  result[0]:=a[3]*idet;
  result[1]:=-a[1]*idet;
  result[2]:=-a[2]*idet;
  result[3]:=a[0]*idet;
  result[4]:=-(a[4]*result[0])-(a[5]*result[2]);
  result[5]:=-(a[4]*result[1])-(a[5]*result[3]);
 end;
end;

procedure ApplyMatrixToXY(const m:TMatrix;var x,y:TVkInt32); overload;
var tx:TVkInt32;
begin
 tx:=x;
 x:=trunc((tx*m[0])+(y*m[2])+m[4]);
 y:=trunc((tx*m[1])+(y*m[3])+m[5]);
end;

procedure ApplyMatrixToXY(const m:TMatrix;var x,y:single); overload;
var tx:single;
begin
 tx:=x;
 x:=(tx*m[0])+(y*m[2])+m[4];
 y:=(tx*m[1])+(y*m[3])+m[5];
end;

function ToDOUBLE(const x:TVkUInt32):TVkDouble;
var a:TVkInt16;
    aw:TVkUInt16 absolute a;
begin
 aw:=x shr 16;
 if a>0 then begin
  result:=aw+((x and 65535)/$ffffffff);
 end else begin
  result:=aw-((x and 65535)/$ffffffff);
 end;
end;

function ToWORD(const b1,b2:TVkUInt8):TVkUInt16;
begin
 result:=(b1 shl 8) or b2;
end;

function ToSMALLINT(const b1,b2:TVkUInt8):TVkInt16;
begin
 result:=TVkInt16(TVkUInt16(ToWORD(b1,b2)));
end;

function ToLONGWORD(const b1,b2,b3,b4:TVkUInt8):TVkUInt32;
begin
 result:=(b1 shl 24) or (b2 shl 16) or (b3 shl 8) or b4;
end;

function ToUINT24(const b1,b2,b3:TVkUInt8):TVkUInt32;
begin
 result:=(b1 shl 16) or (b2 shl 8) or b3;
end;

function IsBitSet(const ByteValue,Bit:TVkUInt8):boolean;
begin
 result:=(ByteValue and (1 shl Bit))<>0;
end;

constructor TVulkanTrueTypeFontByteCodeInterpreter.Create(AFont:TVulkanTrueTypeFont);
var i:TVkInt32;
begin
 inherited Create;
 fFont:=AFont;
{$ifdef ttfdebug}
 fLastCVT:=nil;
 fLastStack:=nil;
 fLastStorage:=nil;
 FillChar(fLastGraphicsState,SizeOf(TVulkanTrueTypeFontGraphicsState),AnsiChar(#0));
 FillChar(fLastPoints,SizeOf(TVulkanTrueTypeFontByteCodeInterpreterPoints),AnsiChar(#0));
{$endif}
 fCVT:=nil;
 fStack:=nil;
 fStorage:=nil;
 fFunctions:=nil;
 fScale:=not fFont.Size;
 fForceReinitialize:=false;
 fGraphicsState:=DefaultGraphicsState;
 fDefaultGraphicsState:=DefaultGraphicsState;
 FillChar(fPoints,SizeOf(TVulkanTrueTypeFontByteCodeInterpreterPoints),AnsiChar(#0));
 fEnds:=nil;
{$ifdef ttfdebug}
 SetLength(fLastCVT,length(fFont.fCVT));
 SetLength(fLastStack,RoundUpToPowerOfTwo(fFont.fMaxStackElements+256));
 SetLength(fLastStorage,RoundUpToPowerOfTwo(fFont.fMaxStorage+16));
{$endif}
 SetLength(fCVT,length(fFont.fCVT));
 SetLength(fStack,RoundUpToPowerOfTwo(fFont.fMaxStackElements+256));
 SetLength(fStorage,RoundUpToPowerOfTwo(fFont.fMaxStorage+16));
{$ifdef ttfdebug}
 SetLength(fLastPoints[VkTTF_Zone_Twilight,VkTTF_PointType_Current],fFont.fMaxTwilightPoints+4);
 SetLength(fLastPoints[VkTTF_Zone_Twilight,VkTTF_PointType_Unhinted],fFont.fMaxTwilightPoints+4);
 SetLength(fLastPoints[VkTTF_Zone_Twilight,VkTTF_PointType_InFontUnits],fFont.fMaxTwilightPoints+4);
{$endif}
 SetLength(fPoints[VkTTF_Zone_Twilight,VkTTF_PointType_Current],fFont.fMaxTwilightPoints+4);
 SetLength(fPoints[VkTTF_Zone_Twilight,VkTTF_PointType_Unhinted],fFont.fMaxTwilightPoints+4);
 SetLength(fPoints[VkTTF_Zone_Twilight,VkTTF_PointType_InFontUnits],fFont.fMaxTwilightPoints+4);
 SetLength(fFunctions,fFont.fMaxFunctionDefs);
 for i:=0 to fFont.fMaxFunctionDefs-1 do begin
  fFunctions[i].Data:=nil;
  fFunctions[i].Size:=0;
 end;
 if assigned(fFont.fFPGM.Data) and (fFont.fFPGM.Size>0) then begin
{$ifdef ttfdebug}
  writeln('FPGM');
  writeln('====');
{$endif}
  Run(fFont.fFPGM);
{$ifdef ttfdebug}
  writeln;
{$endif}
 end;
 Reinitialize;
{$ifdef ttfdebug}
 fForceReinitialize:=true;
{$endif}
end;

destructor TVulkanTrueTypeFontByteCodeInterpreter.Destroy;
begin
{$ifdef ttfdebug}
 SetLength(fLastCVT,0);
 SetLength(fLastStack,0);
 SetLength(fLastStorage,0);
 SetLength(fLastPoints[VkTTF_Zone_Twilight,VkTTF_PointType_Current],0);
 SetLength(fLastPoints[VkTTF_Zone_Twilight,VkTTF_PointType_Unhinted],0);
 SetLength(fLastPoints[VkTTF_Zone_Twilight,VkTTF_PointType_InFontUnits],0);
 SetLength(fLastPoints[VkTTF_Zone_Glyph,VkTTF_PointType_Current],0);
 SetLength(fLastPoints[VkTTF_Zone_Glyph,VkTTF_PointType_Unhinted],0);
 SetLength(fLastPoints[VkTTF_Zone_Glyph,VkTTF_PointType_InFontUnits],0);
{$endif}
 SetLength(fCVT,0);
 SetLength(fStack,0);
 SetLength(fStorage,0);
 SetLength(fFunctions,0);
 SetLength(fPoints[VkTTF_Zone_Twilight,VkTTF_PointType_Current],0);
 SetLength(fPoints[VkTTF_Zone_Twilight,VkTTF_PointType_Unhinted],0);
 SetLength(fPoints[VkTTF_Zone_Twilight,VkTTF_PointType_InFontUnits],0);
 SetLength(fPoints[VkTTF_Zone_Glyph,VkTTF_PointType_Current],0);
 SetLength(fPoints[VkTTF_Zone_Glyph,VkTTF_PointType_Unhinted],0);
 SetLength(fPoints[VkTTF_Zone_Glyph,VkTTF_PointType_InFontUnits],0);
 SetLength(fEnds,0);
 inherited Destroy;
end;

procedure TVulkanTrueTypeFontByteCodeInterpreter.Reinitialize;
var i:TVkInt32;              
begin
 if (fScale<>fFont.Size) or fForceReinitialize then begin
  fScale:=fFont.Size;
  fForceReinitialize:=false;
  if assigned(fFont.fPREP.Data) and (fFont.fPREP.Size>0) then begin
   for i:=0 to (fFont.fMaxTwilightPoints+4)-1 do begin
    fPoints[VkTTF_Zone_Twilight,VkTTF_PointType_Current,i].x:=0;
    fPoints[VkTTF_Zone_Twilight,VkTTF_PointType_Current,i].y:=0;
    fPoints[VkTTF_Zone_Twilight,VkTTF_PointType_Unhinted,i].x:=0;
    fPoints[VkTTF_Zone_Twilight,VkTTF_PointType_Unhinted,i].y:=0;
    fPoints[VkTTF_Zone_Twilight,VkTTF_PointType_InFontUnits,i].x:=0;
    fPoints[VkTTF_Zone_Twilight,VkTTF_PointType_InFontUnits,i].y:=0;
{$ifdef ttfdebug}
    fLastPoints[VkTTF_Zone_Twilight,VkTTF_PointType_Current,i].x:=0;
    fLastPoints[VkTTF_Zone_Twilight,VkTTF_PointType_Current,i].y:=0;
    fLastPoints[VkTTF_Zone_Twilight,VkTTF_PointType_Unhinted,i].x:=0;
    fLastPoints[VkTTF_Zone_Twilight,VkTTF_PointType_Unhinted,i].y:=0;
    fLastPoints[VkTTF_Zone_Twilight,VkTTF_PointType_InFontUnits,i].x:=0;
    fLastPoints[VkTTF_Zone_Twilight,VkTTF_PointType_InFontUnits,i].y:=0;
{$endif}
   end;
   for i:=0 to length(fStorage)-1 do begin
    fStorage[i]:=0;
{$ifdef ttfdebug}
    fLastStorage[i]:=0;
{$endif}
   end;
   for i:=0 to length(fCVT)-1 do begin
    fCVT[i]:=fFont.Scale(fFont.fCVT[i]);
{$ifdef ttfdebug}
    fLastCVT[i]:=fCVT[i];
{$endif}
   end;
   fGraphicsState:=DefaultGraphicsState;
{$ifdef ttfdebug}
   writeln('PREP');
   writeln('====');
{$endif}
   Run(fFont.fPREP);
{$ifdef ttfdebug}
   writeln;
{$endif}
   fDefaultGraphicsState:=fGraphicsState;
   fDefaultGraphicsState.pv:=DefaultGraphicsState.pv;
   fDefaultGraphicsState.fv:=DefaultGraphicsState.fv;
   fDefaultGraphicsState.dv:=DefaultGraphicsState.dv;
   fDefaultGraphicsState.rp:=DefaultGraphicsState.rp;
   fDefaultGraphicsState.zp:=DefaultGraphicsState.zp;
   fDefaultGraphicsState.Loop:=DefaultGraphicsState.Loop;
  end;
 end;
end;

function TVulkanTrueTypeFontByteCodeInterpreter.SkipInstructionPayload(const ProgramBytes:TVulkanTrueTypeFontByteCodeInterpreterProgramBytes;var PC:TVkInt32):boolean;
begin
 case ProgramBytes.Data^[PC] of
  opNPUSHB:begin
   inc(PC);
   if PC>=ProgramBytes.Size then begin
    PC:=0;
    result:=false;
   end else begin
    inc(PC,ProgramBytes.Data^[PC]);
    result:=true;
   end;
  end;
  opNPUSHW:begin
   inc(PC);
   if PC>=ProgramBytes.Size then begin
    PC:=0;
    result:=false;
   end else begin
    inc(PC,ProgramBytes.Data^[PC] shl 1);
    result:=true;
   end;
  end;
  opPUSHB000,opPUSHB001,opPUSHB010,opPUSHB011,opPUSHB100,opPUSHB101,opPUSHB110,opPUSHB111:begin
   inc(PC,(ProgramBytes.Data^[PC]-opPUSHB000)+1);
   result:=true;
  end;
  opPUSHW000,opPUSHW001,opPUSHW010,opPUSHW011,opPUSHW100,opPUSHW101,opPUSHW110,opPUSHW111:begin
   inc(PC,((ProgramBytes.Data^[PC]-opPUSHW000)+1) shl 1);
   result:=true;
  end;
  else begin
   result:=true;
  end;
 end;
end;

function TVulkanTrueTypeFontByteCodeInterpreter.MulDiv(a,b,c:TVkInt32;DoRound:boolean):TVkInt32;
var s:TVkInt32;
begin
 if (a=0) or (b=c) then begin
  result:=a;
 end else begin
  s:=1;
  if a<0 then begin
   a:=-a;
   s:=-s;
  end;
  if b<0 then begin
   b:=-b;
   s:=-s;
  end;
  if c<0 then begin
   c:=-c;
   s:=-s;
  end;
  if c>0 then begin
   if (a=0) or (b=0) then begin
    result:=0;
   end else begin
    if (a<46341) and (b<46341) and ((c<176096) or not DoRound) then begin
     if DoRound then begin
      result:=((a*b)+SARLongint(c,1)) div c;
     end else begin
      result:=(a*b) div c;
     end;
    end else begin
     if DoRound then begin
      result:=((TVkInt64(a)*b)+SARLongint(c,1)) div c;
     end else begin
      result:=(TVkInt64(a)*b) div c;
     end;
    end;
   end;
  end else begin
   result:=$7fffffff;
  end;
  if s<0 then begin
   result:=-result;
  end;
 end;
end;

procedure TVulkanTrueTypeFontByteCodeInterpreter.MovePoint(var p:TVulkanTrueTypeFontGlyphPoint;Distance:TVkInt32;Touch:boolean);
var FVdotPV:TVkInt64;
begin
 if (fGraphicsState.fv[0]=$4000) and (fGraphicsState.pv[0]=$4000) and (fGraphicsState.fv[1]=0) and (fGraphicsState.pv[1]=0) then begin
  inc(p.x,Distance);
  if Touch then begin
   p.Flags:=p.Flags or VkTTF_PathFlag_TouchedX;
  end;
 end else if (fGraphicsState.fv[0]=0) and (fGraphicsState.pv[0]=0) and (fGraphicsState.fv[1]=$4000) and (fGraphicsState.pv[1]=$4000) then begin
  inc(p.y,Distance);
  if Touch then begin
   p.Flags:=p.Flags or VkTTF_PathFlag_TouchedY;
  end;
 end else begin
  FVdotPV:=SARInt64((TVkInt64(fGraphicsState.fv[0])*fGraphicsState.pv[0])+(TVkInt64(fGraphicsState.fv[1])*fGraphicsState.pv[1]),14);
  if fGraphicsState.fv[0]<>0 then begin
   inc(p.x,MulDiv(Distance,fGraphicsState.fv[0],FVdotPV,true));
   if Touch then begin
    p.Flags:=p.Flags or VkTTF_PathFlag_TouchedX;
   end;
  end;
  if fGraphicsState.fv[1]<>0 then begin
   inc(p.y,MulDiv(Distance,fGraphicsState.fv[1],FVdotPV,true));
   if Touch then begin
    p.Flags:=p.Flags or VkTTF_PathFlag_TouchedY;
   end;
  end;
 end;
end;

function TVulkanTrueTypeFontByteCodeInterpreter.DotProduct(x,y:TVulkanTrueTypeFont26d6;const q:TVulkanTrueTypeFontVector2d14):TVulkanTrueTypeFont26d6;
{$ifdef TTFCompactDotProduct}
var v:TVkInt64;
{$else}
var l,lo1,lo2,lo:TVkUInt32;
    m,hi1,hi2,hi,s:TVkInt32;
{$endif}
begin
{$ifdef TTFCompactDotProduct}
 v:=(TVkInt64(x)*q[0])+(TVkInt64(y)*q[1]);
 if v<0 then begin
  result:=-(((-v)+$2000) shr 14);
 end else begin
  result:=(v+$2000) shr 14;
 end;
{$else}
 l:=TVkUInt32(TVkInt32(TVkInt32(x and $ffff)*TVkInt32(q[0])));
 m:=SARLongint(x,16)*TVkInt32(q[0]);

 lo1:=l+(TVkUInt32(m) shl 16);
 hi1:=SARLongint(m,16)+SARLongint(l,31);
 if lo1<l then begin
  inc(hi1);
 end;

 l:=TVkUInt32(TVkInt32(TVkInt32(y and $ffff)*TVkInt32(q[1])));
 m:=SARLongint(y,16)*TVkInt32(q[1]);

 lo2:=l+(TVkUInt32(m) shl 16);
 hi2:=SARLongint(m,16)+SARLongint(l,31);
 if lo2<l then begin
  inc(hi2);
 end;

 lo:=lo1+lo2;
 hi:=hi1+hi2;
 if lo<lo1 then begin
  inc(hi);
 end;

 s:=SARLongint(hi,31);
 l:=lo+TVkUInt32(s);
 inc(hi,s);     
 if l<lo then begin
  inc(hi);
 end;
 lo:=l;

 l:=lo+$2000;
 if l<lo then begin
  inc(hi);
 end;

 result:=TVkUInt32((TVkUInt32(hi) shl 18) or (TVkUInt32(l) shr 14));
{$endif}
end;

function TVulkanTrueTypeFontByteCodeInterpreter.Div18d14(a,b:TVulkanTrueTypeFont26d6):TVulkanTrueTypeFont26d6;
var s:TVkInt32;
begin
 s:=1;
 if a<0 then begin
  a:=-a;
  s:=-s;
 end;
 if b<0 then begin
  b:=-b;
  s:=-s;
 end;
 if b>0 then begin
  if (a<$20000) and (b<$3fff) then begin
   result:=((a shl 14)+SARLongint(b,1)) div b;
  end else begin
   result:=((TVkInt64(a) shl 14)+SARLongint(b,1)) div b;
  end;
 end else begin
  result:=$7fffffff;
 end;
 if s<0 then begin
  result:=-result;
 end;
end;

function TVulkanTrueTypeFontByteCodeInterpreter.Mul18d14(a,b:TVulkanTrueTypeFont26d6):TVulkanTrueTypeFont26d6;
var s:TVkInt32;
begin
 s:=1;
 if a<0 then begin
  a:=-a;
  s:=-s;
 end;
 if b<0 then begin
  b:=-b;
  s:=-s;
 end;
 if (a<46341) and (b<46341) then begin
  result:=SARLongint((a*b)+$2000,14);
 end else begin
  result:=SARInt64((TVkInt64(a)*b)+$2000,14);
 end;
 if s<0 then begin
  result:=-result;
 end;
end;

function TVulkanTrueTypeFontByteCodeInterpreter.Div26d6(a,b:TVulkanTrueTypeFont26d6):TVulkanTrueTypeFont26d6;
var s:TVkInt32;
begin
 s:=1;
 if a<0 then begin
  a:=-a;
  s:=-s;
 end;
 if b<0 then begin
  b:=-b;
  s:=-s;
 end;
 if b>0 then begin
  if a<$1ffffff then begin
   result:=(a shl 6) div b;
  end else begin
   result:=(TVkInt64(a) shl 6) div b;
  end;
 end else begin
  result:=$7fffffff;
 end;
 if s<0 then begin
  result:=-result;
 end;
end;

function TVulkanTrueTypeFontByteCodeInterpreter.Mul26d6(a,b:TVulkanTrueTypeFont26d6):TVulkanTrueTypeFont26d6;
var s:TVkInt32;
begin
 s:=1;
 if a<0 then begin
  a:=-a;
  s:=-s;
 end;
 if b<0 then begin
  b:=-b;
  s:=-s;
 end;
 if (a<46341) and (b<46341) then begin
  result:=SARLongint((a*b)+32,6);
 end else begin
  result:=SARInt64((TVkInt64(a)*b)+32,6);
 end;
 if s<0 then begin
  result:=-result;
 end;
end;

function TVulkanTrueTypeFontByteCodeInterpreter.RoundValue(Value:TVulkanTrueTypeFont26d6):TVulkanTrueTypeFont26d6;
begin                       
 if fGraphicsState.RoundPeriod=0 then begin
  result:=Value;
 end else begin
  if Value>=0 then begin
   result:=(Value-fGraphicsState.RoundPhase)+fGraphicsState.RoundThreshold;
   if fGraphicsState.RoundSuper45 then begin
    result:=(result div fGraphicsState.RoundPeriod)*fGraphicsState.RoundPeriod;
   end else begin
    result:=result and (-fGraphicsState.RoundPeriod);
   end;
   if (Value<>0) and (result<0) then begin
    result:=0;
   end;
   inc(result,fGraphicsState.RoundPhase);
  end else begin
   result:=((-Value)-fGraphicsState.RoundPhase)+fGraphicsState.RoundThreshold;
   if fGraphicsState.RoundSuper45 then begin
    result:=(result div fGraphicsState.RoundPeriod)*fGraphicsState.RoundPeriod;
   end else begin
    result:=result and (-fGraphicsState.RoundPeriod);
   end;
   if result<0 then begin
    result:=0;
   end;
   result:=-(result+fGraphicsState.RoundPhase);
  end;
 end;
end;

procedure TVulkanTrueTypeFontByteCodeInterpreter.IUPInterpolate(IUPY:boolean;p1,p2,ref1,ref2:TVkInt32);
var ifu1,ifu2,t,unh1,unh2,delta1,delta2,xy,ifuXY,i:TVkInt32;
    Scale:TVkInt64;
    ScaleOK:boolean;
begin
 if (p1<=p2) and ((ref1<length(fPoints[VkTTF_Zone_Glyph,VkTTF_PointType_Current])) and (ref2<length(fPoints[VkTTF_Zone_Glyph,VkTTF_PointType_Current]))) then begin
  if IUPY then begin
   ifu1:=fPoints[VkTTF_Zone_Glyph,VkTTF_PointType_InFontUnits,ref1].y;
   ifu2:=fPoints[VkTTF_Zone_Glyph,VkTTF_PointType_InFontUnits,ref2].y;
  end else begin
   ifu1:=fPoints[VkTTF_Zone_Glyph,VkTTF_PointType_InFontUnits,ref1].x;
   ifu2:=fPoints[VkTTF_Zone_Glyph,VkTTF_PointType_InFontUnits,ref2].x;
  end;
  if ifu1>ifu2 then begin
   t:=ifu1;
   ifu1:=ifu2;
   ifu2:=t;
   t:=ref1;
   ref1:=ref2;
   ref2:=t;
  end;
  if IUPY then begin
   unh1:=fPoints[VkTTF_Zone_Glyph,VkTTF_PointType_Unhinted,ref1].y;
   unh2:=fPoints[VkTTF_Zone_Glyph,VkTTF_PointType_Unhinted,ref2].y;
   delta1:=fPoints[VkTTF_Zone_Glyph,VkTTF_PointType_Current,ref1].y-unh1;
   delta2:=fPoints[VkTTF_Zone_Glyph,VkTTF_PointType_Current,ref2].y-unh2;
  end else begin
   unh1:=fPoints[VkTTF_Zone_Glyph,VkTTF_PointType_Unhinted,ref1].x;
   unh2:=fPoints[VkTTF_Zone_Glyph,VkTTF_PointType_Unhinted,ref2].x;
   delta1:=fPoints[VkTTF_Zone_Glyph,VkTTF_PointType_Current,ref1].x-unh1;
   delta2:=fPoints[VkTTF_Zone_Glyph,VkTTF_PointType_Current,ref2].x-unh2;
  end;
  if ifu1=ifu2 then begin
   for i:=p1 to p2 do begin
    if IUPY then begin
     xy:=fPoints[VkTTF_Zone_Glyph,VkTTF_PointType_Unhinted,i].y;
    end else begin
     xy:=fPoints[VkTTF_Zone_Glyph,VkTTF_PointType_Unhinted,i].x;
    end;
    if xy<=unh1 then begin
     inc(xy,delta1);
    end else begin
     inc(xy,delta2);
    end;
    if IUPY then begin
     fPoints[VkTTF_Zone_Glyph,VkTTF_PointType_Current,i].y:=xy;
    end else begin
     fPoints[VkTTF_Zone_Glyph,VkTTF_PointType_Current,i].x:=xy;
    end;
   end;
  end else begin
   Scale:=0;
   ScaleOK:=false;
   for i:=p1 to p2 do begin
    if IUPY then begin
     xy:=fPoints[VkTTF_Zone_Glyph,VkTTF_PointType_Unhinted,i].y;
     IFUXY:=fPoints[VkTTF_Zone_Glyph,VkTTF_PointType_InFontUnits,i].y;
    end else begin
     xy:=fPoints[VkTTF_Zone_Glyph,VkTTF_PointType_Unhinted,i].x;
     IFUXY:=fPoints[VkTTF_Zone_Glyph,VkTTF_PointType_InFontUnits,i].x;
    end;
    if xy<=unh1 then begin
     inc(xy,delta1);
    end else if xy>=unh2 then begin
     inc(xy,delta2);
    end else begin
     if not ScaleOK then begin
      ScaleOK:=true;
      Scale:=MulDiv((unh2+delta2)-(unh1+delta1),$10000,ifu2-ifu1,true);
     end;
     xy:=(unh1+delta1)+MulDiv(ifuXY-ifu1,Scale,$10000,true);
    end;
    if IUPY then begin
     fPoints[VkTTF_Zone_Glyph,VkTTF_PointType_Current,i].y:=xy;
    end else begin
     fPoints[VkTTF_Zone_Glyph,VkTTF_PointType_Current,i].x:=xy;
    end;
   end;
  end;
 end;
end;

procedure TVulkanTrueTypeFontByteCodeInterpreter.IUPShift(IUPY:boolean;p1,p2,p:TVkInt32);
var Delta,i:TVkInt32;
begin
 if IUPY then begin
  Delta:=fPoints[VkTTF_Zone_Glyph,VkTTF_PointType_Current,p].y-fPoints[VkTTF_Zone_Glyph,VkTTF_PointType_Unhinted,p].y;
 end else begin
  Delta:=fPoints[VkTTF_Zone_Glyph,VkTTF_PointType_Current,p].x-fPoints[VkTTF_Zone_Glyph,VkTTF_PointType_Unhinted,p].x;
 end;
 if Delta<>0 then begin
  for i:=p1 to p2 do begin
   if i<>p then begin
    if IUPY then begin
     inc(fPoints[VkTTF_Zone_Glyph,VkTTF_PointType_Current,i].y,Delta);
    end else begin
     inc(fPoints[VkTTF_Zone_Glyph,VkTTF_PointType_Current,i].x,Delta);
    end;
   end;
  end;
 end;
end;

function TVulkanTrueTypeFontByteCodeInterpreter.GetPoint(ZonePointer,PointType,Index:TVkInt32):PVulkanTrueTypeFontGlyphPoint;
begin
 if ((ZonePointer>=0) and (ZonePointer<3)) and
    ((fGraphicsState.zp[ZonePointer]>=0) and (fGraphicsState.zp[ZonePointer]<VkTTF_Zone_Count)) and
    ((Index>=0) and (Index<length(fPoints[fGraphicsState.zp[ZonePointer],PointType]))) then begin
  result:=@fPoints[fGraphicsState.zp[ZonePointer],PointType,Index];
 end else begin
  result:=nil;
 end;
end;

procedure TVulkanTrueTypeFontByteCodeInterpreter.Normalize(var x,y:TVulkanTrueTypeFont26d6);
var l:TVkInt32;
begin
 if (x<>0) or (y<>0) then begin
  if (abs(x)<$4000) and (abs(y)<$4000) then begin
   x:=x shl 14;
   y:=y shl 14;
  end;
  if x=0 then begin
   l:=abs(y);
  end else if y=0 then begin
   l:=abs(x);
  end else begin
   l:=round(sqrt(sqr(x/4096.0)+sqr(y/4096.0))*4096.0);
  end;
  x:=MulDiv(x,$4000,l,true);
  y:=MulDiv(y,$4000,l,true);
 end;
end;

function TVulkanTrueTypeFontByteCodeInterpreter.GetCVT(Index:TVkInt32):TVkInt32;
begin
 if (Index>=0) and (Index<length(fCVT)) then begin
  result:=fCVT[Index];
 end else begin
  result:=0;
 end;
end;

procedure TVulkanTrueTypeFontByteCodeInterpreter.SetCVT(Index,Value:TVkInt32);
begin
 if (Index>=0) and (Index<length(fCVT)) then begin
  fCVT[Index]:=Value;
 end;
end;

procedure TVulkanTrueTypeFontByteCodeInterpreter.ComputePointDisplacement(Flag:boolean;var Zone,Ref:TVkInt32;var dx,dy:TVulkanTrueTypeFont26d6);
var Distance,FVdotPV:TVkInt64;
    p1,p2:PVulkanTrueTypeFontGlyphPoint;
begin
 if Flag then begin
  Ref:=fGraphicsState.rp[1];
  Zone:=0;
 end else begin
  Ref:=fGraphicsState.rp[2];
  Zone:=1;
 end;
 p1:=GetPoint(Zone,VkTTF_PointType_Unhinted,Ref);
 p2:=GetPoint(Zone,VkTTF_PointType_Current,Ref);
 if assigned(p1) and assigned(p2) then begin
  Distance:=DotProduct(p2^.x-p1.x,p2^.y-p1^.y,fGraphicsState.pv);
  if (fGraphicsState.fv[0]=$4000) and (fGraphicsState.pv[0]=$4000) and (fGraphicsState.fv[1]=0) and (fGraphicsState.pv[1]=0) then begin
   dx:=Distance;
   dy:=0;
  end else if (fGraphicsState.fv[0]=0) and (fGraphicsState.pv[0]=0) and (fGraphicsState.fv[1]=$4000) and (fGraphicsState.pv[1]=$4000) then begin
   dx:=0;
   dy:=Distance;
  end else begin
   FVdotPV:=SARInt64((TVkInt64(fGraphicsState.fv[0])*fGraphicsState.pv[0])+(TVkInt64(fGraphicsState.fv[1])*fGraphicsState.pv[1]),14);
   if FVdotPV<>0 then begin
    dx:=MulDiv(fGraphicsState.fv[0],Distance,FVdotPV,true);
    dy:=MulDiv(fGraphicsState.fv[1],Distance,FVdotPV,true);
   end else begin
    dx:=0;
    dy:=0;
   end;
  end;
 end else begin
  raise EVulkanTrueTypeFont.Create('Out of point bounds');
 end;
end;

procedure TVulkanTrueTypeFontByteCodeInterpreter.Run(ProgramBytes:TVulkanTrueTypeFontByteCodeInterpreterProgramBytes;Parameters:PVulkanTrueTypeFontByteCodeInterpreterParameters=nil);
var Steps,PC,Top,CallStackTop,PopCount,Depth,Temp,x,StartPC,i,Distance,PrevEnd,j,k,FirstTouched,CurrentTouched,PointType,
    FirstPoint,EndPoint,CurrentPoint,OldDist,CurrentDist,NewDist,t1,t2,t3,CVTDist,d1,d2,dx,dy,d,ZonePointer,RefIndex,
    Base,Count,a0,a1,b0,b1:TVkInt32;
    Mask:TVkUInt32;
    Opcode:TVkUInt8;
    CallStack:TVulkanTrueTypeFontByteCodeInterpreterCallStackEntries;
    OK,Twilight:boolean;
    f:TVulkanTrueTypeFontByteCodeInterpreterProgramBytes;
    p,OldP,CurrentP,Ref,q,p0,p1,p2:PVulkanTrueTypeFontGlyphPoint;
    OldRange,CurrentRange,ax0,ay0,ax1,ay1,bx0,by0,bx1,by1:TVulkanTrueTypeFont26d6;
    dxa,dya,dxb,dyb,det,v:TVkInt64;
{$ifdef ttfdebug}
 procedure StoreState;
 var i:TVkInt32;
 begin
  for i:=0 to length(fCVT)-1 do begin
   fLastCVT[i]:=fCVT[i];
  end;
  for i:=0 to length(fStack)-1 do begin
   fLastStack[i]:=fStack[i];
  end;
  for i:=0 to length(fStorage)-1 do begin
   fLastStorage[i]:=fStorage[i];
  end;
  fLastPoints[VkTTF_Zone_Twilight,VkTTF_PointType_Current]:=copy(fPoints[VkTTF_Zone_Twilight,VkTTF_PointType_Current]);
  fLastPoints[VkTTF_Zone_Twilight,VkTTF_PointType_Unhinted]:=copy(fPoints[VkTTF_Zone_Twilight,VkTTF_PointType_Unhinted]);
  fLastPoints[VkTTF_Zone_Twilight,VkTTF_PointType_InFontUnits]:=copy(fPoints[VkTTF_Zone_Twilight,VkTTF_PointType_InFontUnits]);
  fLastPoints[VkTTF_Zone_Glyph,VkTTF_PointType_Current]:=copy(fPoints[VkTTF_Zone_Glyph,VkTTF_PointType_Current]);
  fLastPoints[VkTTF_Zone_Glyph,VkTTF_PointType_Unhinted]:=copy(fPoints[VkTTF_Zone_Glyph,VkTTF_PointType_Unhinted]);
  fLastPoints[VkTTF_Zone_Glyph,VkTTF_PointType_InFontUnits]:=copy(fPoints[VkTTF_Zone_Glyph,VkTTF_PointType_InFontUnits]);
  fLastGraphicsState:=fGraphicsState;
 end;
 procedure DumpState;
 var i:TVkInt32;
     p1,p2:PVulkanTrueTypeFontGlyphPoint;
 begin
  if (fLastGraphicsState.pv[0]<>fGraphicsState.pv[0]) or (fLastGraphicsState.pv[1]<>fGraphicsState.pv[1]) then begin
    writeln('    pv: ',fLastGraphicsState.pv[0],',',fLastGraphicsState.pv[1],' => ',fGraphicsState.pv[0],',',fGraphicsState.pv[1]);
  end;
  if (fLastGraphicsState.dv[0]<>fGraphicsState.dv[0]) or (fLastGraphicsState.dv[1]<>fGraphicsState.dv[1]) then begin
    writeln('    dv: ',fLastGraphicsState.dv[0],',',fLastGraphicsState.dv[1],' => ',fGraphicsState.dv[0],',',fGraphicsState.dv[1]);
  end;
  if (fLastGraphicsState.fv[0]<>fGraphicsState.fv[0]) or (fLastGraphicsState.fv[1]<>fGraphicsState.fv[1]) then begin
    writeln('    fv: ',fLastGraphicsState.fv[0],',',fLastGraphicsState.fv[1],' => ',fGraphicsState.fv[0],',',fGraphicsState.fv[1]);
  end;
  if (fLastGraphicsState.zp[0]<>fGraphicsState.zp[0]) or (fLastGraphicsState.zp[1]<>fGraphicsState.zp[1]) or (fLastGraphicsState.zp[2]<>fGraphicsState.zp[2]) then begin
    writeln('    zp: ',fLastGraphicsState.zp[0],',',fLastGraphicsState.zp[1],',',fLastGraphicsState.zp[2],' => ',fGraphicsState.zp[0],',',fGraphicsState.zp[1],',',fGraphicsState.zp[2]);
  end;
  if (fLastGraphicsState.rp[0]<>fGraphicsState.rp[0]) or (fLastGraphicsState.rp[1]<>fGraphicsState.rp[1]) or (fLastGraphicsState.rp[2]<>fGraphicsState.rp[2]) then begin
    writeln('    rp: ',fLastGraphicsState.rp[0],',',fLastGraphicsState.rp[1],',',fLastGraphicsState.rp[2],' => ',fGraphicsState.rp[0],',',fGraphicsState.rp[1],',',fGraphicsState.rp[2]);
  end;
  for i:=0 to length(fCVT)-1 do begin
   if fLastCVT[i]<>fCVT[i] then begin
    writeln('    CVT[',i,']: ',fLastCVT[i],' => ',fCVT[i]);
   end;
  end;
  for i:=0 to length(fStack)-1 do begin
   if fLastStack[i]<>fStack[i] then begin
    writeln('    Stack[',i,']: ',fLastStack[i],' => ',fStack[i]);
   end;
  end;
  for i:=0 to length(fStorage)-1 do begin
   if fLastStorage[i]<>fStorage[i] then begin
    writeln('    Storage[',i,']: ',fLastStorage[i],' => ',fStorage[i]);
   end;
  end;
  for i:=0 to length(fPoints[VkTTF_Zone_Glyph,VkTTF_PointType_Current])-1 do begin
   p1:=@fLastPoints[VkTTF_Zone_Glyph,VkTTF_PointType_Current,i];
   p2:=@fPoints[VkTTF_Zone_Glyph,VkTTF_PointType_Current,i];
   if (p1^.x<>p2^.x) or (p1^.y<>p2^.y) then begin
    writeln('    CurrentPoints[',i,']: ',p1^.x,',',p1^.y,' => ',p2^.x,',',p2^.y);
   end;
  end;
  for i:=0 to length(fPoints[VkTTF_Zone_Glyph,VkTTF_PointType_Unhinted])-1 do begin
   p1:=@fLastPoints[VkTTF_Zone_Glyph,VkTTF_PointType_Unhinted,i];
   p2:=@fPoints[VkTTF_Zone_Glyph,VkTTF_PointType_Unhinted,i];
   if (p1^.x<>p2^.x) or (p1^.y<>p2^.y) then begin
    writeln('    OriginalPoints[',i,']: ',p1^.x,',',p1^.y,' => ',p2^.x,',',p2^.y);
   end;
  end;
  for i:=0 to length(fPoints[VkTTF_Zone_Glyph,VkTTF_PointType_InFontUnits])-1 do begin
   p1:=@fLastPoints[VkTTF_Zone_Glyph,VkTTF_PointType_InFontUnits,i];
   p2:=@fPoints[VkTTF_Zone_Glyph,VkTTF_PointType_InFontUnits,i];
   if (p1^.x<>p2^.x) or (p1^.y<>p2^.y) then begin
    writeln('    InFontUnitsPoints[',i,']: ',p1^.x,',',p1^.y,' => ',p2^.x,',',p2^.y);
   end;
  end;
  for i:=0 to length(fPoints[VkTTF_Zone_Twilight,VkTTF_PointType_Current])-1 do begin
   p1:=@fLastPoints[VkTTF_Zone_Twilight,VkTTF_PointType_Current,i];
   p2:=@fPoints[VkTTF_Zone_Twilight,VkTTF_PointType_Current,i];
   if (p1^.x<>p2^.x) or (p1^.y<>p2^.y) then begin
    writeln('    TwilightCurrentPoints[',i,']: ',p1^.x,',',p1^.y,' => ',p2^.x,',',p2^.y);
   end;
  end;
  for i:=0 to length(fPoints[VkTTF_Zone_Twilight,VkTTF_PointType_Unhinted])-1 do begin
   p1:=@fLastPoints[VkTTF_Zone_Twilight,VkTTF_PointType_Unhinted,i];
   p2:=@fPoints[VkTTF_Zone_Twilight,VkTTF_PointType_Unhinted,i];
   if (p1^.x<>p2^.x) or (p1^.y<>p2^.y) then begin
    writeln('    TwilightOriginalPoints[',i,']: ',p1^.x,',',p1^.y,' => ',p2^.x,',',p2^.y);
   end;
  end;
  for i:=0 to length(fPoints[VkTTF_Zone_Twilight,VkTTF_PointType_InFontUnits])-1 do begin
   p1:=@fLastPoints[VkTTF_Zone_Twilight,VkTTF_PointType_InFontUnits,i];
   p2:=@fPoints[VkTTF_Zone_Twilight,VkTTF_PointType_InFontUnits,i];
   if (p1^.x<>p2^.x) or (p1^.y<>p2^.y) then begin
    writeln('    TwilightInFontUnitsPoints[',i,']: ',p1^.x,',',p1^.y,' => ',p2^.x,',',p2^.y);
   end;
  end;
 end;
{$endif}
begin
 fGraphicsState:=fDefaultGraphicsState;
 if assigned(Parameters) then begin
  fPoints[VkTTF_Zone_Glyph,VkTTF_PointType_Current]:=Parameters^.pCurrent;
  fPoints[VkTTF_Zone_Glyph,VkTTF_PointType_Unhinted]:=Parameters^.pUnhinted;
  fPoints[VkTTF_Zone_Glyph,VkTTF_PointType_InFontUnits]:=Parameters^.pInFontUnits;
  fEnds:=Parameters^.Ends;
 end else begin
  fPoints[VkTTF_Zone_Glyph,VkTTF_PointType_Current]:=nil;
  fPoints[VkTTF_Zone_Glyph,VkTTF_PointType_Unhinted]:=nil;
  fPoints[VkTTF_Zone_Glyph,VkTTF_PointType_InFontUnits]:=nil;
  fEnds:=nil;
 end;
 if ProgramBytes.Size>50000 then begin
  raise EVulkanTrueTypeFont.Create('Too many instructions');
 end else begin
  Steps:=0;
  PC:=0;
  Top:=0;
  CallStack[0].PC:=0;
  CallStackTop:=0;
{$ifdef ttfdebug}
  StoreState;
{$endif}
  while (PC>=0) and (PC<ProgramBytes.Size) do begin
{$ifdef ttfdebug}
   DumpState;
   StoreState;
{$endif}
   inc(Steps);
   if Steps=100000 then begin
    raise EVulkanTrueTypeFont.Create('Too many steps');
   end else begin
    Opcode:=ProgramBytes.Data^[PC];
    PopCount:=OpcodePopCount[Opcode];
    if PopCount=255 then begin
     if Opcode<>0 then begin
      if Opcode<>0 then begin
      end;
     end;
     raise EVulkanTrueTypeFont.Create('Unimplemented instruction');
    end else if Top<PopCount then begin
     raise EVulkanTrueTypeFont.Create('Stack underflow');
    end else begin
     if (ProgramBytes.Size>14) and (ProgramBytes.Data^[13] in [opMSIRP0,opMSIRP1]) then begin
      if (ProgramBytes.Size>14) and (ProgramBytes.Data^[13] in [opMSIRP0,opMSIRP1]) then begin
      end;
     end;
{$ifdef ttfdebug}
      writeln('Opcode: ',OpcodeNames[Opcode]);
{$endif}
     case Opcode of
      opSVTCA0:begin
       fGraphicsState.pv[0]:=0;
       fGraphicsState.pv[1]:=$4000;
       fGraphicsState.fv[0]:=0;
       fGraphicsState.fv[1]:=$4000;
       fGraphicsState.dv[0]:=0;
       fGraphicsState.dv[1]:=$4000;
      end;
      opSVTCA1:begin
       fGraphicsState.pv[0]:=$4000;
       fGraphicsState.pv[1]:=0;
       fGraphicsState.fv[0]:=$4000;
       fGraphicsState.fv[1]:=0;
       fGraphicsState.dv[0]:=$4000;
       fGraphicsState.dv[1]:=0;
      end;
      opSPVTCA0:begin
       fGraphicsState.pv[0]:=0;
       fGraphicsState.pv[1]:=$4000;
       fGraphicsState.dv[0]:=0;
       fGraphicsState.dv[1]:=$4000;
      end;
      opSPVTCA1:begin
       fGraphicsState.pv[0]:=$4000;
       fGraphicsState.pv[1]:=0;
       fGraphicsState.dv[0]:=$4000;
       fGraphicsState.dv[1]:=0;
      end;
      opSFVTCA0:begin
       fGraphicsState.fv[0]:=0;
       fGraphicsState.fv[1]:=$4000;
      end;
      opSFVTCA1:begin
       fGraphicsState.fv[0]:=$4000;
       fGraphicsState.fv[1]:=0;
      end;
      opSPVTL0,opSPVTL1,opSFVTL0,opSFVTL1:begin
       dec(Top,2);
       p1:=GetPoint(1,VkTTF_PointType_Current,fStack[Top]);
       p2:=GetPoint(2,VkTTF_PointType_Current,fStack[Top+1]);
       if assigned(p1) and assigned(p2) then begin
        dx:=p1^.x-p2^.x;
        dy:=p1^.y-p2^.y;
        if (dx=0) and (dy=0) then begin
         dx:=$4000;
        end else if Opcode in [opSPVTL1,opSFVTL1] then begin
         d:=dx;
         dx:=-dy;
         dy:=d;
        end;
        Normalize(dx,dy);
        case Opcode of
         opSFVTL0,opSFVTL1:begin
          fGraphicsState.fv[0]:=dx;
          fGraphicsState.fv[1]:=dy;
         end;
         else begin
          fGraphicsState.pv[0]:=dx;
          fGraphicsState.pv[1]:=dy;
          fGraphicsState.dv:=fGraphicsState.pv;
         end;
        end;
       end else begin
        raise EVulkanTrueTypeFont.Create('Out of point bounds');
       end;
      end;
      opSPVFS:begin
       dec(Top,2);
       dx:=TVkInt16(TVkUInt16(fStack[Top] and $ffff));
       dy:=TVkInt16(TVkUInt16(fStack[Top+1] and $ffff));
       Normalize(dx,dy);
       fGraphicsState.pv[0]:=dx;
       fGraphicsState.pv[1]:=dy;
       fGraphicsState.dv:=fGraphicsState.pv;
      end;
      opSFVFS:begin
       dec(Top,2);
       dx:=TVkInt16(TVkUInt16(fStack[Top] and $ffff));
       dy:=TVkInt16(TVkUInt16(fStack[Top+1] and $ffff));
       Normalize(dx,dy);
       fGraphicsState.fv[0]:=dx;
       fGraphicsState.fv[1]:=dy;
      end;
      opGPV:begin
       if (Top+1)>=length(fStack) then begin
        raise EVulkanTrueTypeFont.Create('Stack overflow');
       end else begin
        fStack[Top]:=fGraphicsState.pv[0];
        fStack[Top+1]:=fGraphicsState.pv[1];
        inc(Top,2);
       end;
      end;
      opGFV:begin
       if (Top+1)>=length(fStack) then begin
        raise EVulkanTrueTypeFont.Create('Stack overflow');
       end else begin
        fStack[Top]:=fGraphicsState.fv[0];
        fStack[Top+1]:=fGraphicsState.fv[1];
        inc(Top,2);
       end;
      end;
      opSFVTPV:begin
       fGraphicsState.fv:=fGraphicsState.pv;
      end;
      opISECT:begin
       dec(Top,5);
       b1:=fStack[Top+4];
       b0:=fStack[Top+3];
       a1:=fStack[Top+2];
       a0:=fStack[Top+1];
       p:=GetPoint(2,VkTTF_PointType_Current,fStack[Top]);
       if assigned(p) then begin
        p^.Flags:=p^.Flags or (VkTTF_PathFlag_TouchedX or VkTTF_PathFlag_TouchedY);
        p0:=GetPoint(1,VkTTF_PointType_Current,a0);
        if assigned(p0) then begin
         ax0:=p0^.x;
         ay0:=p0^.y;
         p0:=GetPoint(1,VkTTF_PointType_Current,a1);
         if assigned(p0) then begin
          ax1:=p0^.x;
          ay1:=p0^.y;
          p0:=GetPoint(0,VkTTF_PointType_Current,b0);
          if assigned(p0) then begin
           bx0:=p0^.x;
           by0:=p0^.y;
           p0:=GetPoint(0,VkTTF_PointType_Current,b1);
           if assigned(p0) then begin
            bx1:=p0^.x;
            by1:=p0^.y;
            dxa:=ax1-ax0;
            dya:=ay1-ay0;
            dxb:=bx1-bx0;
            dyb:=by1-by0;
            det:=(dya*dxb)-(dyb*dxa);
            if abs(det)>=$80 then begin
             v:=((bx0-ax0)*(-dyb))+((by0-ay0)*dxb);
             p^.x:=ax0+((v*dxa) div det);
             p^.y:=ay0+((v*dya) div det);
            end else begin
             // lines are (almost) parallel
             p^.x:=SARLongint(ax0+ax1+bx0+bx1,2);
             p^.y:=SARLongint(ay0+ay1+by0+by1,2);
            end;
           end else begin
            raise EVulkanTrueTypeFont.Create('Out of point bounds');
           end;
          end else begin
           raise EVulkanTrueTypeFont.Create('Out of point bounds');
          end;
         end else begin
          raise EVulkanTrueTypeFont.Create('Out of point bounds');
         end;
        end else begin
         raise EVulkanTrueTypeFont.Create('Out of point bounds');
        end;
       end else begin
        raise EVulkanTrueTypeFont.Create('Out of point bounds');
       end;
      end;
      opSRP0,opSRP1,opSRP2:begin
       dec(Top);
       fGraphicsState.rp[Opcode-opSRP0]:=fStack[Top];
      end;
      opSZP0,opSZP1,opSZP2:begin
       dec(Top);
       fGraphicsState.zp[Opcode-opSZP0]:=fStack[Top];
      end;
      opSZPS:begin
       dec(Top);
       fGraphicsState.zp[0]:=fStack[Top];
       fGraphicsState.zp[1]:=fStack[Top];
       fGraphicsState.zp[2]:=fStack[Top];
      end;
      opSLOOP:begin
       dec(Top);
       // https://developer.apple.com/fonts/TrueType-Reference-Manual/RM05/Chap5.html#SLOOP
       // "Setting the loop variable to zero is an error", but in reality, at some
       // byte code sequences in some font files (for example the "2" glyph at
       // DejaVuSansMono.ttf) gets the SLOOP instruction a zero on top of the stack, so
       // we use here <0 instead <=0 (which would be more correct according to the
       // TTF specifications)
       if fStack[Top]<0 then begin
        raise EVulkanTrueTypeFont.Create('Invalid data');
       end else begin
        fGraphicsState.Loop:=fStack[Top];
       end;
      end;
      opRTG:begin
       fGraphicsState.RoundPeriod:=1 shl 6;
       fGraphicsState.RoundPhase:=0;
       fGraphicsState.RoundThreshold:=1 shl 5;
       fGraphicsState.RoundSuper45:=false;
      end;
      opRTHG:begin
       fGraphicsState.RoundPeriod:=1 shl 6;
       fGraphicsState.RoundPhase:=1 shl 5;
       fGraphicsState.RoundThreshold:=1 shl 5;
       fGraphicsState.RoundSuper45:=false;
      end;
      opSMD:begin
       dec(Top);
       fGraphicsState.MinDist:=fStack[Top];
      end;
      opELSE:begin
       Depth:=0;
       repeat
        inc(PC);
        if PC>=ProgramBytes.Size then begin
         raise EVulkanTrueTypeFont.Create('Unbalanced ELSE');
        end else begin
         case ProgramBytes.Data^[PC] of
          opIF:begin
           inc(Depth);
          end;
          opELSE:begin
          end;
          opEIF:begin
           dec(Depth);
           if Depth<0 then begin
            break;
           end;
          end;
          else begin
           OK:=SkipInstructionPayload(ProgramBytes,PC);
           if not OK Then begin
            raise EVulkanTrueTypeFont.Create('Unbalanced ELSE');
           end;
          end;
         end;
        end;
       until false;
      end;
      opJMPR:begin
       dec(Top);
       inc(PC,fStack[Top]);
       continue;
      end;
      opSCVTCI:begin
       dec(Top);
       fGraphicsState.ControlValueCutIn:=fStack[Top];
      end;
      opSSWCI:begin
       dec(Top);
       fGraphicsState.SingleWidthCutIn:=fStack[Top];
      end;
      opSSW:begin
       dec(Top);
       fGraphicsState.SingleWidth:=fFont.Scale(fStack[Top]);
      end;
      opDUP:begin
       if Top>=length(fStack) then begin
        raise EVulkanTrueTypeFont.Create('Stack overflow');
       end else begin
        fStack[Top]:=fStack[Top-1];
        inc(Top);
       end;
      end;
      opPOP:begin
       dec(Top);
      end;
      opCLEAR:begin
       Top:=0;
      end;
      opSWAP:begin
       Temp:=fStack[Top-1];
       fStack[Top-1]:=fStack[Top-2];
       fStack[Top-2]:=Temp;
      end;
      opDEPTH:begin
       if Top>=length(fStack) then begin
        raise EVulkanTrueTypeFont.Create('Stack overflow');
       end else begin
        fStack[Top]:=Top;
        inc(Top);
       end;
      end;
      opCINDEX:begin
       x:=fStack[Top-1];
       if (x>0) and (x<Top) then begin
        fStack[Top-1]:=fStack[Top-(x+1)];
       end else begin
        raise EVulkanTrueTypeFont.Create('Invalid data');
       end;
      end;
      opMINDEX:begin
       Count:=fStack[Top-1];
       if (Count>0) and (Count<Top) then begin
        dec(Top);
        Temp:=fStack[Top-Count];
        for i:=Top-Count to Top-2 do begin
         fStack[i]:=fStack[i+1];
        end;
        fStack[Top-1]:=Temp;
       end else begin
        raise EVulkanTrueTypeFont.Create('Invalid data');
       end;
      end;
      opALIGNPTS:begin
       dec(Top,2);
       p1:=GetPoint(0,VkTTF_PointType_Current,fStack[Top+1]);
       p2:=GetPoint(1,VkTTF_PointType_Current,fStack[Top]);
       if assigned(p1) and assigned(p2) then begin
        Distance:=SARLongint(DotProduct(p1^.x-p2^.x,p1^.y-p2^.y,fGraphicsState.pv),1);
        MovePoint(p1^,Distance,true);
        MovePoint(p2^,-Distance,true);
       end else begin
        raise EVulkanTrueTypeFont.Create('Out of point bounds');
       end;
      end;
      opUTP:begin
       dec(Top);
       p:=GetPoint(2,VkTTF_PointType_Current,fStack[Top]);
       if assigned(p) then begin
        if fGraphicsState.fv[0]<>0 then begin
         p^.Flags:=p^.Flags and not VkTTF_PathFlag_TouchedX;
        end;
        if fGraphicsState.fv[1]<>0 then begin
         p^.Flags:=p^.Flags and not VkTTF_PathFlag_TouchedY;
        end;
       end else begin
        raise EVulkanTrueTypeFont.Create('Out of point bounds');
       end;
      end;
      opLOOPCALL:begin
       if CallStackTop>=length(CallStack) then begin
        raise EVulkanTrueTypeFont.Create('Call stack overflow');
       end else begin
        dec(Top);
        f:=fFunctions[fStack[Top]];
        if not (assigned(f.Data) and (f.Size>0)) then begin
         raise EVulkanTrueTypeFont.Create('Undefined function');
        end else begin
         CallStack[CallStackTop].ProgramBytes:=ProgramBytes;
         CallStack[CallStackTop].PC:=PC;
         CallStack[CallStackTop].LoopCount:=1;
         dec(Top);
         if fStack[Top]<>0 then begin
          CallStack[CallStackTop].LoopCount:=fStack[Top];
          inc(CallStackTop);
          ProgramBytes:=f;
          PC:=0;
          continue;
         end;
        end;
       end;
      end;
      opCALL:begin
       if CallStackTop>=length(CallStack) then begin
        raise EVulkanTrueTypeFont.Create('Call stack overflow');
       end else begin
        dec(Top);
        f:=fFunctions[fStack[Top]];
        if not (assigned(f.Data) and (f.Size>0)) then begin
         raise EVulkanTrueTypeFont.Create('Undefined function');
        end else begin
         CallStack[CallStackTop].ProgramBytes:=ProgramBytes;
         CallStack[CallStackTop].PC:=PC;
         CallStack[CallStackTop].LoopCount:=1;
         inc(CallStackTop);
         ProgramBytes:=f;
         PC:=0;
         continue;
        end;
       end;
      end;
      opFDEF:begin
       StartPC:=PC+1;
       repeat
        inc(PC);
        if PC>=ProgramBytes.Size then begin
         raise EVulkanTrueTypeFont.Create('Unbalanced FDEF');
        end else begin
         case ProgramBytes.Data^[PC] of
          opFDEF:begin
           raise EVulkanTrueTypeFont.Create('Nested FDEF');
          end;
          opENDF:begin
           dec(Top);
           fFunctions[fStack[Top]].Data:=TVkPointer(@ProgramBytes.Data^[StartPC]);
           fFunctions[fStack[Top]].Size:=(PC-StartPC)+2;
           break;
          end;
          else begin
           OK:=SkipInstructionPayload(ProgramBytes,PC);
           if not OK Then begin
            raise EVulkanTrueTypeFont.Create('Unbalanced FDEF');
           end;
          end;
         end;
        end;
       until false;
      end;
      opENDF:begin
       if CallStackTop<=0 then begin
        raise EVulkanTrueTypeFont.Create('Call stack underflow');
       end else begin
        dec(CallStackTop);
        dec(CallStack[CallStackTop].LoopCount);
        if CallStack[CallStackTop].LoopCount>0 then begin
         inc(CallStackTop);
         PC:=0;
         continue;
        end else begin
         ProgramBytes:=CallStack[CallStackTop].ProgramBytes;
         PC:=CallStack[CallStackTop].PC;
        end;
       end;
      end;
      opMDAP0:begin
       dec(Top);
       i:=fStack[Top];
       p:=GetPoint(0,VkTTF_PointType_Current,i);
       if assigned(p) then begin
        MovePoint(p^,0,true);
        fGraphicsState.rp[0]:=i;
        fGraphicsState.rp[1]:=i;
       end else begin
        raise EVulkanTrueTypeFont.Create('Out of point bounds');
       end;
      end;
      opMDAP1:begin
       dec(Top);
       i:=fStack[Top];
       p:=GetPoint(0,VkTTF_PointType_Current,i);
       if assigned(p) then begin
        Distance:=DotProduct(p^.x,p^.y,fGraphicsState.pv);
        Distance:=RoundValue(Distance)-Distance;
        MovePoint(p^,Distance,true);
        fGraphicsState.rp[0]:=i;
        fGraphicsState.rp[1]:=i;
       end else begin
        raise EVulkanTrueTypeFont.Create('Out of point bounds');
       end;
      end;
      opIUP0,opIUP1:begin
       if Opcode=opIUP0 then begin
        Mask:=VkTTF_PathFlag_TouchedY;
       end else begin
        Mask:=VkTTF_PathFlag_TouchedX;
       end;
       CurrentPoint:=0;
       for i:=0 to length(fEnds)-1 do begin
        EndPoint:=fEnds[i];
        FirstPoint:=CurrentPoint;
        if EndPoint>=length(fPoints[VkTTF_Zone_Glyph,VkTTF_PointType_Current]) then begin
         EndPoint:=length(fPoints[VkTTF_Zone_Glyph,VkTTF_PointType_Current])-1;
        end;
        while (CurrentPoint<=EndPoint) and ((fPoints[VkTTF_Zone_Glyph,VkTTF_PointType_Current,CurrentPoint].Flags and Mask)=0) do begin
         inc(CurrentPoint);
        end;
        if CurrentPoint<=EndPoint then begin
         FirstTouched:=CurrentPoint;
         CurrentTouched:=CurrentPoint;
         inc(CurrentPoint);
         while CurrentPoint<=EndPoint do begin
          if (fPoints[VkTTF_Zone_Glyph,VkTTF_PointType_Current,CurrentPoint].Flags and Mask)<>0 then begin
           IUPInterpolate(Opcode=opIUP0,CurrentTouched+1,CurrentPoint-1,CurrentTouched,CurrentPoint);
           CurrentTouched:=CurrentPoint;
          end;
          inc(CurrentPoint);
         end;
         if CurrentTouched=FirstTouched then begin
          IUPShift(Opcode=opIUP0,FirstPoint,EndPoint,CurrentTouched);
         end else begin
          IUPInterpolate(Opcode=opIUP0,CurrentTouched+1,EndPoint,CurrentTouched,FirstTouched);
          if FirstTouched>0 then begin
           IUPInterpolate(Opcode=opIUP0,FirstPoint,FirstTouched-1,CurrentTouched,FirstTouched);
          end;
         end;
        end;
       end;
      end;
      opSHP0,opSHP1:begin
       if Top<fGraphicsState.Loop then begin
        raise EVulkanTrueTypeFont.Create('Stack underflow');
       end else begin
        ComputePointDisplacement(Opcode=opSHP1,ZonePointer,RefIndex,dx,dy);
        while fGraphicsState.Loop<>0 do begin
         dec(Top);
         i:=fStack[Top];
         p:=GetPoint(2,VkTTF_PointType_Current,i);
         if fGraphicsState.fv[0]<>0 then begin
          inc(p^.x,dx);
          p^.Flags:=p^.Flags or VkTTF_PathFlag_TouchedX;
         end;
         if fGraphicsState.fv[1]<>0 then begin
          inc(p^.y,dy);
          p^.Flags:=p^.Flags or VkTTF_PathFlag_TouchedY;
         end;
         dec(fGraphicsState.Loop);
        end;
        fGraphicsState.Loop:=1;
       end;
      end;
      opSHC0,opSHC1:begin
       ComputePointDisplacement(Opcode=opSHC1,ZonePointer,RefIndex,dx,dy);
       dec(Top);
       x:=fStack[Top];
       if (x<0) or (x>=length(fEnds)) then begin
        raise EVulkanTrueTypeFont.Create('Contour range underflow');
       end else if x=0 then begin
        i:=0;
        j:=fEnds[x];
       end else begin
        i:=fEnds[x-1]+1;
        j:=fEnds[x];
       end;
       while i<=j do begin
        if (ZonePointer<>2) or (i<>RefIndex) then begin
         p:=GetPoint(2,VkTTF_PointType_Current,i);
         if fGraphicsState.fv[0]<>0 then begin
          inc(p^.x,dx);
          p^.Flags:=p^.Flags or VkTTF_PathFlag_TouchedX;
         end;
         if fGraphicsState.fv[1]<>0 then begin
          inc(p^.y,dy);
          p^.Flags:=p^.Flags or VkTTF_PathFlag_TouchedY;
         end;
        end;
        inc(i);
       end;
      end;
      opSHZ0,opSHZ1:begin
       ComputePointDisplacement(Opcode=opSHZ1,ZonePointer,RefIndex,dx,dy);
       dec(Top);
       x:=fStack[Top];
       if (x<0) or (x>2) then begin
        raise EVulkanTrueTypeFont.Create('Zone range underflow');
       end else begin
        i:=0;
        j:=length(fPoints[fGraphicsState.zp[x],VkTTF_PointType_Current]);
        if fGraphicsState.zp[x]=VkTTF_Zone_Glyph then begin
         dec(j,4);
        end;
        while i<j do begin
         if (ZonePointer<>x) or (i<>RefIndex) then begin
          p:=GetPoint(2,VkTTF_PointType_Current,i);
          if fGraphicsState.fv[0]<>0 then begin
           inc(p^.x,dx);
          end;
          if fGraphicsState.fv[1]<>0 then begin
           inc(p^.y,dy);
          end;
         end;
         inc(i);
        end;
       end;
      end;
      opSHPIX:begin
       if Top<(fGraphicsState.Loop+1) then begin
        raise EVulkanTrueTypeFont.Create('Stack underflow');
       end else begin
        dec(Top);
        Distance:=fStack[Top];
        dx:=SARInt64(TVkInt64(Distance)*fGraphicsState.fv[0],14);
        dy:=SARInt64(TVkInt64(Distance)*fGraphicsState.fv[1],14);
        while fGraphicsState.Loop<>0 do begin
         dec(Top);
         i:=fStack[Top];
         p:=GetPoint(2,VkTTF_PointType_Current,i);
         if fGraphicsState.fv[0]<>0 then begin
          inc(p^.x,dx);
          p^.Flags:=p^.Flags or VkTTF_PathFlag_TouchedX;
         end;
         if fGraphicsState.fv[1]<>0 then begin
          inc(p^.y,dy);
          p^.Flags:=p^.Flags or VkTTF_PathFlag_TouchedY;
         end;
         dec(fGraphicsState.Loop);
        end;
        fGraphicsState.Loop:=1;
       end;
      end;
      opIP:begin 
       if Top<fGraphicsState.Loop then begin
        raise EVulkanTrueTypeFont.Create('Stack underflow');
       end else begin
        Twilight:=(fGraphicsState.zp[0]=0) or (fGraphicsState.zp[1]=0) or (fGraphicsState.zp[2]=0);
        if Twilight then begin
         PointType:=VkTTF_PointType_Unhinted;
        end else begin
         PointType:=VkTTF_PointType_InFontUnits;
        end;
        p:=GetPoint(1,PointType,fGraphicsState.rp[2]);
        OldP:=GetPoint(0,PointType,fGraphicsState.rp[1]);
        if assigned(p) and assigned(OldP) then begin
         if PointType=VkTTF_PointType_InFontUnits then begin
          OldRange:=DotProduct(fFont.Scale(p^.x-OldP^.x),fFont.Scale(p^.y-OldP^.y),fGraphicsState.dv);
         end else begin
          OldRange:=DotProduct(p^.x-OldP^.x,p^.y-OldP^.y,fGraphicsState.dv);
         end;
        end else begin
         OldRange:=0;
        end;
        p:=GetPoint(1,VkTTF_PointType_Current,fGraphicsState.rp[2]);
        CurrentP:=GetPoint(0,VkTTF_PointType_Current,fGraphicsState.rp[1]);
        if assigned(p) and assigned(CurrentP) then begin
         CurrentRange:=DotProduct(p^.x-CurrentP^.x,p^.y-CurrentP^.y,fGraphicsState.pv);
        end else begin
         CurrentRange:=0;
        end;
        while fGraphicsState.Loop<>0 do begin
         dec(Top);
         i:=fStack[Top];
         p:=GetPoint(2,PointType,i);
         if assigned(p) then begin
          if PointType=VkTTF_PointType_InFontUnits then begin
           OldDist:=DotProduct(fFont.Scale(p^.x-OldP^.x),fFont.Scale(p^.y-OldP^.y),fGraphicsState.dv);
          end else begin
           OldDist:=DotProduct(p^.x-OldP^.x,p^.y-OldP^.y,fGraphicsState.dv);
          end;
          p:=GetPoint(2,VkTTF_PointType_Current,i);
          if assigned(p) then begin
           CurrentDist:=DotProduct(p^.x-CurrentP^.x,p^.y-CurrentP^.y,fGraphicsState.pv);
           if OldDist<>0 then begin
            if OldRange<>0 then begin
             NewDist:=MulDiv(OldDist,CurrentRange,OldRange,true);
            end else begin
             NewDist:=-OldDist;
            end;
           end else begin
            NewDist:=0;
           end;
           MovePoint(p^,NewDist-CurrentDist,true);
          end;
         end;
         dec(fGraphicsState.Loop);
        end;
        fGraphicsState.Loop:=1;
       end;
      end;
      opMSIRP0,opMSIRP1:begin
       dec(Top,2);
       d:=fStack[Top+1];
       i:=fStack[Top];
       if fGraphicsState.zp[0]=VkTTF_Zone_Twilight then begin
        // undocumented behaviour
        p0:=GetPoint(0,VkTTF_PointType_Unhinted,fGraphicsState.rp[0]);
        p1:=GetPoint(1,VkTTF_PointType_Unhinted,fGraphicsState.rp[0]);
        p2:=GetPoint(1,VkTTF_PointType_Current,fGraphicsState.rp[0]);
        if assigned(p0) and assigned(p1) and assigned(p2) then begin
         p1^:=p0^;
         p2^:=p0^;
        end else begin
         raise EVulkanTrueTypeFont.Create('Out of point bounds');
        end;
       end;
       p1:=GetPoint(1,VkTTF_PointType_Current,i);
       p2:=GetPoint(0,VkTTF_PointType_Current,fGraphicsState.rp[0]);
       if assigned(p1) and assigned(p2) then begin
        Distance:=DotProduct(p1^.x-p2^.x,p1^.y-p2^.y,fGraphicsState.pv);
        MovePoint(p1^,d-Distance,true);
        fGraphicsState.rp[1]:=fGraphicsState.rp[0];
        fGraphicsState.rp[2]:=i;
        if Opcode=opMSIRP1 then begin
         fGraphicsState.rp[0]:=i;
        end;
       end else begin
        raise EVulkanTrueTypeFont.Create('Out of point bounds');
       end;
      end;
      opALIGNRP:begin
       if Top<fGraphicsState.Loop then begin
        raise EVulkanTrueTypeFont.Create('Stack underflow');
       end else begin
        Ref:=GetPoint(0,VkTTF_PointType_Current,fGraphicsState.rp[0]);
        if assigned(Ref) then begin
         while fGraphicsState.Loop<>0 do begin
          dec(Top);
          p:=GetPoint(1,VkTTF_PointType_Current,fStack[Top]);
          if assigned(p) then begin
           MovePoint(p^,-DotProduct(p^.x-Ref^.x,p^.y-Ref^.y,fGraphicsState.pv),true);
           dec(fGraphicsState.Loop);
          end else begin
           raise EVulkanTrueTypeFont.Create('Out of point bounds');
          end;
         end;
         fGraphicsState.Loop:=1;
        end else begin
         raise EVulkanTrueTypeFont.Create('Out of point bounds');
        end;
       end;
      end;
      opRTDG:begin
       fGraphicsState.RoundPeriod:=1 shl 5;
       fGraphicsState.RoundPhase:=0;
       fGraphicsState.RoundThreshold:=1 shl 4;
       fGraphicsState.RoundSuper45:=false;
      end;
      opMIAP0:begin 
       dec(Top,2);
       i:=fStack[Top];
       Distance:=GetCVT(fStack[Top+1]);
       if fGraphicsState.zp[0]=0 then begin
        p:=GetPoint(0,VkTTF_PointType_Unhinted,i);
        q:=GetPoint(0,VkTTF_PointType_Current,i);
        if assigned(p) and assigned(q) then begin
         p^.x:=SARInt64(TVkInt64(Distance)*fGraphicsState.fv[0],14);
         p^.y:=SARInt64(TVkInt64(Distance)*fGraphicsState.fv[1],14);
         q^:=p^;
        end;
       end;
       p:=GetPoint(0,VkTTF_PointType_Current,i);
       if assigned(p) then begin
        OldDist:=DotProduct(p^.x,p^.y,fGraphicsState.pv);
        MovePoint(p^,Distance-OldDist,true);
       end;
       fGraphicsState.rp[0]:=i;
       fGraphicsState.rp[1]:=i;
      end;
      opMIAP1:begin
       dec(Top,2);
       i:=fStack[Top];
       Distance:=GetCVT(fStack[Top+1]);
       if fGraphicsState.zp[0]=0 then begin
        p:=GetPoint(0,VkTTF_PointType_Unhinted,i);
        q:=GetPoint(0,VkTTF_PointType_Current,i);
        if assigned(p) and assigned(q) then begin
         p^.x:=SARInt64(TVkInt64(Distance)*fGraphicsState.fv[0],14);
         p^.y:=SARInt64(TVkInt64(Distance)*fGraphicsState.fv[1],14);
         q^:=p^;
        end;
       end;
       p:=GetPoint(0,VkTTF_PointType_Current,i);
       if assigned(p) then begin
        OldDist:=DotProduct(p^.x,p^.y,fGraphicsState.pv);
        if abs(Distance-OldDist)>fGraphicsState.ControlValueCutIn then begin
         Distance:=OldDist;
        end;
        Distance:=RoundValue(Distance);
        MovePoint(p^,Distance-OldDist,true);
       end;
       fGraphicsState.rp[0]:=i;
       fGraphicsState.rp[1]:=i;
      end;
      opNPUSHB:begin
       inc(PC);
       if PC>=ProgramBytes.Size then begin
        raise EVulkanTrueTypeFont.Create('Insufficient data');
       end else begin
        Opcode:=ProgramBytes.Data^[PC];
        inc(PC);
        if (Top+Opcode)>length(fStack) then begin
         raise EVulkanTrueTypeFont.Create('Stack overflow');
        end else if (PC+Opcode)>ProgramBytes.Size then begin
         raise EVulkanTrueTypeFont.Create('Insufficient data');
        end else begin
         while Opcode>0 do begin
          fStack[Top]:=ProgramBytes.Data^[PC];
          inc(Top);
          inc(PC);
          dec(Opcode);
         end;
        end;
       end;
       continue;
      end;
      opNPUSHW:begin
       inc(PC);
       if PC>=ProgramBytes.Size then begin
        raise EVulkanTrueTypeFont.Create('Insufficient data');
       end else begin
        Opcode:=ProgramBytes.Data^[PC];
        inc(PC);
        if (Top+Opcode)>length(fStack) then begin
         raise EVulkanTrueTypeFont.Create('Stack overflow');
        end else if (PC+(Opcode*2))>ProgramBytes.Size then begin
         raise EVulkanTrueTypeFont.Create('Insufficient data');
        end else begin
         while Opcode>0 do begin
          fStack[Top]:=TVkInt16(TVkUInt16((ProgramBytes.Data^[PC] shl 8) or ProgramBytes.Data^[PC+1]));
          inc(Top);
          inc(PC,2);
          dec(Opcode);
         end;
        end;
       end;
       continue;
      end;
      opWS:begin
       dec(Top,2);
       i:=fStack[Top];
       if (i>=0) and (i<length(fStorage)) then begin
        fStorage[i]:=fStack[Top+1];
       end else begin
        raise EVulkanTrueTypeFont.Create('Invalid data');
       end;
      end;
      opRS:begin
       i:=fStack[Top-1];
       if (i>=0) and (i<length(fStorage)) then begin
        fStack[Top-1]:=fStorage[i];
       end else begin
        raise EVulkanTrueTypeFont.Create('Invalid data');
       end;
      end;
      opWCVTP:begin
       dec(Top,2);
       SetCVT(fStack[Top],fStack[Top+1]);
      end;
      opRCVT:begin
       fStack[Top-1]:=GetCVT(fStack[Top-1]);
      end;
      opGC0,opGC1:begin
       p:=GetPoint(2,VkTTF_PointType_Current,fStack[Top-1]);
       if assigned(p) then begin
        case Opcode of
         opGC0:begin
          fStack[Top-1]:=DotProduct(p^.x,p^.y,fGraphicsState.pv);
         end;
         opGC1:begin
          fStack[Top-1]:=DotProduct(p^.x,p^.y,fGraphicsState.dv);
         end;
        end;
       end else begin
        raise EVulkanTrueTypeFont.Create('Out of point bounds');
       end;
      end;
      opSCFS:begin
       dec(Top,2);
       Distance:=fStack[Top+1];
       p:=GetPoint(2,VkTTF_PointType_Current,fStack[Top]);
       if assigned(p) then begin
        OldDist:=DotProduct(p^.x,p^.y,fGraphicsState.pv);
        MovePoint(p^,Distance-OldDist,true);
        if fGraphicsState.zp[2]=0 then begin
         // UNDOCUMENTED! The MS rasterizer does that with twilight points
         p1:=GetPoint(2,VkTTF_PointType_Unhinted,fStack[Top]);
         if assigned(p1) then begin
{         p1^.x:=p0^.x;
          p1^.y:=p0^.y;}
          p1^.x:=p^.x;
          p1^.y:=p^.y;
         end;
        end;
       end else begin
        raise EVulkanTrueTypeFont.Create('Out of point bounds');
       end;
      end;
      opMD0:begin
       dec(Top);
       p0:=GetPoint(0,VkTTF_PointType_Current,fStack[Top-1]);
       p1:=GetPoint(1,VkTTF_PointType_Current,fStack[Top]);
       if assigned(p0) and assigned(p1) then begin
        fStack[Top-1]:=DotProduct(p0^.x-p1^.x,p0^.y-p1^.y,fGraphicsState.pv);
       end else begin
        raise EVulkanTrueTypeFont.Create('Out of point bounds');
       end;
      end;
      opMD1:begin
       dec(Top);
       if (fGraphicsState.zp[0]=0) or (fGraphicsState.zp[1]=0) then begin
        p0:=GetPoint(0,VkTTF_PointType_Unhinted,fStack[Top-1]);
        p1:=GetPoint(1,VkTTF_PointType_Unhinted,fStack[Top]);
        if assigned(p0) and assigned(p1) then begin
         fStack[Top-1]:=DotProduct(p0^.x-p1^.x,p0^.y-p1^.y,fGraphicsState.dv);
        end else begin
         raise EVulkanTrueTypeFont.Create('Out of point bounds');
        end;
       end else begin
        // UNDOCUMENTED: twilight zone special case
        p0:=GetPoint(0,VkTTF_PointType_InFontUnits,fStack[Top-1]);
        p1:=GetPoint(1,VkTTF_PointType_InFontUnits,fStack[Top]);
        if assigned(p0) and assigned(p1) then begin
         fStack[Top-1]:=DotProduct(fFont.Scale(p0^.x-p1^.x),fFont.Scale(p0^.y-p1^.y),fGraphicsState.dv);
        end else begin
         raise EVulkanTrueTypeFont.Create('Out of point bounds');
        end;
       end;
      end;
      opMPPEM:begin
       if Top>=length(fStack) then begin
        raise EVulkanTrueTypeFont.Create('Stack overflow');
       end else begin
        fStack[Top]:=SARLongint(Font.GetScale+32,6);
        inc(Top);
       end;
      end;
      opMPS:begin
       if Top>=length(fStack) then begin
        raise EVulkanTrueTypeFont.Create('Stack overflow');
       end else begin
        fStack[Top]:=SARLongint(Font.GetScale+32,6);
        inc(Top);
       end;
      end;
      opFLIPON:begin
       fGraphicsState.AutoFlip:=true;
      end;
      opFLIPOFF:begin
       fGraphicsState.AutoFlip:=false;
      end;
      opDEBUG:begin
      end;
      opLT:begin
       dec(Top);
       if fStack[Top-1]<fStack[Top] then begin
        fStack[Top-1]:=1;
       end else begin
        fStack[Top-1]:=0;
       end;
      end;
      opLTEQ:begin
       dec(Top);
       if fStack[Top-1]<=fStack[Top] then begin
        fStack[Top-1]:=1;
       end else begin
        fStack[Top-1]:=0;
       end;
      end;
      opGT:begin
       dec(Top);
       if fStack[Top-1]>fStack[Top] then begin
        fStack[Top-1]:=1;
       end else begin
        fStack[Top-1]:=0;
       end;
      end;
      opGTEQ:begin
       dec(Top);
       if fStack[Top-1]>=fStack[Top] then begin
        fStack[Top-1]:=1;
       end else begin
        fStack[Top-1]:=0;
       end;
      end;
      opEQ:begin
       dec(Top);
       if fStack[Top-1]=fStack[Top] then begin
        fStack[Top-1]:=1;
       end else begin
        fStack[Top-1]:=0;
       end;
      end;
      opNEQ:begin
       dec(Top);
       if fStack[Top-1]<>fStack[Top] then begin
        fStack[Top-1]:=1;
       end else begin
        fStack[Top-1]:=0;
       end;
      end;
      opODD:begin
       fStack[Top-1]:=SARLongint(RoundValue(fStack[Top-1]),6) and 1;
      end;
      opEVEN:begin
       fStack[Top-1]:=(SARLongint(RoundValue(fStack[Top-1]),6) and 1) xor 1;
      end;
      opIF:begin
       dec(Top);
       if fStack[Top]=0 then begin
        Depth:=0;
        repeat
         inc(PC);
         if PC>=ProgramBytes.Size then begin
          raise EVulkanTrueTypeFont.Create('Unbalanced IF');
         end else begin
          case ProgramBytes.Data^[PC] of
           opIF:begin
            inc(Depth);
           end;
           opELSE:begin
            if Depth=0 then begin
             break;
            end;
           end;
           opEIF:begin
            dec(Depth);
            if Depth<0 then begin
             break;
            end;
           end;
           else begin
            OK:=SkipInstructionPayload(ProgramBytes,PC);
            if not OK Then begin
             raise EVulkanTrueTypeFont.Create('Unbalanced IF');
            end;
           end;
          end;
         end;
        until false;
       end;
      end;
      opEIF:begin
      end;
      opAND:begin
       dec(Top);
       if (fStack[Top-1]<>0) and (fStack[Top]<>0) then begin
        fStack[Top-1]:=1;
       end else begin
        fStack[Top-1]:=0;
       end;
      end;
      opOR:begin
       dec(Top);
       if (fStack[Top-1] or fStack[Top])<>0 then begin
        fStack[Top-1]:=1;
       end else begin
        fStack[Top-1]:=0;
       end;
      end;
      opNOT:begin
       if fStack[Top-1]=0 then begin
        fStack[Top-1]:=1;
       end else begin
        fStack[Top-1]:=0;
       end;
      end;
      opDELTAP1,opDELTAP2,opDELTAP3:begin
       if Top<1 then begin
        raise EVulkanTrueTypeFont.Create('Stack underflow');
       end else begin
        dec(Top);
        Base:=fGraphicsState.DeltaBase;
        case Opcode of
         opDELTAP2:begin
          inc(Base,16);
         end;
         opDELTAP3:begin
          inc(Base,32);
         end;
        end;
        x:=SARLongint(fFont.GetScale,6);
        Count:=fStack[Top];
        if Top<(Count*2) then begin
         raise EVulkanTrueTypeFont.Create('Stack underflow');
        end else begin
         while Count<>0 do begin
          dec(Top,2);
          i:=fStack[Top+1];
          j:=fStack[Top];
          k:=((j and $f0) shr 4)+Base;
          if k=x then begin
           p:=GetPoint(0,VkTTF_PointType_Current,i);
           if assigned(p) then begin
            j:=(j and $f)-8;
            if j>=0 then begin
             inc(j);
            end;                                                
            MovePoint(p^,(j*64) div (1 shl fGraphicsState.DeltaShift),true);
           end;
          end;
          dec(Count);
         end;
        end;
       end;
      end;
      opDELTAC1,opDELTAC2,opDELTAC3:begin
       if Top<1 then begin
        raise EVulkanTrueTypeFont.Create('Stack underflow');
       end else begin
        dec(Top);
        Base:=fGraphicsState.DeltaBase;
        case Opcode of
         opDELTAC2:begin
          inc(Base,16);
         end;
         opDELTAC3:begin
          inc(Base,32);
         end;
        end;
        x:=SARLongint(fFont.GetScale+32,6);
        Count:=fStack[Top];
        if Top<(Count*2) then begin
         raise EVulkanTrueTypeFont.Create('Stack underflow');
        end else begin
         while Count<>0 do begin
          dec(Top,2);
          i:=fStack[Top+1];
          j:=fStack[Top];
          k:=((j and $f0) shr 4)+Base;
          if k=x then begin
           j:=(j and $f)-8;
           if j>=0 then begin
            inc(j);
           end;
           j:=(j*64) div (1 shl fGraphicsState.DeltaShift);
           if (i>=0) and (i<length(fFont.fCVT)) then begin
            inc(fCVT[i],j);
           end;
          end;
          dec(Count);
         end;
        end;
       end;
      end;
      opSDB:begin
       dec(Top);
       fGraphicsState.DeltaBase:=fStack[Top];
      end;
      opSDS:begin
       dec(Top);
       fGraphicsState.DeltaShift:=fStack[Top];
      end;
      opADD:begin
       dec(Top);
       inc(fStack[Top-1],fStack[Top]);
      end;
      opSUB:begin
       dec(Top);
       dec(fStack[Top-1],fStack[Top]);
      end;
      opDIV:begin
       dec(Top);
       if fStack[Top]=0 then begin
        raise EVulkanTrueTypeFont.Create('Division by zero');
       end else begin
        fStack[Top-1]:=Div26d6(fStack[Top-1],fStack[Top]);
       end;
      end;
      opMUL:begin
       dec(Top);
       fStack[Top-1]:=Mul26d6(fStack[Top-1],fStack[Top]);
      end;
      opABS:begin
       if fStack[Top-1]<0 then begin
        fStack[Top-1]:=-fStack[Top-1];
       end;
      end;
      opNEG:begin
       fStack[Top-1]:=-fStack[Top-1];
      end;
      opFLOOR:begin
       fStack[Top-1]:=fStack[Top-1] and not 63;
      end;
      opCEILING:begin
       fStack[Top-1]:=(fStack[Top-1]+63) and not 63;
      end;
      opROUND00,opROUND01,opROUND10,opROUND11:begin
       fStack[Top-1]:=RoundValue(fStack[Top-1]);
      end;
      opNROUND00,opNROUND01,opNROUND10,opNROUND11:begin
       // Not needed, since we do not our job for dot-matrix printers :-)
      end;
      opWCVTF:begin
       dec(Top,2);
       SetCVT(fStack[Top],SARLongint(Font.Scale(fStack[Top+1])+32,6));
      end;
      opSROUND,opS45ROUND:begin
       dec(Top);
       case SARLongint(fStack[Top],6) and 3 of
        0:begin
         fGraphicsState.RoundPeriod:=1 shl 5;
        end;
        1,3:begin
         fGraphicsState.RoundPeriod:=1 shl 6;
        end;
        2:begin
         fGraphicsState.RoundPeriod:=1 shl 7;
        end;
       end;
       if Opcode=opS45ROUND then begin
        fGraphicsState.RoundSuper45:=true;
        fGraphicsState.RoundPeriod:=SARLongint(fGraphicsState.RoundPeriod*46341,16);
       end else begin
        fGraphicsState.RoundSuper45:=false;
       end;
       fGraphicsState.RoundPhase:=SARLongint(fGraphicsState.RoundPeriod*(SARLongint(fStack[Top],4) and 3),2);
       x:=fStack[Top] and $f;
       if x<>0 then begin
        fGraphicsState.RoundThreshold:=SARLongint(fGraphicsState.RoundPeriod*(x-4),3);
       end else begin
        fGraphicsState.RoundThreshold:=fGraphicsState.RoundPeriod-1;
       end;
      end;
      opJROT:begin
       dec(Top,2);
       if fStack[Top+1]<>0 then begin
        inc(PC,fStack[Top]);
        continue;
       end;
      end;
      opJROF:begin
       dec(Top,2);
       if fStack[Top+1]=0 then begin
        inc(PC,fStack[Top]);
        continue;
       end;
      end;
      opROFF:begin
       fGraphicsState.RoundPeriod:=0;
       fGraphicsState.RoundPhase:=0;
       fGraphicsState.RoundThreshold:=0;
       fGraphicsState.RoundSuper45:=false;
      end;
      opRUTG:begin
       fGraphicsState.RoundPeriod:=1 shl 6;
       fGraphicsState.RoundPhase:=0;
       fGraphicsState.RoundThreshold:=(1 shl 6)-1;
       fGraphicsState.RoundSuper45:=false;
      end;
      opRDTG:begin
       fGraphicsState.RoundPeriod:=1 shl 6;
       fGraphicsState.RoundPhase:=0;
       fGraphicsState.RoundThreshold:=0;
       fGraphicsState.RoundSuper45:=false;
      end;
      opSANGW:begin
       dec(Top);
      end;
      opFLIPPT:begin
       if Top<fGraphicsState.Loop then begin
        raise EVulkanTrueTypeFont.Create('Stack underflow');
       end else begin
        dec(Top);
        while fGraphicsState.Loop<>0 do begin
         dec(Top);
         i:=fStack[Top];
         p:=GetPoint(1,VkTTF_PointType_Current,i);
         if assigned(p) then begin
          p^.Flags:=p^.Flags xor VkTTF_PathFlag_OnCurve;
         end;
         dec(fGraphicsState.Loop);
        end;
        fGraphicsState.Loop:=1;
       end;
      end;
      opFLIPRGON:begin
       dec(Top,2);
       j:=fStack[Top+1];
       i:=fStack[Top];
       while i<=j do begin
        p:=GetPoint(1,VkTTF_PointType_Current,i);
        if assigned(p) then begin
         p^.Flags:=p^.Flags or VkTTF_PathFlag_OnCurve;
        end;
        inc(i);
       end;
      end;
      opFLIPRGOFF:begin
       dec(Top,2);
       j:=fStack[Top+1];
       i:=fStack[Top];
       while i<=j do begin
        p:=GetPoint(1,VkTTF_PointType_Current,i);
        if assigned(p) then begin
         p^.Flags:=p^.Flags and not VkTTF_PathFlag_OnCurve;
        end;
        inc(i);
       end;
      end;
      opAA:begin
       dec(Top);
      end;
      opSCANCTRL:begin
       dec(Top);
      end; 
      opSDPVTL0,opSDPVTL1:begin
       dec(Top,2);
       p1:=GetPoint(1,VkTTF_PointType_Unhinted,fStack[Top]);
       p2:=GetPoint(2,VkTTF_PointType_Unhinted,fStack[Top+1]);
       if assigned(p1) and assigned(p2) then begin
        dx:=p1^.x-p2^.x;
        dy:=p1^.y-p2^.y;
        if (dx=0) and (dy=0) then begin
         dx:=$4000;
         Opcode:=opSDPVTL0;
        end;
        Normalize(dx,dy);
        if Opcode=opSDPVTL0 then begin
         fGraphicsState.dv[0]:=dx;
         fGraphicsState.dv[1]:=dy;
        end else begin
         fGraphicsState.dv[0]:=-dy;
         fGraphicsState.dv[1]:=dx;
        end;
        p1:=GetPoint(1,VkTTF_PointType_Current,fStack[Top]);
        p2:=GetPoint(2,VkTTF_PointType_Current,fStack[Top+1]);
        if assigned(p1) and assigned(p2) then begin
         dx:=p1^.x-p2^.x;
         dy:=p1^.y-p2^.y;
         if (dx=0) and (dy=0) then begin
          dx:=$4000;
          Opcode:=opSDPVTL0;
         end;
         Normalize(dx,dy);
         if Opcode=opSDPVTL0 then begin
          fGraphicsState.pv[0]:=dx;
          fGraphicsState.pv[1]:=dy;
         end else begin
          fGraphicsState.pv[0]:=-dy;
          fGraphicsState.pv[1]:=dx;
         end;
        end else begin
         raise EVulkanTrueTypeFont.Create('Out of point bounds');
        end;
       end else begin
        raise EVulkanTrueTypeFont.Create('Out of point bounds');
       end;
      end;
      opGETINFO:begin
       x:=0;
       if (fStack[Top-1] and 1)<>0 then begin
        x:=x or 35; // Version 35, same as Windows 98 and Freetype
       end;
       if (fStack[Top-1] and 32)<>0 then begin
        x:=x or 4096; // Greyscale suppiort
       end;
       fStack[Top-1]:=x;
      end;
      opIDEF:begin
       raise EVulkanTrueTypeFont.Create('Unsupported IDEF instruction');
      end;
      opROLL:begin
       t1:=fStack[Top-1];
       t2:=fStack[Top-2];
       t3:=fStack[Top-3];
       fStack[Top-1]:=t3;
       fStack[Top-2]:=t1;
       fStack[Top-3]:=t2;
      end;
      opMAX:begin
       dec(Top);
       if fStack[Top-1]<fStack[Top] then begin
        fStack[Top-1]:=fStack[Top];
       end;
      end;
      opMIN:begin
       dec(Top);
       if fStack[Top-1]>fStack[Top] then begin
        fStack[Top-1]:=fStack[Top];
       end;
      end;
      opSCANTYPE:begin
       dec(Top);
      end;
      opINSTCTRL:begin
       dec(Top,2);
       if (fStack[Top+1]>=1) and (fStack[Top+1]<=2) then begin
        if fStack[Top]<>0 then begin
         fGraphicsState.InstructionControl:=(fGraphicsState.InstructionControl and not fStack[Top+1]) or fStack[Top+1];
        end else begin
         fGraphicsState.InstructionControl:=(fGraphicsState.InstructionControl and not fStack[Top+1]) or fStack[Top];
        end;
       end else begin
        raise EVulkanTrueTypeFont.Create('Invalid reference');
       end;
      end;
      opPUSHB000,opPUSHB001,opPUSHB010,opPUSHB011,opPUSHB100,opPUSHB101,opPUSHB110,opPUSHB111:begin
       inc(PC);
       dec(Opcode,opPUSHB000-1);
       if (Top+Opcode)>length(fStack) then begin
        raise EVulkanTrueTypeFont.Create('Stack overflow');
       end else if (PC+Opcode)>ProgramBytes.Size then begin
        raise EVulkanTrueTypeFont.Create('Insufficient data');
       end else begin
        while Opcode>0 do begin
         fStack[Top]:=ProgramBytes.Data^[PC];
         inc(Top);
         inc(PC);
         dec(Opcode);
        end;
       end;
       continue;
      end;
      opPUSHW000,opPUSHW001,opPUSHW010,opPUSHW011,opPUSHW100,opPUSHW101,opPUSHW110,opPUSHW111:begin
       inc(PC);
       dec(Opcode,opPUSHW000-1);
       if (Top+Opcode)>length(fStack) then begin
        raise EVulkanTrueTypeFont.Create('Stack overflow');
       end else if (PC+(Opcode*2))>ProgramBytes.Size then begin
        raise EVulkanTrueTypeFont.Create('Insufficient data');
       end else begin
        while Opcode>0 do begin
         fStack[Top]:=TVkInt16(TVkUInt16((ProgramBytes.Data^[PC] shl 8) or ProgramBytes.Data^[PC+1]));
         inc(Top);
         inc(PC,2);
         dec(Opcode);
        end;
       end;
       continue;
      end;
      opMDRP00000,opMDRP00001,opMDRP00010,opMDRP00011,opMDRP00100,opMDRP00101,opMDRP00110,opMDRP00111,
      opMDRP01000,opMDRP01001,opMDRP01010,opMDRP01011,opMDRP01100,opMDRP01101,opMDRP01110,opMDRP01111,
      opMDRP10000,opMDRP10001,opMDRP10010,opMDRP10011,opMDRP10100,opMDRP10101,opMDRP10110,opMDRP10111,
      opMDRP11000,opMDRP11001,opMDRP11010,opMDRP11011,opMDRP11100,opMDRP11101,opMDRP11110,opMDRP11111:begin
       dec(Top);
       i:=fStack[Top];
       Ref:=GetPoint(0,VkTTF_PointType_Current,fGraphicsState.rp[0]);
       p:=GetPoint(1,VkTTF_PointType_Current,i);
       if assigned(Ref) and assigned(p) then begin
        if (fGraphicsState.zp[0]=0) or (fGraphicsState.zp[1]=0) then begin
         p0:=GetPoint(1,VkTTF_PointType_Unhinted,i);
         p1:=GetPoint(0,VkTTF_PointType_Unhinted,fGraphicsState.rp[0]);
         OldDist:=DotProduct(p0^.x-p1^.x,p0^.y-p1^.y,fGraphicsState.dv);
        end else begin
         p0:=GetPoint(1,VkTTF_PointType_InFontUnits,i);
         p1:=GetPoint(0,VkTTF_PointType_InFontUnits,fGraphicsState.rp[0]);
         OldDist:=fFont.Scale(DotProduct(p0^.x-p1^.x,p0^.y-p1^.y,fGraphicsState.dv));
        end;
        if abs(OldDist-fGraphicsState.SingleWidth)<fGraphicsState.SingleWidthCutIn then begin
         if OldDist>=0 then begin
          OldDist:=fGraphicsState.SingleWidth;
         end else begin
          OldDist:=-fGraphicsState.SingleWidth;
         end;
        end;
        if (Opcode and 4)<>0 then begin
         Distance:=RoundValue(OldDist);
        end else begin
         Distance:=OldDist;
        end;
        if (Opcode and 8)<>0 then begin
         if OldDist>=0 then begin
          if Distance<fGraphicsState.MinDist then begin
           Distance:=fGraphicsState.MinDist;
          end;
         end else begin
          if Distance>(-fGraphicsState.MinDist) then begin
           Distance:=-fGraphicsState.MinDist;
          end;
         end;
        end;
        fGraphicsState.rp[1]:=fGraphicsState.rp[0];
        if (Opcode and 16)<>0 then begin
         fGraphicsState.rp[0]:=i;
        end;
        fGraphicsState.rp[2]:=i;
        OldDist:=DotProduct(p^.x-Ref^.x,p^.y-Ref^.y,fGraphicsState.pv);
        MovePoint(p^,Distance-OldDist,true);
       end else begin
        raise EVulkanTrueTypeFont.Create('Out of point bounds');
       end;
      end;
      opMIRP00000,opMIRP00001,opMIRP00010,opMIRP00011,opMIRP00100,opMIRP00101,opMIRP00110,opMIRP00111,
      opMIRP01000,opMIRP01001,opMIRP01010,opMIRP01011,opMIRP01100,opMIRP01101,opMIRP01110,opMIRP01111,
      opMIRP10000,opMIRP10001,opMIRP10010,opMIRP10011,opMIRP10100,opMIRP10101,opMIRP10110,opMIRP10111,
      opMIRP11000,opMIRP11001,opMIRP11010,opMIRP11011,opMIRP11100,opMIRP11101,opMIRP11110,opMIRP11111:begin
       dec(Top,2);
       i:=fStack[Top];
       CVTDist:=GetCVT(fStack[Top+1]);
       if abs(CVTDist-fGraphicsState.SingleWidth)<fGraphicsState.SingleWidthCutIn then begin
        if CVTDist>=0 then begin
         CVTDist:=fGraphicsState.SingleWidth;
        end else begin
         CVTDist:=-fGraphicsState.SingleWidth;
        end;
       end;
       if fGraphicsState.zp[1]=VkTTF_Zone_Twilight then begin
        // UNDOCUMENTED: when moving a twilight zone point, its original position is changed as well.
        p0:=GetPoint(0,VkTTF_PointType_Unhinted,fGraphicsState.rp[0]);
        p1:=GetPoint(1,VkTTF_PointType_Unhinted,i);
        if assigned(p0) and assigned(p1) then begin
         p1^.x:=p0^.x+MulDiv(CVTDist,fGraphicsState.fv[0],$4000,true);
         p1^.y:=p0^.y+MulDiv(CVTDist,fGraphicsState.fv[1],$4000,true);
         p2:=GetPoint(1,VkTTF_PointType_Current,i);
         if assigned(p2) then begin
          p2^.x:=p1^.x;
          p2^.y:=p1^.y;
         end;
        end;
       end;
       Ref:=GetPoint(0,VkTTF_PointType_Unhinted,fGraphicsState.rp[0]);
       p:=GetPoint(1,VkTTF_PointType_Unhinted,i);
       if assigned(Ref) and assigned(p) then begin
        OldDist:=DotProduct(p^.x-Ref^.x,p^.y-Ref^.y,fGraphicsState.dv);
        Ref:=GetPoint(0,VkTTF_PointType_Current,fGraphicsState.rp[0]);
        p:=GetPoint(1,VkTTF_PointType_Current,i);   
        if assigned(Ref) and assigned(p) then begin
         CurrentDist:=DotProduct(p^.x-Ref^.x,p^.y-Ref^.y,fGraphicsState.pv);
         if fGraphicsState.AutoFlip and (TVkInt32(OldDist xor CVTDist)<0) then begin
          CVTDist:=-CVTDist;
         end;
         if (Opcode and 4)<>0 then begin
          if (fGraphicsState.zp[0]=fGraphicsState.zp[1]) and
             (abs(CVTDist-OldDist)>fGraphicsState.ControlValueCutIn) then begin
           CVTDist:=OldDist;
          end;
          Distance:=RoundValue(CVTDist);
         end else begin
          Distance:=CVTDist;
         end;
         if (Opcode and 8)<>0 then begin
          if OldDist>=0 then begin
           if Distance<fGraphicsState.MinDist then begin
            Distance:=fGraphicsState.MinDist;
           end;
          end else begin
           if Distance>(-fGraphicsState.MinDist) then begin
            Distance:=-fGraphicsState.MinDist;
           end;
          end;
         end;
         fGraphicsState.rp[1]:=fGraphicsState.rp[0];
         if (Opcode and 16)<>0 then begin
          fGraphicsState.rp[0]:=i;
         end;
         fGraphicsState.rp[2]:=i;
         MovePoint(p^,Distance-CurrentDist,true);
        end else begin
         raise EVulkanTrueTypeFont.Create('Out of point bounds');
        end;
       end else begin
        raise EVulkanTrueTypeFont.Create('Out of point bounds');
       end;
      end;
      else begin
       raise EVulkanTrueTypeFont.Create('Unrecognized instruction');
      end;
     end;
     inc(PC);
    end;
   end;
  end;
 end;
{$ifdef ttfdebug}
 DumpState;
{$endif}
end;

constructor TVulkanTrueTypeFont.Create(const Stream:TStream;const TargetPPI:TVkInt32=96;const ForceSelector:boolean=false;const PlatformID:TVkUInt16=VkTTF_PID_Microsoft;const SpecificID:TVkUInt16=VkTTF_SID_MS_UNICODE_CS;const LanguageID:TVkUInt16=VkTTF_LID_MS_USEnglish;const CollectionIndex:TVkInt32=0);
begin
 inherited Create;
 fTargetPPI:=TargetPPI;
 fForceSelector:=ForceSelector;
 fPlatformID:=PlatformID;
 fSpecificID:=SpecificID;
 FLanguageID:=LanguageID;
 fFontDataSize:=0;
 fFontData:=nil;
 fCMaps[0]:=nil;
 fCMaps[1]:=nil;
 fCMapLengths[0]:=0;
 fCMapLengths[1]:=0;
 fCMapFormat:=0;
 fNumTables:=0;
 fIndexToLocationFormat:=0;
 FillChar(fGlyphBuffer,SizeOf(TVulkanTrueTypeFontGlyphBuffer),AnsiChar(#0));
 FillChar(fPolygonBuffer,SizeOf(TVulkanTrueTypeFontPolygonBuffer),AnsiChar(#0));
 fGlyfOffset:=0;
 fGlyphLoadedBitmap:=nil;
 fGlyphs:=nil;
 fGlyphOffsetArray:=nil;
 fCountGlyphs:=0;
 fMaxTwilightPoints:=0;
 fMaxStorage:=0;
 fMaxFunctionDefs:=0;
 fMaxStackElements:=0;
 fCVT:=nil;
 FillChar(fFPGM,SizeOf(TVulkanTrueTypeFontByteCodeInterpreterProgramBytes),AnsiChar(#0));
 FillChar(fPREP,SizeOf(TVulkanTrueTypeFontByteCodeInterpreterProgramBytes),AnsiChar(#0));
 fStringCopyright:='';
 fStringFamily:='';
 fStringSubFamily:='';
 fStringFullName:='';
 fStringUniqueID:='';
 fStringVersion:='';
 fStringPostScript:='';
 fStringTrademark:='';
 fMaxX:=0;
 fMinX:=0;
 fMaxY:=0;
 fMinY:=0;
 fUnitsPerEm:=0;
 fUnitsPerPixel:=0;
 fThinBoldStrength:=0;
 fAscender:=0;
 fDescender:=0;
 fLineGap:=0;
 fKerningTables:=nil;
 fSize:=12;
 fLetterSpacingX:=0;
 fLetterSpacingY:=0;
 fStyleIndex:=0;
 fHinting:=false;
 fByteCodeInterpreter:=nil;
 begin
  SetLength(fGASPRanges,4);
  begin
   fGASPRanges[0].LowerPPEM:=0;
   fGASPRanges[0].UpperPPEM:=8;
   fGASPRanges[0].Flags:=VkTTF_GASP_DOGRAY or VkTTF_GASP_SYMMETRIC_GRIDFIT;
  end;
  begin
   fGASPRanges[1].LowerPPEM:=9;
   fGASPRanges[1].UpperPPEM:=16;
   fGASPRanges[1].Flags:=VkTTF_GASP_GRIDFIT or VkTTF_GASP_SYMMETRIC_GRIDFIT;
  end;
  begin
   fGASPRanges[2].LowerPPEM:=17;
   fGASPRanges[2].UpperPPEM:=19;
   fGASPRanges[2].Flags:=VkTTF_GASP_GRIDFIT or VkTTF_GASP_DOGRAY or VkTTF_GASP_SYMMETRIC_GRIDFIT;
  end;
  begin
   fGASPRanges[3].LowerPPEM:=20;
   fGASPRanges[3].UpperPPEM:=$7ffffff;
   fGASPRanges[3].Flags:=VkTTF_GASP_GRIDFIT or VkTTF_GASP_DOGRAY or VkTTF_GASP_SYMMETRIC_GRIDFIT or VkTTF_GASP_SYMMETRIC_SMOOTHING;
  end;
 end;
 FillChar(fByteCodeInterpreterParameters,SizeOf(TVulkanTrueTypeFontByteCodeInterpreterParameters),#0);
 fIgnoreByteCodeInterpreter:=true;
 fLastError:=VkTTF_TT_ERR_NoError;
 fPostScriptFlavored:=false;
 try
  if ReadFontData(Stream,CollectionIndex)=VkTTF_TT_ERR_NoError then begin

   repeat

    fLastError:=LoadOS2;
    if fLastError<>VkTTF_TT_ERR_NoError then begin
     break;
    end;

    fLastError:=LoadHEAD;
    if fLastError<>VkTTF_TT_ERR_NoError then begin
     break;
    end;

    fLastError:=LoadMAXP;
    if fLastError<>VkTTF_TT_ERR_NoError then begin
     break;
    end;

    fLastError:=LoadNAME;
    if fLastError<>VkTTF_TT_ERR_NoError then begin
     break;
    end;

    fLastError:=LoadCMAP;
    if fLastError<>VkTTF_TT_ERR_NoError then begin
     break;
    end;

    fLastError:=LoadCFF;
    if fLastError=VkTTF_TT_ERR_NoError then begin

     fPostScriptFlavored:=true;

    end else begin

     fLastError:=LoadLOCA;
     if fLastError<>VkTTF_TT_ERR_NoError then begin
      break;
     end;

     fLastError:=LoadGLYF;
     if fLastError<>VkTTF_TT_ERR_NoError then begin
      break;
     end;

    end;

    fLastError:=LoadHHEA;
    if fLastError<>VkTTF_TT_ERR_NoError then begin
     break;
    end;

    fLastError:=LoadHMTX;
    if fLastError<>VkTTF_TT_ERR_NoError then begin
     break;
    end;

    fLastError:=LoadVHEA;
    if fLastError<>VkTTF_TT_ERR_NoError then begin
     break;
    end;

    fLastError:=LoadVMTX;
    if fLastError<>VkTTF_TT_ERR_NoError then begin
     break;
    end;

    LoadGPOS; // GPOS table is only optional
    LoadKERN; // Kerning table is only optional

    if not fPostScriptFlavored then begin

     LoadCVT; // CVT table is only optional
     LoadFPGM; // FPGM table is only optional
     LoadPREP; // PREP table is only optional

    end;

    LoadGASP; // GASP table is only optional

    break;

   until true;

  end;
  try
   fByteCodeInterpreter:=TVulkanTrueTypeFontByteCodeInterpreter.Create(self);
   fIgnoreByteCodeInterpreter:=false;
   fByteCodeInterpreter.Reinitialize;
  except
   fByteCodeInterpreter:=nil;
   fIgnoreByteCodeInterpreter:=true;
  end;
 finally
 end;
 if fLastError<>VkTTF_TT_ERR_NoError then begin
  case fLastError of
   VkTTF_TT_ERR_InvalidFile:begin
    raise EVulkanTrueTypeFont.Create('Invalid font file');
   end;
   VkTTF_TT_ERR_CorruptFile:begin
    raise EVulkanTrueTypeFont.Create('Corrupt font file');
   end;
   VkTTF_TT_ERR_OutOfMemory:begin
    raise EVulkanTrueTypeFont.Create('Out of memory');
   end;
   VkTTF_TT_ERR_TableNotFound:begin
    raise EVulkanTrueTypeFont.Create('Font table not found');
   end;
   VkTTF_TT_ERR_NoCharacterMapFound:begin
    raise EVulkanTrueTypeFont.Create('No character map found');
   end;
   VkTTF_TT_ERR_UnknownCharacterMapFormat:begin
    raise EVulkanTrueTypeFont.Create('Unknown character map format');
   end;
   VkTTF_TT_ERR_CharacterMapNotPresent:begin
    raise EVulkanTrueTypeFont.Create('Character map not present');
   end;
   VkTTF_TT_ERR_UnableToOpenFile:begin
    raise EVulkanTrueTypeFont.Create('Unable to open file');
   end;
   VkTTF_TT_ERR_UnknownKerningFormat:begin
    raise EVulkanTrueTypeFont.Create('Unknown kerning format');
   end;
   VkTTF_TT_ERR_OutOfBounds:begin
    raise EVulkanTrueTypeFont.Create('Out of bounds');
   end;
   else begin
    raise EVulkanTrueTypeFont.Create('Unknown font error');
   end;
  end;
 end;
end;

destructor TVulkanTrueTypeFont.Destroy;
var i:TVkInt32;
begin
 SetLength(fByteCodeInterpreterParameters.pCurrent,0);
 SetLength(fByteCodeInterpreterParameters.pUnhinted,0);
 SetLength(fByteCodeInterpreterParameters.pInFontUnits,0);
 SetLength(fByteCodeInterpreterParameters.Ends,0);
 FreeAndNil(fByteCodeInterpreter);
 for i:=0 to length(fGlyphs)-1 do begin
  SetLength(fGlyphs[i].Points,0);
  SetLength(fGlyphs[i].EndPointIndices,0);
  SetLength(fGlyphs[i].CompositeSubGlyphs,0);
 end;
 SetLength(fGlyphs,0);
 SetLength(fFontData,0);
 fCMaps[0]:=nil;
 fCMaps[1]:=nil;
 SetLength(fGlyphOffsetArray,0);
 for i:=0 to length(fKerningTables)-1 do begin
  SetLength(fKerningTables[i].KerningPairs,0);
 end;
 SetLength(fCVT,0);
 SetLength(fKerningTables,0);
 SetLength(fGlyphLoadedBitmap,0);
 SetLength(fGASPRanges,0);
 SetLength(fPolygonBuffer.Commands,0);
 SetLength(fGlyphBuffer.Points,0);
 SetLength(fGlyphBuffer.UnhintedPoints,0);
 SetLength(fGlyphBuffer.InFontUnitsPoints,0);
 SetLength(fGlyphBuffer.EndPointIndices,0);
 inherited Destroy;
end;

procedure TVulkanTrueTypeFont.SetSize(NewSize:TVkInt32);
begin
 if fSize<>NewSize then begin
  fSize:=NewSize;
  if assigned(fByteCodeInterpreter) and not fIgnoreByteCodeInterpreter then begin
   try
    fByteCodeInterpreter.Reinitialize;
   except
    fByteCodeInterpreter:=nil;
    fIgnoreByteCodeInterpreter:=true;
   end;
  end;
 end;
end;

function TVulkanTrueTypeFont.ReadFontData(Stream:TStream;CollectionIndex:TVkInt32):TVkInt32;
var i,tablelength,tabledirsize,tabledatasize:TVkInt32;
    tfd:array[0..VkTTF_OFFSET_TABLE_SIZE-1] of TVkUInt8;
    TableDirectory:array of TVkUInt8;
    i64:TVkInt64;
begin
 if (not assigned(Stream)) or (Stream.Seek(0,soBeginning)<>0) then begin
  result:=VkTTF_TT_ERR_UnableToOpenFile;
  exit;
 end;

 if Stream.Read(tfd,VkTTF_OFFSET_TABLE_SIZE)<>VkTTF_OFFSET_TABLE_SIZE then begin
  result:=VkTTF_TT_ERR_CorruptFile;
  exit;
 end;

 if ((tfd[0]=ord('t')) and (tfd[1]=ord('t')) and (tfd[2]=ord('c')) and (tfd[3]=ord('f'))) and
    ((tfd[4]=$00) or (tfd[5] in [$01,$02]) or (tfd[6]=$00) or (tfd[7]=$00)) then begin
  i:=CollectionIndex;
  if TVkUInt32(i+0)>=ToLONGWORD(tfd[8],tfd[9],tfd[10],tfd[11]) then begin
   result:=VkTTF_TT_ERR_InvalidFile;
   exit;
  end;
  if Stream.Seek(12+(i*14),soBeginning)<>(12+(i*14)) then begin
   result:=VkTTF_TT_ERR_CorruptFile;
   exit;
  end;
  if Stream.Read(tfd,4)<>4 then begin
   result:=VkTTF_TT_ERR_CorruptFile;
   exit;
  end;
  i64:=ToLONGWORD(tfd[0],tfd[1],tfd[2],tfd[3]);
  if Stream.Seek(i64,soBeginning)<>i64 then begin
   result:=VkTTF_TT_ERR_CorruptFile;
   exit;
  end;
  if Stream.Read(tfd,VkTTF_OFFSET_TABLE_SIZE)<>VkTTF_OFFSET_TABLE_SIZE then begin
   result:=VkTTF_TT_ERR_CorruptFile;
   exit;
  end;
 end;

 if ((tfd[0]=ord('1')) and (tfd[1]=$00) and (tfd[2]=$00) and (tfd[3]=$00)) or                         // 1\x00\x00\x00    - TrueType 1
    ((tfd[0]=$00) and (tfd[1]=$01) and (tfd[2]=$00) and (tfd[3]=$00)) or                              // \x00\x01\x00\x00 - OpenType 1.0
    ((tfd[0]=ord('t')) and (tfd[1]=ord('y')) and (tfd[2]=ord('p')) and (tfd[3]=ord('1'))) or          // typ1             - TrueType with type 1 font data (but type 1 stuff is not supported here!) 
    ((tfd[0]=ord('t')) and (tfd[1]=ord('r')) and (tfd[2]=ord('u')) and (tfd[3]=ord('e'))) or          // true             - TrueType
    ((tfd[0]=ord('O')) and (tfd[1]=ord('T')) and (tfd[2]=ord('T')) and (tfd[3]=ord('O'))) then begin  // OTTO             - OpenType with CFF

  fNumTables:=ToWORD(tfd[4],tfd[5]); // Get the number of Tables in this font
  tabledirsize:=sizeof(TVkUInt32)*4*fNumTables; // Calculate Size of Table Directory
  TableDirectory:=nil;
  SetLength(TableDirectory,tabledirsize);              // Allocate storage for Table Directory
  if length(TableDirectory)<>tabledirsize then begin
   result:=VkTTF_TT_ERR_OutOfMemory;
   exit;
  end;

  tabledatasize:=0;
  i:=0;
  while i<tabledirsize do begin
   if Stream.Read(TableDirectory[i],16)<>16 then begin
    SetLength(TableDirectory,0);
    result:=VkTTF_TT_ERR_CorruptFile;
    exit;
   end;
   tablelength:=ToLONGWORD(TableDirectory[i+12],TableDirectory[i+13],TableDirectory[i+14],TableDirectory[i+15]);
   if (tablelength and 3)<>0 then begin
    inc(tablelength,4-(tablelength and 3));
   end;
   inc(tabledatasize,tablelength);
   inc(i,16);
  end;

  fFontDataSize:=VkTTF_OFFSET_TABLE_SIZE+tabledirsize+tabledatasize; // Calculate Size of entire font file
  SetLength(fFontData,fFontDataSize); // Allocate space for all that Data
  if length(fFontData)<>fFontDataSize then begin
   SetLength(TableDirectory,0);
   result:=VkTTF_TT_ERR_OutOfMemory;
   exit;
  end;
  FillChar(fFontData[0],fFontDataSize,#0);

  Move(tfd[0],fFontData[0],VkTTF_OFFSET_TABLE_SIZE); // Store the Offset Table
  Move(TableDirectory[0],fFontData[VkTTF_OFFSET_TABLE_SIZE],tabledirsize); // Store the Offset Table
  if Stream.Read(fFontData[VkTTF_OFFSET_TABLE_SIZE+tabledirsize],(fFontDataSize-(VkTTF_OFFSET_TABLE_SIZE+tabledirsize)))<>((fFontDataSize-(VkTTF_OFFSET_TABLE_SIZE+tabledirsize))) then begin // Store the rest of the font
   // Some TTF files are shorter than they must be? So this is commented out:
 { SetLength(TableDirectory,0);
   SetLength(fFontData,0);
   fFontDataSize:=0;
   result:=VkTTF_TT_ERR_OutOfMemory;
   exit;}
  end;

  SetLength(TableDirectory,0);

  result:=VkTTF_TT_ERR_NoError;

 end else begin

  result:=VkTTF_TT_ERR_CorruptFile;

 end;
end;

function TVulkanTrueTypeFont.GetTableDirEntry(Tag:TVkUInt32;var CheckSum,Offset,Size:TVkUInt32):TVkInt32;
var i:TVkInt32;
    Position,CurrentTag:TVkUInt32;
    Found:boolean;
begin
 Position:=VkTTF_OFFSET_TABLE_SIZE;
 Found:=false;
 for i:=0 to fNumTables-1 do begin
  CurrentTag:=ToLONGWORD(fFontData[Position],fFontData[Position+1],fFontData[Position+2],fFontData[Position+3]);
  if CurrentTag=Tag then begin
   CheckSum:=ToLONGWORD(fFontData[Position+4],fFontData[Position+5],fFontData[Position+6],fFontData[Position+7]);
   Offset:=ToLONGWORD(fFontData[Position+8],fFontData[Position+9],fFontData[Position+10],fFontData[Position+11]);
   Size:=ToLONGWORD(fFontData[Position+12],fFontData[Position+13],fFontData[Position+14],fFontData[Position+15]);
   Found:=true;
   break;
  end;
  inc(Position,16);
 end;
 if Found then begin
  result:=VkTTF_TT_ERR_NoError;
 end else begin
  result:=VkTTF_TT_ERR_TableNotFound;
 end;
end;

function TVulkanTrueTypeFont.LoadOS2:TVkInt32;
var Position,Tag,CheckSum,Offset,Size,Version:TVkUInt32;
begin
 Tag:=ToLONGWORD(TVkUInt8('O'),TVkUInt8('S'),TVkUInt8('/'),TVkUInt8('2'));
 result:=GetTableDirEntry(Tag,CheckSum,Offset,Size);
 if result=VkTTF_TT_Err_NoError then begin
  Position:=Offset;
  Version:=ToWORD(fFontData[Position],fFontData[Position+1]);
  inc(Position,sizeof(TVkUInt16));
  if Version<4 then begin
   inc(Position,sizeof(TVkUInt16)); // avg char width
   inc(Position,sizeof(TVkUInt16)); // weight class
   inc(Position,sizeof(TVkUInt16)); // width class
   inc(Position,sizeof(TVkUInt16)); // fs type
   inc(Position,sizeof(TVkUInt16)); // subscript x size
   inc(Position,sizeof(TVkUInt16)); // subscript y size
   inc(Position,sizeof(TVkUInt16)); // subscript x offset
   inc(Position,sizeof(TVkUInt16)); // subscript y offset
   inc(Position,sizeof(TVkUInt16)); // superscript x size
   inc(Position,sizeof(TVkUInt16)); // superscript y size
   inc(Position,sizeof(TVkUInt16)); // superscript x offset
   inc(Position,sizeof(TVkUInt16)); // superscript y offset
   inc(Position,sizeof(TVkUInt16)); // strikeout size
   inc(Position,sizeof(TVkUInt16)); // strikeout offset
   inc(Position,sizeof(TVkUInt16)); // family class
   inc(Position,10); // panose
   inc(Position,sizeof(TVkUInt32)); // unicode range 1
   inc(Position,sizeof(TVkUInt32)); // unicode range 2
   inc(Position,sizeof(TVkUInt32)); // unicode range 3
   inc(Position,sizeof(TVkUInt32)); // unicode range 4
   inc(Position,sizeof(TVkUInt16)); // fs selection
   inc(Position,sizeof(TVkUInt16)); // first char index
   inc(Position,sizeof(TVkUInt16)); // last char index
   inc(Position,sizeof(TVkUInt16)); // typo ascender
   inc(Position,sizeof(TVkUInt16)); // typo descender
   inc(Position,sizeof(TVkUInt16)); // typo line gap
   inc(Position,sizeof(TVkUInt16)); // win ascent
   inc(Position,sizeof(TVkUInt16)); // win descent
   if Version>0 then begin
    inc(Position,sizeof(TVkUInt32)); // ulCodePageRange1
    inc(Position,sizeof(TVkUInt32)); // ulCodePageRange2
    if Version>1 then begin
     inc(Position,sizeof(TVkUInt16)); // x height
     inc(Position,sizeof(TVkUInt16)); // cap height
     inc(Position,sizeof(TVkUInt16)); // default char
     inc(Position,sizeof(TVkUInt16)); // break char
     inc(Position,sizeof(TVkUInt16)); // max context
    end;
   end;
   if Position<>0 then begin
   end;
   result:=VkTTF_TT_ERR_NoError;
  end else begin
   result:=VkTTF_TT_ERR_InvalidFile;
  end;
 end;
end;

function TVulkanTrueTypeFont.LoadHEAD:TVkInt32;
var Position,Tag,CheckSum,Offset,Size,MagicNumber:TVkUInt32;
begin
 Tag:=ToLONGWORD(TVkUInt8('h'),TVkUInt8('e'),TVkUInt8('a'),TVkUInt8('d'));
 result:=GetTableDirEntry(Tag,CheckSum,Offset,Size);
 if result=VkTTF_TT_Err_NoError then begin
  Position:=Offset;
  inc(Position,sizeof(TVkUInt32)); // Table version number
  inc(Position,sizeof(TVkUInt32)); // Font revision number
  inc(Position,sizeof(TVkUInt32)); // CheckSum adjustment
  MagicNumber:=ToLONGWORD(fFontData[Position],fFontData[Position+1],fFontData[Position+2],fFontData[Position+3]);
  inc(Position,sizeof(TVkUInt32)); // Magic number
  if MagicNumber<>$5f0f3cf5 then begin
   result:=VkTTF_TT_ERR_InvalidFile;
   exit;
  end;
  inc(Position,sizeof(TVkUInt16)); // Flags
  fUnitsPerEm:=ToWORD(fFontData[Position],fFontData[Position+1]);
  inc(Position,sizeof(TVkUInt16));
  inc(Position,8); // Date created
  inc(Position,8); // Date modified
  fMinX:=ToSMALLINT(fFontData[Position],fFontData[Position+1]);
  inc(Position,sizeof(TVkInt16));
  fMinY:=ToSMALLINT(fFontData[Position],fFontData[Position+1]);
  inc(Position,sizeof(TVkInt16));
  fMaxX:=ToSMALLINT(fFontData[Position],fFontData[Position+1]);
  inc(Position,sizeof(TVkInt16));
  fMaxY:=ToSMALLINT(fFontData[Position],fFontData[Position+1]);
  inc(Position,sizeof(TVkInt16));
  inc(Position,sizeof(TVkUInt16)); // Mac-style
  inc(Position,sizeof(TVkUInt16)); // Lowest rec pen
  inc(Position,sizeof(TVkInt16)); // Font direction hint
  fIndexToLocationFormat:=ToSMALLINT(fFontData[Position],fFontData[Position+1]);
//inc(Position,sizeof(TVkInt16));
  if fUnitsPerEm=0 then begin
   fUnitsPerEm:=1;
  end;
//fUnitsPerPixel:=fMaxY-fMinY;
  fUnitsPerPixel:=SARLongint(fUnitsPerEm,1);
  if fUnitsPerPixel=0 then begin
   fUnitsPerPixel:=1;
  end;
  fThinBoldStrength:=SARLongint(fUnitsPerEm,4);
  result:=VkTTF_TT_ERR_NoError;
 end;
end;

function TVulkanTrueTypeFont.LoadMAXP:TVkInt32;
var Tag,CheckSum,Offset,Size:TVkUInt32;
    i:TVkInt32;
begin
 Tag:=ToLONGWORD(TVkUInt8('m'),TVkUInt8('a'),TVkUInt8('x'),TVkUInt8('p'));
 result:=GetTableDirEntry(Tag,CheckSum,Offset,Size);
 if result=VkTTF_TT_Err_NoError then begin
  fCountGlyphs:=ToWORD(fFontData[Offset+4],fFontData[Offset+5]);
  fMaxTwilightPoints:=ToWORD(fFontData[Offset+16],fFontData[Offset+17]);
  fMaxStorage:=ToWORD(fFontData[Offset+18],fFontData[Offset+19]);
  fMaxFunctionDefs:=ToWORD(fFontData[Offset+20],fFontData[Offset+21]);
  fMaxStackElements:=ToWORD(fFontData[Offset+24],fFontData[Offset+25]);
  SetLength(fGlyphs,fCountGlyphs);
  if length(fGlyphs)<>fCountGlyphs then begin
   result:=VkTTF_TT_ERR_OutOfMemory;
   exit;
  end;
  for i:=0 to fCountGlyphs-1 do begin
   FillChar(fGlyphs[i],sizeof(TVulkanTrueTypeFontGlyph),#0);
  end;
  SetLength(fGlyphLoadedBitmap,(fCountGlyphs+31) shr 3);
  if length(fGlyphLoadedBitmap)<>((fCountGlyphs+31) shr 3) then begin
   result:=VkTTF_TT_ERR_OutOfMemory;
   exit;
  end;
  for i:=0 to length(fGlyphLoadedBitmap)-1 do begin
   fGlyphLoadedBitmap[i]:=0;
  end;
  result:=VkTTF_TT_ERR_NoError;
 end;
end;

function TVulkanTrueTypeFont.LoadNAME:TVkInt32;
type PVulkanRawByteString=^TVulkanRawByteString;
var Position,Tag,CheckSum,Offset,Size,NumNameRecords,StringStorageOffset,i,j,c,c2,o:TVkUInt32;
    ThisPlatformID,ThisSpecificID,ThisLanguageID,ThisNameID,ThisStringLength,ThisStringOffset:TVkUInt16;
    NameFound:boolean;
    u8s:PVulkanRawByteString;
    s:TVulkanRawByteString;
    si,sl:TVkInt32;
begin
 Tag:=ToLONGWORD(TVkUInt8('n'),TVkUInt8('a'),TVkUInt8('m'),TVkUInt8('e'));
 result:=GetTableDirEntry(Tag,CheckSum,Offset,Size);
 if result=VkTTF_TT_Err_NoError then begin
  Position:=Offset;
  inc(Position,sizeof(TVkUInt16)); // Format Selector
  NumNameRecords:=ToWORD(fFontData[Position],fFontData[Position+1]);
  inc(Position,sizeof(TVkUInt16));
  StringStorageOffset:=ToWORD(fFontData[Position],fFontData[Position+1])+Offset;
  inc(Position,sizeof(TVkUInt16));
  for i:=1 to NumNameRecords do begin
   ThisPlatformID:=ToWORD(fFontData[Position],fFontData[Position+1]);
   inc(Position,sizeof(TVkUInt16));
   ThisSpecificID:=ToWORD(fFontData[Position],fFontData[Position+1]);
   inc(Position,sizeof(TVkUInt16));
   ThisLanguageID:=ToWORD(fFontData[Position],fFontData[Position+1]);
   inc(Position,sizeof(TVkUInt16));
   ThisNameID:=ToWORD(fFontData[Position],fFontData[Position+1]);
   inc(Position,sizeof(TVkUInt16));
   ThisStringLength:=ToWORD(fFontData[Position],fFontData[Position+1]);
   inc(Position,sizeof(TVkUInt16));
   ThisStringOffset:=ToWORD(fFontData[Position],fFontData[Position+1]);
   inc(Position,sizeof(TVkUInt16));
   if (ThisPlatformID=fPlatformID) and (ThisSpecificID=fSpecificID) and (ThisLanguageID=fLanguageID) then begin
    NameFound:=false;
    u8s:=nil;
    case ThisNameID of
     VkTTF_NID_Copyright:begin
      NameFound:=true;
      u8s:=@fStringCopyright;
     end;
     VkTTF_NID_Family:begin
      NameFound:=true;
      u8s:=@fStringFamily;
     end;
     VkTTF_NID_Subfamily:begin
      NameFound:=true;
      u8s:=@fStringSubFamily;
     end;
     VkTTF_NID_UniqueID:begin
      NameFound:=true;
      u8s:=@fStringUniqueID;
     end;
     VkTTF_NID_FullName:begin
      NameFound:=true;
      u8s:=@fStringFullName;
     end;
     VkTTF_NID_Version:begin
      NameFound:=true;
      u8s:=@fStringVersion;
     end;
     VkTTF_NID_PostscriptName:begin
      NameFound:=true;
      u8s:=@fStringPostScript;
     end;
     VkTTF_NID_Trademark:begin
      NameFound:=true;
      u8s:=@fStringTrademark;
     end;
    end;
    if NameFound then begin
     case ThisPlatformID of
      VkTTF_PID_Microsoft:begin
       s:='';
       SetLength(s,ThisStringLength*2);
       if length(s)<>(ThisStringLength*2) then begin
        result:=VkTTF_TT_ERR_OutOfMemory;
        exit;
       end;
       j:=0;
       o:=StringStorageOffset+ThisStringOffset;
       si:=0;
       while j<ThisStringLength do begin
        c:=ToWORD(fFontData[o],fFontData[o+1]);
        inc(j,2);
        inc(o,2);
        if ((c and $fc00)=$d800) and (j<ThisStringLength) then begin
         c2:=ToWORD(fFontData[o],fFontData[o+1]);
         if (c2 and $fc00)=$dc00 then begin
          c:=(((c and $3ff) shl 10) or (c2 and $3ff))+$10000;
          inc(j,2);
          inc(o,2);
         end;
        end;
        sl:=VulkanUTF32CharToUTF8At(c,s,si+1);
        inc(si,sl);
       end;
       SetLength(s,si);
       u8s^:=s;
       s:='';
      end;
      else begin
       s:='';
       SetLength(s,ThisStringLength);
       if length(s)<>ThisStringLength then begin
        result:=VkTTF_TT_ERR_OutOfMemory;
        exit;
       end;
       Move(fFontData[StringStorageOffset+ThisStringOffset],s[1],ThisStringLength);
       u8s^:=VulkanUTF8Correct(s);
       s:='';
      end;
     end;
    end;
   end;
  end;
  result:=VkTTF_TT_ERR_NoError;
 end;
end;

function TVulkanTrueTypeFont.LoadCFF:TVkInt32;
type TIndexData=array of TVkInt32;
var Position,Tag,CheckSum,Offset,Size,EndOffset:TVkUInt32;
    HeaderFormatMajor,HeaderFormatMinor,HeaderSize,HeaderOffsetSize,
    HeaderStartOffset,HeaderEndOffset:TVkInt32;
    NameIndexData,TopDictIndexData,StringIndexData,
    GlobalSubroutineIndexData:TIndexData;
 function LoadIndex(out IndexData:TIndexData):TVkInt32;
 var Count:TVkInt32;
 begin
   if ((Position+SizeOf(TVkUInt16))-1)>=(Offset+Size) then begin
   result:=VkTTF_TT_ERR_CorruptFile;
   exit;
  end;
  Count:=ToWORD(fFontData[Position],fFontData[Position+1]);
  inc(Position,SizeOf(TVkUInt16));

  result:=VkTTF_TT_ERR_NoError;

 end;
begin
 Tag:=ToLONGWORD(TVkUInt8('C'),TVkUInt8('F'),TVkUInt8('F'),TVkUInt8(32));
 result:=GetTableDirEntry(Tag,CheckSum,Offset,Size);
 if result=VkTTF_TT_Err_NoError then begin

  Position:=Offset;

  EndOffset:=Offset+Size;

  if ((Position+SizeOf(TVkUInt8))-1)>=EndOffset then begin
   result:=VkTTF_TT_ERR_CorruptFile;
   exit;
  end;
  HeaderFormatMajor:=fFontData[Position];
  inc(Position,SizeOf(TVkUInt8));

  if ((Position+SizeOf(TVkUInt8))-1)>=EndOffset then begin
   result:=VkTTF_TT_ERR_CorruptFile;
   exit;
  end;
  HeaderFormatMinor:=fFontData[Position];
  inc(Position,SizeOf(TVkUInt8));

  if ((Position+SizeOf(TVkUInt8))-1)>=EndOffset then begin
   result:=VkTTF_TT_ERR_CorruptFile;
   exit;
  end;
  HeaderSize:=fFontData[Position];
  inc(Position,SizeOf(TVkUInt8));

  if ((Position+SizeOf(TVkUInt8))-1)>=EndOffset then begin
   result:=VkTTF_TT_ERR_CorruptFile;
   exit;
  end;
  HeaderOffsetSize:=fFontData[Position];
  inc(Position,SizeOf(TVkUInt8));

  Position:=Offset+HeaderSize;

  result:=LoadIndex(NameIndexData);
  if result<>VkTTF_TT_ERR_NoError then begin
   exit;
  end;

  result:=LoadIndex(TopDictIndexData);
  if result<>VkTTF_TT_ERR_NoError then begin
   exit;
  end;

  result:=LoadIndex(StringIndexData);
  if result<>VkTTF_TT_ERR_NoError then begin
   exit;
  end;

  result:=LoadIndex(GlobalSubroutineIndexData);
  if result<>VkTTF_TT_ERR_NoError then begin
   exit;
  end;

  result:=VkTTF_TT_ERR_NoError;

 end;
end;

function TVulkanTrueTypeFont.LoadLOCA:TVkInt32;
var Position,Tag,CheckSum,Offset,Size,thisOffset:TVkUInt32;
    i:TVkInt32;
begin
 Tag:=ToLONGWORD(TVkUInt8('l'),TVkUInt8('o'),TVkUInt8('c'),TVkUInt8('a'));
 result:=GetTableDirEntry(Tag,CheckSum,Offset,Size);
 if result=VkTTF_TT_Err_NoError then begin
  Position:=Offset;
  SetLength(fGlyphOffsetArray,fCountGlyphs+1);
  if length(fGlyphOffsetArray)<>(fCountGlyphs+1) then begin
   result:=VkTTF_TT_ERR_OutOfMemory;
   exit;
  end;
  thisOffset:=0;
  for i:=0 to fCountGlyphs do begin
   case fIndexToLocationFormat of
    0:begin
     thisOffset:=ToWORD(fFontData[Position],fFontData[Position+1])*2;
     inc(Position,sizeof(TVkUInt16));
    end;
    1:begin
     thisOffset:=ToLONGWORD(fFontData[Position],fFontData[Position+1],fFontData[Position+2],fFontData[Position+3]);
     inc(Position,sizeof(TVkUInt32));
    end;
    else begin
     result:=VkTTF_TT_ERR_CorruptFile;
     exit;
    end;
   end;
   fGlyphOffsetArray[i]:=thisOffset;
  end;
  result:=VkTTF_TT_ERR_NoError;
 end;
end;

function TVulkanTrueTypeFont.LoadGLYF:TVkInt32;
var Tag,CheckSum,Offset,Size:TVkUInt32;
begin
 Tag:=ToLONGWORD(TVkUInt8('g'),TVkUInt8('l'),TVkUInt8('y'),TVkUInt8('f'));
 result:=GetTableDirEntry(Tag,CheckSum,Offset,Size);
 if result=VkTTF_TT_Err_NoError then begin
  fGlyfOffset:=Offset;
  result:=VkTTF_TT_ERR_NoError;
 end;
end;

function TVulkanTrueTypeFont.LoadHHEA:TVkInt32;
var Position,Tag,CheckSum,Offset,Size:TVkUInt32;
begin
 Tag:=ToLONGWORD(TVkUInt8('h'),TVkUInt8('h'),TVkUInt8('e'),TVkUInt8('a'));
 result:=GetTableDirEntry(Tag,CheckSum,Offset,Size);
 if result<>VkTTF_TT_Err_NoError then begin
  Tag:=ToLONGWORD(TVkUInt8('v'),TVkUInt8('h'),TVkUInt8('e'),TVkUInt8('a'));
  result:=GetTableDirEntry(Tag,CheckSum,Offset,Size);
 end else begin
  Position:=Offset;
  inc(Position,sizeof(TVkUInt32)); // Table Version number
  fAscender:=ToSMALLINT(fFontData[Position],fFontData[Position+1]);
  inc(Position,sizeof(TVkInt16));
  fDescender:=ToSMALLINT(fFontData[Position],fFontData[Position+1]);
  inc(Position,sizeof(TVkInt16));
  fLineGap:=ToSMALLINT(fFontData[Position],fFontData[Position+1]);
  inc(Position,sizeof(TVkInt16));
  fAdvanceWidthMax:=ToWORD(fFontData[Position],fFontData[Position+1]);
  inc(Position,sizeof(TVkUInt16));
  inc(Position,sizeof(TVkInt16)); // MinLeftSideBearing
  inc(Position,sizeof(TVkInt16)); // MinRightSideBearing
  inc(Position,sizeof(TVkInt16)); // XMaxExtent
  inc(Position,sizeof(TVkInt16)); // CaretSlopeRise
  inc(Position,sizeof(TVkInt16)); // CaretSlopeRun
  inc(Position,sizeof(TVkUInt16)*5); // 5 reserved words
  inc(Position,sizeof(TVkInt16)); // MetricDataFormat
  fNumfHMetrics:=ToWORD(fFontData[Position],fFontData[Position+1]);
  result:=VkTTF_TT_ERR_NoError;
 end;
end;

function TVulkanTrueTypeFont.LoadHMTX:TVkInt32;
var Position,Tag,CheckSum,Offset,Size:TVkUInt32;
    i,j:TVkInt32;
begin
 Tag:=ToLONGWORD(TVkUInt8('h'),TVkUInt8('m'),TVkUInt8('t'),TVkUInt8('x'));
 result:=GetTableDirEntry(Tag,CheckSum,Offset,Size);
 if result<>VkTTF_TT_Err_NoError then begin
  Tag:=ToLONGWORD(TVkUInt8('v'),TVkUInt8('m'),TVkUInt8('t'),TVkUInt8('x'));
  result:=GetTableDirEntry(Tag,CheckSum,Offset,Size);
 end else begin
  Position:=Offset;
  i:=0;
  while i<fNumfHMetrics do begin
   fGlyphs[i].AdvanceWidth:=ToWORD(fFontData[Position],fFontData[Position+1]);
   inc(Position,sizeof(TVkUInt16));
   fGlyphs[i].LeftSideBearing:=ToSMALLINT(fFontData[Position],fFontData[Position+1]);
   inc(Position,sizeof(TVkInt16));
   inc(i);
  end;
  if fNumfHMetrics<>fCountGlyphs then begin
   j:=fGlyphs[i-1].AdvanceWidth;
   while i<fCountGlyphs do begin
    fGlyphs[i].AdvanceWidth:=j;
    fGlyphs[i].LeftSideBearing:=ToSMALLINT(fFontData[Position],fFontData[Position+1]);
    inc(Position,sizeof(TVkInt16));
    inc(i);
   end;
  end;
  result:=VkTTF_TT_ERR_NoError;
 end;
end;

function TVulkanTrueTypeFont.LoadVHEA:TVkInt32;
var Position,Tag,CheckSum,Offset,Size:TVkUInt32;
begin
 Tag:=ToLONGWORD(TVkUInt8('v'),TVkUInt8('h'),TVkUInt8('e'),TVkUInt8('a'));
 result:=GetTableDirEntry(Tag,CheckSum,Offset,Size);
 if result<>VkTTF_TT_Err_NoError then begin
  Tag:=ToLONGWORD(TVkUInt8('h'),TVkUInt8('h'),TVkUInt8('e'),TVkUInt8('a'));
  result:=GetTableDirEntry(Tag,CheckSum,Offset,Size);
 end else begin
  Position:=Offset;
  inc(Position,sizeof(TVkUInt32)); // Table Version number
  fAscender:=ToSMALLINT(fFontData[Position],fFontData[Position+1]);
  inc(Position,sizeof(TVkInt16));
  fDescender:=ToSMALLINT(fFontData[Position],fFontData[Position+1]);
  inc(Position,sizeof(TVkInt16));
  fLineGap:=ToSMALLINT(fFontData[Position],fFontData[Position+1]);
  inc(Position,sizeof(TVkInt16));
  fAdvanceHeightMax:=ToWORD(fFontData[Position],fFontData[Position+1]);
  inc(Position,sizeof(TVkUInt16));
  inc(Position,sizeof(TVkInt16)); // MinTopSideBearing
  inc(Position,sizeof(TVkInt16)); // MinBottomSideBearing
  inc(Position,sizeof(TVkInt16)); // YMaxExtent
  inc(Position,sizeof(TVkInt16)); // CaretSlopeRise
  inc(Position,sizeof(TVkInt16)); // CaretSlopeRun
  inc(Position,sizeof(TVkUInt16)*5); // 5 reserved words
  inc(Position,sizeof(TVkInt16)); // MetricDataFormat
  fNumfVMetrics:=ToWORD(fFontData[Position],fFontData[Position+1]);
  result:=VkTTF_TT_ERR_NoError;
 end;
end;

function TVulkanTrueTypeFont.LoadVMTX:TVkInt32;
var Position,Tag,CheckSum,Offset,Size:TVkUInt32;
    i,j:TVkInt32;
begin
 Tag:=ToLONGWORD(TVkUInt8('v'),TVkUInt8('m'),TVkUInt8('t'),TVkUInt8('x'));
 result:=GetTableDirEntry(Tag,CheckSum,Offset,Size);
 if result<>VkTTF_TT_Err_NoError then begin
  Tag:=ToLONGWORD(TVkUInt8('h'),TVkUInt8('m'),TVkUInt8('t'),TVkUInt8('x'));
  result:=GetTableDirEntry(Tag,CheckSum,Offset,Size);
 end else begin
  Position:=Offset;
  i:=0;
  while i<fNumfVMetrics do begin
   fGlyphs[i].AdvanceHeight:=ToWORD(fFontData[Position],fFontData[Position+1]);
   inc(Position,sizeof(TVkUInt16));
   fGlyphs[i].TopSideBearing:=ToSMALLINT(fFontData[Position],fFontData[Position+1]);
   inc(Position,sizeof(TVkInt16));
   inc(i);
  end;
  if fNumfVMetrics<>fCountGlyphs then begin
   j:=fGlyphs[i-1].AdvanceHeight;
   while i<fCountGlyphs do begin
    fGlyphs[i].AdvanceWidth:=j;
    fGlyphs[i].TopSideBearing:=ToSMALLINT(fFontData[Position],fFontData[Position+1]);
    inc(Position,sizeof(TVkInt16));
    inc(i);
   end;
  end;
  result:=VkTTF_TT_ERR_NoError;
 end;
end;

function TVulkanTrueTypeFont.LoadGPOS:TVkInt32;
type PGlyphs=^TGlyphs;
     TGlyphs=record
      Count:TVkInt32;
      Items:array of TVkInt32;
     end;
     TGlyphsByClass=array of TGlyphs;
var Position,Tag,CheckSum,Offset,Size,Next:TVkUInt32;
    MajorVersion,MinorVersion,
    FeatureVariations,LookupType,LookupFlags,
    i,j,k,h,BaseOffset,ScriptListOffset,
    FeatureListOffset,LookupListOffset,LookupListCount,
    LookupTableOffset,SubTableCount,SubTableOffset:TVkInt32;
 function LoadSubTable(const LookupType,SubTableOffset:TVkInt32):TVkInt32;
 var GlyphArray:array of TVkUInt32;
  function LoadCoverageTable(const CoverageOffset:TVkInt32):TVkInt32;
  var CoverageFormat,CurrentPosition:TVkUInt32;
      k,h,GlyphCount,RangeCount,StartIndex,EndIndex:TVkInt32;
      GlyphInt64HashMap:TVulkanInt64HashMap;
  begin

   CoverageFormat:=ToWORD(fFontData[CoverageOffset+0],fFontData[CoverageOffset+1]);

   GlyphCount:=0;

   case CoverageFormat of
    1:begin
     GlyphCount:=ToWORD(fFontData[CoverageOffset+2],fFontData[CoverageOffset+3]);
     SetLength(GlyphArray,GlyphCount);
     for k:=0 to GlyphCount-1 do begin
      GlyphArray[k]:=ToWORD(fFontData[CoverageOffset+4+(k*2)],fFontData[CoverageOffset+5+(k*2)]);
     end;
    end;
    2:begin
     RangeCount:=ToWORD(fFontData[CoverageOffset+2],fFontData[CoverageOffset+3]);
     try
      GlyphInt64HashMap:=TVulkanInt64HashMap.Create;
      try
       CurrentPosition:=CoverageOffset+4;
       for k:=0 to RangeCount-1 do begin
        StartIndex:=ToWORD(fFontData[CurrentPosition+0],fFontData[CurrentPosition+1]);
        EndIndex:=ToWORD(fFontData[CurrentPosition+2],fFontData[CurrentPosition+3]);
        inc(CurrentPosition,6);
        for h:=StartIndex to EndIndex do begin
         if not GlyphInt64HashMap.ExistKey(h) then begin
          GlyphInt64HashMap.Add(h,nil);
          if length(GlyphArray)<(GlyphCount+1) then begin
           SetLength(GlyphArray,(GlyphCount+1)*2);
          end;
          GlyphArray[GlyphCount]:=h;
          inc(GlyphCount);
         end;
        end;
       end;
      finally
       GlyphInt64HashMap.Free;
      end;
     finally
      SetLength(GlyphArray,GlyphCount);
     end;
    end;
    else begin
     result:=VkTTF_TT_ERR_UnknownGPOSFormat;
     exit;
    end;
   end;

   result:=VkTTF_TT_Err_NoError;

  end;
  function LoadClassDefinition(Offset:TVkInt32;const ClassCount:TVkInt32;var GlyphsByClass:TGlyphsByClass):TVkInt32;
  var ClassFormat,StartGlyph,GlyphCount,i,Glyph,GlyphClass,ClassRangeCount,StartIndex,EndIndex:TVkInt32;
      Glyphs:PGlyphs;
  begin
   GlyphsByClass:=nil;
   try
    SetLength(GlyphsByClass,ClassCount);
    for i:=0 to ClassCount-1 do begin
     GlyphsByClass[i].Count:=0;
     GlyphsByClass[i].Items:=nil;
    end;
    ClassFormat:=ToWORD(fFontData[Offset+0],fFontData[Offset+1]);
    inc(Offset,2);
    case ClassFormat of
     1:begin
      StartGlyph:=ToWORD(fFontData[Offset+0],fFontData[Offset+1]);
      inc(Offset,2);
      GlyphCount:=ToWORD(fFontData[Offset+0],fFontData[Offset+1]);
      inc(Offset,2);
      for i:=0 to GlyphCount-1 do begin
       Glyph:=StartGlyph+i;
       GlyphClass:=ToWORD(fFontData[Offset+0],fFontData[Offset+1]);
       inc(Offset,2);
       Glyphs:=@GlyphsByClass[GlyphClass];
       if length(Glyphs^.Items)<(Glyphs^.Count+1) then begin
        SetLength(Glyphs^.Items,(Glyphs^.Count+1)*2);
       end;
       Glyphs^.Items[Glyphs^.Count]:=Glyph;
       inc(Glyphs^.Count);
      end;
     end;
     2:begin
      ClassRangeCount:=ToWORD(fFontData[Offset+0],fFontData[Offset+1]);
      inc(Offset,2);
      for i:=0 to ClassRangeCount-1 do begin
       StartIndex:=ToWORD(fFontData[Offset+0],fFontData[Offset+1]);
       inc(Offset,2);
       EndIndex:=ToWORD(fFontData[Offset+0],fFontData[Offset+1]);
       inc(Offset,2);
       GlyphClass:=ToWORD(fFontData[Offset+0],fFontData[Offset+1]);
       inc(Offset,2);
       for Glyph:=StartIndex to EndIndex do begin
        Glyphs:=@GlyphsByClass[GlyphClass];
        if length(Glyphs^.Items)<(Glyphs^.Count+1) then begin
         SetLength(Glyphs^.Items,(Glyphs^.Count+1)*2);
        end;
        Glyphs^.Items[Glyphs^.Count]:=Glyph;
        inc(Glyphs^.Count);
       end;
      end;
     end;
     else begin
      result:=VkTTF_TT_ERR_UnknownGPOSFormat;
      exit;
     end;
    end;
   finally
   end;
   result:=VkTTF_TT_Err_NoError;
  end;
  function ReadValueFromValueRecord(var Offset:TVkInt32;const ValueFormat,TargetMask:TVkInt32):TVkInt32;
  var Mask,Value:TVkInt32;
  begin
   result:=0;
   Mask:=1;
   while (Mask<=$8000) and (Mask<=ValueFormat) do begin
    Value:=ToSMALLINT(fFontData[Offset+0],fFontData[Offset+1]);
    inc(Offset,2);
    if Mask=TargetMask then begin
     result:=Value;
    end;
    Mask:=Mask shl 1;
   end;
  end;
  procedure AddKerningPair(const FirstGlyph,SecondGlyph,Value:TVkInt32;const Horizontal:boolean);
  var i:TVkInt32;
      KerningTable:PVulkanTrueTypeFontKerningTable;
      KerningPair:PVulkanTrueTypeFontKerningPair;
  begin
   KerningTable:=nil;
   for i:=0 to length(fKerningTables)-1 do begin
    if fKerningTables[i].Horizontal=Horizontal then begin
     KerningTable:=@fKerningTables[i];
     break;
    end;
   end;
   if not assigned(KerningTable) then begin
    i:=length(fKerningTables);
    SetLength(fKerningTables,i+1);
    KerningTable:=@fKerningTables[i];
    KerningTable^.Horizontal:=Horizontal;
    KerningTable^.Minimum:=false;
    KerningTable^.XStream:=not Horizontal;
    KerningTable^.ValueOverride:=true;
    KerningTable^.BinarySearch:=false;
    KerningTable^.KerningPairs:=nil;
    KerningTable^.CountKerningPairs:=0;
   end;
   i:=KerningTable^.CountKerningPairs;
   inc(KerningTable^.CountKerningPairs);
   if length(KerningTable^.KerningPairs)<KerningTable^.CountKerningPairs then begin
    SetLength(KerningTable^.KerningPairs,KerningTable^.CountKerningPairs*2);
   end;
   KerningPair:=@KerningTable^.KerningPairs[i];
   KerningPair^.Left:=FirstGlyph;
   KerningPair^.Right:=SecondGlyph;
   KerningPair^.Value:=Value;
  end;
 var i,j,k,h,SubTableType,CoverageOffset,ValueFormat1,ValueFormat2,PairSetCount,
     PairSetTableOffset,FirstGlyph,SecondGlyph,CurrentPosition,
     x,ClassDefOffset1,ClassDefOffset2,Class1Count,Class2Count,
     PairValueCount,NewLookupType,Glyph:TVkInt32;
     GlyphsByClass1,GlyphsByClass2:TGlyphsByClass;
     Found:boolean;
     Glyphs1,Glyphs2:PGlyphs;
 begin

  case LookupType of
   2:begin

    // Pair adjustment subtable

    SubTableType:=ToWORD(fFontData[SubTableOffset+0],fFontData[SubTableOffset+1]);

    case SubTableType of
     1:begin

      // Format 1

      CoverageOffset:=SubTableOffset+ToWORD(fFontData[SubTableOffset+2],fFontData[SubTableOffset+3]);
      ValueFormat1:=ToWORD(fFontData[SubTableOffset+4],fFontData[SubTableOffset+5]);
      ValueFormat2:=ToWORD(fFontData[SubTableOffset+6],fFontData[SubTableOffset+7]);
      PairSetCount:=ToWORD(fFontData[SubTableOffset+8],fFontData[SubTableOffset+9]);
      PairSetTableOffset:=SubTableOffset+10;

      GlyphArray:=nil;
      try

       result:=LoadCoverageTable(CoverageOffset);
       if result<>VkTTF_TT_Err_NoError then begin
        exit;
       end;

       PairSetCount:=Min(PairSetCount,length(GlyphArray));

       for k:=0 to PairSetCount-1 do begin
        FirstGlyph:=GlyphArray[k];
        CurrentPosition:=SubTableOffset+ToWORD(fFontData[PairSetTableOffset+0+(k*2)],fFontData[PairSetTableOffset+1+(k*2)]);
        PairValueCount:=ToWORD(fFontData[CurrentPosition+0],fFontData[CurrentPosition+1]);
        inc(CurrentPosition,2);
        for h:=0 to PairValueCount-1 do begin
         SecondGlyph:=ToWORD(fFontData[CurrentPosition+0],fFontData[CurrentPosition+1]);
         inc(CurrentPosition,2);
         x:=ReadValueFromValueRecord(CurrentPosition,ValueFormat1,$0004);
         ReadValueFromValueRecord(CurrentPosition,ValueFormat2,$0004);
         AddKerningPair(FirstGlyph,SecondGlyph,x,true);
        end;
       end;

      finally
       GlyphArray:=nil;
      end;

     end;
     2:begin

      // Format 2

      CoverageOffset:=SubTableOffset+ToWORD(fFontData[SubTableOffset+2],fFontData[SubTableOffset+3]);
      ValueFormat1:=ToWORD(fFontData[SubTableOffset+4],fFontData[SubTableOffset+5]);
      ValueFormat2:=ToWORD(fFontData[SubTableOffset+6],fFontData[SubTableOffset+7]);
      ClassDefOffset1:=ToWORD(fFontData[SubTableOffset+8],fFontData[SubTableOffset+9]);
      ClassDefOffset2:=ToWORD(fFontData[SubTableOffset+10],fFontData[SubTableOffset+11]);
      Class1Count:=ToWORD(fFontData[SubTableOffset+12],fFontData[SubTableOffset+13]);
      Class2Count:=ToWORD(fFontData[SubTableOffset+14],fFontData[SubTableOffset+15]);

      GlyphArray:=nil;
      try

       result:=LoadCoverageTable(CoverageOffset);
       if result<>VkTTF_TT_Err_NoError then begin
        exit;
       end;

       GlyphsByClass1:=nil;
       try

        GlyphsByClass2:=nil;
        try

         result:=LoadClassDefinition(SubTableOffset+ClassDefOffset1,Class1Count,GlyphsByClass1);
         if result<>VkTTF_TT_Err_NoError then begin
          exit;
         end;

         result:=LoadClassDefinition(SubTableOffset+ClassDefOffset2,Class2Count,GlyphsByClass2);
         if result<>VkTTF_TT_Err_NoError then begin
          exit;
         end;

         for i:=0 to length(GlyphArray)-1 do begin
          Glyph:=GlyphArray[i];
          Found:=false;
          for j:=1 to Class1Count-1 do begin
           Glyphs1:=@GlyphsByClass1[j];
           for k:=0 to Glyphs1^.Count-1 do begin
            if Glyphs1^.Items[k]=Glyph then begin
             Found:=true;
             break;
            end;
           end;
           if Found then begin
            break;
           end;
          end;
          if not Found then begin
           Glyphs1:=@GlyphsByClass1[0];
           if length(Glyphs1^.Items)<(Glyphs1^.Count+1) then begin
            SetLength(Glyphs1^.Items,(Glyphs1^.Count+1)*2);
           end;
           Glyphs1^.Items[Glyphs1^.Count]:=Glyph;
           inc(Glyphs1^.Count);
          end;
         end;

         CurrentPosition:=SubTableOffset+16;

         for i:=0 to Class1Count-1 do begin
          for j:=0 to Class2Count-1 do begin
           x:=ReadValueFromValueRecord(CurrentPosition,ValueFormat1,$0004);
           ReadValueFromValueRecord(CurrentPosition,ValueFormat2,$0004);
           if x<>0 then begin
            Glyphs1:=@GlyphsByClass1[i];
            for k:=0 to Glyphs1^.Count-1 do begin
             FirstGlyph:=Glyphs1^.Items[k];
             Glyphs2:=@GlyphsByClass2[j];
             for h:=0 to Glyphs2^.Count-1 do begin
              SecondGlyph:=Glyphs2^.Items[h];
              AddKerningPair(FirstGlyph,SecondGlyph,x,true);
             end;
            end;
           end;
          end;
         end;

        finally
         GlyphsByClass2:=nil;
        end;

       finally
        GlyphsByClass1:=nil;
       end;

      finally
       GlyphArray:=nil;
      end;

     end;
    end;

   end;
   9:begin

    // Extension positioning subtable

    SubTableType:=ToWORD(fFontData[SubTableOffset+0],fFontData[SubTableOffset+1]);

    case SubTableType of
     1:begin

      // Format 1

      NewLookupType:=ToWORD(fFontData[SubTableOffset+2],fFontData[SubTableOffset+3]);
      CurrentPosition:=SubTableOffset+TVkInt32(ToLONGWORD(fFontData[SubTableOffset+4],fFontData[SubTableOffset+5],fFontData[SubTableOffset+6],fFontData[SubTableOffset+7]));

      result:=LoadSubTable(NewLookupType,CurrentPosition);
      if result<>VkTTF_TT_Err_NoError then begin
       exit;
      end;

     end;
    end;

   end;
  end;

  result:=VkTTF_TT_Err_NoError;

 end;
var KerningTable:PVulkanTrueTypeFontKerningTable;
    DoNeedSort:boolean;
begin

 Tag:=ToLONGWORD(TVkUInt8('G'),TVkUInt8('P'),TVkUInt8('O'),TVkUInt8('S'));
 result:=GetTableDirEntry(Tag,CheckSum,Offset,Size);
 if result=VkTTF_TT_Err_NoError then begin

  Position:=Offset;

  BaseOffset:=Position;

  MajorVersion:=ToWORD(fFontData[Position],fFontData[Position+1]);
  inc(Position,sizeof(TVkUInt16));

  MinorVersion:=ToWORD(fFontData[Position],fFontData[Position+1]);
  inc(Position,sizeof(TVkUInt16));

  ScriptListOffset:=ToWORD(fFontData[Position],fFontData[Position+1]);
  inc(Position,sizeof(TVkUInt16));

  FeatureListOffset:=ToWORD(fFontData[Position],fFontData[Position+1]);
  inc(Position,sizeof(TVkUInt16));

  LookupListOffset:=ToWORD(fFontData[Position],fFontData[Position+1]);
  inc(Position,sizeof(TVkUInt16));

  if (MajorVersion=1) and (MinorVersion=0) then begin
   FeatureVariations:=0;
  end else if (MajorVersion=1) and (MinorVersion=1) then begin
   FeatureVariations:=ToLONGWORD(fFontData[Position],fFontData[Position+1],fFontData[Position+2],fFontData[Position+3]);
   inc(Position,sizeof(TVkUInt32));
  end else begin
   result:=VkTTF_TT_ERR_UnknownGPOSFormat;
   exit;
  end;

  if ScriptListOffset<>0 then begin
  end;

  if FeatureListOffset<>0 then begin
  end;

  LookupListCount:=ToWORD(fFontData[BaseOffset+LookupListOffset+0],fFontData[BaseOffset+LookupListOffset+1]);

  fKerningTables:=nil;

  for i:=0 to LookupListCount-1 do begin

   LookupTableOffset:=BaseOffset+LookupListOffset+ToWORD(fFontData[BaseOffset+LookupListOffset+2+(i*2)],fFontData[BaseOffset+LookupListOffset+3+(i*2)]);

   LookupType:=ToWORD(fFontData[LookupTableOffset+0],fFontData[LookupTableOffset+1]);

   LookupFlags:=ToWORD(fFontData[LookupTableOffset+2],fFontData[LookupTableOffset+3]);

   SubTableCount:=ToWORD(fFontData[LookupTableOffset+4],fFontData[LookupTableOffset+5]);

   for j:=0 to SubTableCount-1 do begin

    SubTableOffset:=LookupTableOffset+ToWORD(fFontData[LookupTableOffset+6+(i*2)],fFontData[LookupTableOffset+7+(i*2)]);

    result:=LoadSubTable(LookupType,SubTableOffset);
    if result<>VkTTF_TT_Err_NoError then begin
     exit;
    end;

   end;

  end;

  for i:=0 to length(fKerningTables)-1 do begin
   KerningTable:=@fKerningTables[i];
   SetLength(KerningTable^.KerningPairs,KerningTable^.CountKerningPairs);
   KerningTable^.BinarySearch:=false;
   if length(KerningTable^.KerningPairs)<>0 then begin
    DoNeedSort:=false;
    for j:=1 to length(KerningTable^.KerningPairs)-1 do begin
     if CompareKerningPairs(@KerningTable^.KerningPairs[j-1],@KerningTable^.KerningPairs[j])>0 then begin
      DoNeedSort:=true;
      break;
     end;
    end;
    if DoNeedSort then begin
     DirectIntroSort(@KerningTable^.KerningPairs[0],0,length(KerningTable^.KerningPairs)-1,SizeOf(TVulkanTrueTypeFontKerningPair),CompareKerningPairs);
    end;
    KerningTable^.BinarySearch:=true;
    for j:=1 to length(KerningTable^.KerningPairs)-1 do begin
     if CompareKerningPairs(@KerningTable^.KerningPairs[j-1],@KerningTable^.KerningPairs[j])>0 then begin
      KerningTable^.BinarySearch:=false;
      break;
     end;
    end;
   end;
  end;

  result:=VkTTF_TT_ERR_NoError;

 end;

end;

function TVulkanTrueTypeFont.LoadKERN:TVkInt32;
var Position,Tag,CheckSum,Offset,Size,SubTableSize,Next,Version:TVkUInt32;
    CountSubTables,i,j:TVkInt32;
    CoverageFormat,CoverageFlags:TVkUInt8;
    DoNeedSort,Minimum,XStream:boolean;
    KerningTable:PVulkanTrueTypeFontKerningTable;
 function LoadKerningTableFormat0:TVkInt32;
 var i,j:TVkInt32;
     DoNeedSort:boolean;
     KerningPair:PVulkanTrueTypeFontKerningPair;
 begin

  KerningTable^.CountKerningPairs:=ToWORD(fFontData[Position],fFontData[Position+1]);
  inc(Position,sizeof(TVkUInt16));
  inc(Position,sizeof(TVkUInt16)); // Search range
  inc(Position,sizeof(TVkUInt16)); // Entry selector
  inc(Position,sizeof(TVkUInt16)); // Range shift

  KerningTable^.KerningPairs:=nil;
  SetLength(KerningTable^.KerningPairs,KerningTable^.CountKerningPairs);
  if length(KerningTable^.KerningPairs)<>KerningTable^.CountKerningPairs then begin
   result:=VkTTF_TT_ERR_OutOfMemory;
   exit;
  end;

  if (length(KerningTable^.KerningPairs)*12)>length(fFontData) then begin
   result:=VkTTF_TT_ERR_CorruptFile;
   exit;
  end;

  for j:=0 to length(KerningTable^.KerningPairs)-1 do begin
   KerningPair:=@KerningTable^.KerningPairs[j];
   KerningPair^.Left:=ToWORD(fFontData[Position],fFontData[Position+1]);
   inc(Position,sizeof(TVkUInt16));
   KerningPair^.Right:=ToWORD(fFontData[Position],fFontData[Position+1]);
   inc(Position,sizeof(TVkUInt16));
   KerningPair^.Value:=ToSMALLINT(fFontData[Position],fFontData[Position+1]);
   inc(Position,sizeof(TVkInt16));
  end;

  KerningTable^.BinarySearch:=false;
  if length(KerningTable^.KerningPairs)<>0 then begin
   DoNeedSort:=false;
   for j:=1 to length(KerningTable^.KerningPairs)-1 do begin
    if CompareKerningPairs(@KerningTable^.KerningPairs[j-1],@KerningTable^.KerningPairs[j])>0 then begin
     DoNeedSort:=true;
     break;
    end;
   end;
   if DoNeedSort then begin
    DirectIntroSort(@KerningTable^.KerningPairs[0],0,length(KerningTable^.KerningPairs)-1,SizeOf(TVulkanTrueTypeFontKerningPair),CompareKerningPairs);
   end;
   KerningTable^.BinarySearch:=true;
   for j:=1 to length(KerningTable^.KerningPairs)-1 do begin
    if CompareKerningPairs(@KerningTable^.KerningPairs[j-1],@KerningTable^.KerningPairs[j])>0 then begin
     KerningTable^.BinarySearch:=false;
     break;
    end;
   end;
  end;

  result:=VkTTF_TT_ERR_NoError;

 end;
 function LoadKerningTableFormat2:TVkInt32;
 var i,j,Offset,RowWidth,LeftOffsetTable,RightOffsetTable,KernArray,
     LeftClassOffset,RightClassOffset,LeftFirstGlyph,LeftCountGlyphs,
     RightFirstGlyph,RightCountGlyphs,LeftGlyphCounter,RightGlyphCounter,
     KerningPairIndex:TVkInt32;
     DoNeedSort:boolean;
     KerningPair:PVulkanTrueTypeFontKerningPair;
 begin

  Offset:=Position;

  RowWidth:=ToWORD(fFontData[Position],fFontData[Position+1]);
  inc(Position,sizeof(TVkUInt16));

  LeftOffsetTable:=ToWORD(fFontData[Position],fFontData[Position+1]);
  inc(Position,sizeof(TVkUInt16));

  RightOffsetTable:=ToWORD(fFontData[Position],fFontData[Position+1]);
  inc(Position,sizeof(TVkUInt16));

  KernArray:=ToWORD(fFontData[Position],fFontData[Position+1]);
  inc(Position,sizeof(TVkUInt16));

  LeftFirstGlyph:=ToWORD(fFontData[Offset+LeftOffsetTable+0],fFontData[Offset+LeftOffsetTable+1]);
  LeftCountGlyphs:=ToWORD(fFontData[Offset+LeftOffsetTable+2],fFontData[Offset+LeftOffsetTable+3]);

  RightFirstGlyph:=ToWORD(fFontData[Offset+RightOffsetTable+0],fFontData[Offset+RightOffsetTable+1]);
  RightCountGlyphs:=ToWORD(fFontData[Offset+RightOffsetTable+2],fFontData[Offset+RightOffsetTable+3]);

  KerningTable^.CountKerningPairs:=0;
  KerningTable^.KerningPairs:=nil;
  try
   for LeftGlyphCounter:=0 to LeftCountGlyphs-1 do begin
    LeftClassOffset:=ToWORD(fFontData[(Offset+LeftOffsetTable+4)+(LeftGlyphCounter*2)],fFontData[(Offset+LeftOffsetTable+5)+(LeftGlyphCounter*2)]);
    for RightGlyphCounter:=0 to RightCountGlyphs-1 do begin
     RightClassOffset:=ToWORD(fFontData[(Offset+RightOffsetTable+4)+(RightGlyphCounter*2)],fFontData[(Offset+RightOffsetTable+5)+(RightGlyphCounter*2)]);
     KerningPairIndex:=KerningTable^.CountKerningPairs;
     inc(KerningTable^.CountKerningPairs);
     if length(KerningTable^.KerningPairs)<KerningTable^.CountKerningPairs then begin
      SetLength(KerningTable^.KerningPairs,KerningTable^.CountKerningPairs*2);
     end;
     KerningPair:=@KerningTable^.KerningPairs[KerningPairIndex];
     KerningPair^.Left:=LeftGlyphCounter+LeftFirstGlyph;
     KerningPair^.Right:=RightGlyphCounter+RightFirstGlyph;
     KerningPair^.Value:=ToSMALLINT(fFontData[Offset+KernArray+LeftClassOffset+RightClassOffset+0],fFontData[Offset+KernArray+LeftClassOffset+RightClassOffset+1]);
    end;
   end;
  finally
   SetLength(KerningTable^.KerningPairs,KerningTable^.CountKerningPairs);
  end;

  if length(KerningTable^.KerningPairs)<>KerningTable^.CountKerningPairs then begin
   result:=VkTTF_TT_ERR_OutOfMemory;
   exit;
  end;

  KerningTable^.BinarySearch:=false;
  if length(KerningTable^.KerningPairs)<>0 then begin
   DoNeedSort:=false;
   for j:=1 to length(KerningTable^.KerningPairs)-1 do begin
    if CompareKerningPairs(@KerningTable^.KerningPairs[j-1],@KerningTable^.KerningPairs[j])>0 then begin
     DoNeedSort:=true;
     break;
    end;
   end;
   if DoNeedSort then begin
    DirectIntroSort(@KerningTable^.KerningPairs[0],0,length(KerningTable^.KerningPairs)-1,SizeOf(TVulkanTrueTypeFontKerningPair),CompareKerningPairs);
   end;
   KerningTable^.BinarySearch:=true;
   for j:=1 to length(KerningTable^.KerningPairs)-1 do begin
    if CompareKerningPairs(@KerningTable^.KerningPairs[j-1],@KerningTable^.KerningPairs[j])>0 then begin
     KerningTable^.BinarySearch:=false;
     break;
    end;
   end;
  end;

  result:=VkTTF_TT_ERR_NoError;

 end;

begin
 Tag:=ToLONGWORD(TVkUInt8('k'),TVkUInt8('e'),TVkUInt8('r'),TVkUInt8('n'));
 result:=GetTableDirEntry(Tag,CheckSum,Offset,Size);
 if result=VkTTF_TT_Err_NoError then begin
  Position:=Offset;

  Version:=ToWORD(fFontData[Position],fFontData[Position+1]);
  inc(Position,sizeof(TVkUInt16)); // Table Version number

  case Version of
   0:begin

    CountSubTables:=ToWORD(fFontData[Position],fFontData[Position+1]);
    inc(Position,sizeof(TVkUInt16));

    SetLength(fKerningTables,CountSubTables);
    if length(fKerningTables)<>CountSubTables then begin
     result:=VkTTF_TT_ERR_OutOfMemory;
     exit;
    end;

    for i:=0 to CountSubTables-1 do begin

     KerningTable:=@fKerningTables[i];

     inc(Position,sizeof(TVkUInt16)); // Subtable version number
     SubTableSize:=ToWORD(fFontData[Position],fFontData[Position+1]);
     inc(Position,sizeof(TVkUInt16)); // Subtable Size
     CoverageFormat:=fFontData[Position];
     CoverageFlags:=fFontData[Position+1];
     inc(Position,2);
     Next:=(Position+SubTableSize)-6;

     KerningTable^.Horizontal:=(CoverageFlags and 1)<>0;
     KerningTable^.Minimum:=(CoverageFlags and 2)<>0;
     KerningTable^.XStream:=(CoverageFlags and 4)<>0;
     KerningTable^.ValueOverride:=(CoverageFlags and 8)<>0;

     case CoverageFormat of
      0:begin
       result:=LoadKerningTableFormat0;
       if result<>VkTTF_TT_ERR_NoError then begin
        exit;
       end;
      end;
      2:begin
       result:=LoadKerningTableFormat2;
       if result<>VkTTF_TT_ERR_NoError then begin
        exit;
       end;
      end;
     end;

     Position:=Next;
    end;

    result:=VkTTF_TT_ERR_NoError;

   end;
   1:begin

    inc(Position,sizeof(TVkUInt16)); // Version-Lo

    CountSubTables:=ToLONGWORD(fFontData[Position],fFontData[Position+1],fFontData[Position+2],fFontData[Position+3]);
    inc(Position,sizeof(TVkUInt32));

    SetLength(fKerningTables,CountSubTables);
    if length(fKerningTables)<>CountSubTables then begin
     result:=VkTTF_TT_ERR_OutOfMemory;
     exit;
    end;

    for i:=0 to CountSubTables-1 do begin

     KerningTable:=@fKerningTables[i];

     SubTableSize:=ToLONGWORD(fFontData[Position],fFontData[Position+1],fFontData[Position+2],fFontData[Position+3]);
     inc(Position,sizeof(TVkUInt32)); // Subtable Size
     CoverageFormat:=fFontData[Position];
     CoverageFlags:=fFontData[Position+1];
     inc(Position,2);
     inc(Position,sizeof(TVkUInt16)); // Tuple Index
     Next:=(Position+SubTableSize)-8;

     if (CoverageFlags and 2)<>0 then begin
      // No support for variation values
      Position:=Next;
      continue;
     end;

     KerningTable^.Horizontal:=(CoverageFlags and 8)<>0;
     KerningTable^.Minimum:=false;
     KerningTable^.XStream:=(CoverageFlags and 4)<>0;
     KerningTable^.ValueOverride:=false;

     case CoverageFormat of
      0:begin
       result:=LoadKerningTableFormat0;
       if result<>VkTTF_TT_ERR_NoError then begin
        exit;
      end;
      end;
      2:begin
       result:=LoadKerningTableFormat2;
       if result<>VkTTF_TT_ERR_NoError then begin
        exit;
       end;
      end;
     end;

     Position:=Next;

    end;

    result:=VkTTF_TT_ERR_NoError;

   end;
   else begin

    result:=VkTTF_TT_ERR_UnknownKerningFormat;

   end;
  end;

 end;
end;

function TVulkanTrueTypeFont.LoadCMAP:TVkInt32;
type PTryEntry=^TTryEntry;
     TTryEntry=record
      PlatformID:TVkUInt32;
      SpecificID:TVkUInt32;
     end;
const TryEntries:array[0..9] of TTryEntry=
       ((PlatformID:VkTTF_PID_Microsoft;SpecificID:VkTTF_SID_MS_UCS_4),
        (PlatformID:VkTTF_PID_Apple;SpecificID:VkTTF_SID_APPLE_UNICODE32),
        (PlatformID:VkTTF_PID_Apple;SpecificID:VkTTF_SID_APPLE_UNICODE_2_0),
        (PlatformID:VkTTF_PID_Microsoft;SpecificID:VkTTF_SID_MS_UNICODE_CS),
        (PlatformID:VkTTF_PID_Apple;SpecificID:VkTTF_SID_APPLE_UNICODE_1_1),
        (PlatformID:VkTTF_PID_Apple;SpecificID:VkTTF_SID_APPLE_DEFAULT),
        (PlatformID:VkTTF_PID_Apple;SpecificID:VkTTF_SID_APPLE_ISO_10646),
        (PlatformID:VkTTF_PID_ISO;SpecificID:VkTTF_SID_ISO_10646),
        (PlatformID:VkTTF_PID_ISO;SpecificID:VkTTF_SID_ISO_8859_1),
        (PlatformID:VkTTF_PID_ISO;SpecificID:VkTTF_SID_ISO_ASCII)
       );
var Position,Tag,CheckSum,Offset,Size,NumSubTables,ThisPlatformID,ThisSpecificID,ThisSubtableOffset,SubtableOffset,
    SubtablePosition,i,j:TVkUInt32;
    SubtableLength,CMapIndex:TVkInt32;
    SubtableFound:boolean;
    TryEntry:PTryEntry;
begin
 Tag:=ToLONGWORD(TVkUInt8('c'),TVkUInt8('m'),TVkUInt8('a'),TVkUInt8('p'));
 result:=GetTableDirEntry(Tag,CheckSum,Offset,Size);
 if result=VkTTF_TT_Err_NoError then begin

  for CMapIndex:=0 to 1 do begin
   fCMaps[CMapIndex]:=nil;
   fCMapLengths[CMapIndex]:=0;
  end;

  for CMapIndex:=0 to 1 do begin

   Position:=Offset;
   inc(Position,sizeof(TVkUInt16)); // Table Version number
   NumSubTables:=ToWORD(fFontData[Position],fFontData[Position+1]);
   inc(Position,sizeof(TVkUInt16));

   SubtableFound:=false;
   SubtableOffset:=0;

   if fForceSelector then begin
    SubtablePosition:=Position;
    for i:=1 to NumSubTables do begin
     ThisPlatformID:=ToWORD(fFontData[SubtablePosition],fFontData[SubtablePosition+1]);
     inc(SubtablePosition,sizeof(TVkUInt16));
     ThisSpecificID:=ToWORD(fFontData[SubtablePosition],fFontData[SubtablePosition+1]);
     inc(SubtablePosition,sizeof(TVkUInt16));
     ThisSubtableOffset:=ToLONGWORD(fFontData[SubtablePosition],fFontData[SubtablePosition+1],fFontData[SubtablePosition+2],fFontData[SubtablePosition+3]);
     inc(SubtablePosition,sizeof(TVkUInt32));
     if (ThisPlatformID=fPlatformID) and (ThisSpecificID=fSpecificID) then begin
      SubtableFound:=true;
      SubtableOffset:=ThisSubtableOffset;
      break;
     end;
    end; 
   end;

{$ifdef HandleVariantSelectorCMap}
   if (CMapIndex=0) and not SubtableFound then begin
    SubtablePosition:=Position;
    for i:=1 to NumSubTables do begin
     ThisPlatformID:=ToWORD(fFontData[SubtablePosition],fFontData[SubtablePosition+1]);
     inc(SubtablePosition,sizeof(TVkUInt16));
     ThisSpecificID:=ToWORD(fFontData[SubtablePosition],fFontData[SubtablePosition+1]);
     inc(SubtablePosition,sizeof(TVkUInt16));
     ThisSubtableOffset:=ToLONGWORD(fFontData[SubtablePosition],fFontData[SubtablePosition+1],fFontData[SubtablePosition+2],fFontData[SubtablePosition+3]);
     inc(SubtablePosition,sizeof(TVkUInt32));
     if (ThisPlatformID=VkTTF_PID_Apple) and (ThisSpecificID=VkTTF_SID_APPLE_VARIANT_SELECTOR) then begin
      SubtableFound:=true;
      SubtableOffset:=ThisSubtableOffset;
      break;
     end;
    end;
   end;
{$endif}

   if not SubtableFound then begin

    for i:=low(TryEntries) to high(TryEntries) do begin
     TryEntry:=@TryEntries[i];
     SubtablePosition:=Position;
     for j:=1 to NumSubTables do begin
      ThisPlatformID:=ToWORD(fFontData[SubtablePosition],fFontData[SubtablePosition+1]);
      inc(SubtablePosition,sizeof(TVkUInt16));
      ThisSpecificID:=ToWORD(fFontData[SubtablePosition],fFontData[SubtablePosition+1]);
      inc(SubtablePosition,sizeof(TVkUInt16));
      ThisSubtableOffset:=ToLONGWORD(fFontData[SubtablePosition],fFontData[SubtablePosition+1],fFontData[SubtablePosition+2],fFontData[SubtablePosition+3]);
      inc(SubtablePosition,sizeof(TVkUInt32));
      if (ThisPlatformID=TryEntry^.PlatformID) and (ThisSpecificID=TryEntry^.SpecificID) then begin
       SubtableFound:=true;
       SubtableOffset:=ThisSubtableOffset;
       break;
      end;
     end;
     if SubtableFound then begin
      break;
     end;
    end;

    if not SubtableFound then begin

     SubtablePosition:=Position;
     for i:=1 to NumSubTables do begin
      ThisPlatformID:=ToWORD(fFontData[SubtablePosition],fFontData[SubtablePosition+1]);
      inc(SubtablePosition,sizeof(TVkUInt16));
      ThisSpecificID:=ToWORD(fFontData[SubtablePosition],fFontData[SubtablePosition+1]);
      inc(SubtablePosition,sizeof(TVkUInt16));
      ThisSubtableOffset:=ToLONGWORD(fFontData[SubtablePosition],fFontData[SubtablePosition+1],fFontData[SubtablePosition+2],fFontData[SubtablePosition+3]);
      inc(SubtablePosition,sizeof(TVkUInt32));
      if (ThisPlatformID<>VkTTF_PID_Apple) and (ThisSpecificID<>VkTTF_SID_APPLE_VARIANT_SELECTOR) then begin
       SubtableFound:=true;
       SubtableOffset:=ThisSubtableOffset;
       break;
      end;
     end;

     if (not SubtableFound) and (NumSubTables>0) then begin
      SubtableFound:=true;
      SubtablePosition:=Position+4;
      SubtableOffset:=ToLONGWORD(fFontData[SubtablePosition],fFontData[SubtablePosition+1],fFontData[SubtablePosition+2],fFontData[SubtablePosition+3]);
     end;

     if not SubtableFound then begin
      result:=VkTTF_TT_ERR_NoCharacterMapFound;
      exit;
     end;
   
    end;

   end;

   Position:=Offset+SubtableOffset;

   fCMapFormat:=ToWORD(fFontData[Position],fFontData[Position+1]);

   case fCMapFormat of
    VkTTF_CMAP_FORMAT0,VkTTF_CMAP_FORMAT2,VkTTF_CMAP_FORMAT4,VkTTF_CMAP_FORMAT6:begin
     SubtableLength:=ToWORD(fFontData[Position+2],fFontData[Position+3]);
    end;
    VkTTF_CMAP_FORMAT8,VkTTF_CMAP_FORMAT10,VkTTF_CMAP_FORMAT12,VkTTF_CMAP_FORMAT13:begin
     SubtableLength:=ToLONGWORD(fFontData[Position+4],fFontData[Position+5],fFontData[Position+6],fFontData[Position+7]);
    end;
    VkTTF_CMAP_FORMAT14:begin
     SubtableLength:=ToLONGWORD(fFontData[Position+2],fFontData[Position+3],fFontData[Position+4],fFontData[Position+5]);
    end;
    else begin
     result:=VkTTF_TT_ERR_UnknownCharacterMapFormat;
     exit;
    end;
   end;

   fCMaps[CMapIndex]:=@fFontData[Offset+SubtableOffset];
   fCMapLengths[CMapIndex]:=SubtableLength;

   if fCMapFormat<>VkTTF_CMAP_FORMAT14 then begin
    break;
   end;

  end;
  result:=VkTTF_TT_ERR_NoError;
 end;
end;

function TVulkanTrueTypeFont.LoadCVT:TVkInt32;
var Position,Tag,CheckSum,Offset,Size:TVkUInt32;
    Index:TVkInt32;
begin
 Tag:=ToLONGWORD(TVkUInt8('c'),TVkUInt8('v'),TVkUInt8('t'),TVkUInt8(' '));
 result:=GetTableDirEntry(Tag,CheckSum,Offset,Size);
 if result=VkTTF_TT_Err_NoError then begin
  SetLength(fCVT,(Size+1) shr 1);
  Position:=Offset;
  for Index:=0 to length(fCVT)-1 do begin
   fCVT[Index]:=TVkInt16(TVkUInt16(ToWORD(fFontData[Position],fFontData[Position+1])));
   inc(Position,SizeOf(TVkUInt16));
  end;
  result:=VkTTF_TT_ERR_NoError;
 end;
end;

function TVulkanTrueTypeFont.LoadFPGM:TVkInt32;
var Tag,CheckSum,Offset,Size:TVkUInt32;
begin
 Tag:=ToLONGWORD(TVkUInt8('f'),TVkUInt8('p'),TVkUInt8('g'),TVkUInt8('m'));
 result:=GetTableDirEntry(Tag,CheckSum,Offset,Size);
 if result=VkTTF_TT_Err_NoError then begin
  fFPGM.Data:=TVkPointer(@fFontData[Offset]);
  fFPGM.Size:=Size;
  result:=VkTTF_TT_ERR_NoError;
 end;
end;

function TVulkanTrueTypeFont.LoadPREP:TVkInt32;
var Tag,CheckSum,Offset,Size:TVkUInt32;
begin
 Tag:=ToLONGWORD(TVkUInt8('p'),TVkUInt8('r'),TVkUInt8('e'),TVkUInt8('p'));
 result:=GetTableDirEntry(Tag,CheckSum,Offset,Size);
 if result=VkTTF_TT_Err_NoError then begin
  fPREP.Data:=TVkPointer(@fFontData[Offset]);
  fPREP.Size:=Size;
  result:=VkTTF_TT_ERR_NoError;
 end;
end;

function TVulkanTrueTypeFont.LoadGASP:TVkInt32;
var Position,Tag,CheckSum,Offset,Size,{Version,}NumRanges,Index:TVkUInt32;
    LowerRange:TVkInt32;
begin
 Tag:=ToLONGWORD(TVkUInt8('g'),TVkUInt8('a'),TVkUInt8('s'),TVkUInt8('p'));
 result:=GetTableDirEntry(Tag,CheckSum,Offset,Size);
 if result=VkTTF_TT_Err_NoError then begin
  Position:=Offset;
  {Version:=}ToWORD(fFontData[Position],fFontData[Position+1]);
  inc(Position,sizeof(TVkUInt16));
  begin
   NumRanges:=ToWORD(fFontData[Position],fFontData[Position+1]);
   inc(Position,sizeof(TVkUInt16));
   if NumRanges>0 then begin
    SetLength(fGASPRanges,NumRanges);
    LowerRange:=0;
    Index:=0;
    while Index<NumRanges do begin
     fGASPRanges[Index].LowerPPEM:=LowerRange;
     fGASPRanges[Index].UpperPPEM:=ToWORD(fFontData[Position],fFontData[Position+1]);
     inc(Position,sizeof(TVkUInt16));
     fGASPRanges[Index].Flags:=ToWORD(fFontData[Position],fFontData[Position+1]);
     inc(Position,sizeof(TVkUInt16));
     LowerRange:=fGASPRanges[Index].UpperPPEM+1;
     inc(Index);
    end;
    if fGASPRanges[NumRanges-1].UpperPPEM=$ffff then begin
     fGASPRanges[NumRanges-1].UpperPPEM:=$7fffffff;
    end;
   end;
  end;
  result:=VkTTF_TT_ERR_NoError;
 end;
end;

function TVulkanTrueTypeFont.GetGASPRange:PVulkanTrueTypeFontGASPRange;
var l,h,m,v:TVkInt32;
begin
 l:=0;
 h:=length(fGASPRanges);
 result:=@fGASPRanges[h-1];
 v:=SARLongint(GetScale+32,6);
 while l<h do begin
  m:=(l+h) shr 1;
  if v<fGASPRanges[m].LowerPPEM then begin
   h:=m;
  end else if v>fGASPRanges[m].UpperPPEM then begin
   l:=m+1;
  end else begin
   result:=@fGASPRanges[m];
   break;
  end;
 end;
end;

function TVulkanTrueTypeFont.LoadGlyphData(GlyphIndex:TVkInt32):TVkInt32;
var Offset,Size,CurrentGlyphOffset,NextGlyphOffset,CurrentGlyphLength,Position,OldPosition,CurrentFlags,CurrentIndex,
    InstructionLength,RepeatCount,CurrentFlag:TVkUInt32;
    SubGlyphIndex,NumContours,Index,NumAllPoints,Last,Current:TVkInt32;
    carg1,carg2,cxx,cyx,cxy,cyy:TVkInt32;
begin
 if (fGlyfOffset<>0) and ((GlyphIndex>=0) and (GlyphIndex<fCountGlyphs)) then begin

  if (fGlyphLoadedBitmap[GlyphIndex shr 3] and (TVkUInt32(1) shl TVkUInt32(GlyphIndex and 31)))=0 then begin

   fGlyphLoadedBitmap[GlyphIndex shr 3]:=fGlyphLoadedBitmap[GlyphIndex shr 3] or (TVkUInt32(1) shl TVkUInt32(GlyphIndex and 31));

   Offset:=fGlyfOffset;

   fGlyphs[GlyphIndex].CompositeSubGlyphs:=nil;

   FillChar(fGlyphs[GlyphIndex].Instructions,SizeOf(TVulkanTrueTypeFontByteCodeInterpreterProgramBytes),AnsiChar(#0));


   CurrentGlyphOffset:=fGlyphOffsetArray[GlyphIndex];
   NextGlyphOffset:=fGlyphOffsetArray[GlyphIndex+1];
   CurrentGlyphLength:=NextGlyphOffset-CurrentGlyphOffset;

   fGlyphs[GlyphIndex].UseMetricsFrom:=-1;

   if CurrentGlyphLength=0 then begin

    fGlyphs[GlyphIndex].Points:=nil;
    fGlyphs[GlyphIndex].Bounds.XMin:=0;
    fGlyphs[GlyphIndex].Bounds.YMin:=0;
    fGlyphs[GlyphIndex].Bounds.XMax:=0;
    fGlyphs[GlyphIndex].Bounds.YMax:=0;

   end else begin

    Position:=Offset+CurrentGlyphOffset;

    if (Position+sizeof(TVkInt16))>(NextGlyphOffset+Offset) then begin
     result:=VkTTF_TT_ERR_CorruptFile;
     exit;
    end;
    NumContours:=ToSMALLINT(fFontData[Position],fFontData[Position+1]);
    inc(Position,sizeof(TVkInt16));

    if (Position+sizeof(TVkInt16))>(NextGlyphOffset+Offset) then begin
     result:=VkTTF_TT_ERR_CorruptFile;
     exit;
    end;
    fGlyphs[GlyphIndex].Bounds.XMin:=ToSMALLINT(fFontData[Position],fFontData[Position+1]);
    inc(Position,sizeof(TVkInt16));

    if (Position+sizeof(TVkInt16))>(NextGlyphOffset+Offset) then begin
     result:=VkTTF_TT_ERR_CorruptFile;
     exit;
    end;
    fGlyphs[GlyphIndex].Bounds.YMin:=ToSMALLINT(fFontData[Position],fFontData[Position+1]);
    inc(Position,sizeof(TVkInt16));

    if (Position+sizeof(TVkInt16))>(NextGlyphOffset+Offset) then begin
     result:=VkTTF_TT_ERR_CorruptFile;
     exit;
    end;
    fGlyphs[GlyphIndex].Bounds.XMax:=ToSMALLINT(fFontData[Position],fFontData[Position+1]);
    inc(Position,sizeof(TVkInt16));

    if (Position+sizeof(TVkInt16))>(NextGlyphOffset+Offset) then begin
     result:=VkTTF_TT_ERR_CorruptFile;
     exit;
    end;
    fGlyphs[GlyphIndex].Bounds.YMax:=ToSMALLINT(fFontData[Position],fFontData[Position+1]);
    inc(Position,sizeof(TVkInt16));

    if NumContours<=0 then begin

     if NumContours=-1 then begin

      OldPosition:=Position;

      SubGlyphIndex:=0;

      repeat

       if (Position+sizeof(TVkUInt16))>(NextGlyphOffset+Offset) then begin
        result:=VkTTF_TT_ERR_CorruptFile;
        exit;
       end;
       CurrentFlags:=ToWORD(fFontData[Position],fFontData[Position+1]);
       inc(Position,sizeof(TVkUInt16));

       if (Position+sizeof(TVkUInt16))>(NextGlyphOffset+Offset) then begin
        result:=VkTTF_TT_ERR_CorruptFile;
        exit;
       end;
       inc(Position,sizeof(TVkUInt16));

       if (CurrentFlags and ARGS_ARE_WORDS)<>0 then begin
        if (Position+sizeof(TVkUInt16))>(NextGlyphOffset+Offset) then begin
         result:=VkTTF_TT_ERR_CorruptFile;
         exit;
        end;
        inc(Position,sizeof(TVkInt16));

        if (Position+sizeof(TVkUInt16))>(NextGlyphOffset+Offset) then begin
         result:=VkTTF_TT_ERR_CorruptFile;
         exit;
        end;
        inc(Position,sizeof(TVkInt16));
       end else begin
        if (Position+sizeof(shortint))>(NextGlyphOffset+Offset) then begin
         result:=VkTTF_TT_ERR_CorruptFile;
         exit;
        end;
        inc(Position);

        if (Position+sizeof(shortint))>(NextGlyphOffset+Offset) then begin
         result:=VkTTF_TT_ERR_CorruptFile;
         exit;
        end;
        inc(Position);
       end;

       if (CurrentFlags and WE_HAVE_A_SCALE)<>0 then begin
        if (Position+sizeof(TVkInt16))>(NextGlyphOffset+Offset) then begin
         result:=VkTTF_TT_ERR_CorruptFile;
         exit;
        end;
        inc(Position,sizeof(TVkInt16));
       end else if (CurrentFlags and WE_HAVE_AN_XY_SCALE)<>0 then begin
        if (Position+sizeof(TVkInt16))>(NextGlyphOffset+Offset) then begin
         result:=VkTTF_TT_ERR_CorruptFile;
         exit;
        end;
        inc(Position,sizeof(TVkInt16));

        if (Position+sizeof(TVkInt16))>(NextGlyphOffset+Offset) then begin
         result:=VkTTF_TT_ERR_CorruptFile;
         exit;
        end;
        inc(Position,sizeof(TVkInt16));
       end else if (CurrentFlags and WE_HAVE_A_2X2)<>0 then begin
        if (Position+sizeof(TVkInt16))>(NextGlyphOffset+Offset) then begin
         result:=VkTTF_TT_ERR_CorruptFile;
         exit;
        end;
        inc(Position,sizeof(TVkInt16));

        if (Position+sizeof(TVkInt16))>(NextGlyphOffset+Offset) then begin
         result:=VkTTF_TT_ERR_CorruptFile;
         exit;
        end;
        inc(Position,sizeof(TVkInt16));

        if (Position+sizeof(TVkInt16))>(NextGlyphOffset+Offset) then begin
         result:=VkTTF_TT_ERR_CorruptFile;
         exit;
        end;
        inc(Position,sizeof(TVkInt16));

        if (Position+sizeof(TVkInt16))>(NextGlyphOffset+Offset) then begin
         result:=VkTTF_TT_ERR_CorruptFile;
         exit;
        end;
        inc(Position,sizeof(TVkInt16));
       end;

       inc(SubGlyphIndex);

      until (CurrentFlags and MORE_COMPONENTS)=0;

      Position:=OldPosition;

      SetLength(fGlyphs[GlyphIndex].CompositeSubGlyphs,SubGlyphIndex);

      SubGlyphIndex:=0;
      repeat

       if (Position+sizeof(TVkUInt16))>(NextGlyphOffset+Offset) then begin
        result:=VkTTF_TT_ERR_CorruptFile;
        exit;
       end;
       CurrentFlags:=ToWORD(fFontData[Position],fFontData[Position+1]);
       inc(Position,sizeof(TVkUInt16));

       if (Position+sizeof(TVkUInt16))>(NextGlyphOffset+Offset) then begin
        result:=VkTTF_TT_ERR_CorruptFile;
        exit;
       end;
       CurrentIndex:=ToWORD(fFontData[Position],fFontData[Position+1]);
       inc(Position,sizeof(TVkUInt16));

       if (CurrentFlags and USE_MY_METRICS)<>0 then begin
        fGlyphs[GlyphIndex].UseMetricsFrom:=CurrentIndex;
       end;

       if (CurrentFlags and ARGS_ARE_WORDS)<>0 then begin
        if (Position+sizeof(TVkUInt16))>(NextGlyphOffset+Offset) then begin
         result:=VkTTF_TT_ERR_CorruptFile;
         exit;
        end;
        carg1:=ToSMALLINT(fFontData[Position],fFontData[Position+1]);
        inc(Position,sizeof(TVkInt16));

        if (Position+sizeof(TVkUInt16))>(NextGlyphOffset+Offset) then begin
         result:=VkTTF_TT_ERR_CorruptFile;
         exit;
        end;
        carg2:=ToSMALLINT(fFontData[Position],fFontData[Position+1]);
        inc(Position,sizeof(TVkInt16));
       end else begin
        if (Position+sizeof(shortint))>(NextGlyphOffset+Offset) then begin
         result:=VkTTF_TT_ERR_CorruptFile;
         exit;
        end;
        carg1:=SHORTINT(fFontData[Position]);
        inc(Position);

        if (Position+sizeof(shortint))>(NextGlyphOffset+Offset) then begin
         result:=VkTTF_TT_ERR_CorruptFile;
         exit;
        end;
        carg2:=SHORTINT(fFontData[Position]);
        inc(Position);
       end;

       cxx:=$10000;
       cyy:=$10000;
       cxy:=0;
       cyx:=0;

       if (CurrentFlags and WE_HAVE_A_SCALE)<>0 then begin
        if (Position+sizeof(TVkInt16))>(NextGlyphOffset+Offset) then begin
         result:=VkTTF_TT_ERR_CorruptFile;
         exit;
        end;
        cxx:=ToSMALLINT(fFontData[Position],fFontData[Position+1])*4;
        inc(Position,sizeof(TVkInt16));
        cyy:=cxx;
       end else if (CurrentFlags and WE_HAVE_AN_XY_SCALE)<>0 then begin
        if (Position+sizeof(TVkInt16))>(NextGlyphOffset+Offset) then begin
         result:=VkTTF_TT_ERR_CorruptFile;
         exit;
        end;
        cxx:=ToSMALLINT(fFontData[Position],fFontData[Position+1])*4;
        inc(Position,sizeof(TVkInt16));

        if (Position+sizeof(TVkInt16))>(NextGlyphOffset+Offset) then begin
         result:=VkTTF_TT_ERR_CorruptFile;
         exit;
        end;
        cyy:=ToSMALLINT(fFontData[Position],fFontData[Position+1])*4;
        inc(Position,sizeof(TVkInt16));
       end else if (CurrentFlags and WE_HAVE_A_2X2)<>0 then begin
        if (Position+sizeof(TVkInt16))>(NextGlyphOffset+Offset) then begin
         result:=VkTTF_TT_ERR_CorruptFile;
         exit;
        end;
        cxx:=ToSMALLINT(fFontData[Position],fFontData[Position+1])*4;
        inc(Position,sizeof(TVkInt16));

        if (Position+sizeof(TVkInt16))>(NextGlyphOffset+Offset) then begin
         result:=VkTTF_TT_ERR_CorruptFile;
         exit;
        end;
        cyx:=ToSMALLINT(fFontData[Position],fFontData[Position+1])*4;
        inc(Position,sizeof(TVkInt16));

        if (Position+sizeof(TVkInt16))>(NextGlyphOffset+Offset) then begin
         result:=VkTTF_TT_ERR_CorruptFile;
         exit;
        end;
        cxy:=ToSMALLINT(fFontData[Position],fFontData[Position+1])*4;
        inc(Position,sizeof(TVkInt16));

        if (Position+sizeof(TVkInt16))>(NextGlyphOffset+Offset) then begin
         result:=VkTTF_TT_ERR_CorruptFile;
         exit;
        end;
        cyy:=ToSMALLINT(fFontData[Position],fFontData[Position+1])*4;
        inc(Position,sizeof(TVkInt16));
       end;

       fGlyphs[GlyphIndex].CompositeSubGlyphs[SubGlyphIndex].Flags:=CurrentFlags;
       fGlyphs[GlyphIndex].CompositeSubGlyphs[SubGlyphIndex].Glyph:=CurrentIndex;
       fGlyphs[GlyphIndex].CompositeSubGlyphs[SubGlyphIndex].Arg1:=carg1;
       fGlyphs[GlyphIndex].CompositeSubGlyphs[SubGlyphIndex].Arg2:=carg2;
       fGlyphs[GlyphIndex].CompositeSubGlyphs[SubGlyphIndex].xx:=cxx;
       fGlyphs[GlyphIndex].CompositeSubGlyphs[SubGlyphIndex].yx:=cyx;
       fGlyphs[GlyphIndex].CompositeSubGlyphs[SubGlyphIndex].xy:=cxy;
       fGlyphs[GlyphIndex].CompositeSubGlyphs[SubGlyphIndex].yy:=cyy;

       inc(SubGlyphIndex);
      until (CurrentFlags and MORE_COMPONENTS)=0;

      if (CurrentFlags and WE_HAVE_INSTR)<>0 then begin

       // TVkUInt8 code instruction Data
       if (Position+sizeof(TVkUInt16))>(NextGlyphOffset+Offset) then begin
        result:=VkTTF_TT_ERR_CorruptFile;
        exit;
       end;
       InstructionLength:=ToWORD(fFontData[Position],fFontData[Position+1]);
       inc(Position,sizeof(TVkUInt16));
       if (Position+InstructionLength)>(NextGlyphOffset+Offset) then begin
        result:=VkTTF_TT_ERR_CorruptFile;
        exit;
       end;

       if InstructionLength>0 then begin
        fGlyphs[GlyphIndex].Instructions.Data:=TVkPointer(@fFontData[Position]);
        fGlyphs[GlyphIndex].Instructions.Size:=InstructionLength;
       end else begin
        fGlyphs[GlyphIndex].Instructions.Data:=nil;
        fGlyphs[GlyphIndex].Instructions.Size:=0;
       end;

      end;
      
     end;

    end else begin

     SetLength(fGlyphs[GlyphIndex].EndPointIndices,NumContours);
     if length(fGlyphs[GlyphIndex].EndPointIndices)<>NumContours then begin
      result:=VkTTF_TT_ERR_OutOfMemory;
      exit;
     end;

     // End point indices
     for Index:=0 to NumContours-1 do begin
      if (Position+sizeof(TVkUInt16))>(NextGlyphOffset+Offset) then begin
       result:=VkTTF_TT_ERR_CorruptFile;
       exit;
      end;
      fGlyphs[GlyphIndex].EndPointIndices[Index]:=ToWORD(fFontData[Position],fFontData[Position+1]);
      inc(Position,sizeof(TVkUInt16));
     end;
     NumAllPoints:=fGlyphs[GlyphIndex].EndPointIndices[length(fGlyphs[GlyphIndex].EndPointIndices)-1]+1;

     // TVkUInt8 code instruction Data
     if (Position+sizeof(TVkUInt16))>(NextGlyphOffset+Offset) then begin
      result:=VkTTF_TT_ERR_CorruptFile;
      exit;
     end;
     InstructionLength:=ToWORD(fFontData[Position],fFontData[Position+1]);
     inc(Position,sizeof(TVkUInt16));
     if (Position+InstructionLength)>(NextGlyphOffset+Offset) then begin
      result:=VkTTF_TT_ERR_CorruptFile;
      exit;
     end;

     if InstructionLength>0 then begin
      fGlyphs[GlyphIndex].Instructions.Data:=TVkPointer(@fFontData[Position]);
      fGlyphs[GlyphIndex].Instructions.Size:=InstructionLength;
     end else begin
      fGlyphs[GlyphIndex].Instructions.Data:=nil;
      fGlyphs[GlyphIndex].Instructions.Size:=0;
     end;
     inc(Position,InstructionLength);

     SetLength(fGlyphs[GlyphIndex].Points,NumAllPoints);
     if length(fGlyphs[GlyphIndex].Points)<>NumAllPoints then begin
      result:=VkTTF_TT_ERR_OutOfMemory;
      exit;
     end;

     // Flags
     Index:=0;
     while Index<NumAllPoints do begin
      if (Position+sizeof(TVkUInt8))>(NextGlyphOffset+Offset) then begin
       result:=VkTTF_TT_ERR_CorruptFile;
       exit;
      end;
      fGlyphs[GlyphIndex].Points[Index].Flags:=fFontData[Position];
      inc(Position);
      if (fGlyphs[GlyphIndex].Points[Index].Flags and VkTTF_PathFlag_Repeat)<>0 then begin
       RepeatCount:=fFontData[Position];
       inc(Position);
       while RepeatCount>0 do begin
        inc(Index);
        fGlyphs[GlyphIndex].Points[Index].Flags:=fGlyphs[GlyphIndex].Points[Index-1].Flags;
        dec(RepeatCount);
       end;
      end;
      inc(Index);
     end;

     // X points
     Last:=0;
     for Index:=0 to NumAllPoints-1 do begin
      CurrentFlag:=fGlyphs[GlyphIndex].Points[Index].Flags;
      if (CurrentFlag and VkTTF_PathFlag_OnXShortVector)<>0 then begin
       if (Position+sizeof(TVkUInt8))>(NextGlyphOffset+Offset) then begin
        result:=VkTTF_TT_ERR_CorruptFile;
        exit;
       end;
       Current:=fFontData[Position];
       inc(Position);
       if (CurrentFlag and VkTTF_PathFlag_PositiveXShortVector)=0 then begin
        Current:=-Current;
       end;
      end else if (CurrentFlag and VkTTF_PathFlag_ThisXIsSame)<>0 then begin
       Current:=0;
      end else begin
       if (Position+sizeof(TVkInt16))>(NextGlyphOffset+Offset) then begin
        result:=VkTTF_TT_ERR_CorruptFile;
        exit;
       end;
       Current:=ToSMALLINT(fFontData[Position],fFontData[Position+1]);
       inc(Position,sizeof(TVkInt16));
      end;
      Last:=Last+Current;
      fGlyphs[GlyphIndex].Points[Index].x:=Last;
     end;

     // Y points
     Last:=0;
     for Index:=0 to NumAllPoints-1 do begin
      CurrentFlag:=fGlyphs[GlyphIndex].Points[Index].Flags;
      if (CurrentFlag and VkTTF_PathFlag_OnYShortVector)<>0 then begin
       if (Position+sizeof(TVkUInt8))>(NextGlyphOffset+Offset) then begin
        result:=VkTTF_TT_ERR_CorruptFile;
        exit;
       end;
       Current:=fFontData[Position];
       inc(Position);
       if (CurrentFlag and VkTTF_PathFlag_PositiveYShortVector)=0 then begin
        Current:=-Current;
       end;
      end else if (CurrentFlag and VkTTF_PathFlag_ThisYIsSame)<>0 then begin
       Current:=0;
      end else begin
       if (Position+sizeof(TVkInt16))>(NextGlyphOffset+Offset) then begin
        result:=VkTTF_TT_ERR_CorruptFile;
        exit;
       end;
       Current:=ToSMALLINT(fFontData[Position],fFontData[Position+1]);
       inc(Position,sizeof(TVkInt16));
      end;
      Last:=Last+Current;
      fGlyphs[GlyphIndex].Points[Index].y:=Last;
     end;

    end;

   end;

   if (fGlyphs[GlyphIndex].UseMetricsFrom>=0) and (fGlyphs[GlyphIndex].UseMetricsFrom<fCountGlyphs) then begin
    if LoadGlyphData(fGlyphs[GlyphIndex].UseMetricsFrom)=VkTTF_TT_ERR_NoError then begin
     fGlyphs[GlyphIndex].Bounds:=fGlyphs[fGlyphs[GlyphIndex].UseMetricsFrom].Bounds;
    end;
   end;

   result:=VkTTF_TT_ERR_NoError;

  end else begin

   result:=VkTTF_TT_ERR_NoError;

  end;

 end else begin

  result:=VkTTF_TT_ERR_OutOfBounds;

 end;

end;

function TVulkanTrueTypeFont.GetGlyphIndex(CharCode:TVkUInt32;CMapIndex:TVkInt32=0):TVkUInt32;
var CMap:PVulkanTrueTypeFontByteArray;
    SegCount,u:TVkUInt16;
    EndCount,StartCount,IDDelta,IDRangeOffset,Data,SubHeaderKeysData:PVulkanTrueTypeFontByteArray;
    CMapLength,EndV,Start,Delta,Range,Index,Seg,i,NumSH,NumGlyphID,index1,Idx,IDDeltaValue,
    IDRangeOffsetValue,Offset,FirstCode,EntryCount,l,h,m,CharHi,CharLo,
    NumSelectors,SelectorIndex,LastVarSelector,VarSelector,DefaultOffset,
    NonDefaultOffset,NumMappings,Unicode:TVkUInt32;
begin
 if (CMapIndex>=0) and (CMapIndex<length(fCMaps)) then begin
  CMap:=fCMaps[CMapIndex];
  CMapLength:=fCMapLengths[CMapIndex];
 end else begin
  CMap:=nil;
  CMapLength:=0;
 end;
 if CMapLength=0 then begin
  fLastError:=VkTTF_TT_ERR_CharacterMapNotPresent;
  result:=0;
 end else begin
  fLastError:=VkTTF_TT_ERR_NoError;
  case fCMapFormat of
   VkTTF_CMAP_FORMAT0:begin
    Offset:=CharCode+6;
    if Offset<TVkUInt32(CMapLength) then begin
     result:=CMap^[Offset];
    end else begin
     result:=0;
    end;
   end;
   VkTTF_CMAP_FORMAT2:begin
    if CharCode>$ffff then begin
     result:=0;
    end else begin
     if CharCode<256 then begin
      Index:=CharCode;
     end else begin
      Index:=CharCode shr 8;
     end;
     SubHeaderKeysData:=@CMap^[6];
     NumSH:=0;
     for i:=0 to 255 do begin
      u:=ToWORD(SubHeaderKeysData[i*2],SubHeaderKeysData[(i*2)+1]) shr 3;
      fSubHeaderKeys[i]:=u;
      if NumSH<u then begin
       NumSH:=u;
      end;
     end;
     NumGlyphID:=((TVkUInt32(CMapLength)-(2*(256+3))-(NumSH*8)) and $ffff) shr 1;
     index1:=fSubHeaderKeys[Index];
     if index1=0 then begin
      if CharCode<256 then begin
       if CharCode<NumGlyphID then begin
        Data:=@CMap^[6+(256*2)+(NumSH*8)];
        result:=ToWORD(Data^[CharCode*2],Data^[(CharCode*2)+1]);
       end else begin
        result:=0;
       end;
      end else begin
       result:=0;
      end;
     end else begin
      if CharCode<256 then begin
       result:=0;
      end else begin
       idx:=CharCode and $ff;
       Data:=@CMap^[6+(256*2)+(index1*8)];
       FirstCode:=ToWORD(Data^[0],Data^[1]);
       EntryCount:=ToWORD(Data^[2],Data^[3]);
       IDDeltaValue:=ToWORD(Data^[4],Data^[5]);
       IDRangeOffsetValue:=ToWORD(Data^[6],Data^[7])-(((NumSH-index1)*8)+2);
       if (idx>=FirstCode) and (idx<(FirstCode+EntryCount)) then begin
        Offset:=(IDRangeOffsetValue shr 1)+(idx-FirstCode);
        if Offset<NumGlyphID then begin
         Data:=@CMap^[6+(256*2)+(NumSH*8)];
         result:=ToWORD(Data^[Offset*2],Data^[(Offset*2)+1]);
         if result<>0 then begin
          result:=(result+IDDeltaValue) and $ffff;
         end;
        end else begin
         result:=0;
        end;
       end else begin
        result:=0;
       end;
      end;
     end;
    end;
   end;
   VkTTF_CMAP_FORMAT4:begin
    if CharCode>$ffff then begin
     result:=0;
    end else begin
     CharCode:=CharCode and $ffff;
     SegCount:=ToWORD(CMap^[6],CMap^[7]) shr 1;
     EndCount:=@CMap^[14];
     StartCount:=@CMap^[16+(2*SegCount)];
     IDDelta:=@CMap^[16+(4*SegCount)];
     IDRangeOffset:=@CMap^[16+(6*SegCount)];
     seg:=0;
     EndV:=ToWORD(EndCount^[0],EndCount^[1]);
     while EndV<CharCode do begin
      inc(seg);
      EndV:=ToWORD(EndCount^[seg*2],EndCount^[(seg*2)+1]);
     end;
     Start:=ToWORD(StartCount^[seg*2],StartCount^[(seg*2)+1]);
     Delta:=ToWORD(IDDelta^[seg*2],IDDelta^[(seg*2)+1]);
     Range:=ToWORD(IDRangeOffset[seg*2],IDRangeOffset[(seg*2)+1]);
     if Start>CharCode then begin
      result:=0;
     end else begin
      if Range=0 then begin
       Index:=(TVkUInt16(CharCode)+TVkUInt16(Delta)) and $ffff;
      end else begin
       Index:=Range+((CharCode-Start)*2)+((16+(6*SegCount))+(seg*2));
       Index:=ToWORD(CMap^[Index],CMap^[Index+1]);
       if Index<>0 then begin
        Index:=(TVkUInt16(Index)+TVkUInt16(Delta)) and $ffff;
       end;
      end;
      result:=Index;
     end;
    end;
   end;
   VkTTF_CMAP_FORMAT6:begin
    FirstCode:=ToWORD(CMap^[6],CMap^[7]);
    EntryCount:=ToWORD(CMap^[8],CMap^[9]);
    if (CharCode>=FirstCode) and (CharCode<(FirstCode+EntryCount)) then begin
     Offset:=(TVkUInt32(CharCode-FirstCode)*2)+10;
     result:=ToWORD(CMap^[Offset],CMap^[Offset+1]);
    end else begin
     result:=0;
    end;
   end;
   VkTTF_CMAP_FORMAT8:begin
    result:=0;
    EntryCount:=ToLONGWORD(CMap^[8204],CMap^[8205],CMap^[8206],CMap^[8207]);
    if EntryCount>0 then begin
     l:=0;
     h:=EntryCount;
     while l<h do begin
      m:=(l+h) shr 1;
      Offset:=8208+(m*12);
      Start:=ToLONGWORD(CMap^[Offset],CMap^[Offset+1],CMap^[Offset+2],CMap^[Offset+3]);
      EndV:=ToLONGWORD(CMap^[Offset+4],CMap^[Offset+5],CMap^[Offset+6],CMap^[Offset+7]);
      if CharCode<Start then begin
       h:=m;
      end else if CharCode>EndV then begin
       l:=m+1;
      end else begin
       if (m and $ffff0000)=0 then begin
        if (CMap^[12+(m shr 3)] and ($80 shr (m and 7)))<>0 then begin
         break;
        end;
       end else begin
        if ((CMap^[12+((m and $ffff) shr 3)] and ($80 shr ((m and $ffff) and 7)))=0) or
            ((CMap^[12+(((m shr 16) and $ffff) shr 3)] and ($80 shr (((m shr 16) and $ffff) and 7)))=0) then begin
          break;
        end;
       end;
       result:=(ToLONGWORD(CMap^[Offset+8],CMap^[Offset+9],CMap^[Offset+10],CMap^[Offset+11])+CharCode)-Start;
       break;
      end;
     end;
    end;
   end;
   VkTTF_CMAP_FORMAT10:begin
    FirstCode:=ToLONGWORD(CMap^[12],CMap^[13],CMap^[14],CMap^[15]);
    EntryCount:=ToLONGWORD(CMap^[16],CMap^[17],CMap^[18],CMap^[19]);
    if (CharCode>=FirstCode) and (CharCode<(FirstCode+EntryCount)) then begin
     Offset:=(TVkUInt32(CharCode-FirstCode)*2)+20;
     result:=ToWORD(CMap^[Offset],CMap^[Offset+1]);
    end else begin
     result:=0;
    end;
   end;
   VkTTF_CMAP_FORMAT12:begin
    result:=0;
    EntryCount:=ToWORD(CMap^[6],CMap^[7]);
    if EntryCount>0 then begin
     l:=0;
     h:=EntryCount;
     while l<h do begin
      m:=(l+h) shr 1;
      Offset:=16+(m*12);
      Start:=ToLONGWORD(CMap^[Offset],CMap^[Offset+1],CMap^[Offset+2],CMap^[Offset+3]);
      EndV:=ToLONGWORD(CMap^[Offset+4],CMap^[Offset+5],CMap^[Offset+6],CMap^[Offset+7]);
      if CharCode<Start then begin
       h:=m;
      end else if CharCode>EndV then begin
       l:=m+1;
      end else begin
       result:=(ToLONGWORD(CMap^[Offset+8],CMap^[Offset+9],CMap^[Offset+10],CMap^[Offset+11])+CharCode)-Start;
       break;
      end;
     end;
    end;
   end;
   VkTTF_CMAP_FORMAT13:begin
    result:=0;
    EntryCount:=ToWORD(CMap^[6],CMap^[7]);
    if EntryCount>0 then begin
     l:=0;
     h:=EntryCount;
     while l<h do begin
      m:=(l+h) shr 1;
      Offset:=16+(m*12);
      Start:=ToLONGWORD(CMap^[Offset],CMap^[Offset+1],CMap^[Offset+2],CMap^[Offset+3]);
      EndV:=ToLONGWORD(CMap^[Offset+4],CMap^[Offset+5],CMap^[Offset+6],CMap^[Offset+7]);
      if CharCode<Start then begin
       h:=m;
      end else if CharCode>EndV then begin
       l:=m+1;
      end else begin
       result:=ToLONGWORD(CMap^[Offset+8],CMap^[Offset+9],CMap^[Offset+10],CMap^[Offset+11]);
       break;
      end;
     end;
    end;
   end;
   VkTTF_CMAP_FORMAT14:begin
    result:=0;
    NumSelectors:=ToLONGWORD(CMap^[6],CMap^[7],CMap^[8],CMap^[9]);
    if NumSelectors>0 then begin
     DefaultOffset:=0;
     NonDefaultOffset:=0;
     l:=0;
     h:=NumSelectors;
     while l<h do begin
      m:=(l+h) shr 1;
      Offset:=10+(m*11);
      VarSelector:=ToUINT24(CMap^[Offset],CMap^[Offset+1],CMap^[Offset+2]);
      DefaultOffset:=ToLONGWORD(CMap^[Offset+3],CMap^[Offset+4],CMap^[Offset+5],CMap^[Offset+6]);
      NonDefaultOffset:=ToLONGWORD(CMap^[Offset+7],CMap^[Offset+8],CMap^[Offset+9],CMap^[Offset+10]);
      if CharCode<VarSelector then begin
       h:=m;
      end else if CharCode>VarSelector then begin
       l:=m+1;
      end else begin
       break;
      end;
     end;
     if (DefaultOffset>0) and (DefaultOffset<TVkUInt32(CMapLength)) then begin
      NumMappings:=ToLONGWORD(CMap^[NonDefaultOffset],CMap^[NonDefaultOffset+1],CMap^[NonDefaultOffset+2],CMap^[NonDefaultOffset+3]);
      if ((NonDefaultOffset+4)+(NumMappings*4))<TVkUInt32(CMapLength) then begin
       l:=0;
       h:=NumMappings;
       while l<h do begin
        m:=(l+h) shr 1;
        Offset:=(NonDefaultOffset+4)+(m*4);
        Unicode:=ToUINT24(CMap^[Offset],CMap^[Offset+1],CMap^[Offset+2]);
        if CharCode<Unicode then begin
         h:=m;
        end else if CharCode>(Unicode+CMap^[Offset+3]) then begin
         l:=m+1;
        end else begin
         result:=GetGlyphIndex(CharCode,CMapIndex+1);
         exit;
        end;
       end;
      end;
     end;
     if (NonDefaultOffset>0) and (NonDefaultOffset<TVkUInt32(CMapLength)) then begin
      NumMappings:=ToLONGWORD(CMap^[NonDefaultOffset],CMap^[NonDefaultOffset+1],CMap^[NonDefaultOffset+2],CMap^[NonDefaultOffset+3]);
      if ((NonDefaultOffset+4)+(NumMappings*5))<TVkUInt32(CMapLength) then begin
       l:=0;
       h:=NumMappings;
       while l<h do begin
        m:=(l+h) shr 1;
        Offset:=(NonDefaultOffset+4)+(m*5);
        Unicode:=ToUINT24(CMap^[Offset],CMap^[Offset+1],CMap^[Offset+2]);
        if CharCode<Unicode then begin
         h:=m;
        end else if CharCode>Unicode then begin
         l:=m+1;
        end else begin
         result:=ToWORD(CMap^[Offset+3],CMap^[Offset+4]);
         break;
        end;
       end;
      end;
     end;
    end;
   end;
   else begin
    result:=0;
   end;
  end;
 end;
end;

function TVulkanTrueTypeFont.GetGlyphAdvanceWidth(GlyphIndex:TVkInt32):TVkInt32;
begin
 if (GlyphIndex>=0) and (GlyphIndex<fCountGlyphs) then begin
  result:=fGlyphs[GlyphIndex].AdvanceWidth;
  case fStyleIndex of
   2,3:begin
    // Thin
    dec(result,fThinBoldStrength);
   end;
   4,5:begin
    // Bold
    inc(result,fThinBoldStrength);
   end;
  end;
 end else begin
  result:=0;
 end;
end;

function TVulkanTrueTypeFont.GetGlyphAdvanceHeight(GlyphIndex:TVkInt32):TVkInt32;
begin
 if (GlyphIndex>=0) and (GlyphIndex<fCountGlyphs) then begin
  result:=fGlyphs[GlyphIndex].AdvanceHeight;
 end else begin
  result:=0;
 end;
end;

function TVulkanTrueTypeFont.GetGlyphLeftSideBearing(GlyphIndex:TVkInt32):TVkInt32;
begin
 if (GlyphIndex>=0) and (GlyphIndex<fCountGlyphs) then begin
  result:=fGlyphs[GlyphIndex].LeftSideBearing;
  case fStyleIndex of
   2,3:begin
    // Thin
    dec(result,fThinBoldStrength);
   end;
   4,5:begin
    // Bold
    inc(result,fThinBoldStrength);
   end;
  end;
 end else begin
  result:=0;
 end;
end;

function TVulkanTrueTypeFont.GetGlyphRightSideBearing(GlyphIndex:TVkInt32):TVkInt32;
begin
 if ((GlyphIndex>=0) and (GlyphIndex<fCountGlyphs)) and (LoadGlyphData(GlyphIndex)=VkTTF_TT_ERR_NoError) then begin
  result:=fGlyphs[GlyphIndex].LeftSideBearing;
  case fStyleIndex of
   2,3:begin
    // Thin
    dec(result,fThinBoldStrength);
   end;
   4,5:begin
    // Bold
    inc(result,fThinBoldStrength);
   end;
  end;
  result:=fGlyphs[GlyphIndex].AdvanceWidth-(result+(fGlyphs[GlyphIndex].Bounds.XMax-fGlyphs[GlyphIndex].Bounds.XMin));
 end else begin
  result:=0;
 end;
end;

function TVulkanTrueTypeFont.GetGlyphTopSideBearing(GlyphIndex:TVkInt32):TVkInt32;
begin
 if (GlyphIndex>=0) and (GlyphIndex<fCountGlyphs) then begin
  result:=fGlyphs[GlyphIndex].TopSideBearing;
 end else begin
  result:=0;
 end;
end;

function TVulkanTrueTypeFont.GetGlyphBottomSideBearing(GlyphIndex:TVkInt32):TVkInt32;
begin
 if ((GlyphIndex>=0) and (GlyphIndex<fCountGlyphs)) and (LoadGlyphData(GlyphIndex)=VkTTF_TT_ERR_NoError) then begin
  result:=fGlyphs[GlyphIndex].AdvanceHeight-(fGlyphs[GlyphIndex].TopSideBearing+(fGlyphs[GlyphIndex].Bounds.YMax-fGlyphs[GlyphIndex].Bounds.YMin));
 end else begin
  result:=0;
 end;
end;

function TVulkanTrueTypeFont.GetKerning(Left,Right:TVkUInt32;Horizontal:boolean):TVkInt32;
var KerningIndex,KerningPairIndex,LeftIndex,RightIndex,MiddleIndex,Index:TVkInt32;
    KerningTable:PVulkanTrueTypeFontKerningTable;
    KerningPair:PVulkanTrueTypeFontKerningPair;
begin
 result:=0;
 if length(fKerningTables)>0 then begin
  for KerningIndex:=0 to length(fKerningTables)-1 do begin
   KerningTable:=@fKerningTables[KerningIndex];
   if (length(KerningTable^.KerningPairs)<>0) and
      (Horizontal=((KerningTable^.Horizontal and not KerningTable^.XStream) or
                   ((not KerningTable^.Horizontal) and KerningTable^.XStream))) then begin
    Index:=-1;
    if KerningTable^.BinarySearch then begin
     LeftIndex:=0;
     RightIndex:=length(KerningTable^.KerningPairs);
     while LeftIndex<RightIndex do begin
      MiddleIndex:=(LeftIndex+RightIndex) shr 1;
      KerningPair:=@KerningTable^.KerningPairs[MiddleIndex];
      if (Left=KerningPair^.Left) and (Right=KerningPair^.Right) then begin
       Index:=MiddleIndex;
       break;
      end else begin
       if (Left<KerningPair^.Left) or ((Left=KerningPair^.Left) and (Right<KerningPair^.Right)) then begin
        RightIndex:=MiddleIndex;
       end else begin
        LeftIndex:=MiddleIndex+1;
       end;
      end;
     end;
    end else begin
     for KerningPairIndex:=0 to length(KerningTable^.KerningPairs)-1 do begin
      KerningPair:=@KerningTable^.KerningPairs[KerningPairIndex];
      if (Left=KerningPair^.Left) and (Right=KerningPair^.Right) then begin
       Index:=KerningPairIndex;
       break;
      end;
     end;
    end;
    if Index>=0 then begin
     if KerningTable^.Minimum then begin
      if KerningTable^.KerningPairs[Index].Value>=0 then begin
       result:=Min(result,KerningTable^.KerningPairs[Index].Value);
      end else begin
       result:=Max(result,KerningTable^.KerningPairs[Index].Value);
      end;
     end else if KerningTable^.ValueOverride then begin
      result:=KerningTable^.KerningPairs[Index].Value;
     end else begin
      inc(result,KerningTable^.KerningPairs[Index].Value);
     end;
    end;
   end;
  end;
 end;
end;

function TVulkanTrueTypeFont.GetScaleFactor:TVkDouble;
begin
 if fSize<0 then begin
  result:=(-fSize)/fUnitsPerEm;
 end else begin
  result:=(fSize*fTargetPPI)/(fUnitsPerEm*72);
 end;
end;

function TVulkanTrueTypeFont.GetScaleFactorFixed:TVkInt32;
begin
 if fSize<0 then begin
  result:=(TVkInt64(-fSize)*$10000) div fUnitsPerEm;
 end else begin
  result:=((TVkInt64(fSize*fTargetPPI)*$10000)+(fUnitsPerEm*36)) div (fUnitsPerEm*72);
 end;
end;

function TVulkanTrueTypeFont.Scale(Value:TVkInt32):TVkInt32;
begin
 if fSize<0 then begin
  if Value>=0 then begin
   result:=((Value*TVkInt64((-fSize)*64))+SARLongint(fUnitsPerEm+1,1)) div fUnitsPerEm;
  end else begin
   result:=((Value*TVkInt64((-fSize)*64))-SARLongint(fUnitsPerEm+1,1)) div fUnitsPerEm;
  end;
 end else begin
  if Value>=0 then begin
   result:=((Value*TVkInt64(fSize*64*fTargetPPI))+SARLongint((fUnitsPerEm*72)+1,1)) div (fUnitsPerEm*72);
  end else begin
   result:=((Value*TVkInt64(fSize*64*fTargetPPI))-SARLongint((fUnitsPerEm*72)+1,1)) div (fUnitsPerEm*72);
  end;
 end;
end;

function TVulkanTrueTypeFont.GetScale:TVkInt32;
begin
 if fSize<0 then begin
  result:=(-fSize)*64;
 end else begin
  result:=((fSize*64*fTargetPPI)+36) div 72;
 end;
end;

function TVulkanTrueTypeFont.ScaleRound(Value:TVkInt32):TVkInt32;
begin
 if fSize<0 then begin
  if Value>=0 then begin
   result:=(Value+SARLongint(fUnitsPerPixel,1)) div fUnitsPerPixel;
  end else begin
   result:=(Value-SARLongint(fUnitsPerPixel,1)) div fUnitsPerPixel;
  end;
 end else begin
  if Value>=0 then begin
   result:=((Value*fTargetPPI)+SARLongint(fUnitsPerEm*72,1)) div (fUnitsPerEm*72);
  end else begin
   result:=((Value*fTargetPPI)-SARLongint(fUnitsPerEm*72,1)) div (fUnitsPerEm*72);
  end;
 end;
end;

procedure TVulkanTrueTypeFont.ResetGlyphBuffer(var GlyphBuffer:TVulkanTrueTypeFontGlyphBuffer);
begin
 GlyphBuffer.CountPoints:=0;
 GlyphBuffer.CountIndices:=0;
end;

procedure TVulkanTrueTypeFont.TransformGlyphBuffer(var GlyphBuffer:TVulkanTrueTypeFontGlyphBuffer;GlyphStartPointIndex,StartIndex,EndIndex:TVkInt32);
var Sum,Direction,StartPointIndex,i,j,x,y,xs,ys:TVkInt32;
    pprev,pfirst,pnext,pcur,pin,pout:TVulkanTrueTypeFontGlyphPoint;
    ain,aout,ad,s:single;
    Matrix:TMatrix;
begin
 Sum:=0;
 StartPointIndex:=GlyphStartPointIndex;
 for i:=StartIndex to EndIndex do begin
  if ((GlyphBuffer.EndPointIndices[i]-StartPointIndex)+1)>0 then begin
   x:=GlyphBuffer.Points[StartPointIndex].x;
   y:=GlyphBuffer.Points[StartPointIndex].y;
   xs:=x;
   ys:=y;
   for j:=StartPointIndex to GlyphBuffer.EndPointIndices[i] do begin
    inc(Sum,(x*GlyphBuffer.Points[j].y)-(y*GlyphBuffer.Points[j].x));
    x:=GlyphBuffer.Points[j].x;
    y:=GlyphBuffer.Points[j].y;
   end;
   inc(Sum,(x*ys)-(y*xs));
  end;
  StartPointIndex:=GlyphBuffer.EndPointIndices[i]+1;
 end;
 if Sum<0 then begin
  Direction:=1;
 end else begin
  Direction:=-1;
 end;
 StartPointIndex:=GlyphStartPointIndex;
 for i:=StartIndex to EndIndex do begin
  if ((GlyphBuffer.EndPointIndices[i]-StartPointIndex)+1)>1 then begin
   if fStyleIndex in [2,3,4,5] then begin
    // Thin/Bold
    pfirst:=GlyphBuffer.Points[StartPointIndex];
    pprev:=GlyphBuffer.Points[GlyphBuffer.EndPointIndices[i]];
    pcur:=pfirst;
    for j:=StartPointIndex to GlyphBuffer.EndPointIndices[i] do begin
     if (j+1)<=GlyphBuffer.EndPointIndices[i] then begin
      pnext:=GlyphBuffer.Points[j+1];
     end else begin
      pnext:=pfirst;
     end;
     pin.x:=pcur.x-pprev.x;
     pin.y:=pcur.y-pprev.y;
     pout.x:=pnext.x-pcur.x;
     pout.y:=pnext.y-pcur.y;
     ain:=arctan2(pin.y,pin.x);
     aout:=arctan2(pout.y,pout.x);
     ad:=aout-ain;
     s:=cos(ad*0.5);
     if abs(s)<=0.25 then begin
      pin.x:=0;
      pin.y:=0;
     end else begin
      pin.x:=trunc(SARLongint(fThinBoldStrength,1)/s);
      pin.y:=0;
      if fStyleIndex in [2,3] then begin
       // Thin
       Matrix:=MatrixRotate(((ain+(ad*0.5)-((pi*0.5)*Direction))*rad2deg));
      end else begin
       // Bold
       Matrix:=MatrixRotate(((ain+(ad*0.5)+((pi*0.5)*Direction))*rad2deg));
      end;
      ApplyMatrixToXY(Matrix,pin.x,pin.y);
     end;
     GlyphBuffer.Points[j].x:=pcur.x+fThinBoldStrength+pin.x;
     GlyphBuffer.Points[j].y:=pcur.y+fThinBoldStrength+pin.y;
     pprev:=pcur;
     pcur:=pnext;
    end;
   end;
   if fStyleIndex in [1,3,5] then begin
    // Italic
    for j:=StartPointIndex to GlyphBuffer.EndPointIndices[i] do begin
     // Rotate only x coord by about 12 degrees
     Matrix[0]:=1;
     Matrix[1]:=0;
     Matrix[2]:=0.375;
     Matrix[3]:=1;
     Matrix[4]:=0;
     Matrix[5]:=0;
     ApplyMatrixToXY(Matrix,GlyphBuffer.Points[j].x,GlyphBuffer.Points[j].y);
    end;
   end;
  end;
  StartPointIndex:=GlyphBuffer.EndPointIndices[i]+1;
 end;
end;

procedure TVulkanTrueTypeFont.FillGlyphBuffer(var GlyphBuffer:TVulkanTrueTypeFontGlyphBuffer;const GlyphIndex:TVkInt32);
const fi65536=1.0/65536;
var CountSubGlyphs,SubGlyphArrayIndex,PointIndex,cx,cy,OriginalCount,DstCount,SrcCount,l,Offset,Count,EndOffset:TVkInt32;
    SubGlyph:PVulkanTrueTypeFontGlyphCompositeSubGlyph;
    HaveScale:boolean;
    p:TVulkanTrueTypeFontGlyphPoint;
begin
 if ((GlyphIndex>=0) and (GlyphIndex<fCountGlyphs)) and not fGlyphs[GlyphIndex].Locked then begin

  fGlyphs[GlyphIndex].Locked:=true;
  try

   if LoadGlyphData(GlyphIndex)=VkTTF_TT_ERR_NoError then begin

    if GlyphBuffer.CountPoints=0 then begin
     GlyphBuffer.Bounds:=fGlyphs[GlyphIndex].Bounds;
     GlyphBuffer.Bounds.XMin:=Scale(GlyphBuffer.Bounds.XMin);
     GlyphBuffer.Bounds.YMin:=Scale(GlyphBuffer.Bounds.YMin);
     GlyphBuffer.Bounds.XMax:=Scale(GlyphBuffer.Bounds.XMax);
     GlyphBuffer.Bounds.YMax:=Scale(GlyphBuffer.Bounds.YMax);
    end;

    CountSubGlyphs:=length(fGlyphs[GlyphIndex].CompositeSubGlyphs);
    if CountSubGlyphs>0 then begin

     OriginalCount:=GlyphBuffer.CountPoints;

     EndOffset:=GlyphBuffer.CountIndices;

     for SubGlyphArrayIndex:=0 to CountSubGlyphs-1 do begin

      SubGlyph:=@fGlyphs[GlyphIndex].CompositeSubGlyphs[SubGlyphArrayIndex];

      Offset:=GlyphBuffer.CountPoints;

      FillGlyphBuffer(GlyphBuffer,SubGlyph^.Glyph);

      if ((SubGlyph^.Flags and USE_MY_METRICS)<>0) and (SubGlyph^.Glyph<TVkUInt32(fCountGlyphs)) then begin
       GlyphBuffer.Bounds:=fGlyphs[SubGlyph^.Glyph].Bounds;
       GlyphBuffer.Bounds.XMin:=Scale(GlyphBuffer.Bounds.XMin);
       GlyphBuffer.Bounds.YMin:=Scale(GlyphBuffer.Bounds.YMin);
       GlyphBuffer.Bounds.XMax:=Scale(GlyphBuffer.Bounds.XMax);
       GlyphBuffer.Bounds.YMax:=Scale(GlyphBuffer.Bounds.YMax);
      end;

      HaveScale:=(SubGlyph^.Flags and (WE_HAVE_A_SCALE or WE_HAVE_AN_XY_SCALE or WE_HAVE_A_2X2))<>0;

      if HaveScale then begin
       for PointIndex:=Offset to GlyphBuffer.CountPoints-1 do begin
        Transform(GlyphBuffer.Points[PointIndex].x,GlyphBuffer.Points[PointIndex].y,SubGlyph^.xx,SubGlyph^.yx,SubGlyph^.xy,SubGlyph^.yy);
       end;
      end;

      if (SubGlyph^.Flags and ARGS_ARE_XY_VALUES)<>0 then begin
       cx:=SubGlyph^.Arg1;
       cy:=SubGlyph^.Arg2;
      end else if (SubGlyph^.Arg1>=0) and (SubGlyph^.Arg1<OriginalCount) and
                  (SubGlyph^.Arg2>=OriginalCount) and ((SubGlyph^.Arg2-OriginalCount)<GlyphBuffer.CountPoints) then begin
       cx:=GlyphBuffer.Points[SubGlyph^.Arg1].x-GlyphBuffer.Points[SubGlyph^.Arg2+OriginalCount].x;
       cy:=GlyphBuffer.Points[SubGlyph^.Arg1].y-GlyphBuffer.Points[SubGlyph^.Arg2+OriginalCount].y;
      end else begin
       cx:=0;
       cy:=0;
      end;

      if (cx<>0) or (cy<>0) then begin
       if HaveScale and ((SubGlyph^.Flags and UNSCALED_COMPONENT_OFFSET)=0) then begin
 {$ifdef cpuarm}
        cx:=MulFix(cx,SQRTFixed(MulFix(SubGlyph^.xx,SubGlyph^.xx)+MulFix(SubGlyph^.xy,SubGlyph^.xy)));
        cy:=MulFix(cy,SQRTFixed(MulFix(SubGlyph^.yx,SubGlyph^.yx)+MulFix(SubGlyph^.yy,SubGlyph^.yy)));
 {$else}
        cx:=round(cx*sqrt(sqr(SubGlyph^.xx*fi65536)+sqr(SubGlyph^.xy*fi65536)));
        cy:=round(cy*sqrt(sqr(SubGlyph^.yx*fi65536)+sqr(SubGlyph^.yy*fi65536)));
 {$endif}
       end;
      end;

      if fHinting and ((cx<>0) or (cy<>0)) then begin
       for PointIndex:=Offset to GlyphBuffer.CountPoints-1 do begin
        GlyphBuffer.InFontUnitsPoints[PointIndex].x:=GlyphBuffer.InFontUnitsPoints[PointIndex].x+cx;
        GlyphBuffer.InFontUnitsPoints[PointIndex].y:=GlyphBuffer.InFontUnitsPoints[PointIndex].y+cy;
       end;
      end;

      cx:=Scale(cx);
      cy:=Scale(cy);

      if (SubGlyph^.Flags and ROUND_XY_TO_GRID)<>0 then begin
       cx:=(cx+32) and not 63;
       cy:=(cy+32) and not 63;
      end;

      if (cx<>0) or (cy<>0) then begin
       for PointIndex:=Offset to GlyphBuffer.CountPoints-1 do begin
        GlyphBuffer.Points[PointIndex].x:=GlyphBuffer.Points[PointIndex].x+cx;
        GlyphBuffer.Points[PointIndex].y:=GlyphBuffer.Points[PointIndex].y+cy;
       end;
      end;

     end;

     if (fHinting and assigned(fByteCodeInterpreter)) and not fIgnoreByteCodeInterpreter then begin
      try

       Offset:=OriginalCount;

       for PointIndex:=Offset to GlyphBuffer.CountPoints-1 do begin
        GlyphBuffer.UnhintedPoints[PointIndex]:=GlyphBuffer.Points[PointIndex];
       end;

       Count:=(GlyphBuffer.CountPoints-Offset)+4;
       SetLength(fByteCodeInterpreterParameters.pCurrent,Count);
       SetLength(fByteCodeInterpreterParameters.pUnhinted,Count);
       SetLength(fByteCodeInterpreterParameters.pInFontUnits,Count);
       for PointIndex:=Offset to GlyphBuffer.CountPoints-1 do begin
        fByteCodeInterpreterParameters.pCurrent[PointIndex-Offset]:=GlyphBuffer.Points[PointIndex];
        fByteCodeInterpreterParameters.pUnhinted[PointIndex-Offset]:=GlyphBuffer.UnhintedPoints[PointIndex];
        fByteCodeInterpreterParameters.pInFontUnits[PointIndex-Offset]:=GlyphBuffer.InFontUnitsPoints[PointIndex];
       end;

       p.x:=fGlyphs[GlyphIndex].Bounds.XMin-fGlyphs[GlyphIndex].LeftSideBearing;
       p.y:=0;
       p.Flags:=0;
       fByteCodeInterpreterParameters.pInFontUnits[Count-4]:=p;
       fByteCodeInterpreterParameters.pUnhinted[Count-4]:=p;
       fByteCodeInterpreterParameters.pCurrent[Count-4]:=p;

       p.x:=(fGlyphs[GlyphIndex].Bounds.XMin-fGlyphs[GlyphIndex].LeftSideBearing)+fGlyphs[GlyphIndex].AdvanceWidth;
       p.y:=0;
       p.Flags:=0;
       fByteCodeInterpreterParameters.pInFontUnits[Count-3]:=p;
       p.x:=Scale(p.x);
       fByteCodeInterpreterParameters.pUnhinted[Count-3]:=p;
       fByteCodeInterpreterParameters.pCurrent[Count-3]:=p;

       p.x:=0;
       p.y:=fGlyphs[GlyphIndex].Bounds.YMax+fGlyphs[GlyphIndex].TopSideBearing;
       p.Flags:=0;
       fByteCodeInterpreterParameters.pInFontUnits[Count-2]:=p;
       p.y:=Scale(p.y);
       fByteCodeInterpreterParameters.pUnhinted[Count-2]:=p;
       fByteCodeInterpreterParameters.pCurrent[Count-2]:=p;

       p.x:=0;
       p.y:=(fGlyphs[GlyphIndex].Bounds.YMax+fGlyphs[GlyphIndex].TopSideBearing)-fGlyphs[GlyphIndex].AdvanceHeight;
       p.Flags:=0;
       fByteCodeInterpreterParameters.pInFontUnits[Count-1]:=p;
       p.y:=Scale(p.y);
       fByteCodeInterpreterParameters.pUnhinted[Count-1]:=p;
       fByteCodeInterpreterParameters.pCurrent[Count-1]:=p;

       Count:=GlyphBuffer.CountIndices-EndOffset;
       SetLength(fByteCodeInterpreterParameters.Ends,Count);
       for PointIndex:=EndOffset to GlyphBuffer.CountIndices-1 do begin
        fByteCodeInterpreterParameters.Ends[PointIndex-EndOffset]:=GlyphBuffer.EndPointIndices[PointIndex]-EndOffset;
       end;

{$ifdef ttfdebug}
       writeln('GLYF');
       writeln('====');
{$endif}
       fByteCodeInterpreter.Run(fGlyphs[GlyphIndex].Instructions,@fByteCodeInterpreterParameters);
{$ifdef ttfdebug}
       writeln;
{$endif}

       for PointIndex:=Offset to GlyphBuffer.CountPoints-1 do begin
        GlyphBuffer.Points[PointIndex]:=fByteCodeInterpreterParameters.pCurrent[PointIndex-Offset];
        GlyphBuffer.UnhintedPoints[PointIndex]:=fByteCodeInterpreterParameters.pUnhinted[PointIndex-Offset];
        GlyphBuffer.InFontUnitsPoints[PointIndex]:=fByteCodeInterpreterParameters.pInFontUnits[PointIndex-Offset];
       end;

      except
       fByteCodeInterpreter:=nil;
       fIgnoreByteCodeInterpreter:=true;
      end;
     end;

    end else begin

     Offset:=GlyphBuffer.CountPoints;
     DstCount:=Offset;
     SrcCount:=length(fGlyphs[GlyphIndex].Points);
     if SrcCount>0 then begin
      l:=DstCount+SrcCount;
      if (l+1)>=length(GlyphBuffer.Points) then begin
       SetLength(GlyphBuffer.Points,RoundUpToPowerOfTwo(l+1));
      end;
      if fHinting then begin
       if (l+1)>=length(GlyphBuffer.UnhintedPoints) then begin
        SetLength(GlyphBuffer.UnhintedPoints,RoundUpToPowerOfTwo(l+1));
       end;
       if (l+1)>=length(GlyphBuffer.InFontUnitsPoints) then begin
        SetLength(GlyphBuffer.InFontUnitsPoints,RoundUpToPowerOfTwo(l+1));
       end;
      end;
      Move(fGlyphs[GlyphIndex].Points[0],GlyphBuffer.Points[DstCount],SrcCount*SizeOf(TVulkanTrueTypeFontGlyphPoint));
      if fHinting then begin
       Move(fGlyphs[GlyphIndex].Points[0],GlyphBuffer.UnhintedPoints[DstCount],SrcCount*SizeOf(TVulkanTrueTypeFontGlyphPoint));
       Move(fGlyphs[GlyphIndex].Points[0],GlyphBuffer.InFontUnitsPoints[DstCount],SrcCount*SizeOf(TVulkanTrueTypeFontGlyphPoint));
      end;
      GlyphBuffer.CountPoints:=l;
     end;

     EndOffset:=GlyphBuffer.CountIndices;
     DstCount:=EndOffset;
     SrcCount:=length(fGlyphs[GlyphIndex].EndPointIndices);
     if SrcCount>0 then begin
      l:=DstCount+SrcCount;
      if (l+1)>=length(GlyphBuffer.EndPointIndices) then begin
       SetLength(GlyphBuffer.EndPointIndices,RoundUpToPowerOfTwo(l+1));
      end;
      Move(fGlyphs[GlyphIndex].EndPointIndices[0],GlyphBuffer.EndPointIndices[DstCount],SrcCount*SizeOf(TVkInt32));
      GlyphBuffer.CountIndices:=l;
      for l:=0 to SrcCount-1 do begin
       inc(GlyphBuffer.EndPointIndices[l+DstCount],Offset);
      end;
     end;

     if fStyleIndex<>0 then begin
      TransformGlyphBuffer(GlyphBuffer,Offset,DstCount,GlyphBuffer.CountIndices-1);
     end;

     for PointIndex:=Offset to GlyphBuffer.CountPoints-1 do begin
      GlyphBuffer.Points[PointIndex].x:=Scale(GlyphBuffer.Points[PointIndex].x);
      GlyphBuffer.Points[PointIndex].y:=Scale(GlyphBuffer.Points[PointIndex].y);
     end;

     if (fHinting and assigned(fByteCodeInterpreter)) and not fIgnoreByteCodeInterpreter then begin
      try

       for PointIndex:=Offset to GlyphBuffer.CountPoints-1 do begin
        GlyphBuffer.UnhintedPoints[PointIndex]:=GlyphBuffer.Points[PointIndex];
       end;

       Count:=(GlyphBuffer.CountPoints-Offset)+4;
       SetLength(fByteCodeInterpreterParameters.pCurrent,Count);
       SetLength(fByteCodeInterpreterParameters.pUnhinted,Count);
       SetLength(fByteCodeInterpreterParameters.pInFontUnits,Count);
       for PointIndex:=Offset to GlyphBuffer.CountPoints-1 do begin
        fByteCodeInterpreterParameters.pCurrent[PointIndex-Offset]:=GlyphBuffer.Points[PointIndex];
        fByteCodeInterpreterParameters.pUnhinted[PointIndex-Offset]:=GlyphBuffer.UnhintedPoints[PointIndex];
        fByteCodeInterpreterParameters.pInFontUnits[PointIndex-Offset]:=GlyphBuffer.InFontUnitsPoints[PointIndex];
       end;

       p.x:=fGlyphs[GlyphIndex].Bounds.XMin-fGlyphs[GlyphIndex].LeftSideBearing;
       p.y:=0;
       p.Flags:=0;
       fByteCodeInterpreterParameters.pInFontUnits[Count-4]:=p;
       p.x:=Scale(p.x);
       fByteCodeInterpreterParameters.pUnhinted[Count-4]:=p;
       fByteCodeInterpreterParameters.pCurrent[Count-4]:=p;

       p.x:=(fGlyphs[GlyphIndex].Bounds.XMin-fGlyphs[GlyphIndex].LeftSideBearing)+fGlyphs[GlyphIndex].AdvanceWidth;
       p.y:=0;
       p.Flags:=0;
       fByteCodeInterpreterParameters.pInFontUnits[Count-3]:=p;
       p.x:=Scale(p.x);
       fByteCodeInterpreterParameters.pUnhinted[Count-3]:=p;
       fByteCodeInterpreterParameters.pCurrent[Count-3]:=p;

       p.x:=0;
       p.y:=fGlyphs[GlyphIndex].Bounds.YMax+fGlyphs[GlyphIndex].TopSideBearing;
       p.Flags:=0;
       fByteCodeInterpreterParameters.pInFontUnits[Count-2]:=p;
       p.y:=Scale(p.y);
       fByteCodeInterpreterParameters.pUnhinted[Count-2]:=p;
       fByteCodeInterpreterParameters.pCurrent[Count-2]:=p;

       p.x:=0;
       p.y:=(fGlyphs[GlyphIndex].Bounds.YMax+fGlyphs[GlyphIndex].TopSideBearing)-fGlyphs[GlyphIndex].AdvanceHeight;
       p.Flags:=0;
       fByteCodeInterpreterParameters.pInFontUnits[Count-1]:=p;
       p.y:=Scale(p.y);
       fByteCodeInterpreterParameters.pUnhinted[Count-1]:=p;
       fByteCodeInterpreterParameters.pCurrent[Count-1]:=p;

       Count:=GlyphBuffer.CountIndices-EndOffset;
       SetLength(fByteCodeInterpreterParameters.Ends,Count);
       for PointIndex:=EndOffset to GlyphBuffer.CountIndices-1 do begin
        fByteCodeInterpreterParameters.Ends[PointIndex-EndOffset]:=GlyphBuffer.EndPointIndices[PointIndex]-EndOffset;
       end;

{$ifdef ttfdebug}
       writeln('GLYF');
       writeln('====');
{$endif}
       fByteCodeInterpreter.Run(fGlyphs[GlyphIndex].Instructions,@fByteCodeInterpreterParameters);
{$ifdef ttfdebug}
       writeln;
{$endif}

       for PointIndex:=Offset to GlyphBuffer.CountPoints-1 do begin
        GlyphBuffer.Points[PointIndex]:=fByteCodeInterpreterParameters.pCurrent[PointIndex-Offset];
        GlyphBuffer.UnhintedPoints[PointIndex]:=fByteCodeInterpreterParameters.pUnhinted[PointIndex-Offset];
        GlyphBuffer.InFontUnitsPoints[PointIndex]:=fByteCodeInterpreterParameters.pInFontUnits[PointIndex-Offset];
       end;

      except
       fByteCodeInterpreter:=nil;
       fIgnoreByteCodeInterpreter:=true;
      end;
     end;

    end;

   end;

  finally
   fGlyphs[GlyphIndex].Locked:=false;
  end;

 end;

end;

procedure TVulkanTrueTypeFont.ResetPolygonBuffer(var PolygonBuffer:TVulkanTrueTypeFontPolygonBuffer);
begin
 PolygonBuffer.CountCommands:=0;
end;

procedure TVulkanTrueTypeFont.FillPolygonBuffer(var PolygonBuffer:TVulkanTrueTypeFontPolygonBuffer;const GlyphBuffer:TVulkanTrueTypeFontGlyphBuffer);
var StartPointIndex,CommandIndex,CommandCount,i,j,fx,fy,lx,ly,cx,cy,x,y,MiddleX,MiddleY,MaxY:TVkInt32;
    OnCurve:boolean;
begin
 CommandCount:=PolygonBuffer.CountCommands;
 StartPointIndex:=0;
 MaxY:=Scale(fMaxY);
 for i:=0 to GlyphBuffer.CountIndices-1 do begin
  if (GlyphBuffer.EndPointIndices[i]-StartPointIndex)>=0 then begin
   fx:=GlyphBuffer.Points[StartPointIndex].x*4;
   fy:=(MaxY-GlyphBuffer.Points[StartPointIndex].y)*4;
   lx:=GlyphBuffer.Points[GlyphBuffer.EndPointIndices[i]].x*4;
   ly:=(MaxY-GlyphBuffer.Points[GlyphBuffer.EndPointIndices[i]].y)*4;
   cx:=fx;
   cy:=fy;
   OnCurve:=(GlyphBuffer.Points[StartPointIndex].Flags and VkTTF_PathFlag_OnCurve)<>0;
   if (not OnCurve) and ((GlyphBuffer.Points[GlyphBuffer.EndPointIndices[i]].Flags and VkTTF_PathFlag_OnCurve)=0) then begin
    lx:=SARLongint((fx+lx)+1,1);
    ly:=SARLongint((fy+ly)+1,1);
   end;
   CommandIndex:=CommandCount;
   inc(CommandCount);
   if (CommandCount+1)>=length(PolygonBuffer.Commands) then begin
    SetLength(PolygonBuffer.Commands,RoundUpToPowerOfTwo(CommandCount+1));
   end;
   PolygonBuffer.Commands[CommandIndex].CommandType:=VkTTF_PolygonCommandType_MOVETO;
   PolygonBuffer.Commands[CommandIndex].Points[0].x:=fx;
   PolygonBuffer.Commands[CommandIndex].Points[0].y:=fy;
   for j:=StartPointIndex+1 to GlyphBuffer.EndPointIndices[i] do begin
    x:=GlyphBuffer.Points[j].x*4;
    y:=(MaxY-GlyphBuffer.Points[j].y)*4;
    if OnCurve then begin
     OnCurve:=(GlyphBuffer.Points[j].Flags and VkTTF_PathFlag_OnCurve)<>0;
     if OnCurve then begin
      CommandIndex:=CommandCount;
      inc(CommandCount);
      if (CommandCount+1)>=length(PolygonBuffer.Commands) then begin
       SetLength(PolygonBuffer.Commands,RoundUpToPowerOfTwo(CommandCount+1));
      end;
      PolygonBuffer.Commands[CommandIndex].CommandType:=VkTTF_PolygonCommandType_LINETO;
      PolygonBuffer.Commands[CommandIndex].Points[0].x:=x;
      PolygonBuffer.Commands[CommandIndex].Points[0].y:=y;
     end else begin
      cx:=x;
      cy:=y;
     end;
    end else begin
     OnCurve:=(GlyphBuffer.Points[j].Flags and VkTTF_PathFlag_OnCurve)<>0;
     if OnCurve then begin
      CommandIndex:=CommandCount;
      inc(CommandCount);
      if (CommandCount+1)>=length(PolygonBuffer.Commands) then begin
       SetLength(PolygonBuffer.Commands,RoundUpToPowerOfTwo(CommandCount+1));
      end;
      PolygonBuffer.Commands[CommandIndex].CommandType:=VkTTF_PolygonCommandType_QUADRATICCURVETO;
      PolygonBuffer.Commands[CommandIndex].Points[0].x:=cx;
      PolygonBuffer.Commands[CommandIndex].Points[0].y:=cy;
      PolygonBuffer.Commands[CommandIndex].Points[1].x:=x;
      PolygonBuffer.Commands[CommandIndex].Points[1].y:=y;
     end else begin
      MiddleX:=SARLongint((cx+x)+1,1);
      MiddleY:=SARLongint((cy+y)+1,1);
      CommandIndex:=CommandCount;
      inc(CommandCount);
      if (CommandCount+1)>=length(PolygonBuffer.Commands) then begin
       SetLength(PolygonBuffer.Commands,RoundUpToPowerOfTwo(CommandCount+1));
      end;
      PolygonBuffer.Commands[CommandIndex].CommandType:=VkTTF_PolygonCommandType_QUADRATICCURVETO;
      PolygonBuffer.Commands[CommandIndex].Points[0].x:=cx;
      PolygonBuffer.Commands[CommandIndex].Points[0].y:=cy;
      PolygonBuffer.Commands[CommandIndex].Points[1].x:=MiddleX;
      PolygonBuffer.Commands[CommandIndex].Points[1].y:=MiddleY;
      cx:=x;
      cy:=y;
     end;
    end;
   end;
   if (GlyphBuffer.Points[StartPointIndex].Flags and VkTTF_PathFlag_OnCurve)<>0 then begin
    if OnCurve then begin
     CommandIndex:=CommandCount;
     inc(CommandCount);
     if (CommandCount+1)>=length(PolygonBuffer.Commands) then begin
      SetLength(PolygonBuffer.Commands,RoundUpToPowerOfTwo(CommandCount+1));
     end;
     PolygonBuffer.Commands[CommandIndex].CommandType:=VkTTF_PolygonCommandType_LINETO;
     PolygonBuffer.Commands[CommandIndex].Points[0].x:=fx;
     PolygonBuffer.Commands[CommandIndex].Points[0].y:=fy;
    end else begin
     CommandIndex:=CommandCount;
     inc(CommandCount);
     if (CommandCount+1)>=length(PolygonBuffer.Commands) then begin
      SetLength(PolygonBuffer.Commands,RoundUpToPowerOfTwo(CommandCount+1));
     end;
     PolygonBuffer.Commands[CommandIndex].CommandType:=VkTTF_PolygonCommandType_QUADRATICCURVETO;
     PolygonBuffer.Commands[CommandIndex].Points[0].x:=cx;
     PolygonBuffer.Commands[CommandIndex].Points[0].y:=cy;
     PolygonBuffer.Commands[CommandIndex].Points[1].x:=fx;
     PolygonBuffer.Commands[CommandIndex].Points[1].y:=fy;
    end;
   end else begin
    if not OnCurve then begin
     CommandIndex:=length(PolygonBuffer.Commands);
     SetLength(PolygonBuffer.Commands,CommandIndex+1);
     PolygonBuffer.Commands[CommandIndex].CommandType:=VkTTF_PolygonCommandType_QUADRATICCURVETO;
     PolygonBuffer.Commands[CommandIndex].Points[0].x:=cx;
     PolygonBuffer.Commands[CommandIndex].Points[0].y:=cy;
     PolygonBuffer.Commands[CommandIndex].Points[1].x:=lx;
     PolygonBuffer.Commands[CommandIndex].Points[1].y:=ly;
    end;
   end;
  end;
  StartPointIndex:=GlyphBuffer.EndPointIndices[i]+1;
 end;
 CommandIndex:=CommandCount;
 inc(CommandCount);
 if (CommandCount+1)>=length(PolygonBuffer.Commands) then begin
  SetLength(PolygonBuffer.Commands,RoundUpToPowerOfTwo(CommandCount+1));
 end;
 PolygonBuffer.Commands[CommandIndex].CommandType:=VkTTF_PolygonCommandType_CLOSE;
 PolygonBuffer.CountCommands:=CommandCount;
end;

procedure TVulkanTrueTypeFont.FillTextPolygonBuffer(var PolygonBuffer:TVulkanTrueTypeFontPolygonBuffer;const Text:UTF8String;const StartX:TVkInt32=0;const StartY:TVkInt32=0);
var TextIndex,CurrentGlyph,LastGlyph,CurrentX,CurrentY,OffsetX,OffsetY,
    CommandCount,CommandIndex,CommandBaseIndex:TVkInt32;
    GlyphBuffer:TVulkanTrueTypeFontGlyphBuffer;
    GlyphPolygonBuffer:TVulkanTrueTypeFontPolygonBuffer;
    Command:PVulkanTrueTypeFontPolygonCommand;
begin
 Initialize(GlyphBuffer);
 Initialize(GlyphPolygonBuffer);
 try

  CommandCount:=PolygonBuffer.CountCommands;

  CurrentX:=StartX;
  CurrentY:=StartY;

  LastGlyph:=-1;

  TextIndex:=1;
  while TextIndex<=length(Text) do begin

   CurrentGlyph:=GetGlyphIndex(VulkanUTF8CodeUnitGetCharAndIncFallback(Text,TextIndex));
   if (CurrentGlyph>0) or (CurrentGlyph<fCountGlyphs) then begin

    if (LastGlyph>=0) and (LastGlyph<fCountGlyphs) then begin
     inc(CurrentX,GetKerning(LastGlyph,CurrentGlyph,true));
     inc(CurrentY,GetKerning(LastGlyph,CurrentGlyph,false));
    end;

    if LastGlyph<0 then begin
     dec(CurrentX,GetGlyphLeftSideBearing(CurrentGlyph));
     dec(CurrentY,GetGlyphTopSideBearing(CurrentGlyph));
    end;

    ResetGlyphBuffer(GlyphBuffer);
    FillGlyphBuffer(GlyphBuffer,CurrentGlyph);

    ResetPolygonBuffer(GlyphPolygonBuffer);
    FillPolygonBuffer(GlyphPolygonBuffer,GlyphBuffer);

    CommandBaseIndex:=CommandCount;
    inc(CommandCount,GlyphPolygonBuffer.CountCommands);
    if CommandCount>=length(PolygonBuffer.Commands) then begin
     SetLength(PolygonBuffer.Commands,RoundUpToPowerOfTwo(CommandCount+1));
    end;

    // *4 because from 1/64 truetype font units to 1/256 rasterizer units
    OffsetX:=Scale(CurrentX)*4;
    OffsetY:=Scale(CurrentY)*4;

    for CommandIndex:=0 to GlyphPolygonBuffer.CountCommands-1 do begin
     Command:=@PolygonBuffer.Commands[CommandBaseIndex+CommandIndex];
     Command^:=GlyphPolygonBuffer.Commands[CommandIndex];
     inc(Command^.Points[0].x,OffsetX);
     inc(Command^.Points[0].y,OffsetY);
     inc(Command^.Points[1].x,OffsetX);
     inc(Command^.Points[1].y,OffsetY);
    end;

    inc(CurrentX,GetGlyphAdvanceWidth(CurrentGlyph)+fLetterSpacingX);
    inc(CurrentY,GetGlyphAdvanceHeight(CurrentGlyph)+fLetterSpacingY);

   end;

   LastGlyph:=CurrentGlyph;

  end;

  PolygonBuffer.CountCommands:=CommandCount;

 finally
  Finalize(GlyphBuffer);
  Finalize(GlyphPolygonBuffer);
 end;
end;

function TVulkanTrueTypeFont.GetStyleIndex(Thin,Bold,Italic:boolean):TVkInt32;
begin
 if Bold then begin
  if Italic then begin
   result:=5;
  end else begin
   result:=4;
  end;
 end else if Thin then begin
  if Italic then begin
   result:=3;
  end else begin
   result:=2;
  end;
 end else begin
  if Italic then begin
   result:=1;
  end else begin
   result:=0;
  end;
 end;
end;

function TVulkanTrueTypeFont.TextWidth(const Text:UTF8String):TVkInt32;
var TextIndex,CurrentGlyph,LastGlyph,Width,NewWidth:TVkInt32;
begin
 result:=0;
 Width:=0;
 TextIndex:=1;
 LastGlyph:=-1;
 while TextIndex<=length(Text) do begin
  CurrentGlyph:=GetGlyphIndex(VulkanUTF8CodeUnitGetCharAndIncFallback(Text,TextIndex));
  if (CurrentGlyph>0) or (CurrentGlyph<fCountGlyphs) then begin
   if (LastGlyph>=0) and (LastGlyph<fCountGlyphs) then begin
    inc(result,GetKerning(LastGlyph,CurrentGlyph,true));
   end;
   if LastGlyph<0 then begin
    dec(result,GetGlyphLeftSideBearing(CurrentGlyph));
   end;
   if LoadGlyphData(CurrentGlyph)=VkTTF_TT_ERR_NoError then begin
    NewWidth:=result+(fGlyphs[CurrentGlyph].Bounds.XMax-fGlyphs[CurrentGlyph].Bounds.XMin);
    if Width<NewWidth then begin
     Width:=NewWidth;
    end;
   end;
   inc(result,GetGlyphAdvanceWidth(CurrentGlyph)+fLetterSpacingX);
  end;
  LastGlyph:=CurrentGlyph;
 end;
 if result=0 then begin
  result:=fMaxX-fMinX;
 end;
 if result<Width then begin
  result:=Width;
 end;
end;

function TVulkanTrueTypeFont.TextHeight(const Text:UTF8String):TVkInt32;
var TextIndex,CurrentGlyph,LastGlyph,Height,NewHeight:TVkInt32;
begin
 result:=0;
 Height:=0;
 TextIndex:=1;
 LastGlyph:=-1;
 while TextIndex<=length(Text) do begin
  CurrentGlyph:=GetGlyphIndex(VulkanUTF8CodeUnitGetCharAndIncFallback(Text,TextIndex));
  if (CurrentGlyph>0) or (CurrentGlyph<fCountGlyphs) then begin
   if (LastGlyph>=0) and (LastGlyph<fCountGlyphs) then begin
    inc(result,GetKerning(LastGlyph,CurrentGlyph,false));
   end;
   if LastGlyph<0 then begin
    dec(result,GetGlyphTopSideBearing(CurrentGlyph));
   end;
   if LoadGlyphData(CurrentGlyph)=VkTTF_TT_ERR_NoError then begin
    NewHeight:=result+(fGlyphs[CurrentGlyph].Bounds.YMax-fGlyphs[CurrentGlyph].Bounds.YMin);
    if Height<NewHeight then begin
     Height:=NewHeight;
    end;
   end;
   inc(result,GetGlyphAdvanceHeight(CurrentGlyph)+fLetterSpacingY);
  end;
  LastGlyph:=CurrentGlyph;
 end;
 if result=0 then begin
  result:=fMaxY-fMinY;
 end;
 if result<Height then begin
  result:=Height;
 end;
end;

function TVulkanTrueTypeFont.RowHeight(const Percent:TVkInt32):TVkInt32;
begin
 result:=((fUnitsPerEm*Percent)+50) div 100;
end;

function TVulkanTrueTypeFont.GetUnitsPerEm:TVkInt32;
begin
 result:=fUnitsPerEm;
end;

procedure TVulkanTrueTypeFont.GetPolygonBufferBounds(const PolygonBuffer:TVulkanTrueTypeFontPolygonBuffer;out x0,y0,x1,y1:TVkInt32;const Tolerance:TVkInt32=2;const MaxLevel:TVkInt32=32);
var lastcx,lastcy:TVkInt32;
    First:boolean;
 procedure PointAt(x,y:TVkInt32);
 begin
  lastcx:=x;
  lastcy:=y;
  if First then begin
   First:=false;
   x0:=x;
   y0:=y;
   x1:=x;
   y1:=y;
  end else begin
   if x0>x then begin
    x0:=x;
   end;
   if y0>y then begin
    y0:=y;
   end;
   if x1<x then begin
    x1:=x;
   end;
   if y1<y then begin
    y1:=y;
   end;
  end;
 end;
 procedure QuadraticCurveTo(const cx,cy,ax,ay:TVkInt32;const Tolerance:TVkInt32=2;const MaxLevel:TVkInt32=32);
  procedure Recursive(const x1,y1,x2,y2,x3,y3,Level:TVkInt32);
  var x12,y12,x23,y23,x123,y123,mx,my,d:TVkInt32;
  begin
   x12:=SARLongint(x1+x2,1);
   y12:=SARLongint(y1+y2,1);
   x23:=SARLongint(x2+x3,1);
   y23:=SARLongint(y2+y3,1);
   x123:=SARLongint(x12+x23,1);
   y123:=SARLongint(y12+y23,1);
   mx:=SARLongint(x1+x3,1);
   my:=SARLongint(y1+y3,1);
   d:=abs(mx-x123)+abs(my-y123);
   if (Level>MaxLevel) or (d<Tolerance) then begin
    PointAt(x123,y123);
   end else begin
    Recursive(x1,y1,x12,y12,x123,y123,Level+1);
    Recursive(x123,y123,x23,y23,x3,y3,Level+1);
   end;
  end;
 begin
  Recursive(lastcx,lastcy,cx,cy,ax,ay,0);
  PointAt(ax,ay);
 end;
 procedure CubicCurveTo(const c1x,c1y,c2x,c2y,ax,ay:TVkInt32;const Tolerance:TVkInt32=2;const MaxLevel:TVkInt32=32);
  procedure Recursive(const x1,y1,x2,y2,x3,y3,x4,y4,Level:TVkInt32);
  var x12,y12,x23,y23,x34,y34,x123,y123,x234,y234,x1234,y1234,d:TVkInt32;
  begin
   x12:=SARLongint(x1+x2,1);
   y12:=SARLongint(y1+y2,1);
   x23:=SARLongint(x2+x3,1);
   y23:=SARLongint(y2+y3,1);
   x34:=SARLongint(x3+x4,1);
   y34:=SARLongint(y3+y4,1);
   x123:=SARLongint(x12+x23,1);
   y123:=SARLongint(y12+y23,1);
   x234:=SARLongint(x23+x34,1);
   y234:=SARLongint(y23+y34,1);
   x1234:=SARLongint(x123+x234,1);
   y1234:=SARLongint(y123+y234,1);
// d:=abs(SARlongint(x1+x4,1)-x1234)+abs(SARLongint(y1+y4,1)-y1234);
   d:=abs(((x1+x3)-x2)-x2)+abs(((y1+y3)-y2)-y2)+abs(((x2+x4)-x3)-x3)+abs(((y2+y4)-y3)-y3);
   if (Level>MaxLevel) or (d<Tolerance) then begin
    PointAt(x1234,y1234);
   end else begin
    Recursive(x1,y1,x12,y12,x123,y123,x1234,y1234,Level+1);
    Recursive(x1234,y1234,x234,y234,x34,y34,x4,y4,Level+1);
   end;
  end;
 begin
  Recursive(lastcx,lastcy,c1x,c1y,c2x,c2y,ax,ay,0);
  PointAt(ax,ay);
 end;
var CommandIndex:TVkInt32;
begin
 x0:=0;
 y0:=0;
 x1:=0;
 y1:=0;
 First:=true;
 fPolygonBuffer.CountCommands:=0;
 for CommandIndex:=0 to PolygonBuffer.CountCommands-1 do begin
  case PolygonBuffer.Commands[CommandIndex].CommandType of
   VkTTF_PolygonCommandType_MOVETO,VkTTF_PolygonCommandType_LINETO:begin
    PointAt(PolygonBuffer.Commands[CommandIndex].Points[0].x,PolygonBuffer.Commands[CommandIndex].Points[0].y);
   end;
   VkTTF_PolygonCommandType_QUADRATICCURVETO:begin
    QuadraticCurveTo(PolygonBuffer.Commands[CommandIndex].Points[0].x,PolygonBuffer.Commands[CommandIndex].Points[0].y,
                     PolygonBuffer.Commands[CommandIndex].Points[1].x,PolygonBuffer.Commands[CommandIndex].Points[1].y,
                     Tolerance,MaxLevel);
   end;
   VkTTF_PolygonCommandType_CUBICCURVETO:begin
    CubicCurveTo(PolygonBuffer.Commands[CommandIndex].Points[0].x,PolygonBuffer.Commands[CommandIndex].Points[0].y,
                 PolygonBuffer.Commands[CommandIndex].Points[1].x,PolygonBuffer.Commands[CommandIndex].Points[1].y,
                 PolygonBuffer.Commands[CommandIndex].Points[2].x,PolygonBuffer.Commands[CommandIndex].Points[2].y,
                 Tolerance,MaxLevel);
   end;
   VkTTF_PolygonCommandType_CLOSE:begin
   end;
  end;
 end;
end;

procedure TVulkanTrueTypeFont.DrawPolygonBuffer(Rasterizer:TVulkanTrueTypeFontRasterizer;const PolygonBuffer:TVulkanTrueTypeFontPolygonBuffer;x,y:TVkInt32;Tolerance:TVkInt32=2;MaxLevel:TVkInt32=32);
var CommandIndex:TVkInt32;
begin
 if assigned(Rasterizer) then begin
  fPolygonBuffer.CountCommands:=0;
  for CommandIndex:=0 to PolygonBuffer.CountCommands-1 do begin
   case PolygonBuffer.Commands[CommandIndex].CommandType of
    VkTTF_PolygonCommandType_MOVETO:begin
     Rasterizer.MoveTo(x+PolygonBuffer.Commands[CommandIndex].Points[0].x,y+PolygonBuffer.Commands[CommandIndex].Points[0].y);
    end;
    VkTTF_PolygonCommandType_LINETO:begin
     Rasterizer.LineTo(x+PolygonBuffer.Commands[CommandIndex].Points[0].x,y+PolygonBuffer.Commands[CommandIndex].Points[0].y);
    end;
    VkTTF_PolygonCommandType_QUADRATICCURVETO:begin
     Rasterizer.QuadraticCurveTo(x+PolygonBuffer.Commands[CommandIndex].Points[0].x,y+PolygonBuffer.Commands[CommandIndex].Points[0].y,
                                 x+PolygonBuffer.Commands[CommandIndex].Points[1].x,y+PolygonBuffer.Commands[CommandIndex].Points[1].y,
                                 Tolerance,MaxLevel);
    end;
    VkTTF_PolygonCommandType_CUBICCURVETO:begin
     Rasterizer.CubicCurveTo(x+PolygonBuffer.Commands[CommandIndex].Points[0].x,y+PolygonBuffer.Commands[CommandIndex].Points[0].y,
                             x+PolygonBuffer.Commands[CommandIndex].Points[1].x,y+PolygonBuffer.Commands[CommandIndex].Points[1].y,
                             x+PolygonBuffer.Commands[CommandIndex].Points[2].x,y+PolygonBuffer.Commands[CommandIndex].Points[2].y,
                             Tolerance,MaxLevel);
    end;
    VkTTF_PolygonCommandType_CLOSE:begin
     Rasterizer.Close;
    end;
   end;
  end;
 end;
end;

function CompareVulkanFontGlyphsByArea(const a,b:TVkPointer):TVkInt32;
begin
 result:=(PVulkanFontGlyph(b)^.Width*PVulkanFontGlyph(b)^.Height)-(PVulkanFontGlyph(a)^.Width*PVulkanFontGlyph(a)^.Height);
end;

function CompareVulkanFontKerningPairs(const a,b:TVkPointer):TVkInt32;
begin
 result:=TVkInt64(PVulkanFontKerningPair(a)^.Left)-TVkInt64(PVulkanFontKerningPair(b)^.Left);
 if result=0 then begin
  result:=TVkInt64(PVulkanFontKerningPair(a)^.Right)-TVkInt64(PVulkanFontKerningPair(b)^.Right);
 end;
end;                                              

constructor TVulkanFont.Create(const aDevice:TVulkanDevice;const aTargetPPI:TVkInt32=72);
begin

 inherited Create(aDevice);

 fTargetPPI:=aTargetPPI;

 fUnitsPerEm:=72;

 fBaseScaleFactor:=1.0;

 fInverseBaseScaleFactor:=1.0;

 fMinX:=0.0;
 fMinY:=0.0;
 fMaxX:=0.0;
 fMaxY:=0.0;

 fMinimumCodePoint:=High(TVkUInt32);
 fMaximumCodePoint:=Low(TVkUInt32);

 fCodePointBitmap:=nil;

 fGlyphs:=nil;

 fCodePointGlyphPairs:=nil;

 fKerningPairs:=nil;

 fCodePointToGlyphHashMap:=TVulkanInt64HashMap.Create;

 fKerningPairHashMap:=TVulkanInt64HashMap.Create;

{$ifdef PasVulkanPasMP}
 fDistanceFieldJobs:=nil;
{$endif}

 fAutomaticTrim:=false;

end;

constructor TVulkanFont.CreateFromTrueTypeFont(const aDevice:TVulkanDevice;const aTrueTypeFont:TVulkanTrueTypeFont;const aCodePointRanges:array of TVulkanFontCodePointRange);
const GlyphMetaDataScaleFactor=1.0;
      GlyphRasterizationScaleFactor=1.0/256.0;
var Index,TTFGlyphIndex,GlyphIndex,OtherGlyphIndex,CountGlyphs,
    CodePointGlyphPairIndex,CountCodePointGlyphPairs,
    TrueTypeFontKerningIndex,TrueTypeFontKerningPairIndex,
    KerningPairIndex,CountKerningPairs,
    x0,y0,x1,y1:TVkInt32;
    KerningPairDoubleIndex:TVkUInt64;
    CodePointRange:PVulkanFontCodePointRange;
    CodePointIndex,BitmapCodePointIndex:TVkUInt32;
    CodePointBitmap:TVulkanFontCodePointBitmap;
    CodePointToTTFGlyphHashMap:TVulkanInt64HashMap;
    TTFGlyphToGlyphHashMap:TVulkanInt64HashMap;
    GlyphToTTFGlyphHashMap:TVulkanInt64HashMap;
    KerningPairHashMap:TVulkanInt64HashMap;
    Int64HashMapData:TVulkanInt64HashMapData;
    Glyph:PVulkanFontGlyph;
    GlyphBuffer:TVulkanTrueTypeFontGlyphBuffer;
    PolygonBuffers:TVulkanTrueTypeFontPolygonBuffers;
    SortedGlyphs:TPVulkanFontGlyphs;
    DistanceField:TVulkanFontDistanceField;
    TrueTypeFontKerningTable:PVulkanTrueTypeFontKerningTable;
    TrueTypeFontKerningPair:PVulkanTrueTypeFontKerningPair;
    CodePointGlyphPair:PVulkanFontCodePointGlyphPair;
    KerningPair:PVulkanFontKerningPair;
    GlyphDistanceField:PVulkanFontDistanceField;
    GlyphDistanceFields:TVulkanFontDistanceFields;
{$ifdef PasVulkanPasMP}
    PasMPInstance:TPasMP;
    GlyphDistanceFieldJob:PVulkanFontDistanceFieldJob;
{$endif}
begin

 Create(aDevice,aTrueTypeFont.fTargetPPI);

{$ifdef PasVulkanPasMP}
 PasMPInstance:=GetVulkanPasMP;
{$endif}

 fUnitsPerEm:=aTrueTypeFont.GetUnitsPerEm;

 fBaseScaleFactor:=aTrueTypeFont.GetScaleFactor;

 fInverseBaseScaleFactor:=1.0/fBaseScaleFactor;

 fMinX:=aTrueTypeFont.MinX;
 fMinY:=aTrueTypeFont.MinY;
 fMaxX:=aTrueTypeFont.MaxX;
 fMaxY:=aTrueTypeFont.MaxY;

 for Index:=low(aCodePointRanges) to high(aCodePointRanges) do begin
  CodePointRange:=@aCodePointRanges[Index];
  fMinimumCodePoint:=Min(fMinimumCodePoint,Min(CodePointRange^.FromCodePoint,CodePointRange^.ToCodePoint));
  fMaximumCodePoint:=Max(fMaximumCodePoint,Max(CodePointRange^.FromCodePoint,CodePointRange^.ToCodePoint));
 end;

 if fMinimumCodePoint<=fMaximumCodePoint then begin

  SetLength(CodePointBitmap,((fMaximumCodePoint-fMinimumCodePoint)+32) shr 5);

  FillChar(CodePointBitmap[0],length(CodePointBitmap)*SizeOf(TVkUInt32),#0);

  for Index:=low(aCodePointRanges) to high(aCodePointRanges) do begin
   CodePointRange:=@aCodePointRanges[Index];
   for CodePointIndex:=Min(CodePointRange^.FromCodePoint,CodePointRange^.ToCodePoint) to Max(CodePointRange^.FromCodePoint,CodePointRange^.ToCodePoint) do begin
    BitmapCodePointIndex:=CodePointIndex-fMinimumCodePoint;
    CodePointBitmap[BitmapCodePointIndex shr 5]:=CodePointBitmap[BitmapCodePointIndex shr 5] or (TVkUInt32(1) shl (BitmapCodePointIndex and 31));
   end;
  end;

  TTFGlyphToGlyphHashMap:=TVulkanInt64HashMap.Create;
  try

   GlyphToTTFGlyphHashMap:=TVulkanInt64HashMap.Create;
   try

    // Collect used glyphs
    CodePointToTTFGlyphHashMap:=TVulkanInt64HashMap.Create;
    try
     CountGlyphs:=0;
     CountCodePointGlyphPairs:=0;
     try
      for CodePointIndex:=fMinimumCodePoint to fMaximumCodePoint do begin
       BitmapCodePointIndex:=CodePointIndex-fMinimumCodePoint;
       if (CodePointBitmap[BitmapCodePointIndex shr 5] and (TVkUInt32(1) shl (BitmapCodePointIndex and 31)))<>0 then begin
        TTFGlyphIndex:=aTrueTypeFont.GetGlyphIndex(CodePointIndex);
        if (TTFGlyphIndex>=0) and (TTFGlyphIndex<aTrueTypeFont.CountGlyphs) then begin
         if not CodePointToTTFGlyphHashMap.ExistKey(CodePointIndex) then begin
          CodePointToTTFGlyphHashMap.Add(CodePointIndex,{%H-}TVkPointer(TVkPtrUInt(TTFGlyphIndex)));
          if TTFGlyphToGlyphHashMap.TryGet(TTFGlyphIndex,Int64HashMapData) then begin
           GlyphIndex:={%H-}TVkPtrUInt(TVkPointer(Int64HashMapData));
          end else begin
           GlyphIndex:=CountGlyphs;
           inc(CountGlyphs);
           TTFGlyphToGlyphHashMap.Add(TTFGlyphIndex,{%H-}TVkPointer(TVkPtrUInt(GlyphIndex)));
           GlyphToTTFGlyphHashMap.Add(GlyphIndex,{%H-}TVkPointer(TVkPtrUInt(TTFGlyphIndex)));
          end;
          fCodePointToGlyphHashMap.Add(CodePointIndex,{%H-}TVkPointer(TVkPtrUInt(GlyphIndex)));
          CodePointGlyphPairIndex:=CountCodePointGlyphPairs;
          inc(CountCodePointGlyphPairs);
          if length(fCodePointGlyphPairs)<CountCodePointGlyphPairs then begin
           SetLength(fCodePointGlyphPairs,CountCodePointGlyphPairs*2);
          end;
          CodePointGlyphPair:=@fCodePointGlyphPairs[CodePointGlyphPairIndex];
          CodePointGlyphPair^.CodePoint:=CodePointIndex;
          CodePointGlyphPair^.Glyph:=GlyphIndex;
         end;
        end;
       end;
      end;
     finally
      SetLength(fGlyphs,CountGlyphs);
      SetLength(fCodePointGlyphPairs,CountCodePointGlyphPairs);
     end;
    finally
     CodePointToTTFGlyphHashMap.Free;
    end;

    // Convert glyph data and get polygon data
    PolygonBuffers:=nil;
    try

     SetLength(PolygonBuffers,CountGlyphs);

     for GlyphIndex:=0 to CountGlyphs-1 do begin

      Glyph:=@fGlyphs[GlyphIndex];

      FillChar(Glyph^,SizeOf(TVulkanFontGlyph),#0);

      if GlyphToTTFGlyphHashMap.TryGet(GlyphIndex,Int64HashMapData) then begin

       TTFGlyphIndex:={%H-}TVkPtrUInt(TVkPointer(Int64HashMapData));

       Glyph^.AdvanceWidth:=aTrueTypeFont.GetGlyphAdvanceWidth(TTFGlyphIndex)*GlyphMetaDataScaleFactor;
       Glyph^.AdvanceHeight:=aTrueTypeFont.GetGlyphAdvanceHeight(TTFGlyphIndex)*GlyphMetaDataScaleFactor;
       Glyph^.LeftSideBearing:=aTrueTypeFont.GetGlyphLeftSideBearing(TTFGlyphIndex)*GlyphMetaDataScaleFactor;
       Glyph^.RightSideBearing:=aTrueTypeFont.GetGlyphRightSideBearing(TTFGlyphIndex)*GlyphMetaDataScaleFactor;
       Glyph^.TopSideBearing:=aTrueTypeFont.GetGlyphTopSideBearing(TTFGlyphIndex)*GlyphMetaDataScaleFactor;
       Glyph^.BottomSideBearing:=aTrueTypeFont.GetGlyphBottomSideBearing(TTFGlyphIndex)*GlyphMetaDataScaleFactor;
       Glyph^.BoundsMinX:=aTrueTypeFont.Glyphs[TTFGlyphIndex].Bounds.XMin*GlyphMetaDataScaleFactor;
       Glyph^.BoundsMinY:=aTrueTypeFont.Glyphs[TTFGlyphIndex].Bounds.YMin*GlyphMetaDataScaleFactor;
       Glyph^.BoundsMaxX:=aTrueTypeFont.Glyphs[TTFGlyphIndex].Bounds.XMax*GlyphMetaDataScaleFactor;
       Glyph^.BoundsMaxY:=aTrueTypeFont.Glyphs[TTFGlyphIndex].Bounds.YMax*GlyphMetaDataScaleFactor;

       GlyphBuffer.Points:=nil;
       PolygonBuffers[GlyphIndex].Commands:=nil;
       try
        aTrueTypeFont.ResetGlyphBuffer(GlyphBuffer);
        aTrueTypeFont.FillGlyphBuffer(GlyphBuffer,TTFGlyphIndex);

        aTrueTypeFont.ResetPolygonBuffer(PolygonBuffers[GlyphIndex]);
        aTrueTypeFont.FillPolygonBuffer(PolygonBuffers[GlyphIndex],GlyphBuffer);

        aTrueTypeFont.GetPolygonBufferBounds(PolygonBuffers[GlyphIndex],x0,y0,x1,y1);

        Glyph^.OffsetX:=(x0*GlyphRasterizationScaleFactor)-(VulkanFontDistanceFieldSpreadValue*2.0);
        Glyph^.OffsetY:=(y0*GlyphRasterizationScaleFactor)-(VulkanFontDistanceFieldSpreadValue*2.0);
        Glyph^.Width:=Max(1,ceil(((x1-x0)*GlyphRasterizationScaleFactor)+(VulkanFontDistanceFieldSpreadValue*4.0)));
        Glyph^.Height:=Max(1,ceil(((y1-y0)*GlyphRasterizationScaleFactor)+(VulkanFontDistanceFieldSpreadValue*4.0)));

       finally
        GlyphBuffer.Points:=nil;
       end;

      end;
     end;

     GlyphDistanceFields:=nil;
     try

      SetLength(GlyphDistanceFields,CountGlyphs);

{$ifdef PasVulkanPasMP}
      fDistanceFieldJobs:=nil;
      try

       SetLength(fDistanceFieldJobs,CountGlyphs);
{$endif}

       // Rasterize glyph signed distance field sprites
       for GlyphIndex:=0 to CountGlyphs-1 do begin
        Glyph:=@fGlyphs[GlyphIndex];
        GlyphDistanceField:=@GlyphDistanceFields[GlyphIndex];
        GlyphDistanceField^.OffsetX:=-Glyph^.OffsetX;
        GlyphDistanceField^.OffsetY:=-Glyph^.OffsetY;
        GlyphDistanceField^.Width:=Max(1,Glyph^.Width);
        GlyphDistanceField^.Height:=Max(1,Glyph^.Height);
        GlyphDistanceField^.Pixels:=nil;
        SetLength(GlyphDistanceField^.Pixels,GlyphDistanceField^.Width*GlyphDistanceField^.Height);
{$ifdef PasVulkanPasMP}
        GlyphDistanceFieldJob:=@fDistanceFieldJobs[GlyphIndex];
        GlyphDistanceFieldJob^.DistanceField:=GlyphDistanceField;
        GlyphDistanceFieldJob^.MultiChannel:=false;
        GlyphDistanceFieldJob^.PolygonBuffer:=PolygonBuffers[GlyphIndex];
{$else}
        GenerateSignedDistanceField(GlyphDistanceField^,false,PolygonBuffers[GlyphIndex]);
{$endif}
       end;

{$ifdef PasVulkanPasMP}
       if CountGlyphs>0 then begin
        PasMPInstance.Invoke(PasMPInstance.ParallelFor(@fDistanceFieldJobs[0],0,CountGlyphs-1,GenerateSignedDistanceFieldParallelForJobFunction,1,10,nil,0));
       end;

      finally
       fDistanceFieldJobs:=nil;
      end;
{$endif}

      // Insert glyph signed distance field sprites by sorted area size order
      SortedGlyphs:=nil;
      try

       SetLength(SortedGlyphs,length(fGlyphs));

       for GlyphIndex:=0 to length(fGlyphs)-1 do begin
        SortedGlyphs[GlyphIndex]:=@fGlyphs[GlyphIndex];
       end;

       if length(SortedGlyphs)>1 then begin
        IndirectIntroSort(@SortedGlyphs[0],0,length(SortedGlyphs)-1,CompareVulkanFontGlyphsByArea);
       end;

       for GlyphIndex:=0 to length(SortedGlyphs)-1 do begin
        Glyph:=SortedGlyphs[GlyphIndex];
        if (Glyph^.Width>0) and (Glyph^.Height>0) then begin
         OtherGlyphIndex:={$H-}((TVkPtrUInt(TVkPointer(Glyph))-TVkPtrUInt(TVkPointer(@fGlyphs[0])))) div SizeOf(TVulkanFontGlyph);
         Glyph^.Sprite:=LoadRawSprite(TVulkanRawByteString(String('glyph'+IntToStr(OtherGlyphIndex))),
                                      @GlyphDistanceFields[OtherGlyphIndex].Pixels[0],
                                      Glyph^.Width,
                                      Glyph^.Height);
        end;
       end;

      finally
       SortedGlyphs:=nil;
      end;

     finally
      GlyphDistanceFields:=nil;
     end;

    finally
     PolygonBuffers:=nil;
    end;

   finally
    GlyphToTTFGlyphHashMap.Free;
   end;

   // Convert kerning pair lookup data
   fKerningPairs:=nil;
   CountKerningPairs:=0;
   try
    KerningPairHashMap:=TVulkanInt64HashMap.Create;
    try
     for TrueTypeFontKerningIndex:=0 to length(aTrueTypeFont.fKerningTables)-1 do begin
      TrueTypeFontKerningTable:=@aTrueTypeFont.fKerningTables[TrueTypeFontKerningIndex];
      for TrueTypeFontKerningPairIndex:=0 to length(TrueTypeFontKerningTable^.KerningPairs)-1 do begin
       TrueTypeFontKerningPair:=@TrueTypeFontKerningTable^.KerningPairs[TrueTypeFontKerningPairIndex];
       if TTFGlyphToGlyphHashMap.TryGet(TrueTypeFontKerningPair^.Left,Int64HashMapData) then begin
        GlyphIndex:={%H-}TVkPtrUInt(TVkPointer(Int64HashMapData));
        if TTFGlyphToGlyphHashMap.TryGet(TrueTypeFontKerningPair^.Right,Int64HashMapData) then begin
         OtherGlyphIndex:={%H-}TVkPtrUInt(TVkPointer(Int64HashMapData));
         KerningPairDoubleIndex:=CombineTwoUInt32IntoOneUInt64(GlyphIndex,OtherGlyphIndex);
         if not KerningPairHashMap.ExistKey(KerningPairDoubleIndex) then begin
          KerningPairIndex:=CountKerningPairs;
          inc(CountKerningPairs);
          if length(fKerningPairs)<CountKerningPairs then begin
           SetLength(fKerningPairs,CountKerningPairs*2);
          end;
          KerningPairHashMap.Add(KerningPairDoubleIndex,{%H-}TVkPointer(TVkPtrUInt(KerningPairIndex)));
          KerningPair:=@fKerningPairs[KerningPairIndex];
          KerningPair^.Left:=TrueTypeFontKerningPair^.Left;
          KerningPair^.Right:=TrueTypeFontKerningPair^.Right;
          KerningPair^.Horizontal:=aTrueTypeFont.GetKerning(KerningPair^.Left,KerningPair^.Right,true);
          KerningPair^.Vertical:=aTrueTypeFont.GetKerning(KerningPair^.Left,KerningPair^.Right,false);
         end;
        end;
       end;
      end;
     end;
    finally
     KerningPairHashMap.Free;
    end;
   finally
    SetLength(fKerningPairs,CountKerningPairs);
    if length(fKerningPairs)>1 then begin
     DirectIntroSort(@fKerningPairs[0],0,length(fKerningPairs)-1,SizeOf(TVulkanFontKerningPair),CompareVulkanFontKerningPairs);
    end;
    for KerningPairIndex:=0 to length(fKerningPairs)-1 do begin
     KerningPair:=@fKerningPairs[KerningPairIndex];
     KerningPairDoubleIndex:=CombineTwoUInt32IntoOneUInt64(KerningPair^.Left,KerningPair^.Right);
     fKerningPairHashMap.Add(KerningPairDoubleIndex,{%H-}TVkPointer(TVkPtrUInt(KerningPairIndex)));
    end;
   end;
               
  finally
   TTFGlyphToGlyphHashMap.Free;
  end;

 end;

end;

destructor TVulkanFont.Destroy;
begin

 fCodePointBitmap:=nil;

 fGlyphs:=nil;

 fCodePointGlyphPairs:=nil;

 fKerningPairs:=nil;

 fCodePointToGlyphHashMap.Free;

 fKerningPairHashMap.Free;

{$ifdef PasVulkanPasMP}
 fDistanceFieldJobs:=nil;
{$endif}

 inherited Destroy;
end;

class function TVulkanFont.CodePointRange(const aFromCodePoint,aToCodePoint:TVkUInt32): TVulkanFontCodePointRange;
begin
 result.FromCodePoint:=Min(aFromCodePoint,aToCodePoint);
 result.ToCodePoint:=Max(aFromCodePoint,aToCodePoint);
end;

class function TVulkanFont.CodePointRange(const aFromCodePoint,aToCodePoint:WideChar):TVulkanFontCodePointRange;
begin
 result.FromCodePoint:=Min(TVkUInt16(WideChar(aFromCodePoint)),TVkUInt16(WideChar(aToCodePoint)));
 result.ToCodePoint:=Max(TVkUInt16(WideChar(aFromCodePoint)),TVkUInt16(WideChar(aToCodePoint)));
end;

class function TVulkanFont.CodePointRange(const aCharacterRange:TVulkanFontCharacterRange):TVulkanFontCodePointRange;
var Index:AnsiChar;
begin
 result.FromCodePoint:=High(TVkUInt32);
 result.ToCodePoint:=Low(TVkUInt32);
 for Index:=Low(AnsiChar) to High(AnsiChar) do begin
  if Index in aCharacterRange then begin
   result.FromCodePoint:=TVkUInt8(AnsiChar(Index));
   break;
  end;
 end;
 for Index:=High(AnsiChar) downto Low(AnsiChar) do begin
  if Index in aCharacterRange then begin
   result.ToCodePoint:=TVkUInt8(AnsiChar(Index));
   break;
  end;
 end;
end;

function TVulkanFont.GetScaleFactor(const aSize:TVkFloat):TVkFloat;
begin
 if aSize<0.0 then begin
  result:=(-aSize)/fUnitsPerEm;
 end else begin
  result:=(aSize*fTargetPPI)/(fUnitsPerEm*72);
 end;
end;

procedure TVulkanFont.GenerateSignedDistanceField(var DistanceField:TVulkanFontDistanceField;const MultiChannel:boolean;const PolygonBuffer:TVulkanTrueTypeFontPolygonBuffer);
const DistanceFieldSpreadValue=VulkanFontDistanceFieldSpreadValue;
      DistanceFieldMagnitudeValue=DistanceFieldSpreadValue;
      DistanceFieldPadValue=DistanceFieldSpreadValue;
      Scalar1Value=1.0;
      CloseValue=Scalar1Value/16.0;
      CloseSquaredValue=CloseValue*CloseValue;
      NearlyZeroValue=Scalar1Value/int64(1 shl 18);
      TangentToleranceValue=Scalar1Value/int64(1 shl 11);
      RasterizerToScreenScale=1.0/256.0;
type PPathSegmentSide=^TPathSegmentSide;
     TPathSegmentSide=
      (
       pssLeft=-1,
       pssOn=0,
       pssRight=1,
       pssNone=2
      );
     PDistanceFieldDataItem=^TDistanceFieldDataItem;
     TDistanceFieldDataItem=record
      SquaredDistance:TVkFloat;
      SquaredDistanceR:TVkFloat;
      SquaredDistanceG:TVkFloat;
      SquaredDistanceB:TVkFloat;
      PseudoSquaredDistanceR:TVkFloat;
      PseudoSquaredDistanceG:TVkFloat;
      PseudoSquaredDistanceB:TVkFloat;
      DeltaWindingScore:TVkInt32;
     end;
     TDistanceFieldData=array of TDistanceFieldDataItem;
     PDoublePrecisionPoint=^TDoublePrecisionPoint;
     TDoublePrecisionPoint=record
      x:TVkDouble;
      y:TVkDouble;
     end;
     PDoublePrecisionAffineMatrix=^TDoublePrecisionAffineMatrix;
     TDoublePrecisionAffineMatrix=array[0..5] of TVkDouble;
     PPathSegmentType=^TPathSegmentType;
     TPathSegmentType=
      (
       pstLine,
       pstQuadraticBezierCurve
      );
     PBoundingBox=^TBoundingBox;
     TBoundingBox=record
      Min:TDoublePrecisionPoint;
      Max:TDoublePrecisionPoint;
     end;
     PPathSegmentColor=^TPathSegmentColor;
     TPathSegmentColor=
      (
       pscBlack=0,
       pscRed=1,
       pscGreen=2,
       pscYellow=3,
       pscBlue=4,
       pscMagenta=5,
       pscCyan=6,
       pscWhite=7
      );
     PPathSegmentPoints=^TPathSegmentPoints;
     TPathSegmentPoints=array[0..2] of TDoublePrecisionPoint;
     PPathSegment=^TPathSegment;
     TPathSegment=record
      Type_:TPathSegmentType;
      Color:TPathSegmentColor;
      Points:TPathSegmentPoints;
      P0T,P2T:TDoublePrecisionPoint;
      XFormMatrix:TDoublePrecisionAffineMatrix;
      ScalingFactor:TVkDouble;
      SquaredScalingFactor:TVkDouble;
      NearlyZeroScaled:TVkDouble;
      SquaredTangentToleranceScaled:TVkDouble;
      BoundingBox:TBoundingBox;
     end;
     TPathSegments=array of TPathSegment;
     PContour=^TContour;
     TContour=record
      PathSegments:TPathSegments;
      CountPathSegments:TVkInt32;
     end;
     TContours=array of TContour;
     PShape=^TShape;
     TShape=record
      Contours:TContours;
      CountContours:TVkInt32;
     end;
     PRowDataIntersectionType=^TRowDataIntersectionType;
     TRowDataIntersectionType=
      (
       rditNoIntersection,
       rditVerticalLine,
       rditTangentLine,
       rditTwoPointsIntersect
      );
     PRowData=^TRowData;
     TRowData=record
      IntersectionType:TRowDataIntersectionType;
      QuadraticXDirection:TVkInt32;
      ScanlineXDirection:TVkInt32;
      YAtIntersection:TVkFloat;
      XAtIntersection:array[0..1] of TVkFloat;
     end;
 const DoublePrecisionAffineMatrixIdentity:TDoublePrecisionAffineMatrix=(1.0,0.0,0.0,0.0,1.0,0.0);
 function Clamp(const Value,MinValue,MaxValue:TVkInt64):TVkInt64; overload;
 begin
  if Value<=MinValue then begin
   result:=MinValue;
  end else if Value>=MaxValue then begin
   result:=MaxValue;
  end else begin
   result:=Value;
  end;
 end;
 function Clamp(const Value,MinValue,MaxValue:TVkDouble):TVkDouble; overload;
 begin
  if Value<=MinValue then begin
   result:=MinValue;
  end else if Value>=MaxValue then begin
   result:=MaxValue;
  end else begin
   result:=Value;
  end;
 end;
 function DoublePrecisionPointAdd(const a,b:TDoublePrecisionPoint):TDoublePrecisionPoint;
 begin
  result.x:=a.x+b.x;
  result.y:=a.y+b.y;
 end;
 function DoublePrecisionPointSub(const a,b:TDoublePrecisionPoint):TDoublePrecisionPoint;
 begin
  result.x:=a.x-b.x;
  result.y:=a.y-b.y;
 end;
 function DoublePrecisionPointLength(const p:TDoublePrecisionPoint):TVkDouble;
 begin
  result:=sqrt(sqr(p.x)+sqr(p.y));
 end;
 function DoublePrecisionPointDistance(const a,b:TDoublePrecisionPoint):TVkDouble;
 begin
  result:=sqrt(sqr(a.x-b.x)+sqr(a.y-b.y));
 end;
 function DoublePrecisionPointLengthSquared(const v:TDoublePrecisionPoint):TVkDouble;
 begin
  result:=sqr(v.x)+sqr(v.y);
 end;
 function DoublePrecisionPointDistanceSquared(const a,b:TDoublePrecisionPoint):TVkDouble;
 begin
  result:=sqr(a.x-b.x)+sqr(a.y-b.y);
 end;
 function DoublePrecisionPointCrossProduct(const a,b:TDoublePrecisionPoint):TVkDouble;
 begin
  result:=(a.x*b.y)-(a.y*b.x);
 end;
 function DoublePrecisionPointDotProduct(const a,b:TDoublePrecisionPoint):TVkDouble;
 begin
  result:=(a.x*b.x)+(a.y*b.y);
 end;
 function DoublePrecisionPointNormalize(const v:TDoublePrecisionPoint):TDoublePrecisionPoint;
 var f:TVkDouble;
 begin
  f:=sqr(v.x)+sqr(v.y);
  if IsZero(f) then begin
   result.x:=0.0;
   result.y:=0.0;
  end else begin
   result.x:=v.x/f;
   result.y:=v.y/f;
  end;
 end;
 function DoublePrecisionPointLerp(const a,b:TDoublePrecisionPoint;const t:TVkDouble):TDoublePrecisionPoint;
 begin
  if t<=0.0 then begin
   result:=a;
  end else if t>=1.0 then begin
   result:=b;
  end else begin
   result.x:=(a.x*(1.0-t))+(b.x*t);
   result.y:=(a.y*(1.0-t))+(b.y*t);
  end;
 end;
 function DoublePrecisionPointMap(const p:TDoublePrecisionPoint;const m:TDoublePrecisionAffineMatrix):TDoublePrecisionPoint;
 begin
  result.x:=(p.x*m[0])+(p.y*m[1])+m[2];
  result.y:=(p.x*m[3])+(p.y*m[4])+m[5];
 end;
 function BetweenClosedOpen(const a,b,c:TVkDouble;const Tolerance:TVkDouble=0.0;const XFormToleranceToX:boolean=false):boolean;
 var ToleranceB,ToleranceC:TVkDouble;
 begin
  Assert(Tolerance>=0.0);
  if XFormToleranceToX then begin
   ToleranceB:=Tolerance/sqrt((sqr(b)*4.0)+1.0);
   ToleranceC:=Tolerance/sqrt((sqr(c)*4.0)+1.0);
  end else begin
   ToleranceB:=Tolerance;
   ToleranceC:=Tolerance;
  end;
  if b<c then begin
   result:=(a>=(b-ToleranceB)) and (a<(c-ToleranceC));
  end else begin
   result:=(a>=(c-ToleranceC)) and (a<(b-ToleranceB));
  end;
 end;
 function BetweenClosed(const a,b,c:TVkDouble;const Tolerance:TVkDouble=0.0;const XFormToleranceToX:boolean=false):boolean;
 var ToleranceB,ToleranceC:TVkDouble;
 begin
  Assert(Tolerance>=0.0);
  if XFormToleranceToX then begin
   ToleranceB:=Tolerance/sqrt((sqr(b)*4.0)+1.0);
   ToleranceC:=Tolerance/sqrt((sqr(c)*4.0)+1.0);
  end else begin
   ToleranceB:=Tolerance;
   ToleranceC:=Tolerance;
  end;
  if b<c then begin
   result:=(a>=(b-ToleranceB)) and (a<=(c+ToleranceC));
  end else begin
   result:=(a>=(c-ToleranceC)) and (a<=(b+ToleranceB));
  end;
 end;
 function NearlyZero(const Value:TVkDouble;const Tolerance:TVkDouble=NearlyZeroValue):boolean;
 begin
  Assert(Tolerance>=0.0);
  result:=abs(Value)<=Tolerance;
 end;
 function NearlyEqual(const x,y:TVkDouble;const Tolerance:TVkDouble=NearlyZeroValue;const XFormToleranceToX:boolean=false):boolean;
 begin
  Assert(Tolerance>=0.0);
  if XFormToleranceToX then begin
   result:=abs(x-y)<=(Tolerance/sqrt((sqr(y)*4.0)+1.0));
  end else begin
   result:=abs(x-y)<=Tolerance;
  end;
 end;
 function SignOf(const Value:TVkDouble):TVkInt32;
 begin
  if Value<0.0 then begin
   result:=-1;
  end else begin
   result:=1;
  end;
 end;
 function IsColinear(const Points:array of TDoublePrecisionPoint):boolean;
 begin
  Assert(length(Points)=3);
  result:=abs(((Points[1].y-Points[0].y)*(Points[1].x-Points[2].x))-
              ((Points[1].y-Points[2].y)*(Points[1].x-Points[0].x)))<=CloseSquaredValue;
 end;
 function PathSegmentDirection(const PathSegment:TPathSegment;const Which:TVkInt32):TDoublePrecisionPoint;
 begin
  case PathSegment.Type_ of
   pstLine:begin
    result.x:=PathSegment.Points[1].x-PathSegment.Points[0].x;
    result.y:=PathSegment.Points[1].y-PathSegment.Points[0].y;
   end;
   pstQuadraticBezierCurve:begin
    case Which of
     0:begin
      result.x:=PathSegment.Points[1].x-PathSegment.Points[0].x;
      result.y:=PathSegment.Points[1].y-PathSegment.Points[0].y;
     end;
     1:begin
      result.x:=PathSegment.Points[2].x-PathSegment.Points[1].x;
      result.y:=PathSegment.Points[2].y-PathSegment.Points[1].y;
     end;
     else begin
      result.x:=0.0;
      result.y:=0.0;
      Assert(false);
     end;
    end;
   end;
   else begin
    result.x:=0.0;
    result.y:=0.0;
    Assert(false);
   end;
  end;
 end;
 function PathSegmentCountPoints(const PathSegment:TPathSegment):TVkInt32;
 begin
  case PathSegment.Type_ of
   pstLine:begin
    result:=2;
   end;
   pstQuadraticBezierCurve:begin
    result:=3;
   end;
   else begin
    result:=0;
    Assert(false);
   end;
  end;
 end;
 function PathSegmentEndPoint(const PathSegment:TPathSegment):PDoublePrecisionPoint;
 begin
  case PathSegment.Type_ of
   pstLine:begin
    result:=@PathSegment.Points[1];
   end;
   pstQuadraticBezierCurve:begin
    result:=@PathSegment.Points[2];
   end;
   else begin
    result:=nil;
    Assert(false);
   end;
  end;
 end;
 function PathSegmentCornerPoint(const PathSegment:TPathSegment;const WhichA,WhichB:TVkInt32):PDoublePrecisionPoint;
 begin
  case PathSegment.Type_ of
   pstLine:begin
    result:=@PathSegment.Points[WhichB and 1];
   end;
   pstQuadraticBezierCurve:begin
    result:=@PathSegment.Points[(WhichA and 1)+(WhichB and 1)];
   end;
   else begin
    result:=nil;
    Assert(false);
   end;
  end;
 end;
 procedure InitializePathSegment(var PathSegment:TPathSegment);
 var p0,p1,p2,p1mp0,d,t,sp0,sp1,sp2,p01p,p02p,p12p:TDoublePrecisionPoint;
     Hypotenuse,CosTheta,SinTheta,a,b,h,c,g,f,gd,fd,x,y,Lambda:TVkDouble;
 begin
  case PathSegment.Type_ of
   pstLine:begin
    p0:=PathSegment.Points[0];
    p2:=PathSegment.Points[1];
    PathSegment.BoundingBox.Min.x:=Min(p0.x,p2.x);
    PathSegment.BoundingBox.Min.y:=Min(p0.y,p2.y);
    PathSegment.BoundingBox.Max.x:=Max(p0.x,p2.x);
    PathSegment.BoundingBox.Max.y:=Max(p0.y,p2.y);
    PathSegment.ScalingFactor:=1.0;
    PathSegment.SquaredScalingFactor:=1.0;
    Hypotenuse:=DoublePrecisionPointDistance(p0,p2);
    CosTheta:=(p2.x-p0.x)/Hypotenuse;
    SinTheta:=(p2.y-p0.y)/Hypotenuse;
    PathSegment.XFormMatrix[0]:=CosTheta;
    PathSegment.XFormMatrix[1]:=SinTheta;
    PathSegment.XFormMatrix[2]:=(-(CosTheta*p0.x))-(SinTheta*p0.y);
    PathSegment.XFormMatrix[3]:=-SinTheta;
    PathSegment.XFormMatrix[4]:=CosTheta;
    PathSegment.XFormMatrix[5]:=(SinTheta*p0.x)-(CosTheta*p0.y);
   end;
   else {pstQuad:}begin
    p0:=PathSegment.Points[0];
    p1:=PathSegment.Points[1];
    p2:=PathSegment.Points[2];
    PathSegment.BoundingBox.Min.x:=Min(p0.x,p2.x);
    PathSegment.BoundingBox.Min.y:=Min(p0.y,p2.y);
    PathSegment.BoundingBox.Max.x:=Max(p0.x,p2.x);
    PathSegment.BoundingBox.Max.y:=Max(p0.y,p2.y);
    p1mp0.x:=p1.x-p0.x;
    p1mp0.y:=p1.y-p0.y;
    d.x:=(p1mp0.x-p2.x)+p1.x;
    d.y:=(p1mp0.y-p2.y)+p1.y;
    if IsZero(d.x) then begin
     t.x:=p0.x;
    end else begin
     t.x:=p0.x+(Clamp(p1mp0.x/d.x,0.0,1.0)*p1mp0.x);
    end;
    if IsZero(d.y) then begin
     t.y:=p0.y;
    end else begin
     t.y:=p0.y+(Clamp(p1mp0.y/d.y,0.0,1.0)*p1mp0.y);
    end;
    PathSegment.BoundingBox.Min.x:=Min(PathSegment.BoundingBox.Min.x,t.x);
    PathSegment.BoundingBox.Min.y:=Min(PathSegment.BoundingBox.Min.y,t.y);
    PathSegment.BoundingBox.Max.x:=Max(PathSegment.BoundingBox.Max.x,t.x);
    PathSegment.BoundingBox.Max.y:=Max(PathSegment.BoundingBox.Max.y,t.y);
    sp0.x:=sqr(p0.x);
    sp0.y:=sqr(p0.y);
    sp1.x:=sqr(p1.x);
    sp1.y:=sqr(p1.y);
    sp2.x:=sqr(p2.x);
    sp2.y:=sqr(p2.y);
    p01p.x:=p0.x*p1.x;
    p01p.y:=p0.y*p1.y;
    p02p.x:=p0.x*p2.x;
    p02p.y:=p0.y*p2.y;
    p12p.x:=p1.x*p2.x;
    p12p.y:=p1.y*p2.y;
    a:=sqr((p0.y-(2.0*p1.y))+p2.y);
    h:=-(((p0.y-(2.0*p1.y))+p2.y)*((p0.x-(2.0*p1.x))+p2.x));
    b:=sqr((p0.x-(2.0*p1.x))+p2.x);
    c:=((((((sp0.x*sp2.y)-(4.0*p01p.x*p12p.y))-(2.0*p02p.x*p02p.y))+(4.0*p02p.x*sp1.y))+(4.0*sp1.x*p02p.y))-(4.0*p12p.x*p01p.y))+(sp2.x*sp0.y);
    g:=((((((((((p0.x*p02p.y)-(2.0*p0.x*sp1.y))+(2.0*p0.x*p12p.y))-(p0.x*sp2.y))+(2.0*p1.x*p01p.y))-(4.0*p1.x*p02p.y))+(2.0*p1.x*p12p.y))-(p2.x*sp0.y))+(2.0*p2.x*p01p.y))+(p2.x*p02p.y))-(2.0*p2.x*sp1.y);
    f:=-(((((((((((sp0.x*p2.y)-(2.0*p01p.x*p1.y))-(2.0*p01p.x*p2.y))-(p02p.x*p0.y))+(4.0*p02p.x*p1.y))-(p02p.x*p2.y))+(2.0*sp1.x*p0.y))+(2.0*sp1.x*p2.y))-(2.0*p12p.x*p0.y))-(2.0*p12p.x*p1.y))+(sp2.x*p0.y));
    CosTheta:=sqrt(a/(a+b));
    SinTheta:=(-SignOf((a+b)*h))*sqrt(b/(a+b));
    gd:=(CosTheta*g)-(SinTheta*f);
    fd:=(SinTheta*g)+(CosTheta*f);
    x:=gd/(a+b);
    y:=(1.0/(2.0*fd))*(c-(sqr(gd)/(a+b)));
    Lambda:=-((a+b)/(2.0*fd));
    PathSegment.ScalingFactor:=abs(1.0/Lambda);
    PathSegment.SquaredScalingFactor:=sqr(PathSegment.ScalingFactor);
    CosTheta:=CosTheta*Lambda;
    SinTheta:=SinTheta*Lambda;
    PathSegment.XFormMatrix[0]:=CosTheta;
    PathSegment.XFormMatrix[1]:=-SinTheta;
    PathSegment.XFormMatrix[2]:=x*Lambda;
    PathSegment.XFormMatrix[3]:=SinTheta;
    PathSegment.XFormMatrix[4]:=CosTheta;
    PathSegment.XFormMatrix[5]:=y*Lambda;
   end;
  end;
  PathSegment.NearlyZeroScaled:=NearlyZeroValue/PathSegment.ScalingFactor;
  PathSegment.SquaredTangentToleranceScaled:=sqr(TangentToleranceValue)/PathSegment.SquaredScalingFactor;
  PathSegment.P0T:=DoublePrecisionPointMap(p0,PathSegment.XFormMatrix);
  PathSegment.P2T:=DoublePrecisionPointMap(p2,PathSegment.XFormMatrix);
 end;
 procedure InitializeDistances(var Data:TDistanceFieldData);
 var Index:TVkInt32;
 begin
  for Index:=0 to length(Data)-1 do begin
   Data[Index].SquaredDistance:=sqr(DistanceFieldMagnitudeValue);
   Data[Index].SquaredDistanceR:=sqr(DistanceFieldMagnitudeValue);
   Data[Index].SquaredDistanceG:=sqr(DistanceFieldMagnitudeValue);
   Data[Index].SquaredDistanceB:=sqr(DistanceFieldMagnitudeValue);
   Data[Index].PseudoSquaredDistanceR:=sqr(DistanceFieldMagnitudeValue);
   Data[Index].PseudoSquaredDistanceG:=sqr(DistanceFieldMagnitudeValue);
   Data[Index].PseudoSquaredDistanceB:=sqr(DistanceFieldMagnitudeValue);
   Data[Index].DeltaWindingScore:=0;
  end;
 end;
 function AddLineToPathSegmentArray(var Contour:TContour;const Points:array of TDoublePrecisionPoint):TVkInt32;
 var PathSegment:PPathSegment;
 begin
  Assert(length(Points)=2);
  result:=Contour.CountPathSegments;
  inc(Contour.CountPathSegments);
  if length(Contour.PathSegments)<=Contour.CountPathSegments then begin
   SetLength(Contour.PathSegments,Contour.CountPathSegments*2);
  end;
  PathSegment:=@Contour.PathSegments[result];
  PathSegment^.Type_:=pstLine;
  PathSegment^.Color:=pscBlack;
  PathSegment^.Points[0]:=Points[0];
  PathSegment^.Points[1]:=Points[1];
  InitializePathSegment(PathSegment^);
 end;
 function AddQuadraticBezierCurveToPathSegmentArray(var Contour:TContour;const Points:array of TDoublePrecisionPoint):TVkInt32;
 var PathSegment:PPathSegment;
 begin
  Assert(length(Points)=3);
  result:=Contour.CountPathSegments;
  if (DoublePrecisionPointDistanceSquared(Points[0],Points[1])<CloseSquaredValue) or
     (DoublePrecisionPointDistanceSquared(Points[1],Points[2])<CloseSquaredValue) or
     IsColinear(Points) then begin
   if not (SameValue(Points[0].x,Points[2].x) and SameValue(Points[0].y,Points[2].y)) then begin
    inc(Contour.CountPathSegments);
    if length(Contour.PathSegments)<=Contour.CountPathSegments then begin
     SetLength(Contour.PathSegments,Contour.CountPathSegments*2);
    end;
    PathSegment:=@Contour.PathSegments[result];
    PathSegment^.Type_:=pstLine;
    PathSegment^.Color:=pscBlack;
    PathSegment^.Points[0]:=Points[0];
    PathSegment^.Points[1]:=Points[2];
    InitializePathSegment(PathSegment^);
   end;
  end else begin
   inc(Contour.CountPathSegments);
   if length(Contour.PathSegments)<=Contour.CountPathSegments then begin
    SetLength(Contour.PathSegments,Contour.CountPathSegments*2);
   end;
   PathSegment:=@Contour.PathSegments[result];
   PathSegment^.Type_:=pstQuadraticBezierCurve;
   PathSegment^.Color:=pscBlack;
   PathSegment^.Points[0]:=Points[0];
   PathSegment^.Points[1]:=Points[1];
   PathSegment^.Points[2]:=Points[2];
   InitializePathSegment(PathSegment^);
  end;
 end;
 function AddQuadraticBezierCurveAsSubdividedLinesToPathSegmentArray(var Contour:TContour;const Points:array of TDoublePrecisionPoint;const Tolerance:TVkDouble=RasterizerToScreenScale;const MaxLevel:TVkInt32=32):TVkInt32;
 var LastPoint:TDoublePrecisionPoint;
  procedure LineToPointAt(const Point:TDoublePrecisionPoint);
  begin
   AddLineToPathSegmentArray(Contour,[LastPoint,Point]);
   LastPoint:=Point;
  end;
  procedure Recursive(const x1,y1,x2,y2,x3,y3:TVkDouble;const Level:TVkInt32);
  var x12,y12,x23,y23,x123,y123,mx,my,d:TVkDouble;
      Point:TDoublePrecisionPoint;
  begin
   x12:=(x1+x2)*0.5;
   y12:=(y1+y2)*0.5;
   x23:=(x2+x3)*0.5;
   y23:=(y2+y3)*0.5;
   x123:=(x12+x23)*0.5;
   y123:=(y12+y23)*0.5;
   mx:=(x1+x3)*0.5;
   my:=(y1+y3)*0.5;
   d:=abs(mx-x123)+abs(my-y123);
   if (Level>MaxLevel) or (d<Tolerance) then begin
    Point.x:=x123;
    Point.y:=y123;
    LineToPointAt(Point);
   end else begin
    Recursive(x1,y1,x12,y12,x123,y123,level+1);
    Recursive(x123,y123,x23,y23,x3,y3,level+1);
   end;
  end;
 begin
  Assert(length(Points)=3);
  result:=Contour.CountPathSegments;
  LastPoint:=Points[0];
  Recursive(Points[0].x,Points[0].y,Points[1].x,Points[1].y,Points[2].x,Points[2].y,0);
  LineToPointAt(Points[2]);
 end;
 function AddCubicBezierCurveAsSubdividedQuadraticBezierCurvesToPathSegmentArray(var Contour:TContour;const Points:array of TDoublePrecisionPoint):TVkInt32;
 type TLine=record
       a,b,c:TVkDouble;
       Exist,Vertical:boolean;
      end;
      TPointLine=record
       p:TDoublePrecisionPoint;
       l:TLine;
      end;
 var LastPoint:TDoublePrecisionPoint;
  procedure MoveTo(const p:TDoublePrecisionPoint);
  begin
   LastPoint:=p;
  end;
  procedure LineTo(const p:TDoublePrecisionPoint);
  begin
   AddLineToPathSegmentArray(Contour,[LastPoint,p]);
   LastPoint:=p;
  end;
  procedure CurveTo(const p0,p1:TDoublePrecisionPoint);
  begin
   AddQuadraticBezierCurveToPathSegmentArray(Contour,[LastPoint,p0,p1]);
   LastPoint:=p1;
  end;
  function GetLine(const P0,P1:TDoublePrecisionPoint):TLine;
  begin
   FillChar(result,SizeOf(TLine),#0);
   if SameValue(P0.x,P1.x) then begin
    if SameValue(P0.y,P1.y) then begin
     // P0 and P1 are same point, return null
     result.Exist:=false;
     result.Vertical:=false;
    end else begin
     // Otherwise, the line is a vertical line
     result.Exist:=true;
     result.Vertical:=true;
     result.c:=P0.x;
    end;
   end else begin
    result.Exist:=true;
    result.Vertical:=false;
    result.a:=(P0.y-P1.y)/(P0.x-P1.x);
    result.b:=P0.y-(result.a*P0.x);
   end;
  end;
  function GetLine2(const P0,v0:TDoublePrecisionPoint):TLine;
  begin
   FillChar(result,SizeOf(TLine),#0);
   result.Exist:=true;
   if IsZero(v0.x) then begin
    // The line is vertical
    result.Vertical:=true;
    result.c:=p0.x;
   end else begin
    result.Vertical:=false;
    result.a:=v0.y/v0.x;
    result.b:=P0.y-(result.a*P0.x);
   end;
  end;
  function GetLineCross(const l0,l1:TLine;var b:boolean):TDoublePrecisionPoint;
  var u:TVkDouble;
  begin

   result.x:=0.0;
   result.y:=0.0;

   // Make sure both line exists
   b:=false;
   if (not l0.exist) or (not l1.exist) then begin
    exit;
   end;

   // Checks whether both lines are vertical
   if (not l0.vertical) and (not l1.vertical) then begin

    // Lines are not verticals but parallel, intersection does not exist
    if l0.a=l1.a then begin
     exit;
    end;

    // Calculate common x value.
    u:=(l1.b-l0.b)/(l0.a-l1.a);

    // Return the new point
    result.x:=u;
    result.y:=(l0.a*u)+l0.b;
   end else begin
    if l0.Vertical then begin
     if l1.Vertical then begin
      // Both lines vertical, intersection does not exist
      exit;
     end else begin
      // Return the point on l1 with x = c0
      result.x:=l0.c;
      result.y:=(l1.a*l0.c)+l1.b;
     end;
    end else if l1.Vertical then begin
     // No need to test c0 as it was tested above, return the point on l0 with x = c1
     result.x:=l1.c;
     result.y:=(l0.a*l1.c)+l0.b;
    end;
   end;

   // We're done!
   b:=true;
  end;
  function GetCubicPoint(const c0,c1,c2,c3,t:TVkDouble):TVkDouble;
  var ts,g,b,a:TVkDouble;
  begin
   ts:=t*t;
   g:=3*(c1-c0);
   b:=(3*(c2-c1))-g;
   a:=((c3-c0)-b)-g;
   result:=(a*ts*t)+(b*ts)+(g*t)+c0;
  end;
  function GetCubicDerivative(const c0,c1,c2,c3,t:TVkDouble):TVkDouble;
  var g,b,a:TVkDouble;
  begin
   g:=3*(c1-c0);
   b:=(3*(c2-c1))-g;
   a:=((c3-c0)-b)-g;
   result:=(3*a*t*t)+(2*b*t)+g;
  end;
  function GetCubicTangent(const P0,P1,P2,P3:TDoublePrecisionPoint;t:TVkDouble):TPointLine;
  var P,V:TDoublePrecisionPoint;
      l:TLine;
  begin

   // Calculates the position of the cubic bezier at t
   P.x:=GetCubicPoint(P0.x,P1.x,P2.x,P3.x,t);
   P.y:=GetCubicPoint(P0.y,P1.y,P2.y,P3.y,t);

   // Calculates the tangent values of the cubic bezier at t
   V.x:=GetCubicDerivative(P0.x,P1.x,P2.x,P3.x,t);
   V.y:=GetCubicDerivative(P0.y,P1.y,P2.y,P3.y,t);

   // Calculates the line equation for the tangent at t
   l:=GetLine2(P,V);

   // Return the Point/Tangent object
   result.P:=P;
   result.l:=l;

  end;
  procedure CubicCurveToTangent(const P0,P1,P2,P3:TDoublePrecisionPoint);
  const NumberOfSegments=8;
   function SliceCubicBezierSegment(const p0,p1,p2,p3:TDoublePrecisionPoint;const u1,u2:TVkDouble;const Tu1,Tu2:TPointLine;Recursion:TVkInt32):TVkInt32;
   var P,ControlPoint:TDoublePrecisionPoint;
       b:boolean;
       d,uMid:TVkDouble;
       TuMid:TPointLine;
   begin

    // Prevents infinite recursion (no more than 10 levels) if 10 levels are reached the latest subsegment is approximated with a line (no quadratic curve). It should be good enough.
    if Recursion>10 then begin
     P:=Tu2.P;
     LineTo(P);
     result:=1;
     exit;
    end;

    // Recursion level is OK, process current segment
    ControlPoint:=GetLineCross(Tu1.l,Tu2.l,b);

    // A control point is considered misplaced if its distance from one of the anchor is greater
    // than the distance between the two anchors.
    d:=DoublePrecisionPointDistance(Tu1.P,Tu2.P);
    if (not b) or (DoublePrecisionPointDistance(Tu1.P,ControlPoint)>d) or (DoublePrecisionPointDistance(Tu2.P,ControlPoint)>d) then begin

     // Total for this subsegment starts at 0
     result:=0;

     // If the Control Point is misplaced, slice the segment more
     uMid:=(u1+u2)*0.5;
     TuMid:=GetCubicTangent(P0,P1,P2,P3,uMid);
     inc(result,SliceCubicBezierSegment(P0,P1,P2,P3,u1,uMid,Tu1,TuMid,Recursion+1));
     inc(result,SliceCubicBezierSegment(P0,P1,P2,P3,uMid,u2,TuMid,Tu2,Recursion+1));

    end else begin

     // If everything is OK draw curve
     P:=Tu2.P;
     CurveTo(ControlPoint,P);
     result:=1;

    end;
   end;
  var CurrentTime,NextTime:TPointLine;
      TimeStep:TVkDouble;
      i:TVkInt32;
  begin

   // Get the time step from number of output segments
   TimeStep:=1.0/NumberOfSegments;

   // Get the first tangent Object
   CurrentTime.P:=P0;
   CurrentTime.l:=GetLine(P0,P1);

   MoveTo(P0);

   // Get tangent objects for all intermediate segments and draw the segments
   for i:=1 to NumberOfSegments do begin

    // Get tangent object for next point
    NextTime:=GetCubicTangent(P0,P1,P2,P3,i*TimeStep);

    // Get segment data for the current segment
    SliceCubicBezierSegment(P0,P1,P2,P3,(i-1)*TimeStep,i*TimeStep,CurrentTime,NextTime,0);

    // Prepare for next round
    CurrentTime:=NextTime;

   end;

  end;
 begin
  Assert(length(Points)=4);
  result:=Contour.CountPathSegments;
  CubicCurveToTangent(Points[0],Points[1],Points[2],Points[3]);
 end;
 function AddCubicBezierCurveAsSubdividedLinesToPathSegmentArray(var Contour:TContour;const Points:array of TDoublePrecisionPoint;const Tolerance:TVkDouble=RasterizerToScreenScale;const MaxLevel:TVkInt32=32):TVkInt32;
 var LastPoint:TDoublePrecisionPoint;
  procedure LineToPointAt(const Point:TDoublePrecisionPoint);
  begin
   AddLineToPathSegmentArray(Contour,[LastPoint,Point]);
   LastPoint:=Point;
  end;
  procedure Recursive(const x1,y1,x2,y2,x3,y3,x4,y4:TVkDouble;const Level:TVkInt32);
  var x12,y12,x23,y23,x34,y34,x123,y123,x234,y234,x1234,y1234,mx,my,d:TVkDouble;
      Point:TDoublePrecisionPoint;
  begin
   x12:=(x1+x2)*0.5;
   y12:=(y1+y2)*0.5;
   x23:=(x2+x3)*0.5;
   y23:=(y2+y3)*0.5;
   x34:=(x3+x4)*0.5;
   y34:=(y3+y4)*0.5;
   x123:=(x12+x23)*0.5;
   y123:=(y12+y23)*0.5;
   x234:=(x23+x34)*0.5;
   y234:=(y23+y34)*0.5;
   x1234:=(x123+x234)*0.5;
   y1234:=(y123+y234)*0.5;
   mx:=(x1+x4)*0.5;
   my:=(y1+y4)*0.5;
   d:=abs(mx-x1234)+abs(my-y1234);
   if (Level>MaxLevel) or (d<Tolerance) then begin
    Point.x:=x1234;
    Point.y:=y1234;
    LineToPointAt(Point);
   end else begin
    Recursive(x1,y1,x12,y12,x123,y123,x1234,y1234,Level+1);
    Recursive(x1234,y1234,x234,y234,x34,y34,x4,y4,Level+1);
   end;
  end;
 begin
  Assert(length(Points)=4);
  result:=Contour.CountPathSegments;
  LastPoint:=Points[0];
  Recursive(Points[0].x,Points[0].y,Points[1].x,Points[1].y,Points[2].x,Points[2].y,Points[3].x,Points[3].y,0);
  LineToPointAt(Points[3]);
 end;
 function CubeRoot(Value:TVkDouble):TVkDouble;
 begin
  if IsZero(Value) then begin
   result:=0.0;
  end else begin
   result:=exp(ln(abs(Value))/3.0);
   if Value<0.0 then begin
    result:=-result;
   end;
  end;
 end;
 function CalculateNearestPointForQuadraticBezierCurve(const PathSegment:TPathSegment;const XFormPoint:TDoublePrecisionPoint):TVkDouble;
 const OneDiv3=1.0/3.0;
       OneDiv27=1.0/27.0;
 var a,b,a3,b2,c,SqrtC,CosPhi,Phi:TVkDouble;
 begin
  a:=0.5-XFormPoint.y;
  b:=(-0.5)*XFormPoint.x;
  a3:=sqr(a)*a;
  b2:=sqr(b);
  c:=(b2*0.25)+(a3*OneDiv27);
  if c>=0.0 then begin
   SqrtC:=sqrt(c);
   b:=b*(-0.5);
   result:=CubeRoot(b+SqrtC)+CubeRoot(b-SqrtC);
  end else begin
   CosPhi:=sqrt((b2*0.25)*((-27.0)/a3));
   if b>0.0 then begin
    CosPhi:=-CosPhi;
   end;
   Phi:=ArcCos(CosPhi);
   if XFormPoint.x>0.0 then begin
    result:=2.0*sqrt(a*(-OneDiv3))*cos(Phi*OneDiv3);
    if not BetweenClosed(result,PathSegment.P0T.x,PathSegment.P2T.x) then begin
     result:=2.0*sqrt(a*(-OneDiv3))*cos((Phi*OneDiv3)+(pi*2.0*OneDiv3));
    end;
   end else begin
    result:=2.0*sqrt(a*(-OneDiv3))*cos((Phi*OneDiv3)+(pi*2.0*OneDiv3));
    if not BetweenClosed(result,PathSegment.P0T.x,PathSegment.P2T.x) then begin
     result:=2.0*sqrt(a*(-OneDiv3))*cos(Phi*OneDiv3);
    end;
   end;
  end;
 end;
 procedure PrecomputationForRow(out RowData:TRowData;const PathSegment:TPathSegment;const PointLeft,PointRight:TDoublePrecisionPoint);
 var XFormPointLeft,XFormPointRight:TDoublePrecisionPoint;
     x0,y0,x1,y1,m,b,m2,c,Tolerance,d:TVkDouble;
 begin
  if PathSegment.Type_=pstQuadraticBezierCurve then begin
   XFormPointLeft:=DoublePrecisionPointMap(PointLeft,PathSegment.XFormMatrix);
   XFormPointRight:=DoublePrecisionPointMap(PointRight,PathSegment.XFormMatrix);
   RowData.QuadraticXDirection:=SignOf(PathSegment.P2T.x-PathSegment.P0T.x);
   RowData.ScanlineXDirection:=SignOf(XFormPointRight.x-XFormPointLeft.x);
   x0:=XFormPointLeft.x;
   y0:=XFormPointLeft.y;
   x1:=XFormPointRight.x;
   y1:=XFormPointRight.y;
   if NearlyEqual(x0,x1,PathSegment.NearlyZeroScaled,true) then begin
    RowData.IntersectionType:=rditVerticalLine;
    RowData.YAtIntersection:=sqr(x0);
    RowData.ScanlineXDirection:=0;
   end else begin
    m:=(y1-y0)/(x1-x0);
    b:=y0-(m*x0);
    m2:=sqr(m);
    c:=m2+(4.0*b);
    Tolerance:=(4.0*PathSegment.SquaredTangentToleranceScaled)/(m2+1.0);
    if (RowData.ScanlineXDirection=1) and
       (SameValue(PathSegment.Points[0].y,PointLeft.y) or
        SameValue(PathSegment.Points[2].y,PointLeft.y)) and
        NearlyZero(c,Tolerance) then begin
     RowData.IntersectionType:=rditTangentLine;
     RowData.XAtIntersection[0]:=m*0.5;
     RowData.XAtIntersection[1]:=m*0.5;
    end else if c<=0.0 then begin
     RowData.IntersectionType:=rditNoIntersection;
    end else begin
     RowData.IntersectionType:=rditTwoPointsIntersect;
     d:=sqrt(c);
     RowData.XAtIntersection[0]:=(m+d)*0.5;
     RowData.XAtIntersection[1]:=(m-d)*0.5;
    end;
   end;
  end;
 end;
 function CalculateSideOfQuadraticBezierCurve(const PathSegment:TPathSegment;const Point,XFormPoint:TDoublePrecisionPoint;const RowData:TRowData):TPathSegmentSide;
 var p0,p1:TVkDouble;
     sp0,sp1:TVkInt32;
     ip0,ip1:boolean;
 begin
  case RowData.IntersectionType of
   rditVerticalLine:begin
    result:=TPathSegmentSide(TVkInt32(SignOf(XFormPoint.y-RowData.YAtIntersection)*RowData.QuadraticXDirection));
   end;
   rditTwoPointsIntersect:begin
    result:=pssNone;
    p0:=RowData.XAtIntersection[0];
    p1:=RowData.XAtIntersection[1];
    sp0:=SignOf(p0-XFormPoint.x);
    ip0:=true;
    ip1:=true;
    if RowData.ScanlineXDirection=1 then begin
     if ((RowData.QuadraticXDirection=-1) and
         (PathSegment.Points[0].y<=Point.y) and
         NearlyEqual(PathSegment.P0T.x,p0,PathSegment.NearlyZeroScaled,true)) or
        ((RowData.QuadraticXDirection=1) and
         (PathSegment.Points[2].y<=Point.y) and
         NearlyEqual(PathSegment.P2T.x,p0,PathSegment.NearlyZeroScaled,true)) then begin
      ip0:=false;
     end;
     if ((RowData.QuadraticXDirection=-1) and
         (PathSegment.Points[2].y<=Point.y) and
         NearlyEqual(PathSegment.P2T.x,p1,PathSegment.NearlyZeroScaled,true)) or
        ((RowData.QuadraticXDirection=1) and
         (PathSegment.Points[0].y<=Point.y) and
         NearlyEqual(PathSegment.P0T.x,p1,PathSegment.NearlyZeroScaled,true)) then begin
      ip1:=false;
     end;
    end;
    if ip0 and BetweenClosed(p0,PathSegment.P0T.x,PathSegment.P2T.x,PathSegment.NearlyZeroScaled,true) then begin
     result:=TPathSegmentSide(TVkInt32(sp0*RowData.QuadraticXDirection));
    end;
    if ip1 and BetweenClosed(p1,PathSegment.P0T.x,PathSegment.P2T.x,PathSegment.NearlyZeroScaled,true) then begin
     sp1:=SignOf(p1-XFormPoint.x);
     if (result=pssNone) or (sp1=1) then begin
      result:=TPathSegmentSide(TVkInt32(-sp1*RowData.QuadraticXDirection));
     end;
    end;
   end;
   rditTangentLine:begin
    result:=pssNone;
    if RowData.ScanlineXDirection=1 then begin
     if SameValue(PathSegment.Points[0].y,Point.y) then begin
      result:=TPathSegmentSide(TVkInt32(SignOf(RowData.XAtIntersection[0]-XFormPoint.x)));
     end else if SameValue(PathSegment.Points[2].y,Point.y) then begin
      result:=TPathSegmentSide(TVkInt32(SignOf(XFormPoint.x-RowData.XAtIntersection[0])));
     end;
    end;
   end;
   else begin
    result:=pssNone;
   end;
  end;
 end;
 function DistanceToPathSegment(const Point:TDoublePrecisionPoint;const PathSegment:TPathSegment;const RowData:TRowData;out PathSegmentSide:TPathSegmentSide):TVkDouble;
 var XFormPoint,x:TDoublePrecisionPoint;
     NearestPoint:TVkDouble;
 begin
  XFormPoint:=DoublePrecisionPointMap(Point,PathSegment.XFormMatrix);
  case PathSegment.Type_ of
   pstLine:begin
    if BetweenClosed(XFormPoint.x,PathSegment.P0T.x,PathSegment.P2T.x) then begin
     result:=sqr(XFormPoint.y);
    end else if XFormPoint.x<PathSegment.P0T.x then begin
     result:=sqr(XFormPoint.x)+sqr(XFormPoint.y);
    end else begin
     result:=sqr(XFormPoint.x-PathSegment.P2T.x)+sqr(XFormPoint.y);
    end;
    if BetweenClosedOpen(Point.y,PathSegment.BoundingBox.Min.y,PathSegment.BoundingBox.Max.y) then begin
     PathSegmentSide:=TPathSegmentSide(TVkInt32(SignOf(XFormPoint.y)));
    end else begin
     PathSegmentSide:=pssNone;
    end;
   end;
   pstQuadraticBezierCurve:begin
    NearestPoint:=CalculateNearestPointForQuadraticBezierCurve(PathSegment,XFormPoint);
    if BetweenClosed(NearestPoint,PathSegment.P0T.x,PathSegment.P2T.x) then begin
     x.x:=NearestPoint;
     x.y:=sqr(NearestPoint);
     result:=DoublePrecisionPointDistanceSquared(XFormPoint,x)*PathSegment.SquaredScalingFactor;
    end else begin
     result:=Min(DoublePrecisionPointDistanceSquared(XFormPoint,PathSegment.P0T),
                 DoublePrecisionPointDistanceSquared(XFormPoint,PathSegment.P2T))*PathSegment.SquaredScalingFactor;
    end;
    if BetweenClosedOpen(Point.y,PathSegment.BoundingBox.Min.y,PathSegment.BoundingBox.Max.y) then begin
     PathSegmentSide:=CalculateSideOfQuadraticBezierCurve(PathSegment,Point,XFormPoint,RowData);
    end else begin
     PathSegmentSide:=pssNone;
    end;
   end;
   else begin
    PathSegmentSide:=pssNone;
    result:=0.0;
   end;
  end;
 end;
 procedure ConvertShape(out Shape:TShape;const DoSubdivideCurvesIntoLines:boolean);
 var CommandIndex:TVkInt32;
     Contour:PContour;
     StartPoint,LastPoint,ControlPoint,OtherControlPoint,Point:TDoublePrecisionPoint;
 begin
  Shape.Contours:=nil;
  Shape.CountContours:=0;
  try
   Contour:=nil;
   try
    StartPoint.x:=0.0;
    StartPoint.y:=0.0;
    LastPoint.x:=0.0;
    LastPoint.y:=0.0;
    for CommandIndex:=0 to PolygonBuffer.CountCommands-1 do begin
     case PolygonBuffer.Commands[CommandIndex].CommandType of
      VkTTF_PolygonCommandType_MOVETO:begin
       if assigned(Contour) then begin
        SetLength(Contour^.PathSegments,Contour^.CountPathSegments);
       end;
       if length(Shape.Contours)<(Shape.CountContours+1) then begin
        SetLength(Shape.Contours,(Shape.CountContours+1)*2);
       end;
       Contour:=@Shape.Contours[Shape.CountContours];
       inc(Shape.CountContours);
       LastPoint.x:=(PolygonBuffer.Commands[CommandIndex].Points[0].x*RasterizerToScreenScale)+DistanceField.OffsetX;
       LastPoint.y:=(PolygonBuffer.Commands[CommandIndex].Points[0].y*RasterizerToScreenScale)+DistanceField.OffsetY;
       StartPoint:=LastPoint;
      end;
      VkTTF_PolygonCommandType_LINETO:begin
       Point.x:=(PolygonBuffer.Commands[CommandIndex].Points[0].x*RasterizerToScreenScale)+DistanceField.OffsetX;
       Point.y:=(PolygonBuffer.Commands[CommandIndex].Points[0].y*RasterizerToScreenScale)+DistanceField.OffsetY;
       if assigned(Contour) and not (SameValue(LastPoint.x,Point.x) and SameValue(LastPoint.y,Point.y)) then begin
        AddLineToPathSegmentArray(Contour^,[LastPoint,Point]);
       end;
       LastPoint:=Point;
      end;
      VkTTF_PolygonCommandType_QUADRATICCURVETO:begin
       ControlPoint.x:=(PolygonBuffer.Commands[CommandIndex].Points[0].x*RasterizerToScreenScale)+DistanceField.OffsetX;
       ControlPoint.y:=(PolygonBuffer.Commands[CommandIndex].Points[0].y*RasterizerToScreenScale)+DistanceField.OffsetY;
       Point.x:=(PolygonBuffer.Commands[CommandIndex].Points[1].x*RasterizerToScreenScale)+DistanceField.OffsetX;
       Point.y:=(PolygonBuffer.Commands[CommandIndex].Points[1].y*RasterizerToScreenScale)+DistanceField.OffsetY;
       if assigned(Contour) and not ((SameValue(LastPoint.x,Point.x) and SameValue(LastPoint.y,Point.y)) and
                                     (SameValue(LastPoint.x,ControlPoint.x) and SameValue(LastPoint.y,ControlPoint.y))) then begin
        if DoSubdivideCurvesIntoLines then begin
         AddQuadraticBezierCurveAsSubdividedLinesToPathSegmentArray(Contour^,[LastPoint,ControlPoint,Point]);
        end else begin
         AddQuadraticBezierCurveToPathSegmentArray(Contour^,[LastPoint,ControlPoint,Point]);
        end;
       end;
       LastPoint:=Point;
      end;
      VkTTF_PolygonCommandType_CUBICCURVETO:begin
       ControlPoint.x:=(PolygonBuffer.Commands[CommandIndex].Points[0].x*RasterizerToScreenScale)+DistanceField.OffsetX;
       ControlPoint.y:=(PolygonBuffer.Commands[CommandIndex].Points[0].y*RasterizerToScreenScale)+DistanceField.OffsetY;
       OtherControlPoint.x:=(PolygonBuffer.Commands[CommandIndex].Points[1].x*RasterizerToScreenScale)+DistanceField.OffsetX;
       OtherControlPoint.y:=(PolygonBuffer.Commands[CommandIndex].Points[1].y*RasterizerToScreenScale)+DistanceField.OffsetY;
       Point.x:=(PolygonBuffer.Commands[CommandIndex].Points[2].x*RasterizerToScreenScale)+DistanceField.OffsetX;
       Point.y:=(PolygonBuffer.Commands[CommandIndex].Points[2].y*RasterizerToScreenScale)+DistanceField.OffsetY;
       if assigned(Contour) and not ((SameValue(LastPoint.x,Point.x) and SameValue(LastPoint.y,Point.y)) and
                                     (SameValue(LastPoint.x,OtherControlPoint.x) and SameValue(LastPoint.y,OtherControlPoint.y)) and
                                     (SameValue(LastPoint.x,ControlPoint.x) and SameValue(LastPoint.y,ControlPoint.y))) then begin
        if DoSubdivideCurvesIntoLines then begin
         AddCubicBezierCurveAsSubdividedLinesToPathSegmentArray(Contour^,[LastPoint,ControlPoint,Point]);
        end else begin
         AddCubicBezierCurveAsSubdividedQuadraticBezierCurvesToPathSegmentArray(Contour^,[LastPoint,ControlPoint,Point]);
        end;
       end;
       LastPoint:=Point;
      end;
      VkTTF_PolygonCommandType_CLOSE:begin
       if assigned(Contour) then begin
        if not (SameValue(LastPoint.x,StartPoint.x) and SameValue(LastPoint.y,StartPoint.y)) then begin
         AddLineToPathSegmentArray(Contour^,[LastPoint,StartPoint]);
        end;
        SetLength(Contour^.PathSegments,Contour^.CountPathSegments);
       end;
       Contour:=nil;
      end;
     end;
    end;
   finally
    if assigned(Contour) then begin
     SetLength(Contour^.PathSegments,Contour^.CountPathSegments);
    end;
   end;
  finally
   SetLength(Shape.Contours,Shape.CountContours);
  end;
 end;
 procedure SplitPathSegmentIntoThreePartsInsideContour(var Contour:TContour;const BasePathSegmentIndex:TVkInt32);
 var BasePathSegment:TPathSegment;
 begin
  if (BasePathSegmentIndex>=0) and (BasePathSegmentIndex<Contour.CountPathSegments) then begin
   BasePathSegment:=Contour.PathSegments[BasePathSegmentIndex];
   if BasePathSegment.Type_ in [pstLine,pstQuadraticBezierCurve] then begin
    inc(Contour.CountPathSegments,2);
    if length(Contour.PathSegments)<=Contour.CountPathSegments then begin
     SetLength(Contour.PathSegments,Contour.CountPathSegments*2);
    end;
    Move(Contour.PathSegments[BasePathSegmentIndex+1],Contour.PathSegments[BasePathSegmentIndex+3],(Contour.CountPathSegments-(BasePathSegmentIndex+3))*SizeOf(TPathSegment));
    FillChar(Contour.PathSegments[BasePathSegmentIndex],SizeOf(TPathSegment)*3,#0);
   end else begin
    Assert(false);
   end;
   case BasePathSegment.Type_ of
    pstLine:begin
     Contour.PathSegments[BasePathSegmentIndex+0].Type_:=pstLine;
     Contour.PathSegments[BasePathSegmentIndex+0].Color:=BasePathSegment.Color;
     Contour.PathSegments[BasePathSegmentIndex+0].Points[0]:=BasePathSegment.Points[0];
     Contour.PathSegments[BasePathSegmentIndex+0].Points[1]:=DoublePrecisionPointLerp(BasePathSegment.Points[0],BasePathSegment.Points[1],1.0/3.0);
     Contour.PathSegments[BasePathSegmentIndex+1].Type_:=pstLine;
     Contour.PathSegments[BasePathSegmentIndex+1].Color:=BasePathSegment.Color;
     Contour.PathSegments[BasePathSegmentIndex+1].Points[0]:=Contour.PathSegments[BasePathSegmentIndex+0].Points[1];
     Contour.PathSegments[BasePathSegmentIndex+1].Points[1]:=DoublePrecisionPointLerp(BasePathSegment.Points[0],BasePathSegment.Points[1],2.0/3.0);
     Contour.PathSegments[BasePathSegmentIndex+2].Type_:=pstLine;
     Contour.PathSegments[BasePathSegmentIndex+2].Color:=BasePathSegment.Color;
     Contour.PathSegments[BasePathSegmentIndex+2].Points[0]:=Contour.PathSegments[BasePathSegmentIndex+1].Points[1];
     Contour.PathSegments[BasePathSegmentIndex+2].Points[1]:=BasePathSegment.Points[1];
    end;
    pstQuadraticBezierCurve:begin
     Contour.PathSegments[BasePathSegmentIndex+0].Type_:=pstQuadraticBezierCurve;
     Contour.PathSegments[BasePathSegmentIndex+0].Color:=BasePathSegment.Color;
     Contour.PathSegments[BasePathSegmentIndex+0].Points[0]:=BasePathSegment.Points[0];
     Contour.PathSegments[BasePathSegmentIndex+0].Points[1]:=DoublePrecisionPointLerp(BasePathSegment.Points[0],BasePathSegment.Points[1],1.0/3.0);
     Contour.PathSegments[BasePathSegmentIndex+0].Points[2]:=DoublePrecisionPointLerp(DoublePrecisionPointLerp(BasePathSegment.Points[0],BasePathSegment.Points[1],1.0/3.0),DoublePrecisionPointLerp(BasePathSegment.Points[1],BasePathSegment.Points[2],1.0/3.0),1.0/3.0);
     Contour.PathSegments[BasePathSegmentIndex+1].Type_:=pstQuadraticBezierCurve;
     Contour.PathSegments[BasePathSegmentIndex+1].Color:=BasePathSegment.Color;
     Contour.PathSegments[BasePathSegmentIndex+1].Points[0]:=Contour.PathSegments[BasePathSegmentIndex+0].Points[2];
     Contour.PathSegments[BasePathSegmentIndex+1].Points[1]:=DoublePrecisionPointLerp(DoublePrecisionPointLerp(BasePathSegment.Points[0],BasePathSegment.Points[1],5.0/9.0),DoublePrecisionPointLerp(BasePathSegment.Points[1],BasePathSegment.Points[2],4.0/9.0),0.5);
     Contour.PathSegments[BasePathSegmentIndex+1].Points[2]:=DoublePrecisionPointLerp(DoublePrecisionPointLerp(BasePathSegment.Points[0],BasePathSegment.Points[1],2.0/3.0),DoublePrecisionPointLerp(BasePathSegment.Points[1],BasePathSegment.Points[2],2.0/3.0),2.0/3.0);
     Contour.PathSegments[BasePathSegmentIndex+2].Type_:=pstQuadraticBezierCurve;
     Contour.PathSegments[BasePathSegmentIndex+2].Color:=BasePathSegment.Color;
     Contour.PathSegments[BasePathSegmentIndex+2].Points[0]:=Contour.PathSegments[BasePathSegmentIndex+1].Points[2];
     Contour.PathSegments[BasePathSegmentIndex+2].Points[1]:=DoublePrecisionPointLerp(BasePathSegment.Points[0],BasePathSegment.Points[1],2.0/3.0);
     Contour.PathSegments[BasePathSegmentIndex+2].Points[2]:=BasePathSegment.Points[2];
    end;
    else begin
     Assert(false);
    end;
   end;
   InitializePathSegment(Contour.PathSegments[BasePathSegmentIndex+0]);
   InitializePathSegment(Contour.PathSegments[BasePathSegmentIndex+1]);
   InitializePathSegment(Contour.PathSegments[BasePathSegmentIndex+2]);
  end;
 end;
 procedure SplitPathSegmentIntoThreePartsToContour(var Contour:TContour;const BasePathSegmentIndex:TVkInt32;const BasePathSegment:TPathSegment);
 begin
  if (BasePathSegmentIndex>=0) and (BasePathSegmentIndex<Contour.CountPathSegments) then begin
   case BasePathSegment.Type_ of
    pstLine:begin
     Contour.PathSegments[BasePathSegmentIndex+0].Type_:=pstLine;
     Contour.PathSegments[BasePathSegmentIndex+0].Color:=BasePathSegment.Color;
     Contour.PathSegments[BasePathSegmentIndex+0].Points[0]:=BasePathSegment.Points[0];
     Contour.PathSegments[BasePathSegmentIndex+0].Points[1]:=DoublePrecisionPointLerp(BasePathSegment.Points[0],BasePathSegment.Points[1],1.0/3.0);
     Contour.PathSegments[BasePathSegmentIndex+1].Type_:=pstLine;
     Contour.PathSegments[BasePathSegmentIndex+1].Color:=BasePathSegment.Color;
     Contour.PathSegments[BasePathSegmentIndex+1].Points[0]:=Contour.PathSegments[BasePathSegmentIndex+0].Points[1];
     Contour.PathSegments[BasePathSegmentIndex+1].Points[1]:=DoublePrecisionPointLerp(BasePathSegment.Points[0],BasePathSegment.Points[1],2.0/3.0);
     Contour.PathSegments[BasePathSegmentIndex+2].Type_:=pstLine;
     Contour.PathSegments[BasePathSegmentIndex+2].Color:=BasePathSegment.Color;
     Contour.PathSegments[BasePathSegmentIndex+2].Points[0]:=Contour.PathSegments[BasePathSegmentIndex+1].Points[1];
     Contour.PathSegments[BasePathSegmentIndex+2].Points[1]:=BasePathSegment.Points[1];
    end;
    pstQuadraticBezierCurve:begin
     Contour.PathSegments[BasePathSegmentIndex+0].Type_:=pstQuadraticBezierCurve;
     Contour.PathSegments[BasePathSegmentIndex+0].Color:=BasePathSegment.Color;
     Contour.PathSegments[BasePathSegmentIndex+0].Points[0]:=BasePathSegment.Points[0];
     Contour.PathSegments[BasePathSegmentIndex+0].Points[1]:=DoublePrecisionPointLerp(BasePathSegment.Points[0],BasePathSegment.Points[1],1.0/3.0);
     Contour.PathSegments[BasePathSegmentIndex+0].Points[2]:=DoublePrecisionPointLerp(DoublePrecisionPointLerp(BasePathSegment.Points[0],BasePathSegment.Points[1],1.0/3.0),DoublePrecisionPointLerp(BasePathSegment.Points[1],BasePathSegment.Points[2],1.0/3.0),1.0/3.0);
     Contour.PathSegments[BasePathSegmentIndex+1].Type_:=pstQuadraticBezierCurve;
     Contour.PathSegments[BasePathSegmentIndex+1].Color:=BasePathSegment.Color;
     Contour.PathSegments[BasePathSegmentIndex+1].Points[0]:=Contour.PathSegments[BasePathSegmentIndex+0].Points[2];
     Contour.PathSegments[BasePathSegmentIndex+1].Points[1]:=DoublePrecisionPointLerp(DoublePrecisionPointLerp(BasePathSegment.Points[0],BasePathSegment.Points[1],5.0/9.0),DoublePrecisionPointLerp(BasePathSegment.Points[1],BasePathSegment.Points[2],4.0/9.0),0.5);
     Contour.PathSegments[BasePathSegmentIndex+1].Points[2]:=DoublePrecisionPointLerp(DoublePrecisionPointLerp(BasePathSegment.Points[0],BasePathSegment.Points[1],2.0/3.0),DoublePrecisionPointLerp(BasePathSegment.Points[1],BasePathSegment.Points[2],2.0/3.0),2.0/3.0);
     Contour.PathSegments[BasePathSegmentIndex+2].Type_:=pstQuadraticBezierCurve;
     Contour.PathSegments[BasePathSegmentIndex+2].Color:=BasePathSegment.Color;
     Contour.PathSegments[BasePathSegmentIndex+2].Points[0]:=Contour.PathSegments[BasePathSegmentIndex+1].Points[2];
     Contour.PathSegments[BasePathSegmentIndex+2].Points[1]:=DoublePrecisionPointLerp(BasePathSegment.Points[0],BasePathSegment.Points[1],2.0/3.0);
     Contour.PathSegments[BasePathSegmentIndex+2].Points[2]:=BasePathSegment.Points[2];
    end;
    else begin
     Assert(false);
    end;
   end;
   InitializePathSegment(Contour.PathSegments[BasePathSegmentIndex+0]);
   InitializePathSegment(Contour.PathSegments[BasePathSegmentIndex+1]);
   InitializePathSegment(Contour.PathSegments[BasePathSegmentIndex+2]);
  end;
 end;
 procedure NormalizeShape(var Shape:TShape);
 var ContourIndex:TVkInt32;
     Contour:PContour;
 begin
  for ContourIndex:=0 to Shape.CountContours-1 do begin
   Contour:=@Shape.Contours[ContourIndex];
   if Contour^.CountPathSegments=1 then begin
    try
     SplitPathSegmentIntoThreePartsInsideContour(Contour^,0);
    finally
     SetLength(Contour^.PathSegments,Contour^.CountPathSegments);
    end;
   end;
  end;
 end;
 procedure PathSegmentColorizeShape(var Shape:TShape);
 const AngleThreshold=3.0;
       EdgeThreshold=1.00000001;
 type PCorner=^TCorner;
      TCorner=TVkInt32;
      TCorners=array of TCorner;
 var ContourIndex,PathSegmentIndex,CountCorners,CornerIndex,SplineIndex,StartIndex,
     OtherPathSegmentIndex:TVkInt32;
     Seed:TVkUInt64;
     Contour:PContour;
     PathSegment:PPathSegment;
     Corners:TCorners;
     CurrentDirection,PreviousDirection,a,b:TDoublePrecisionPoint;
     CrossThreshold:TVkDouble;
     Color,InitialColor:TPathSegmentColor;
     Colors:array[0..2] of TPathSegmentColor;
     PathSegments:TPathSegments;
  procedure SwitchColor(var Color:TPathSegmentColor;const BannedColor:TPathSegmentColor=pscBlack);
  const StartColors:array[0..2] of TPathSegmentColor=(pscCyan,pscMagenta,pscYellow);
  var CombinedColor:TPathSegmentColor;
      Shifted:TVkUInt64;
  begin
   CombinedColor:=TPathSegmentColor(TVkInt32(TVkInt32(Color) and TVkInt32(BannedColor)));
   if CombinedColor in [pscRed,pscGreen,pscBlue] then begin
    Color:=TPathSegmentColor(TVkInt32(TVkInt32(CombinedColor) xor TVkInt32(TPathSegmentColor(pscWhite))));
   end else if CombinedColor in [pscBlack,pscWhite] then begin
    Color:=StartColors[Seed mod 3];
    Seed:=Seed div 3;
   end else begin
    Shifted:=TVkInt32(Color) shl (1+(Seed and 1));
    Color:=TPathSegmentColor(TVkInt32((Shifted or (Shifted shr 3)) and TVkInt32(TPathSegmentColor(pscWhite))));
    Seed:=Seed shr 1;
   end;
  end;
 begin

  Seed:=$7ffffffffffffff;

  CrossThreshold:=sin(AngleThreshold);

  for ContourIndex:=0 to Shape.CountContours-1 do begin

   Contour:=@Shape.Contours[ContourIndex];
   try

    Corners:=nil;
    CountCorners:=0;
    try

     if Contour^.CountPathSegments>0 then begin

      PreviousDirection:=PathSegmentDirection(Contour^.PathSegments[Contour^.CountPathSegments-1],1);

      for PathSegmentIndex:=0 to Contour^.CountPathSegments-1 do begin

       PathSegment:=@Contour^.PathSegments[PathSegmentIndex];

       CurrentDirection:=PathSegmentDirection(PathSegment^,0);

       a:=DoublePrecisionPointNormalize(PreviousDirection);
       b:=DoublePrecisionPointNormalize(CurrentDirection);

       if (((a.x*b.x)+(a.y*b.y))<=0.0) or (abs((a.x*b.y)-(a.y*b.x))>CrossThreshold) then begin

        if length(Corners)<(CountCorners+1) then begin
         SetLength(Corners,(CountCorners+1)*2);
        end;
        Corners[CountCorners]:=PathSegmentIndex;
        inc(CountCorners);

       end;

       PreviousDirection:=PathSegmentDirection(PathSegment^,1);

      end;

     end;

     case CountCorners of
      0:begin
       for PathSegmentIndex:=0 to Contour^.CountPathSegments-1 do begin
        PathSegment:=@Contour^.PathSegments[PathSegmentIndex];
        PathSegment^.Color:=pscWhite;
       end;
      end;
      1:begin
       Colors[0]:=pscWhite;
       Colors[1]:=pscWhite;
       SwitchColor(Colors[0]);
       Colors[2]:=Colors[0];
       SwitchColor(Colors[2]);
       CornerIndex:=Corners[0];
       if Contour^.CountPathSegments>2 then begin
        for PathSegmentIndex:=0 to Contour^.CountPathSegments-1 do begin
         PathSegment:=@Contour^.PathSegments[CornerIndex];
         PathSegment^.Color:=Colors[abs((trunc(((3+((2.875*PathSegmentIndex)/(Contour^.CountPathSegments-1)))-1.4375)+0.5)-3)+1) mod 3];
         inc(CornerIndex);
         if CornerIndex>=Contour^.CountPathSegments then begin
          CornerIndex:=0;
         end;
        end;
       end else if Contour^.CountPathSegments=2 then begin
        PathSegments:=copy(Contour^.PathSegments,0,Contour^.CountPathSegments);
        try
         SetLength(Contour^.PathSegments,6);
         try
          Contour^.CountPathSegments:=6;
          SplitPathSegmentIntoThreePartsToContour(Contour^,CornerIndex*3,PathSegments[0]);
          SplitPathSegmentIntoThreePartsToContour(Contour^,3-(CornerIndex*3),PathSegments[1]);
          Contour^.PathSegments[0].Color:=Colors[0];
          Contour^.PathSegments[1].Color:=Colors[0];
          Contour^.PathSegments[2].Color:=Colors[1];
          Contour^.PathSegments[3].Color:=Colors[1];
          Contour^.PathSegments[4].Color:=Colors[2];
          Contour^.PathSegments[5].Color:=Colors[2];
         finally
          SetLength(Contour^.PathSegments,Contour^.CountPathSegments);
         end;
        finally
         PathSegments:=nil;
        end;
       end else if Contour^.CountPathSegments=1 then begin
        PathSegments:=copy(Contour^.PathSegments,0,Contour^.CountPathSegments);
        try
         SetLength(Contour^.PathSegments,3);
         try
          Contour^.CountPathSegments:=3;
          SplitPathSegmentIntoThreePartsToContour(Contour^,0,PathSegments[0]);
          Contour^.PathSegments[0].Color:=Colors[0];
          Contour^.PathSegments[1].Color:=Colors[1];
          Contour^.PathSegments[2].Color:=Colors[2];
         finally
          SetLength(Contour^.PathSegments,Contour^.CountPathSegments);
         end;
        finally
         PathSegments:=nil;
        end;
       end;
      end;
      else begin
       SplineIndex:=0;
       StartIndex:=Corners[0];
       Color:=pscWhite;
       SwitchColor(Color);
       InitialColor:=Color;
       for PathSegmentIndex:=0 to Contour^.CountPathSegments-1 do begin
        OtherPathSegmentIndex:=StartIndex+PathSegmentIndex;
        if OtherPathSegmentIndex>=Contour^.CountPathSegments then begin
         dec(OtherPathSegmentIndex,Contour^.CountPathSegments);
        end;
        if ((SplineIndex+1)<CountCorners) and (Corners[SplineIndex+1]=OtherPathSegmentIndex) then begin
         inc(SplineIndex);
         SwitchColor(Color,TPathSegmentColor(TVkInt32(IfThen(SplineIndex=(CountCorners-1),TVkInt32(InitialColor),TVkInt32(TPathSegmentColor(pscBlack))))));
        end;
        Contour^.PathSegments[OtherPathSegmentIndex].Color:=Color;
       end;
      end;
     end;

    finally
     Corners:=nil;
    end;

   finally
    SetLength(Contour^.PathSegments,Contour^.CountPathSegments);
   end;

  end;

 end;
 function GetLineNonClippedTime(const p,p0,p1:TDoublePrecisionPoint):TVkDouble;
 var pAP,pAB:TDoublePrecisionPoint;
 begin
  pAP.x:=p.x-p0.x;
  pAP.y:=p.y-p0.y;
  pAB.x:=p1.x-p0.x;
  pAB.y:=p1.y-p0.y;
  result:=((pAP.x*pAB.x)+(pAP.y*pAB.y))/(sqr(pAB.x)+sqr(pAB.y));
 end;
 function GetQuadraticBezierCurveNonClippedTime(const p,p0,p1,p2:TDoublePrecisionPoint):TVkDouble;
 var b0,b1,b2,d21,d10,d20,gf,pp,d0p:TDoublePrecisionPoint;
     a,b,d,f,ap,bp,v,c:TVkDouble;
 begin
  b0.x:=p0.x-p.x;
  b0.y:=p0.y-p.y;
  b1.x:=p1.x-p.x;
  b1.y:=p1.y-p.y;
  b2.x:=p2.x-p.x;
  b2.y:=p2.y-p.y;
  a:=((b0.x*b2.y)-(b0.y*b2.x))*2.0;
  b:=((b1.x*b0.y)-(b1.y*b0.x))*2.0;
  d:=((b2.x*b1.y)-(b2.y*b1.x))*2.0;
  c:=(2.0*a)+b+d;
  if IsZero(c) then begin
   result:=GetLineNonClippedTime(p,p0,p2);
  end else begin
   f:=(b*d)-sqr(a);
   d21.x:=b2.x-b1.x;
   d21.y:=b2.y-b1.y;
   d10.x:=b1.x-b0.x;
   d10.y:=b1.y-b0.y;
   d20.x:=b2.x-b0.x;
   d20.y:=b2.y-b0.y;
   gf.x:=((d21.y*b)+(d10.y*d)+(d20.y*a))*2.0;
   gf.y:=((d21.x*b)+(d10.x*d)+(d20.x*a))*(-2.0);
   v:=-(f/(sqr(gf.x)+sqr(gf.y)));
   pp.x:=gf.x*v;
   pp.y:=gf.y*v;
   d0p.x:=b0.x-pp.x;
   d0p.y:=b0.y-pp.y;
   ap:=(d0p.x*d20.y)-(d0p.y*d20.x);
   bp:=((d10.x*d0p.y)-(d10.y*d0p.x))*2.0;
   result:=(ap+bp)/c;
  end;
 end;
 function GetNonClampedSignedLineDistance(const p,p0,p1:TDoublePrecisionPoint):TVkDouble;
 begin
  result:=((p.x*(p0.y-p1.y))+(p0.x*(p1.y-p.y))+(p1.x*(p.y-p0.y)))/sqrt(sqr(p1.x-p0.x)+sqr(p1.y-p0.y));
 end;
 procedure CalculateDistanceFieldData(const Shape:TShape;var DistanceFieldData:TDistanceFieldData;const Width,Height:TVkInt32);
 var ContourIndex,PathSegmentIndex,x0,y0,x1,y1,x,y,PixelIndex,Dilation,DeltaWindingScore:TVkInt32;
     Contour:PContour;
     PathSegment:PPathSegment;
     PathSegmentBoundingBox:TBoundingBox;
     PreviousPathSegmentSide,PathSegmentSide:TPathSegmentSide;
     RowData:TRowData;
     DistanceFieldDataItem:PDistanceFieldDataItem;
     PointLeft,PointRight,Point,p0,p1,Direction,OriginPointDifference:TDoublePrecisionPoint;
     pX,pY,CurrentSquaredDistance,CurrentSquaredPseudoDistance,Time,Value:TvkDouble;
 begin
  RowData.QuadraticXDirection:=0;
  for ContourIndex:=0 to Shape.CountContours-1 do begin
   Contour:=@Shape.Contours[ContourIndex];
   for PathSegmentIndex:=0 to Contour^.CountPathSegments-1 do begin
    PathSegment:=@Contour^.PathSegments[PathSegmentIndex];
    PathSegmentBoundingBox.Min.x:=PathSegment.BoundingBox.Min.x-DistanceFieldPadValue;
    PathSegmentBoundingBox.Min.y:=PathSegment.BoundingBox.Min.y-DistanceFieldPadValue;
    PathSegmentBoundingBox.Max.x:=PathSegment.BoundingBox.Max.x+DistanceFieldPadValue;
    PathSegmentBoundingBox.Max.y:=PathSegment.BoundingBox.Max.y+DistanceFieldPadValue;
    x0:=Clamp(Trunc(Floor(PathSegmentBoundingBox.Min.x)),0,Width-1);
    y0:=Clamp(Trunc(Floor(PathSegmentBoundingBox.Min.y)),0,Height-1);
    x1:=Clamp(Trunc(Ceil(PathSegmentBoundingBox.Max.x)),0,Width-1);
    y1:=Clamp(Trunc(Ceil(PathSegmentBoundingBox.Max.y)),0,Height-1);
{   x0:=0;
    y0:=0;
    x1:=Width-1;
    y1:=Height-1;}
    for y:=y0 to y1 do begin
     PreviousPathSegmentSide:=pssNone;
     pY:=y+0.5;
     PointLeft.x:=x0;
     PointLeft.y:=pY;
     PointRight.x:=x1;
     PointRight.y:=pY;
     if BetweenClosedOpen(pY,PathSegment.BoundingBox.Min.y,PathSegment.BoundingBox.Max.y) then begin
      PrecomputationForRow(RowData,PathSegment^,PointLeft,PointRight);
     end;
     for x:=x0 to x1 do begin
      PixelIndex:=(y*Width)+x;
      pX:=x+0.5;
      Point.x:=pX;
      Point.y:=pY;
      DistanceFieldDataItem:=@DistanceFieldData[PixelIndex];
      Dilation:=Clamp(Floor(sqrt(Max(1,DistanceFieldDataItem^.SquaredDistance))+0.5),1,DistanceFieldPadValue);
      PathSegmentBoundingBox.Min.x:=Floor(PathSegment.BoundingBox.Min.x)-DistanceFieldPadValue;
      PathSegmentBoundingBox.Min.y:=Floor(PathSegment.BoundingBox.Min.y)-DistanceFieldPadValue;
      PathSegmentBoundingBox.Max.x:=Ceil(PathSegment.BoundingBox.Max.x)+DistanceFieldPadValue;
      PathSegmentBoundingBox.Max.y:=Ceil(PathSegment.BoundingBox.Max.y)+DistanceFieldPadValue;
      if (Dilation<>DistanceFieldPadValue) and not
         (((x>=PathSegmentBoundingBox.Min.x) and (x<=PathSegmentBoundingBox.Max.x)) and
          ((y>=PathSegmentBoundingBox.Min.y) and (y<=PathSegmentBoundingBox.Max.y))) then begin
       continue;
      end else begin
       PathSegmentSide:=pssNone;
       CurrentSquaredDistance:=DistanceToPathSegment(Point,PathSegment^,RowData,PathSegmentSide);
       CurrentSquaredPseudoDistance:=CurrentSquaredDistance;
(**)    if MultiChannel then begin
        case PathSegment^.Type_ of
         pstLine:begin
          Time:=GetLineNonClippedTime(Point,PathSegment^.Points[0],PathSegment^.Points[1]);
         end;
         pstQuadraticBezierCurve:begin
          Time:=GetQuadraticBezierCurveNonClippedTime(Point,PathSegment^.Points[0],PathSegment^.Points[1],PathSegment^.Points[2]);
         end;
         else begin
          Time:=0.5;
         end;
        end;
        if Time<=0.0 then begin
         p0:=PathSegmentCornerPoint(PathSegment^,0,0)^;
         p1:=PathSegmentCornerPoint(PathSegment^,0,1)^;
         Direction:=DoublePrecisionPointNormalize(DoublePrecisionPointSub(p1,p0));
         OriginPointDifference:=DoublePrecisionPointSub(Point,p0);
         if DoublePrecisionPointDotProduct(OriginPointDifference,Direction)<0.0 then begin
          Value:=DoublePrecisionPointCrossProduct(OriginPointDifference,Direction);
//         Value:=GetNonClampedSignedLineDistance(Point,p0,p1);
          if abs(Value)<=abs(CurrentSquaredPseudoDistance) then begin
           CurrentSquaredPseudoDistance:=abs(Value);
          end;
         end;
{         Value:=GetNonClampedSignedLineDistance(Point,PathSegmentCornerPoint(PathSegment^,0,0)^,PathSegmentCornerPoint(PathSegment^,0,1)^);
         if Value<0.0 then begin
          Value:=sqr(Value);
          if abs(Value)<=abs(CurrentSquaredPseudoDistance) then begin
           CurrentSquaredPseudoDistance:=abs(Value);
          end;
         end;}
        end else if Time>=1.0 then begin
         p0:=PathSegmentCornerPoint(PathSegment^,1,0)^;
         p1:=PathSegmentCornerPoint(PathSegment^,1,1)^;
         Direction:=DoublePrecisionPointNormalize(DoublePrecisionPointSub(p1,p0));
         OriginPointDifference:=DoublePrecisionPointSub(Point,p1);
         if DoublePrecisionPointDotProduct(OriginPointDifference,Direction)>0.0 then begin
          Value:=DoublePrecisionPointCrossProduct(OriginPointDifference,Direction);
//         Value:=GetNonClampedSignedLineDistance(Point,p0,p1);
          if abs(Value)<=abs(CurrentSquaredPseudoDistance) then begin
           CurrentSquaredPseudoDistance:=abs(Value);
          end;
         end;
{         Value:=GetNonClampedSignedLineDistance(Point,PathSegmentCornerPoint(PathSegment^,1,0)^,PathSegmentCornerPoint(PathSegment^,1,1)^);
         if Value>0.0 then begin
          Value:=sqr(Value);
          if abs(Value)<=abs(CurrentSquaredPseudoDistance) then begin
           CurrentSquaredPseudoDistance:=abs(Value);
          end;
         end;}
        end;
       end;(**)
       if (PreviousPathSegmentSide=pssLeft) and (PathSegmentSide=pssRight) then begin
        DeltaWindingScore:=-1;
       end else if (PreviousPathSegmentSide=pssRight) and (PathSegmentSide=pssLeft) then begin
        DeltaWindingScore:=1;
       end else begin
        DeltaWindingScore:=0;
       end;
       PreviousPathSegmentSide:=PathSegmentSide;
       if CurrentSquaredDistance<DistanceFieldDataItem^.SquaredDistance then begin
        DistanceFieldDataItem^.SquaredDistance:=CurrentSquaredDistance;
       end;
       if MultiChannel then begin
        if (((TVKInt32(PathSegment^.Color) and TVkInt32(TPathSegmentColor(pscRed)))<>0)) and
           (CurrentSquaredDistance<DistanceFieldDataItem^.SquaredDistanceR) then begin
         DistanceFieldDataItem^.SquaredDistanceR:=CurrentSquaredDistance;
         DistanceFieldDataItem^.PseudoSquaredDistanceR:=CurrentSquaredPseudoDistance;
        end;
        if (((TVKInt32(PathSegment^.Color) and TVkInt32(TPathSegmentColor(pscGreen)))<>0)) and
           (CurrentSquaredDistance<DistanceFieldDataItem^.SquaredDistanceG) then begin
         DistanceFieldDataItem^.SquaredDistanceG:=CurrentSquaredDistance;
         DistanceFieldDataItem^.PseudoSquaredDistanceG:=CurrentSquaredPseudoDistance;
        end;
        if (((TVKInt32(PathSegment^.Color) and TVkInt32(TPathSegmentColor(pscBlue)))<>0)) and
           (CurrentSquaredDistance<DistanceFieldDataItem^.SquaredDistanceB) then begin
         DistanceFieldDataItem^.SquaredDistanceB:=CurrentSquaredDistance;
         DistanceFieldDataItem^.PseudoSquaredDistanceB:=CurrentSquaredPseudoDistance;
        end;
       end;
       inc(DistanceFieldDataItem^.DeltaWindingScore,DeltaWindingScore);
      end;
     end;
    end;
   end;
  end;
 end;
 function PackDistanceFieldValue(Distance:TVkDouble):TVkUInt8;
 begin
  result:=Clamp(Round((Distance*(128.0/DistanceFieldMagnitudeValue))+128.0),0,255);
 end;
 function PackPseudoDistanceFieldValue(Distance:TVkDouble):TVkUInt8;
 begin
  result:=Clamp(Round((Distance*(128.0/DistanceFieldMagnitudeValue))+128.0),0,255);
 end;
 function GenerateDistanceFieldPicture(const DistanceFieldData:TDistanceFieldData;const Width,Height:TVkInt32):boolean;
 var x,y,PixelIndex,DistanceFieldSign,WindingNumber,Value:TVkInt32;
     DistanceFieldDataItem:PDistanceFieldDataItem;
     DistanceFieldPixel:PVulkanFontDistanceFieldPixel;
 begin

  result:=true;

  PixelIndex:=0;
  for y:=0 to Height-1 do begin
   WindingNumber:=0;
   for x:=0 to Width-1 do begin
    DistanceFieldDataItem:=@DistanceFieldData[PixelIndex];
    inc(WindingNumber,DistanceFieldDataItem^.DeltaWindingScore);
    if WindingNumber<>0 then begin
     DistanceFieldSign:=1;
    end else begin
     DistanceFieldSign:=-1;
    end;
    if (x=(Width-1)) and (WindingNumber<>0) then begin
     result:=false;
     break;
    end else begin
     DistanceFieldPixel:=@DistanceField.Pixels[PixelIndex];
     if MultiChannel then begin
      DistanceFieldPixel^.r:=PackPseudoDistanceFieldValue(sqrt(DistanceFieldDataItem^.PseudoSquaredDistanceR)*DistanceFieldSign);
      DistanceFieldPixel^.g:=PackPseudoDistanceFieldValue(sqrt(DistanceFieldDataItem^.PseudoSquaredDistanceG)*DistanceFieldSign);
      DistanceFieldPixel^.b:=PackPseudoDistanceFieldValue(sqrt(DistanceFieldDataItem^.PseudoSquaredDistanceB)*DistanceFieldSign);
      DistanceFieldPixel^.a:=PackDistanceFieldValue(sqrt(DistanceFieldDataItem^.SquaredDistance)*DistanceFieldSign);
     end else begin
      Value:=PackDistanceFieldValue(sqrt(DistanceFieldDataItem^.SquaredDistance)*DistanceFieldSign);
      DistanceFieldPixel^.r:=Value;
      DistanceFieldPixel^.g:=Value;
      DistanceFieldPixel^.b:=Value;
      DistanceFieldPixel^.a:=Value;
     end;
     inc(PixelIndex);
    end;
   end;
   if not result then begin
    break;
   end;
  end;

 end;
var TryIteration:TVkInt32;
    Shape:TShape;
    DistanceFieldData:TDistanceFieldData;
begin
 Initialize(Shape);
 try

  DistanceFieldData:=nil;
  try

   SetLength(DistanceFieldData,DistanceField.Width*DistanceField.Height);

   for TryIteration:=0 to 1 do begin

    InitializeDistances(DistanceFieldData);

    ConvertShape(Shape,TryIteration=1);

    if MultiChannel then begin

     NormalizeShape(Shape);

     PathSegmentColorizeShape(Shape);

     NormalizeShape(Shape);

    end;

    CalculateDistanceFieldData(Shape,DistanceFieldData,DistanceField.Width,DistanceField.Height);

    if GenerateDistanceFieldPicture(DistanceFieldData,DistanceField.Width,DistanceField.Height) then begin
     break;
    end else begin
     // Try it again, after all quadratic bezier curves were subdivided into lines at the next try iteration
    end;

   end;

  finally
   DistanceFieldData:=nil;
  end;

 finally
  Finalize(Shape);
 end;

end;

{$ifdef PasVulkanPasMP}
procedure TVulkanFont.GenerateSignedDistanceFieldParallelForJobFunction(const Job:PPasMPJob;const ThreadIndex:TPasMPInt32;const Data:pointer;const FromIndex,ToIndex:TPasMPNativeInt);
var Index:TPasMPNativeInt;
    JobData:PVulkanFontDistanceFieldJob;
begin
 Index:=FromIndex;
 while Index<=ToIndex do begin
  JobData:=@fDistanceFieldJobs[Index];
  GenerateSignedDistanceField(JobData^.DistanceField^,JobData^.MultiChannel,JobData^.PolygonBuffer);
  inc(Index);
 end;
end;
{$endif}

function TVulkanFont.TextWidth(const aText:TVulkanRawByteString;const aSize:TVkFloat):TVkFloat;
var TextIndex,CurrentGlyph,LastGlyph:TVkInt32;
    CurrentCodePoint:TVkUInt32;
    Width,NewWidth:TVkFloat;
    Int64HashMapData:TVulkanInt64HashMapData;
    Glyph:PVulkanFontGlyph;
begin
 result:=0.0;
 Width:=0.0;
 TextIndex:=1;
 LastGlyph:=-1;
 while TextIndex<=length(aText) do begin
  CurrentCodePoint:=VulkanUTF8CodeUnitGetCharAndIncFallback(aText,TextIndex);
  if fCodePointToGlyphHashMap.TryGet(CurrentCodePoint,Int64HashMapData) then begin
   CurrentGlyph:={%H-}TVkPtrUInt(TVkPointer(Int64HashMapData));
   if (CurrentGlyph>=0) or (CurrentGlyph<length(fGlyphs)) then begin
    if ((LastGlyph>=0) and (LastGlyph<length(fGlyphs))) and
       fKerningPairHashMap.TryGet(CombineTwoUInt32IntoOneUInt64(LastGlyph,CurrentGlyph),Int64HashMapData) then begin
     result:=result+fKerningPairs[TVkPtrUInt(TVkPointer(Int64HashMapData))].Horizontal;
    end;
    Glyph:=@fGlyphs[CurrentGlyph];
    if LastGlyph<0 then begin
     result:=result+Glyph^.LeftSideBearing;
    end;
    NewWidth:=result+(Glyph^.BoundsMaxX-Glyph^.BoundsMinX);
    if Width<NewWidth then begin
     Width:=NewWidth;
    end;
    result:=result+Glyph^.AdvanceWidth;
   end;
  end else begin
   CurrentGlyph:=0;
  end;
  LastGlyph:=CurrentGlyph;
 end;
 if result=0 then begin
  result:=fMaxX-fMinX;
 end;
 if result<Width then begin
  result:=Width;
 end;
 result:=result*GetScaleFactor(aSize);
end;

function TVulkanFont.TextHeight(const aText:TVulkanRawByteString;const aSize:TVkFloat):TVkFloat;
var TextIndex,CurrentGlyph,LastGlyph:TVkInt32;
    CurrentCodePoint:TVkUInt32;
    Height,NewHeight:TVkFloat;
    Int64HashMapData:TVulkanInt64HashMapData;
    Glyph:PVulkanFontGlyph;
begin
 result:=0.0;
 Height:=0.0;
 TextIndex:=1;
 LastGlyph:=-1;
 while TextIndex<=length(aText) do begin
  CurrentCodePoint:=VulkanUTF8CodeUnitGetCharAndIncFallback(aText,TextIndex);
  if fCodePointToGlyphHashMap.TryGet(CurrentCodePoint,Int64HashMapData) then begin
   CurrentGlyph:={%H-}TVkPtrUInt(TVkPointer(Int64HashMapData));
   if (CurrentGlyph>=0) or (CurrentGlyph<length(fGlyphs)) then begin
    if ((LastGlyph>=0) and (LastGlyph<length(fGlyphs))) and
       fKerningPairHashMap.TryGet(CombineTwoUInt32IntoOneUInt64(LastGlyph,CurrentGlyph),Int64HashMapData) then begin
     result:=result+fKerningPairs[TVkPtrUInt(TVkPointer(Int64HashMapData))].Vertical;
    end;
    Glyph:=@fGlyphs[CurrentGlyph];
    if LastGlyph<0 then begin
     result:=result+Glyph^.TopSideBearing;
    end;
    NewHeight:=result+(Glyph^.BoundsMaxY-Glyph^.BoundsMinY);
    if Height<NewHeight then begin
     Height:=NewHeight;
    end;
    result:=result+Glyph^.AdvanceHeight;
   end;
  end else begin
   CurrentGlyph:=0;
  end;
  LastGlyph:=CurrentGlyph;
 end;
 if result=0 then begin
  result:=fMaxY-fMinY;
 end;
 if result<Height then begin
  result:=Height;
 end;
 result:=result*GetScaleFactor(aSize);
end;

function TVulkanFont.RowHeight(const Percent:TVkFloat):TVkFloat;
begin
 result:=fUnitsPerEm*(Percent*0.01);
end;

procedure TVulkanFont.Draw(const aSpriteBatch:TVulkanSpriteBatch;const aText:TVulkanRawByteString;const aX,aY,aSize:TVkFloat;const aColorRed:TVkFloat=1.0;const aColorGreen:TVkFloat=1.0;const aColorBlue:TVkFloat=1.0;const aColorAlpha:TVkFloat=1.0);
var TextIndex,CurrentCodePoint,CurrentGlyph,LastGlyph:TVkInt32;
    x,y,ScaleFactor,RescaleFactor:TVkFloat;
    Int64HashMapData:TVulkanInt64HashMapData;
    KerningPair:PVulkanFontKerningPair;
    Glyph:PVulkanFontGlyph;
    Src,Dest:TVulkanSpriteRect;
    Color:TVulkanSpriteColor;
begin
 Color.r:=aColorRed;
 Color.g:=aColorGreen;
 Color.b:=aColorBlue;
 Color.a:=aColorAlpha;
 x:=0.0;
 y:=0.0;
 ScaleFactor:=GetScaleFactor(aSize);
 RescaleFactor:=ScaleFactor*fInverseBaseScaleFactor;
 TextIndex:=1;
 LastGlyph:=-1;
 while TextIndex<=length(aText) do begin                 
  CurrentCodePoint:=VulkanUTF8CodeUnitGetCharAndIncFallback(aText,TextIndex);
  if fCodePointToGlyphHashMap.TryGet(CurrentCodePoint,Int64HashMapData) then begin
   CurrentGlyph:={%H-}TVkPtrUInt(TVkPointer(Int64HashMapData));
   if (CurrentGlyph>=0) or (CurrentGlyph<length(fGlyphs)) then begin
    if ((LastGlyph>=0) and (LastGlyph<length(fGlyphs))) and
       fKerningPairHashMap.TryGet(CombineTwoUInt32IntoOneUInt64(LastGlyph,CurrentGlyph),Int64HashMapData) then begin
     KerningPair:=@fKerningPairs[TVkPtrUInt(TVkPointer(Int64HashMapData))];
     x:=x+KerningPair^.Horizontal;
     y:=y+KerningPair^.Vertical;
    end;
    Glyph:=@fGlyphs[CurrentGlyph];
    if LastGlyph<0 then begin
     x:=x+Glyph^.LeftSideBearing;
     y:=y+Glyph^.TopSideBearing;
    end;
    Src.Left:=0.0;
    Src.Top:=0.0;
    Src.Right:=Src.Left+Glyph^.Width;
    Src.Bottom:=Src.Top+Glyph^.Height;
    Dest.Left:=aX+(x*ScaleFactor)+(Glyph^.OffsetX*RescaleFactor);
    Dest.Top:=aY+(y*ScaleFactor)+(Glyph^.OffsetY*RescaleFactor);
    Dest.Right:=aX+(x*ScaleFactor)+((Glyph^.OffsetX+Glyph^.Width)*RescaleFactor);
    Dest.Bottom:=aY+(y*ScaleFactor)+((Glyph^.OffsetY+Glyph^.Height)*RescaleFactor);
    aSpriteBatch.Draw(Glyph^.Sprite,Src,Dest,Color);
    x:=x+Glyph^.AdvanceWidth;
    y:=y+Glyph^.AdvanceHeight;
   end;
  end else begin
   CurrentGlyph:=0;
  end;
  LastGlyph:=CurrentGlyph;
 end;
end;

initialization
 GenerateHalfFloatLookUpTables;
{$ifdef PasVulkanPasMP}
 VulkanPasMP:=nil;
 VulkanPasMPLock:=TPasMPSpinLock.Create;
{$endif}
finalization
{$ifdef PasVulkanPasMP}
 FreeAndNil(VulkanPasMPLock);
{$endif}
end.


